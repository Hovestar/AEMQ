
RTOSDemo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004b3c  00400000  00400000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000440  20000000  00404b3c  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000a1e4  20000440  00404f7c  00010440  2**2
                  ALLOC
  3 .stack        00003004  2000a624  0040f160  00010440  2**0
                  ALLOC
  4 .ARM.attributes 0000002a  00000000  00000000  00010440  2**0
                  CONTENTS, READONLY
  5 .comment      00000071  00000000  00000000  0001046a  2**0
                  CONTENTS, READONLY
  6 .debug_info   0000b576  00000000  00000000  000104db  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002429  00000000  00000000  0001ba51  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000488b  00000000  00000000  0001de7a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000d28  00000000  00000000  00022705  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000b28  00000000  00000000  0002342d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00012add  00000000  00000000  00023f55  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000e0e9  00000000  00000000  00036a32  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0004d6cc  00000000  00000000  00044b1b  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000027a8  00000000  00000000  000921e8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	2000d628 	.word	0x2000d628
  400004:	00401605 	.word	0x00401605
  400008:	004015fd 	.word	0x004015fd
  40000c:	004015fd 	.word	0x004015fd
  400010:	004015fd 	.word	0x004015fd
  400014:	004015fd 	.word	0x004015fd
  400018:	004015fd 	.word	0x004015fd
	...
  40002c:	00401c25 	.word	0x00401c25
  400030:	004015fd 	.word	0x004015fd
  400034:	00000000 	.word	0x00000000
  400038:	00401e21 	.word	0x00401e21
  40003c:	00401e5d 	.word	0x00401e5d
  400040:	004015fd 	.word	0x004015fd
  400044:	004015fd 	.word	0x004015fd
  400048:	004015fd 	.word	0x004015fd
  40004c:	004015fd 	.word	0x004015fd
  400050:	004015fd 	.word	0x004015fd
  400054:	004015fd 	.word	0x004015fd
  400058:	004015fd 	.word	0x004015fd
  40005c:	004015fd 	.word	0x004015fd
  400060:	004015fd 	.word	0x004015fd
  400064:	004015fd 	.word	0x004015fd
  400068:	004015fd 	.word	0x004015fd
  40006c:	00401271 	.word	0x00401271
  400070:	0040128d 	.word	0x0040128d
  400074:	004012a9 	.word	0x004012a9
  400078:	004015fd 	.word	0x004015fd
  40007c:	00400691 	.word	0x00400691
  400080:	004015fd 	.word	0x004015fd
  400084:	004015fd 	.word	0x004015fd
  400088:	004015fd 	.word	0x004015fd
  40008c:	004015fd 	.word	0x004015fd
  400090:	004015fd 	.word	0x004015fd
  400094:	004015fd 	.word	0x004015fd
  400098:	004015fd 	.word	0x004015fd
  40009c:	004015fd 	.word	0x004015fd
  4000a0:	004015fd 	.word	0x004015fd
  4000a4:	004015fd 	.word	0x004015fd
  4000a8:	004015fd 	.word	0x004015fd
  4000ac:	004015fd 	.word	0x004015fd
  4000b0:	004015fd 	.word	0x004015fd
  4000b4:	004015fd 	.word	0x004015fd
  4000b8:	004015fd 	.word	0x004015fd
  4000bc:	004015fd 	.word	0x004015fd
  4000c0:	004015fd 	.word	0x004015fd
  4000c4:	004015fd 	.word	0x004015fd
  4000c8:	004015fd 	.word	0x004015fd
  4000cc:	004015fd 	.word	0x004015fd

004000d0 <deregister_tm_clones>:
  4000d0:	b508      	push	{r3, lr}
  4000d2:	4805      	ldr	r0, [pc, #20]	; (4000e8 <deregister_tm_clones+0x18>)
  4000d4:	4b05      	ldr	r3, [pc, #20]	; (4000ec <deregister_tm_clones+0x1c>)
  4000d6:	1a19      	subs	r1, r3, r0
  4000d8:	2906      	cmp	r1, #6
  4000da:	d800      	bhi.n	4000de <deregister_tm_clones+0xe>
  4000dc:	bd08      	pop	{r3, pc}
  4000de:	4a04      	ldr	r2, [pc, #16]	; (4000f0 <deregister_tm_clones+0x20>)
  4000e0:	2a00      	cmp	r2, #0
  4000e2:	d0fb      	beq.n	4000dc <deregister_tm_clones+0xc>
  4000e4:	4790      	blx	r2
  4000e6:	e7f9      	b.n	4000dc <deregister_tm_clones+0xc>
  4000e8:	00404b3c 	.word	0x00404b3c
  4000ec:	00404b3f 	.word	0x00404b3f
  4000f0:	00000000 	.word	0x00000000

004000f4 <register_tm_clones>:
  4000f4:	b508      	push	{r3, lr}
  4000f6:	4807      	ldr	r0, [pc, #28]	; (400114 <register_tm_clones+0x20>)
  4000f8:	4b07      	ldr	r3, [pc, #28]	; (400118 <register_tm_clones+0x24>)
  4000fa:	1a19      	subs	r1, r3, r0
  4000fc:	108a      	asrs	r2, r1, #2
  4000fe:	eb02 73d2 	add.w	r3, r2, r2, lsr #31
  400102:	1059      	asrs	r1, r3, #1
  400104:	d100      	bne.n	400108 <register_tm_clones+0x14>
  400106:	bd08      	pop	{r3, pc}
  400108:	4a04      	ldr	r2, [pc, #16]	; (40011c <register_tm_clones+0x28>)
  40010a:	2a00      	cmp	r2, #0
  40010c:	d0fb      	beq.n	400106 <register_tm_clones+0x12>
  40010e:	4790      	blx	r2
  400110:	e7f9      	b.n	400106 <register_tm_clones+0x12>
  400112:	bf00      	nop
  400114:	00404b3c 	.word	0x00404b3c
  400118:	00404b3c 	.word	0x00404b3c
  40011c:	00000000 	.word	0x00000000

00400120 <__do_global_dtors_aux>:
  400120:	b510      	push	{r4, lr}
  400122:	4c06      	ldr	r4, [pc, #24]	; (40013c <__do_global_dtors_aux+0x1c>)
  400124:	7823      	ldrb	r3, [r4, #0]
  400126:	b943      	cbnz	r3, 40013a <__do_global_dtors_aux+0x1a>
  400128:	f7ff ffd2 	bl	4000d0 <deregister_tm_clones>
  40012c:	4804      	ldr	r0, [pc, #16]	; (400140 <__do_global_dtors_aux+0x20>)
  40012e:	b110      	cbz	r0, 400136 <__do_global_dtors_aux+0x16>
  400130:	4804      	ldr	r0, [pc, #16]	; (400144 <__do_global_dtors_aux+0x24>)
  400132:	f3af 8000 	nop.w
  400136:	2101      	movs	r1, #1
  400138:	7021      	strb	r1, [r4, #0]
  40013a:	bd10      	pop	{r4, pc}
  40013c:	20000440 	.word	0x20000440
  400140:	00000000 	.word	0x00000000
  400144:	00404b3c 	.word	0x00404b3c

00400148 <frame_dummy>:
  400148:	b508      	push	{r3, lr}
  40014a:	4b08      	ldr	r3, [pc, #32]	; (40016c <frame_dummy+0x24>)
  40014c:	b11b      	cbz	r3, 400156 <frame_dummy+0xe>
  40014e:	4808      	ldr	r0, [pc, #32]	; (400170 <frame_dummy+0x28>)
  400150:	4908      	ldr	r1, [pc, #32]	; (400174 <frame_dummy+0x2c>)
  400152:	f3af 8000 	nop.w
  400156:	4808      	ldr	r0, [pc, #32]	; (400178 <frame_dummy+0x30>)
  400158:	6801      	ldr	r1, [r0, #0]
  40015a:	b111      	cbz	r1, 400162 <frame_dummy+0x1a>
  40015c:	4a07      	ldr	r2, [pc, #28]	; (40017c <frame_dummy+0x34>)
  40015e:	b102      	cbz	r2, 400162 <frame_dummy+0x1a>
  400160:	4790      	blx	r2
  400162:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  400166:	f7ff bfc5 	b.w	4000f4 <register_tm_clones>
  40016a:	bf00      	nop
  40016c:	00000000 	.word	0x00000000
  400170:	00404b3c 	.word	0x00404b3c
  400174:	20000444 	.word	0x20000444
  400178:	00404b3c 	.word	0x00404b3c
  40017c:	00000000 	.word	0x00000000

00400180 <usart_disable_interrupt>:
 *
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_disable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
  400180:	b480      	push	{r7}
  400182:	b083      	sub	sp, #12
  400184:	af00      	add	r7, sp, #0
  400186:	6078      	str	r0, [r7, #4]
  400188:	6039      	str	r1, [r7, #0]
	p_usart->US_IDR = ul_sources;
  40018a:	687b      	ldr	r3, [r7, #4]
  40018c:	683a      	ldr	r2, [r7, #0]
  40018e:	60da      	str	r2, [r3, #12]
}
  400190:	f107 070c 	add.w	r7, r7, #12
  400194:	46bd      	mov	sp, r7
  400196:	bc80      	pop	{r7}
  400198:	4770      	bx	lr
  40019a:	bf00      	nop

0040019c <usart_get_interrupt_mask>:
 * \param p_usart Pointer to a USART peripheral.
 *
 * \return The interrupt mask value.
 */
uint32_t usart_get_interrupt_mask(Usart *p_usart)
{
  40019c:	b480      	push	{r7}
  40019e:	b083      	sub	sp, #12
  4001a0:	af00      	add	r7, sp, #0
  4001a2:	6078      	str	r0, [r7, #4]
	return p_usart->US_IMR;
  4001a4:	687b      	ldr	r3, [r7, #4]
  4001a6:	691b      	ldr	r3, [r3, #16]
}
  4001a8:	4618      	mov	r0, r3
  4001aa:	f107 070c 	add.w	r7, r7, #12
  4001ae:	46bd      	mov	sp, r7
  4001b0:	bc80      	pop	{r7}
  4001b2:	4770      	bx	lr

004001b4 <usart_get_status>:
 * \param p_usart Pointer to a USART instance.
 *
 * \return The current USART status.
 */
uint32_t usart_get_status(Usart *p_usart)
{
  4001b4:	b480      	push	{r7}
  4001b6:	b083      	sub	sp, #12
  4001b8:	af00      	add	r7, sp, #0
  4001ba:	6078      	str	r0, [r7, #4]
	return p_usart->US_CSR;
  4001bc:	687b      	ldr	r3, [r7, #4]
  4001be:	695b      	ldr	r3, [r3, #20]
}
  4001c0:	4618      	mov	r0, r3
  4001c2:	f107 070c 	add.w	r7, r7, #12
  4001c6:	46bd      	mov	sp, r7
  4001c8:	bc80      	pop	{r7}
  4001ca:	4770      	bx	lr

004001cc <usart_putchar>:
 *
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_putchar(Usart *p_usart, uint32_t c)
{
  4001cc:	b480      	push	{r7}
  4001ce:	b085      	sub	sp, #20
  4001d0:	af00      	add	r7, sp, #0
  4001d2:	6078      	str	r0, [r7, #4]
  4001d4:	6039      	str	r1, [r7, #0]
	uint32_t timeout = USART_DEFAULT_TIMEOUT;
  4001d6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  4001da:	60fb      	str	r3, [r7, #12]

	while (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  4001dc:	e00e      	b.n	4001fc <usart_putchar+0x30>
		if (!timeout--) {
  4001de:	68fb      	ldr	r3, [r7, #12]
  4001e0:	2b00      	cmp	r3, #0
  4001e2:	bf14      	ite	ne
  4001e4:	2300      	movne	r3, #0
  4001e6:	2301      	moveq	r3, #1
  4001e8:	b2db      	uxtb	r3, r3
  4001ea:	68fa      	ldr	r2, [r7, #12]
  4001ec:	f102 32ff 	add.w	r2, r2, #4294967295
  4001f0:	60fa      	str	r2, [r7, #12]
  4001f2:	2b00      	cmp	r3, #0
  4001f4:	d002      	beq.n	4001fc <usart_putchar+0x30>
			return 1;
  4001f6:	f04f 0301 	mov.w	r3, #1
  4001fa:	e00e      	b.n	40021a <usart_putchar+0x4e>
 */
uint32_t usart_putchar(Usart *p_usart, uint32_t c)
{
	uint32_t timeout = USART_DEFAULT_TIMEOUT;

	while (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  4001fc:	687b      	ldr	r3, [r7, #4]
  4001fe:	695b      	ldr	r3, [r3, #20]
  400200:	f003 0302 	and.w	r3, r3, #2
  400204:	2b00      	cmp	r3, #0
  400206:	d0ea      	beq.n	4001de <usart_putchar+0x12>
		if (!timeout--) {
			return 1;
		}
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  400208:	683b      	ldr	r3, [r7, #0]
  40020a:	ea4f 53c3 	mov.w	r3, r3, lsl #23
  40020e:	ea4f 53d3 	mov.w	r3, r3, lsr #23
  400212:	687a      	ldr	r2, [r7, #4]
  400214:	61d3      	str	r3, [r2, #28]

	return 0;
  400216:	f04f 0300 	mov.w	r3, #0
}
  40021a:	4618      	mov	r0, r3
  40021c:	f107 0714 	add.w	r7, r7, #20
  400220:	46bd      	mov	sp, r7
  400222:	bc80      	pop	{r7}
  400224:	4770      	bx	lr
  400226:	bf00      	nop

00400228 <usart_getchar>:
 *
 * \retval 0 Data has been received.
 * \retval 1 on failure.
 */
uint32_t usart_getchar(Usart *p_usart, uint32_t *c)
{
  400228:	b480      	push	{r7}
  40022a:	b085      	sub	sp, #20
  40022c:	af00      	add	r7, sp, #0
  40022e:	6078      	str	r0, [r7, #4]
  400230:	6039      	str	r1, [r7, #0]
	uint32_t timeout = USART_DEFAULT_TIMEOUT;
  400232:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  400236:	60fb      	str	r3, [r7, #12]

	/* If the receiver is empty, wait until it's not empty or timeout has reached. */
	while (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  400238:	e00e      	b.n	400258 <usart_getchar+0x30>
		if (!timeout--) {
  40023a:	68fb      	ldr	r3, [r7, #12]
  40023c:	2b00      	cmp	r3, #0
  40023e:	bf14      	ite	ne
  400240:	2300      	movne	r3, #0
  400242:	2301      	moveq	r3, #1
  400244:	b2db      	uxtb	r3, r3
  400246:	68fa      	ldr	r2, [r7, #12]
  400248:	f102 32ff 	add.w	r2, r2, #4294967295
  40024c:	60fa      	str	r2, [r7, #12]
  40024e:	2b00      	cmp	r3, #0
  400250:	d002      	beq.n	400258 <usart_getchar+0x30>
			return 1;
  400252:	f04f 0301 	mov.w	r3, #1
  400256:	e00f      	b.n	400278 <usart_getchar+0x50>
uint32_t usart_getchar(Usart *p_usart, uint32_t *c)
{
	uint32_t timeout = USART_DEFAULT_TIMEOUT;

	/* If the receiver is empty, wait until it's not empty or timeout has reached. */
	while (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  400258:	687b      	ldr	r3, [r7, #4]
  40025a:	695b      	ldr	r3, [r3, #20]
  40025c:	f003 0301 	and.w	r3, r3, #1
  400260:	2b00      	cmp	r3, #0
  400262:	d0ea      	beq.n	40023a <usart_getchar+0x12>
			return 1;
		}
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  400264:	687b      	ldr	r3, [r7, #4]
  400266:	699b      	ldr	r3, [r3, #24]
  400268:	ea4f 53c3 	mov.w	r3, r3, lsl #23
  40026c:	ea4f 53d3 	mov.w	r3, r3, lsr #23
  400270:	683a      	ldr	r2, [r7, #0]
  400272:	6013      	str	r3, [r2, #0]

	return 0;
  400274:	f04f 0300 	mov.w	r3, #0
}
  400278:	4618      	mov	r0, r3
  40027a:	f107 0714 	add.w	r7, r7, #20
  40027e:	46bd      	mov	sp, r7
  400280:	bc80      	pop	{r7}
  400282:	4770      	bx	lr

00400284 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  400284:	b580      	push	{r7, lr}
  400286:	b086      	sub	sp, #24
  400288:	af00      	add	r7, sp, #0
  40028a:	6078      	str	r0, [r7, #4]
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
  40028c:	f04f 0300 	mov.w	r3, #0
  400290:	60fb      	str	r3, [r7, #12]

	vTaskSuspendAll();
  400292:	f642 7331 	movw	r3, #12081	; 0x2f31
  400296:	f2c0 0340 	movt	r3, #64	; 0x40
  40029a:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
  40029c:	f24a 4364 	movw	r3, #42084	; 0xa464
  4002a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4002a4:	681b      	ldr	r3, [r3, #0]
  4002a6:	2b00      	cmp	r3, #0
  4002a8:	d104      	bne.n	4002b4 <pvPortMalloc+0x30>
		{
			prvHeapInit();
  4002aa:	f240 43d9 	movw	r3, #1241	; 0x4d9
  4002ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4002b2:	4798      	blx	r3

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the xBlockLink structure 
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
  4002b4:	f24a 4368 	movw	r3, #42088	; 0xa468
  4002b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4002bc:	681a      	ldr	r2, [r3, #0]
  4002be:	687b      	ldr	r3, [r7, #4]
  4002c0:	4013      	ands	r3, r2
  4002c2:	2b00      	cmp	r3, #0
  4002c4:	f040 808b 	bne.w	4003de <pvPortMalloc+0x15a>
		{
			/* The wanted size is increased so it can contain a xBlockLink
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
  4002c8:	687b      	ldr	r3, [r7, #4]
  4002ca:	2b00      	cmp	r3, #0
  4002cc:	d012      	beq.n	4002f4 <pvPortMalloc+0x70>
			{
				xWantedSize += heapSTRUCT_SIZE;
  4002ce:	f644 23cc 	movw	r3, #19148	; 0x4acc
  4002d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4002d6:	881b      	ldrh	r3, [r3, #0]
  4002d8:	687a      	ldr	r2, [r7, #4]
  4002da:	18d3      	adds	r3, r2, r3
  4002dc:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number 
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
  4002de:	687b      	ldr	r3, [r7, #4]
  4002e0:	f003 0307 	and.w	r3, r3, #7
  4002e4:	2b00      	cmp	r3, #0
  4002e6:	d005      	beq.n	4002f4 <pvPortMalloc+0x70>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  4002e8:	687b      	ldr	r3, [r7, #4]
  4002ea:	f023 0307 	bic.w	r3, r3, #7
  4002ee:	f103 0308 	add.w	r3, r3, #8
  4002f2:	607b      	str	r3, [r7, #4]
				}
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
  4002f4:	687b      	ldr	r3, [r7, #4]
  4002f6:	2b00      	cmp	r3, #0
  4002f8:	d071      	beq.n	4003de <pvPortMalloc+0x15a>
  4002fa:	f240 0300 	movw	r3, #0
  4002fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400302:	681b      	ldr	r3, [r3, #0]
  400304:	687a      	ldr	r2, [r7, #4]
  400306:	429a      	cmp	r2, r3
  400308:	d869      	bhi.n	4003de <pvPortMalloc+0x15a>
			{
				/* Traverse the list from the start	(lowest address) block until 
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
  40030a:	f24a 435c 	movw	r3, #42076	; 0xa45c
  40030e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400312:	613b      	str	r3, [r7, #16]
				pxBlock = xStart.pxNextFreeBlock;
  400314:	f24a 435c 	movw	r3, #42076	; 0xa45c
  400318:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40031c:	681b      	ldr	r3, [r3, #0]
  40031e:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  400320:	e004      	b.n	40032c <pvPortMalloc+0xa8>
				{
					pxPreviousBlock = pxBlock;
  400322:	697b      	ldr	r3, [r7, #20]
  400324:	613b      	str	r3, [r7, #16]
					pxBlock = pxBlock->pxNextFreeBlock;
  400326:	697b      	ldr	r3, [r7, #20]
  400328:	681b      	ldr	r3, [r3, #0]
  40032a:	617b      	str	r3, [r7, #20]
			{
				/* Traverse the list from the start	(lowest address) block until 
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  40032c:	697b      	ldr	r3, [r7, #20]
  40032e:	685a      	ldr	r2, [r3, #4]
  400330:	687b      	ldr	r3, [r7, #4]
  400332:	429a      	cmp	r2, r3
  400334:	d203      	bcs.n	40033e <pvPortMalloc+0xba>
  400336:	697b      	ldr	r3, [r7, #20]
  400338:	681b      	ldr	r3, [r3, #0]
  40033a:	2b00      	cmp	r3, #0
  40033c:	d1f1      	bne.n	400322 <pvPortMalloc+0x9e>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size 
				was	not found. */
				if( pxBlock != pxEnd )
  40033e:	f24a 4364 	movw	r3, #42084	; 0xa464
  400342:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400346:	681b      	ldr	r3, [r3, #0]
  400348:	697a      	ldr	r2, [r7, #20]
  40034a:	429a      	cmp	r2, r3
  40034c:	d047      	beq.n	4003de <pvPortMalloc+0x15a>
				{
					/* Return the memory space pointed to - jumping over the 
					xBlockLink structure at its start. */
					pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
  40034e:	693b      	ldr	r3, [r7, #16]
  400350:	681a      	ldr	r2, [r3, #0]
  400352:	f644 23cc 	movw	r3, #19148	; 0x4acc
  400356:	f2c0 0340 	movt	r3, #64	; 0x40
  40035a:	881b      	ldrh	r3, [r3, #0]
  40035c:	18d3      	adds	r3, r2, r3
  40035e:	60fb      	str	r3, [r7, #12]

					/* This block is being returned for use so must be taken out 
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  400360:	697b      	ldr	r3, [r7, #20]
  400362:	681a      	ldr	r2, [r3, #0]
  400364:	693b      	ldr	r3, [r7, #16]
  400366:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into 
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  400368:	697b      	ldr	r3, [r7, #20]
  40036a:	685a      	ldr	r2, [r3, #4]
  40036c:	687b      	ldr	r3, [r7, #4]
  40036e:	1ad2      	subs	r2, r2, r3
  400370:	f644 23cc 	movw	r3, #19148	; 0x4acc
  400374:	f2c0 0340 	movt	r3, #64	; 0x40
  400378:	881b      	ldrh	r3, [r3, #0]
  40037a:	ea4f 0343 	mov.w	r3, r3, lsl #1
  40037e:	429a      	cmp	r2, r3
  400380:	d912      	bls.n	4003a8 <pvPortMalloc+0x124>
					{
						/* This block is to be split into two.  Create a new 
						block following the number of bytes requested. The void 
						cast is used to prevent byte alignment warnings from the 
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
  400382:	697a      	ldr	r2, [r7, #20]
  400384:	687b      	ldr	r3, [r7, #4]
  400386:	18d3      	adds	r3, r2, r3
  400388:	60bb      	str	r3, [r7, #8]

						/* Calculate the sizes of two blocks split from the 
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  40038a:	697b      	ldr	r3, [r7, #20]
  40038c:	685a      	ldr	r2, [r3, #4]
  40038e:	687b      	ldr	r3, [r7, #4]
  400390:	1ad2      	subs	r2, r2, r3
  400392:	68bb      	ldr	r3, [r7, #8]
  400394:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
  400396:	697b      	ldr	r3, [r7, #20]
  400398:	687a      	ldr	r2, [r7, #4]
  40039a:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
  40039c:	68b8      	ldr	r0, [r7, #8]
  40039e:	f240 53d5 	movw	r3, #1493	; 0x5d5
  4003a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4003a6:	4798      	blx	r3
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
  4003a8:	f240 0300 	movw	r3, #0
  4003ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4003b0:	681a      	ldr	r2, [r3, #0]
  4003b2:	697b      	ldr	r3, [r7, #20]
  4003b4:	685b      	ldr	r3, [r3, #4]
  4003b6:	1ad2      	subs	r2, r2, r3
  4003b8:	f240 0300 	movw	r3, #0
  4003bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4003c0:	601a      	str	r2, [r3, #0]

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
  4003c2:	697b      	ldr	r3, [r7, #20]
  4003c4:	685a      	ldr	r2, [r3, #4]
  4003c6:	f24a 4368 	movw	r3, #42088	; 0xa468
  4003ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4003ce:	681b      	ldr	r3, [r3, #0]
  4003d0:	431a      	orrs	r2, r3
  4003d2:	697b      	ldr	r3, [r7, #20]
  4003d4:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
  4003d6:	697b      	ldr	r3, [r7, #20]
  4003d8:	f04f 0200 	mov.w	r2, #0
  4003dc:	601a      	str	r2, [r3, #0]
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	xTaskResumeAll();
  4003de:	f642 7355 	movw	r3, #12117	; 0x2f55
  4003e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4003e6:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
  4003e8:	68fb      	ldr	r3, [r7, #12]
  4003ea:	2b00      	cmp	r3, #0
  4003ec:	d104      	bne.n	4003f8 <pvPortMalloc+0x174>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
  4003ee:	f244 637d 	movw	r3, #18045	; 0x467d
  4003f2:	f2c0 0340 	movt	r3, #64	; 0x40
  4003f6:	4798      	blx	r3
		}
	}
	#endif

	return pvReturn;
  4003f8:	68fb      	ldr	r3, [r7, #12]
}
  4003fa:	4618      	mov	r0, r3
  4003fc:	f107 0718 	add.w	r7, r7, #24
  400400:	46bd      	mov	sp, r7
  400402:	bd80      	pop	{r7, pc}

00400404 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  400404:	b580      	push	{r7, lr}
  400406:	b084      	sub	sp, #16
  400408:	af00      	add	r7, sp, #0
  40040a:	6078      	str	r0, [r7, #4]
unsigned char *puc = ( unsigned char * ) pv;
  40040c:	687b      	ldr	r3, [r7, #4]
  40040e:	60fb      	str	r3, [r7, #12]
xBlockLink *pxLink;

	if( pv != NULL )
  400410:	687b      	ldr	r3, [r7, #4]
  400412:	2b00      	cmp	r3, #0
  400414:	d05c      	beq.n	4004d0 <vPortFree+0xcc>
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
  400416:	f644 23cc 	movw	r3, #19148	; 0x4acc
  40041a:	f2c0 0340 	movt	r3, #64	; 0x40
  40041e:	881b      	ldrh	r3, [r3, #0]
  400420:	f1c3 0300 	rsb	r3, r3, #0
  400424:	68fa      	ldr	r2, [r7, #12]
  400426:	18d3      	adds	r3, r2, r3
  400428:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
  40042a:	68fb      	ldr	r3, [r7, #12]
  40042c:	60bb      	str	r3, [r7, #8]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
  40042e:	68bb      	ldr	r3, [r7, #8]
  400430:	685a      	ldr	r2, [r3, #4]
  400432:	f24a 4368 	movw	r3, #42088	; 0xa468
  400436:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40043a:	681b      	ldr	r3, [r3, #0]
  40043c:	4013      	ands	r3, r2
  40043e:	2b00      	cmp	r3, #0
  400440:	d105      	bne.n	40044e <vPortFree+0x4a>
  400442:	f641 6305 	movw	r3, #7685	; 0x1e05
  400446:	f2c0 0340 	movt	r3, #64	; 0x40
  40044a:	4798      	blx	r3
  40044c:	e7fe      	b.n	40044c <vPortFree+0x48>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
  40044e:	68bb      	ldr	r3, [r7, #8]
  400450:	681b      	ldr	r3, [r3, #0]
  400452:	2b00      	cmp	r3, #0
  400454:	d005      	beq.n	400462 <vPortFree+0x5e>
  400456:	f641 6305 	movw	r3, #7685	; 0x1e05
  40045a:	f2c0 0340 	movt	r3, #64	; 0x40
  40045e:	4798      	blx	r3
  400460:	e7fe      	b.n	400460 <vPortFree+0x5c>
		
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
  400462:	68bb      	ldr	r3, [r7, #8]
  400464:	685a      	ldr	r2, [r3, #4]
  400466:	f24a 4368 	movw	r3, #42088	; 0xa468
  40046a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40046e:	681b      	ldr	r3, [r3, #0]
  400470:	4013      	ands	r3, r2
  400472:	2b00      	cmp	r3, #0
  400474:	d02c      	beq.n	4004d0 <vPortFree+0xcc>
		{
			if( pxLink->pxNextFreeBlock == NULL )
  400476:	68bb      	ldr	r3, [r7, #8]
  400478:	681b      	ldr	r3, [r3, #0]
  40047a:	2b00      	cmp	r3, #0
  40047c:	d128      	bne.n	4004d0 <vPortFree+0xcc>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
  40047e:	68bb      	ldr	r3, [r7, #8]
  400480:	685a      	ldr	r2, [r3, #4]
  400482:	f24a 4368 	movw	r3, #42088	; 0xa468
  400486:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40048a:	681b      	ldr	r3, [r3, #0]
  40048c:	ea6f 0303 	mvn.w	r3, r3
  400490:	401a      	ands	r2, r3
  400492:	68bb      	ldr	r3, [r7, #8]
  400494:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
  400496:	f642 7331 	movw	r3, #12081	; 0x2f31
  40049a:	f2c0 0340 	movt	r3, #64	; 0x40
  40049e:	4798      	blx	r3
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
  4004a0:	68bb      	ldr	r3, [r7, #8]
  4004a2:	685a      	ldr	r2, [r3, #4]
  4004a4:	f240 0300 	movw	r3, #0
  4004a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4004ac:	681b      	ldr	r3, [r3, #0]
  4004ae:	18d2      	adds	r2, r2, r3
  4004b0:	f240 0300 	movw	r3, #0
  4004b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4004b8:	601a      	str	r2, [r3, #0]
					prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
  4004ba:	68b8      	ldr	r0, [r7, #8]
  4004bc:	f240 53d5 	movw	r3, #1493	; 0x5d5
  4004c0:	f2c0 0340 	movt	r3, #64	; 0x40
  4004c4:	4798      	blx	r3
					traceFREE( pv, pxLink->xBlockSize );
				}
				xTaskResumeAll();
  4004c6:	f642 7355 	movw	r3, #12117	; 0x2f55
  4004ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4004ce:	4798      	blx	r3
			}
		}
	}
}
  4004d0:	f107 0710 	add.w	r7, r7, #16
  4004d4:	46bd      	mov	sp, r7
  4004d6:	bd80      	pop	{r7, pc}

004004d8 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
  4004d8:	b580      	push	{r7, lr}
  4004da:	b084      	sub	sp, #16
  4004dc:	af00      	add	r7, sp, #0
xBlockLink *pxFirstFreeBlock;
unsigned char *pucHeapEnd, *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
  4004de:	4b3c      	ldr	r3, [pc, #240]	; (4005d0 <prvHeapInit+0xf8>)
  4004e0:	f023 0307 	bic.w	r3, r3, #7
  4004e4:	60fb      	str	r3, [r7, #12]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  4004e6:	f24a 435c 	movw	r3, #42076	; 0xa45c
  4004ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4004ee:	68fa      	ldr	r2, [r7, #12]
  4004f0:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
  4004f2:	f24a 435c 	movw	r3, #42076	; 0xa45c
  4004f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4004fa:	f04f 0200 	mov.w	r2, #0
  4004fe:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = pucAlignedHeap + xTotalHeapSize;
  400500:	f644 23d0 	movw	r3, #19152	; 0x4ad0
  400504:	f2c0 0340 	movt	r3, #64	; 0x40
  400508:	681b      	ldr	r3, [r3, #0]
  40050a:	68fa      	ldr	r2, [r7, #12]
  40050c:	18d3      	adds	r3, r2, r3
  40050e:	60bb      	str	r3, [r7, #8]
	pucHeapEnd -= heapSTRUCT_SIZE;
  400510:	f644 23cc 	movw	r3, #19148	; 0x4acc
  400514:	f2c0 0340 	movt	r3, #64	; 0x40
  400518:	881b      	ldrh	r3, [r3, #0]
  40051a:	f1c3 0300 	rsb	r3, r3, #0
  40051e:	68ba      	ldr	r2, [r7, #8]
  400520:	18d3      	adds	r3, r2, r3
  400522:	60bb      	str	r3, [r7, #8]
	pxEnd = ( void * ) pucHeapEnd;
  400524:	f24a 4364 	movw	r3, #42084	; 0xa464
  400528:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40052c:	68ba      	ldr	r2, [r7, #8]
  40052e:	601a      	str	r2, [r3, #0]
	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
  400530:	f24a 4364 	movw	r3, #42084	; 0xa464
  400534:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400538:	681b      	ldr	r3, [r3, #0]
  40053a:	f003 0307 	and.w	r3, r3, #7
  40053e:	2b00      	cmp	r3, #0
  400540:	d005      	beq.n	40054e <prvHeapInit+0x76>
  400542:	f641 6305 	movw	r3, #7685	; 0x1e05
  400546:	f2c0 0340 	movt	r3, #64	; 0x40
  40054a:	4798      	blx	r3
  40054c:	e7fe      	b.n	40054c <prvHeapInit+0x74>
	pxEnd->xBlockSize = 0;
  40054e:	f24a 4364 	movw	r3, #42084	; 0xa464
  400552:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400556:	681b      	ldr	r3, [r3, #0]
  400558:	f04f 0200 	mov.w	r2, #0
  40055c:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
  40055e:	f24a 4364 	movw	r3, #42084	; 0xa464
  400562:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400566:	681b      	ldr	r3, [r3, #0]
  400568:	f04f 0200 	mov.w	r2, #0
  40056c:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
  40056e:	68fb      	ldr	r3, [r7, #12]
  400570:	607b      	str	r3, [r7, #4]
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
  400572:	f644 23d0 	movw	r3, #19152	; 0x4ad0
  400576:	f2c0 0340 	movt	r3, #64	; 0x40
  40057a:	681a      	ldr	r2, [r3, #0]
  40057c:	f644 23cc 	movw	r3, #19148	; 0x4acc
  400580:	f2c0 0340 	movt	r3, #64	; 0x40
  400584:	881b      	ldrh	r3, [r3, #0]
  400586:	1ad2      	subs	r2, r2, r3
  400588:	687b      	ldr	r3, [r7, #4]
  40058a:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  40058c:	f24a 4364 	movw	r3, #42084	; 0xa464
  400590:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400594:	681a      	ldr	r2, [r3, #0]
  400596:	687b      	ldr	r3, [r7, #4]
  400598:	601a      	str	r2, [r3, #0]

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
  40059a:	f240 0300 	movw	r3, #0
  40059e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4005a2:	681a      	ldr	r2, [r3, #0]
  4005a4:	f644 23cc 	movw	r3, #19148	; 0x4acc
  4005a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4005ac:	881b      	ldrh	r3, [r3, #0]
  4005ae:	1ad2      	subs	r2, r2, r3
  4005b0:	f240 0300 	movw	r3, #0
  4005b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4005b8:	601a      	str	r2, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  4005ba:	f24a 4368 	movw	r3, #42088	; 0xa468
  4005be:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4005c2:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  4005c6:	601a      	str	r2, [r3, #0]
}
  4005c8:	f107 0710 	add.w	r7, r7, #16
  4005cc:	46bd      	mov	sp, r7
  4005ce:	bd80      	pop	{r7, pc}
  4005d0:	20000464 	.word	0x20000464

004005d4 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
  4005d4:	b480      	push	{r7}
  4005d6:	b085      	sub	sp, #20
  4005d8:	af00      	add	r7, sp, #0
  4005da:	6078      	str	r0, [r7, #4]
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  4005dc:	f24a 435c 	movw	r3, #42076	; 0xa45c
  4005e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4005e4:	60fb      	str	r3, [r7, #12]
  4005e6:	e002      	b.n	4005ee <prvInsertBlockIntoFreeList+0x1a>
  4005e8:	68fb      	ldr	r3, [r7, #12]
  4005ea:	681b      	ldr	r3, [r3, #0]
  4005ec:	60fb      	str	r3, [r7, #12]
  4005ee:	68fb      	ldr	r3, [r7, #12]
  4005f0:	681a      	ldr	r2, [r3, #0]
  4005f2:	687b      	ldr	r3, [r7, #4]
  4005f4:	429a      	cmp	r2, r3
  4005f6:	d3f7      	bcc.n	4005e8 <prvInsertBlockIntoFreeList+0x14>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
  4005f8:	68fb      	ldr	r3, [r7, #12]
  4005fa:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
  4005fc:	68fb      	ldr	r3, [r7, #12]
  4005fe:	685b      	ldr	r3, [r3, #4]
  400600:	68ba      	ldr	r2, [r7, #8]
  400602:	18d2      	adds	r2, r2, r3
  400604:	687b      	ldr	r3, [r7, #4]
  400606:	429a      	cmp	r2, r3
  400608:	d108      	bne.n	40061c <prvInsertBlockIntoFreeList+0x48>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  40060a:	68fb      	ldr	r3, [r7, #12]
  40060c:	685a      	ldr	r2, [r3, #4]
  40060e:	687b      	ldr	r3, [r7, #4]
  400610:	685b      	ldr	r3, [r3, #4]
  400612:	18d2      	adds	r2, r2, r3
  400614:	68fb      	ldr	r3, [r7, #12]
  400616:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
  400618:	68fb      	ldr	r3, [r7, #12]
  40061a:	607b      	str	r3, [r7, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
  40061c:	687b      	ldr	r3, [r7, #4]
  40061e:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
  400620:	687b      	ldr	r3, [r7, #4]
  400622:	685b      	ldr	r3, [r3, #4]
  400624:	68ba      	ldr	r2, [r7, #8]
  400626:	18d2      	adds	r2, r2, r3
  400628:	68fb      	ldr	r3, [r7, #12]
  40062a:	681b      	ldr	r3, [r3, #0]
  40062c:	429a      	cmp	r2, r3
  40062e:	d11e      	bne.n	40066e <prvInsertBlockIntoFreeList+0x9a>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  400630:	68fb      	ldr	r3, [r7, #12]
  400632:	681a      	ldr	r2, [r3, #0]
  400634:	f24a 4364 	movw	r3, #42084	; 0xa464
  400638:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40063c:	681b      	ldr	r3, [r3, #0]
  40063e:	429a      	cmp	r2, r3
  400640:	d00d      	beq.n	40065e <prvInsertBlockIntoFreeList+0x8a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  400642:	687b      	ldr	r3, [r7, #4]
  400644:	685a      	ldr	r2, [r3, #4]
  400646:	68fb      	ldr	r3, [r7, #12]
  400648:	681b      	ldr	r3, [r3, #0]
  40064a:	685b      	ldr	r3, [r3, #4]
  40064c:	18d2      	adds	r2, r2, r3
  40064e:	687b      	ldr	r3, [r7, #4]
  400650:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  400652:	68fb      	ldr	r3, [r7, #12]
  400654:	681b      	ldr	r3, [r3, #0]
  400656:	681a      	ldr	r2, [r3, #0]
  400658:	687b      	ldr	r3, [r7, #4]
  40065a:	601a      	str	r2, [r3, #0]
  40065c:	e00b      	b.n	400676 <prvInsertBlockIntoFreeList+0xa2>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  40065e:	f24a 4364 	movw	r3, #42084	; 0xa464
  400662:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400666:	681a      	ldr	r2, [r3, #0]
  400668:	687b      	ldr	r3, [r7, #4]
  40066a:	601a      	str	r2, [r3, #0]
  40066c:	e003      	b.n	400676 <prvInsertBlockIntoFreeList+0xa2>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
  40066e:	68fb      	ldr	r3, [r7, #12]
  400670:	681a      	ldr	r2, [r3, #0]
  400672:	687b      	ldr	r3, [r7, #4]
  400674:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  400676:	68fa      	ldr	r2, [r7, #12]
  400678:	687b      	ldr	r3, [r7, #4]
  40067a:	429a      	cmp	r2, r3
  40067c:	d002      	beq.n	400684 <prvInsertBlockIntoFreeList+0xb0>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  40067e:	68fb      	ldr	r3, [r7, #12]
  400680:	687a      	ldr	r2, [r7, #4]
  400682:	601a      	str	r2, [r3, #0]
	}
}
  400684:	f107 0714 	add.w	r7, r7, #20
  400688:	46bd      	mov	sp, r7
  40068a:	bc80      	pop	{r7}
  40068c:	4770      	bx	lr
  40068e:	bf00      	nop

00400690 <USART1_Handler>:
 * inside an interrupt service routine.  The serial driver used here is *not* 
 * intended to represent an efficient implementation.  Real applications should 
 * make use of the USARTS peripheral DMA channel (PDC).
 */
void USART1_Handler( void )
{
  400690:	b590      	push	{r4, r7, lr}
  400692:	b087      	sub	sp, #28
  400694:	af00      	add	r7, sp, #0
portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
  400696:	f04f 0300 	mov.w	r3, #0
  40069a:	60fb      	str	r3, [r7, #12]
uint8_t ucChar;
uint32_t ulChar;
uint32_t ulUSARTStatus, ulUSARTMask;

	ulUSARTStatus = usart_get_status( serUSART_PORT );
  40069c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  4006a0:	f2c4 0002 	movt	r0, #16386	; 0x4002
  4006a4:	f240 13b5 	movw	r3, #437	; 0x1b5
  4006a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4006ac:	4798      	blx	r3
  4006ae:	6178      	str	r0, [r7, #20]
	ulUSARTMask = usart_get_interrupt_mask( serUSART_PORT );
  4006b0:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  4006b4:	f2c4 0002 	movt	r0, #16386	; 0x4002
  4006b8:	f240 139d 	movw	r3, #413	; 0x19d
  4006bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4006c0:	4798      	blx	r3
  4006c2:	6138      	str	r0, [r7, #16]
	ulUSARTStatus &= ulUSARTMask;
  4006c4:	697a      	ldr	r2, [r7, #20]
  4006c6:	693b      	ldr	r3, [r7, #16]
  4006c8:	4013      	ands	r3, r2
  4006ca:	617b      	str	r3, [r7, #20]

	if( ( ulUSARTStatus & US_CSR_TXRDY ) != 0UL )
  4006cc:	697b      	ldr	r3, [r7, #20]
  4006ce:	f003 0302 	and.w	r3, r3, #2
  4006d2:	2b00      	cmp	r3, #0
  4006d4:	d02a      	beq.n	40072c <USART1_Handler+0x9c>
	{
		/* The interrupt was caused by the TX register becoming empty.  Are 
		there any more characters to transmit? */
		if( xQueueReceiveFromISR( xCharsForTx, &ucChar, &xHigherPriorityTaskWoken ) == pdTRUE )
  4006d6:	f24a 4370 	movw	r3, #42096	; 0xa470
  4006da:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4006de:	6819      	ldr	r1, [r3, #0]
  4006e0:	f107 020b 	add.w	r2, r7, #11
  4006e4:	f107 030c 	add.w	r3, r7, #12
  4006e8:	4608      	mov	r0, r1
  4006ea:	4611      	mov	r1, r2
  4006ec:	461a      	mov	r2, r3
  4006ee:	f242 63b9 	movw	r3, #9913	; 0x26b9
  4006f2:	f2c0 0340 	movt	r3, #64	; 0x40
  4006f6:	4798      	blx	r3
  4006f8:	4603      	mov	r3, r0
  4006fa:	2b01      	cmp	r3, #1
  4006fc:	d10b      	bne.n	400716 <USART1_Handler+0x86>
		{
			/* A character was retrieved from the queue so can be sent to the
			USART now. */
			usart_putchar( serUSART_PORT, ( uint32_t ) ucChar );
  4006fe:	7afb      	ldrb	r3, [r7, #11]
  400700:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  400704:	f2c4 0002 	movt	r0, #16386	; 0x4002
  400708:	4619      	mov	r1, r3
  40070a:	f240 13cd 	movw	r3, #461	; 0x1cd
  40070e:	f2c0 0340 	movt	r3, #64	; 0x40
  400712:	4798      	blx	r3
  400714:	e00a      	b.n	40072c <USART1_Handler+0x9c>
		}
		else
		{
			usart_disable_interrupt( serUSART_PORT, US_IER_TXRDY );		
  400716:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  40071a:	f2c4 0002 	movt	r0, #16386	; 0x4002
  40071e:	f04f 0102 	mov.w	r1, #2
  400722:	f240 1381 	movw	r3, #385	; 0x181
  400726:	f2c0 0340 	movt	r3, #64	; 0x40
  40072a:	4798      	blx	r3
		}		
	}
	
	if( ( ulUSARTStatus & US_CSR_RXRDY ) != 0UL )
  40072c:	697b      	ldr	r3, [r7, #20]
  40072e:	f003 0301 	and.w	r3, r3, #1
  400732:	2b00      	cmp	r3, #0
  400734:	d021      	beq.n	40077a <USART1_Handler+0xea>
	{
		/* A character has been received on the USART, send it to the Rx
		handler task. */
		usart_getchar( serUSART_PORT, &ulChar );
  400736:	f107 0304 	add.w	r3, r7, #4
  40073a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  40073e:	f2c4 0002 	movt	r0, #16386	; 0x4002
  400742:	4619      	mov	r1, r3
  400744:	f240 2329 	movw	r3, #553	; 0x229
  400748:	f2c0 0340 	movt	r3, #64	; 0x40
  40074c:	4798      	blx	r3
		ucChar = ( uint8_t ) ( ulChar & 0xffUL );
  40074e:	687b      	ldr	r3, [r7, #4]
  400750:	b2db      	uxtb	r3, r3
  400752:	72fb      	strb	r3, [r7, #11]
		xQueueSendFromISR( xRxedChars, &ucChar, &xHigherPriorityTaskWoken );
  400754:	f24a 436c 	movw	r3, #42092	; 0xa46c
  400758:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40075c:	6819      	ldr	r1, [r3, #0]
  40075e:	f107 020b 	add.w	r2, r7, #11
  400762:	f107 030c 	add.w	r3, r7, #12
  400766:	4608      	mov	r0, r1
  400768:	4611      	mov	r1, r2
  40076a:	461a      	mov	r2, r3
  40076c:	f04f 0300 	mov.w	r3, #0
  400770:	f242 3411 	movw	r4, #8977	; 0x2311
  400774:	f2c0 0440 	movt	r4, #64	; 0x40
  400778:	47a0      	blx	r4
	the unblocked task has a priority equal to or higher than the currently 
	running task (the task this ISR interrupted), then xHigherPriorityTaskWoken 
	will have automatically been set to pdTRUE within the queue send or receive 
	function.  portEND_SWITCHING_ISR() will then ensure that this ISR returns 
	directly to the higher priority unblocked task. */
	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
  40077a:	68fb      	ldr	r3, [r7, #12]
  40077c:	2b00      	cmp	r3, #0
  40077e:	d006      	beq.n	40078e <USART1_Handler+0xfe>
  400780:	f64e 5304 	movw	r3, #60676	; 0xed04
  400784:	f2ce 0300 	movt	r3, #57344	; 0xe000
  400788:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40078c:	601a      	str	r2, [r3, #0]
}
  40078e:	f107 071c 	add.w	r7, r7, #28
  400792:	46bd      	mov	sp, r7
  400794:	bd90      	pop	{r4, r7, pc}
  400796:	bf00      	nop

00400798 <osc_enable>:
#define OSC_MAINCK_XTAL_HZ			BOARD_FREQ_MAINCK_XTAL			//!< External crystal oscillator.
#define OSC_MAINCK_BYPASS_HZ		BOARD_FREQ_MAINCK_BYPASS		//!< External bypass oscillator.
//@}

static inline void osc_enable(uint32_t ul_id)
{
  400798:	b580      	push	{r7, lr}
  40079a:	b082      	sub	sp, #8
  40079c:	af00      	add	r7, sp, #0
  40079e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4007a0:	687b      	ldr	r3, [r7, #4]
  4007a2:	2b07      	cmp	r3, #7
  4007a4:	d84a      	bhi.n	40083c <osc_enable+0xa4>
  4007a6:	a201      	add	r2, pc, #4	; (adr r2, 4007ac <osc_enable+0x14>)
  4007a8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4007ac:	0040083d 	.word	0x0040083d
  4007b0:	004007cd 	.word	0x004007cd
  4007b4:	004007dd 	.word	0x004007dd
  4007b8:	004007ed 	.word	0x004007ed
  4007bc:	004007fd 	.word	0x004007fd
  4007c0:	0040080d 	.word	0x0040080d
  4007c4:	0040081d 	.word	0x0040081d
  4007c8:	0040082d 	.word	0x0040082d
	case OSC_SLCK_32K_RC:
		break;

	case OSC_SLCK_32K_XTAL:
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  4007cc:	f04f 0000 	mov.w	r0, #0
  4007d0:	f241 3371 	movw	r3, #4977	; 0x1371
  4007d4:	f2c0 0340 	movt	r3, #64	; 0x40
  4007d8:	4798      	blx	r3
		break;
  4007da:	e02f      	b.n	40083c <osc_enable+0xa4>

	case OSC_SLCK_32K_BYPASS:
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
  4007dc:	f04f 0001 	mov.w	r0, #1
  4007e0:	f241 3371 	movw	r3, #4977	; 0x1371
  4007e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4007e8:	4798      	blx	r3
		break;
  4007ea:	e027      	b.n	40083c <osc_enable+0xa4>


	case OSC_MAINCK_4M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_4_MHz);
  4007ec:	f04f 0000 	mov.w	r0, #0
  4007f0:	f241 33fd 	movw	r3, #5117	; 0x13fd
  4007f4:	f2c0 0340 	movt	r3, #64	; 0x40
  4007f8:	4798      	blx	r3
		break;
  4007fa:	e01f      	b.n	40083c <osc_enable+0xa4>

	case OSC_MAINCK_8M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
  4007fc:	f04f 0010 	mov.w	r0, #16
  400800:	f241 33fd 	movw	r3, #5117	; 0x13fd
  400804:	f2c0 0340 	movt	r3, #64	; 0x40
  400808:	4798      	blx	r3
		break;
  40080a:	e017      	b.n	40083c <osc_enable+0xa4>

	case OSC_MAINCK_12M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
  40080c:	f04f 0020 	mov.w	r0, #32
  400810:	f241 33fd 	movw	r3, #5117	; 0x13fd
  400814:	f2c0 0340 	movt	r3, #64	; 0x40
  400818:	4798      	blx	r3
		break;
  40081a:	e00f      	b.n	40083c <osc_enable+0xa4>


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL);
  40081c:	f04f 0000 	mov.w	r0, #0
  400820:	f241 43dd 	movw	r3, #5341	; 0x14dd
  400824:	f2c0 0340 	movt	r3, #64	; 0x40
  400828:	4798      	blx	r3
		break;
  40082a:	e007      	b.n	40083c <osc_enable+0xa4>

	case OSC_MAINCK_BYPASS:
		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS);
  40082c:	f04f 0001 	mov.w	r0, #1
  400830:	f241 43dd 	movw	r3, #5341	; 0x14dd
  400834:	f2c0 0340 	movt	r3, #64	; 0x40
  400838:	4798      	blx	r3
		break;
  40083a:	bf00      	nop
	}
}
  40083c:	f107 0708 	add.w	r7, r7, #8
  400840:	46bd      	mov	sp, r7
  400842:	bd80      	pop	{r7, pc}

00400844 <osc_is_ready>:
		break;
	}
}

static inline bool osc_is_ready(uint32_t ul_id)
{
  400844:	b580      	push	{r7, lr}
  400846:	b082      	sub	sp, #8
  400848:	af00      	add	r7, sp, #0
  40084a:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  40084c:	687b      	ldr	r3, [r7, #4]
  40084e:	2b07      	cmp	r3, #7
  400850:	d82d      	bhi.n	4008ae <osc_is_ready+0x6a>
  400852:	a201      	add	r2, pc, #4	; (adr r2, 400858 <osc_is_ready+0x14>)
  400854:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400858:	00400879 	.word	0x00400879
  40085c:	0040087f 	.word	0x0040087f
  400860:	0040087f 	.word	0x0040087f
  400864:	00400897 	.word	0x00400897
  400868:	00400897 	.word	0x00400897
  40086c:	00400897 	.word	0x00400897
  400870:	00400897 	.word	0x00400897
  400874:	00400897 	.word	0x00400897
	case OSC_SLCK_32K_RC:
		return 1;
  400878:	f04f 0301 	mov.w	r3, #1
  40087c:	e019      	b.n	4008b2 <osc_is_ready+0x6e>

	case OSC_SLCK_32K_XTAL:
	case OSC_SLCK_32K_BYPASS:
		return pmc_osc_is_ready_32kxtal();
  40087e:	f241 33c1 	movw	r3, #5057	; 0x13c1
  400882:	f2c0 0340 	movt	r3, #64	; 0x40
  400886:	4798      	blx	r3
  400888:	4603      	mov	r3, r0
  40088a:	2b00      	cmp	r3, #0
  40088c:	bf0c      	ite	eq
  40088e:	2300      	moveq	r3, #0
  400890:	2301      	movne	r3, #1
  400892:	b2db      	uxtb	r3, r3
  400894:	e00d      	b.n	4008b2 <osc_is_ready+0x6e>
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  400896:	f241 5379 	movw	r3, #5497	; 0x1579
  40089a:	f2c0 0340 	movt	r3, #64	; 0x40
  40089e:	4798      	blx	r3
  4008a0:	4603      	mov	r3, r0
  4008a2:	2b00      	cmp	r3, #0
  4008a4:	bf0c      	ite	eq
  4008a6:	2300      	moveq	r3, #0
  4008a8:	2301      	movne	r3, #1
  4008aa:	b2db      	uxtb	r3, r3
  4008ac:	e001      	b.n	4008b2 <osc_is_ready+0x6e>
	}

	return 0;
  4008ae:	f04f 0300 	mov.w	r3, #0
}
  4008b2:	4618      	mov	r0, r3
  4008b4:	f107 0708 	add.w	r7, r7, #8
  4008b8:	46bd      	mov	sp, r7
  4008ba:	bd80      	pop	{r7, pc}

004008bc <osc_get_rate>:

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  4008bc:	b480      	push	{r7}
  4008be:	b083      	sub	sp, #12
  4008c0:	af00      	add	r7, sp, #0
  4008c2:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4008c4:	687b      	ldr	r3, [r7, #4]
  4008c6:	2b07      	cmp	r3, #7
  4008c8:	d834      	bhi.n	400934 <osc_get_rate+0x78>
  4008ca:	a201      	add	r2, pc, #4	; (adr r2, 4008d0 <osc_get_rate+0x14>)
  4008cc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4008d0:	004008f1 	.word	0x004008f1
  4008d4:	004008f7 	.word	0x004008f7
  4008d8:	004008fd 	.word	0x004008fd
  4008dc:	00400903 	.word	0x00400903
  4008e0:	0040090d 	.word	0x0040090d
  4008e4:	00400917 	.word	0x00400917
  4008e8:	00400921 	.word	0x00400921
  4008ec:	0040092b 	.word	0x0040092b
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  4008f0:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  4008f4:	e020      	b.n	400938 <osc_get_rate+0x7c>

#ifdef BOARD_FREQ_SLCK_XTAL
	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  4008f6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4008fa:	e01d      	b.n	400938 <osc_get_rate+0x7c>
#endif

#ifdef BOARD_FREQ_SLCK_BYPASS
	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  4008fc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400900:	e01a      	b.n	400938 <osc_get_rate+0x7c>
#endif

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
  400902:	f44f 6310 	mov.w	r3, #2304	; 0x900
  400906:	f2c0 033d 	movt	r3, #61	; 0x3d
  40090a:	e015      	b.n	400938 <osc_get_rate+0x7c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  40090c:	f44f 5390 	mov.w	r3, #4608	; 0x1200
  400910:	f2c0 037a 	movt	r3, #122	; 0x7a
  400914:	e010      	b.n	400938 <osc_get_rate+0x7c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
  400916:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  40091a:	f2c0 03b7 	movt	r3, #183	; 0xb7
  40091e:	e00b      	b.n	400938 <osc_get_rate+0x7c>

#ifdef BOARD_FREQ_MAINCK_XTAL
	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  400920:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  400924:	f2c0 03b7 	movt	r3, #183	; 0xb7
  400928:	e006      	b.n	400938 <osc_get_rate+0x7c>
#endif

#ifdef BOARD_FREQ_MAINCK_BYPASS
	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  40092a:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  40092e:	f2c0 03b7 	movt	r3, #183	; 0xb7
  400932:	e001      	b.n	400938 <osc_get_rate+0x7c>
#endif
	}

	return 0;
  400934:	f04f 0300 	mov.w	r3, #0
}
  400938:	4618      	mov	r0, r3
  40093a:	f107 070c 	add.w	r7, r7, #12
  40093e:	46bd      	mov	sp, r7
  400940:	bc80      	pop	{r7}
  400942:	4770      	bx	lr

00400944 <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
  400944:	b580      	push	{r7, lr}
  400946:	b082      	sub	sp, #8
  400948:	af00      	add	r7, sp, #0
  40094a:	4603      	mov	r3, r0
  40094c:	71fb      	strb	r3, [r7, #7]
	while (!osc_is_ready(id)) {
  40094e:	bf00      	nop
  400950:	79fb      	ldrb	r3, [r7, #7]
  400952:	4618      	mov	r0, r3
  400954:	f640 0345 	movw	r3, #2117	; 0x845
  400958:	f2c0 0340 	movt	r3, #64	; 0x40
  40095c:	4798      	blx	r3
  40095e:	4603      	mov	r3, r0
  400960:	f083 0301 	eor.w	r3, r3, #1
  400964:	b2db      	uxtb	r3, r3
  400966:	2b00      	cmp	r3, #0
  400968:	d1f2      	bne.n	400950 <osc_wait_ready+0xc>
		/* Do nothing */
	}
}
  40096a:	f107 0708 	add.w	r7, r7, #8
  40096e:	46bd      	mov	sp, r7
  400970:	bd80      	pop	{r7, pc}
  400972:	bf00      	nop

00400974 <pll_config_init>:
 * \note The SAM3S PLL hardware interprets mul as mul+1. For readability the hardware mul+1
 * is hidden in this implementation. Use mul as mul effective value.
 */
static inline void pll_config_init(struct pll_config *p_cfg,
		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
{
  400974:	b580      	push	{r7, lr}
  400976:	b086      	sub	sp, #24
  400978:	af00      	add	r7, sp, #0
  40097a:	60f8      	str	r0, [r7, #12]
  40097c:	607a      	str	r2, [r7, #4]
  40097e:	603b      	str	r3, [r7, #0]
  400980:	460b      	mov	r3, r1
  400982:	72fb      	strb	r3, [r7, #11]
	uint32_t vco_hz;

	Assert(e_src < PLL_NR_SOURCES);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(e_src) / ul_div;
  400984:	7afb      	ldrb	r3, [r7, #11]
  400986:	4618      	mov	r0, r3
  400988:	f640 03bd 	movw	r3, #2237	; 0x8bd
  40098c:	f2c0 0340 	movt	r3, #64	; 0x40
  400990:	4798      	blx	r3
  400992:	4602      	mov	r2, r0
  400994:	687b      	ldr	r3, [r7, #4]
  400996:	fbb2 f3f3 	udiv	r3, r2, r3
  40099a:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_INPUT_MIN_HZ);
	Assert(vco_hz <= PLL_INPUT_MAX_HZ);
	
	vco_hz *= ul_mul;
  40099c:	697b      	ldr	r3, [r7, #20]
  40099e:	683a      	ldr	r2, [r7, #0]
  4009a0:	fb02 f303 	mul.w	r3, r2, r3
  4009a4:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_OUTPUT_MIN_HZ);
	Assert(vco_hz <= PLL_OUTPUT_MAX_HZ);

	/* PMC hardware will automatically make it mul+1 */
	p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_DIVA(ul_div) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
  4009a6:	683b      	ldr	r3, [r7, #0]
  4009a8:	f103 33ff 	add.w	r3, r3, #4294967295
  4009ac:	ea4f 4203 	mov.w	r2, r3, lsl #16
  4009b0:	f04f 0300 	mov.w	r3, #0
  4009b4:	f2c0 73ff 	movt	r3, #2047	; 0x7ff
  4009b8:	4013      	ands	r3, r2
  4009ba:	687a      	ldr	r2, [r7, #4]
  4009bc:	b2d2      	uxtb	r2, r2
  4009be:	4313      	orrs	r3, r2
  4009c0:	f443 527c 	orr.w	r2, r3, #16128	; 0x3f00
  4009c4:	68fb      	ldr	r3, [r7, #12]
  4009c6:	601a      	str	r2, [r3, #0]
}
  4009c8:	f107 0718 	add.w	r7, r7, #24
  4009cc:	46bd      	mov	sp, r7
  4009ce:	bd80      	pop	{r7, pc}

004009d0 <pll_enable>:
		PMC->CKGR_PLLBR = p_cfg->ctrl;
	}
}

static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
  4009d0:	b580      	push	{r7, lr}
  4009d2:	b082      	sub	sp, #8
  4009d4:	af00      	add	r7, sp, #0
  4009d6:	6078      	str	r0, [r7, #4]
  4009d8:	6039      	str	r1, [r7, #0]
	Assert(ul_pll_id < NR_PLLS);
	
	if (ul_pll_id == PLLA_ID) {
  4009da:	683b      	ldr	r3, [r7, #0]
  4009dc:	2b00      	cmp	r3, #0
  4009de:	d10e      	bne.n	4009fe <pll_enable+0x2e>
		pmc_disable_pllack(); // Always stop PLL first!
  4009e0:	f241 5395 	movw	r3, #5525	; 0x1595
  4009e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4009e8:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  4009ea:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4009ee:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4009f2:	687a      	ldr	r2, [r7, #4]
  4009f4:	6812      	ldr	r2, [r2, #0]
  4009f6:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  4009fa:	629a      	str	r2, [r3, #40]	; 0x28
  4009fc:	e00b      	b.n	400a16 <pll_enable+0x46>
	} else {
		pmc_disable_pllbck();
  4009fe:	f241 53c9 	movw	r3, #5577	; 0x15c9
  400a02:	f2c0 0340 	movt	r3, #64	; 0x40
  400a06:	4798      	blx	r3
		PMC->CKGR_PLLBR = p_cfg->ctrl;
  400a08:	f44f 6380 	mov.w	r3, #1024	; 0x400
  400a0c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  400a10:	687a      	ldr	r2, [r7, #4]
  400a12:	6812      	ldr	r2, [r2, #0]
  400a14:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
  400a16:	f107 0708 	add.w	r7, r7, #8
  400a1a:	46bd      	mov	sp, r7
  400a1c:	bd80      	pop	{r7, pc}
  400a1e:	bf00      	nop

00400a20 <pll_is_locked>:
	else
		pmc_disable_pllbck();
}

static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
  400a20:	b580      	push	{r7, lr}
  400a22:	b082      	sub	sp, #8
  400a24:	af00      	add	r7, sp, #0
  400a26:	6078      	str	r0, [r7, #4]
	Assert(ul_pll_id < NR_PLLS);
	
	if (ul_pll_id == PLLA_ID)
  400a28:	687b      	ldr	r3, [r7, #4]
  400a2a:	2b00      	cmp	r3, #0
  400a2c:	d106      	bne.n	400a3c <pll_is_locked+0x1c>
		return pmc_is_locked_pllack();
  400a2e:	f241 53ad 	movw	r3, #5549	; 0x15ad
  400a32:	f2c0 0340 	movt	r3, #64	; 0x40
  400a36:	4798      	blx	r3
  400a38:	4603      	mov	r3, r0
  400a3a:	e005      	b.n	400a48 <pll_is_locked+0x28>
	else
		return pmc_is_locked_pllbck();
  400a3c:	f241 53e1 	movw	r3, #5601	; 0x15e1
  400a40:	f2c0 0340 	movt	r3, #64	; 0x40
  400a44:	4798      	blx	r3
  400a46:	4603      	mov	r3, r0
}
  400a48:	4618      	mov	r0, r3
  400a4a:	f107 0708 	add.w	r7, r7, #8
  400a4e:	46bd      	mov	sp, r7
  400a50:	bd80      	pop	{r7, pc}
  400a52:	bf00      	nop

00400a54 <pll_enable_source>:

static inline void pll_enable_source(enum pll_source e_src)
{
  400a54:	b580      	push	{r7, lr}
  400a56:	b082      	sub	sp, #8
  400a58:	af00      	add	r7, sp, #0
  400a5a:	4603      	mov	r3, r0
  400a5c:	71fb      	strb	r3, [r7, #7]
	switch (e_src) {
  400a5e:	79fb      	ldrb	r3, [r7, #7]
  400a60:	f1a3 0303 	sub.w	r3, r3, #3
  400a64:	2b04      	cmp	r3, #4
  400a66:	d80e      	bhi.n	400a86 <pll_enable_source+0x32>
	case PLL_SRC_MAINCK_4M_RC:
	case PLL_SRC_MAINCK_8M_RC:
	case PLL_SRC_MAINCK_12M_RC:
	case PLL_SRC_MAINCK_XTAL:
	case PLL_SRC_MAINCK_BYPASS:
		osc_enable(e_src);
  400a68:	79fb      	ldrb	r3, [r7, #7]
  400a6a:	4618      	mov	r0, r3
  400a6c:	f240 7399 	movw	r3, #1945	; 0x799
  400a70:	f2c0 0340 	movt	r3, #64	; 0x40
  400a74:	4798      	blx	r3
		osc_wait_ready(e_src);
  400a76:	79fb      	ldrb	r3, [r7, #7]
  400a78:	4618      	mov	r0, r3
  400a7a:	f640 1345 	movw	r3, #2373	; 0x945
  400a7e:	f2c0 0340 	movt	r3, #64	; 0x40
  400a82:	4798      	blx	r3
		break;
  400a84:	e000      	b.n	400a88 <pll_enable_source+0x34>

	default:
		Assert(false);
		break;
  400a86:	bf00      	nop
	}
}
  400a88:	f107 0708 	add.w	r7, r7, #8
  400a8c:	46bd      	mov	sp, r7
  400a8e:	bd80      	pop	{r7, pc}

00400a90 <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
  400a90:	b580      	push	{r7, lr}
  400a92:	b082      	sub	sp, #8
  400a94:	af00      	add	r7, sp, #0
  400a96:	6078      	str	r0, [r7, #4]
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  400a98:	bf00      	nop
  400a9a:	6878      	ldr	r0, [r7, #4]
  400a9c:	f640 2321 	movw	r3, #2593	; 0xa21
  400aa0:	f2c0 0340 	movt	r3, #64	; 0x40
  400aa4:	4798      	blx	r3
  400aa6:	4603      	mov	r3, r0
  400aa8:	2b00      	cmp	r3, #0
  400aaa:	d0f6      	beq.n	400a9a <pll_wait_for_lock+0xa>
		/* Do nothing */
	}

	return 0;
  400aac:	f04f 0300 	mov.w	r3, #0
}
  400ab0:	4618      	mov	r0, r3
  400ab2:	f107 0708 	add.w	r7, r7, #8
  400ab6:	46bd      	mov	sp, r7
  400ab8:	bd80      	pop	{r7, pc}
  400aba:	bf00      	nop

00400abc <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
  400abc:	b580      	push	{r7, lr}
  400abe:	af00      	add	r7, sp, #0
    case SYSCLK_SRC_MAINCK_BYPASS:
		return OSC_MAINCK_BYPASS_HZ;

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLLACK:
		return pll_get_default_rate(0);	
  400ac0:	f04f 0006 	mov.w	r0, #6
  400ac4:	f640 03bd 	movw	r3, #2237	; 0x8bd
  400ac8:	f2c0 0340 	movt	r3, #64	; 0x40
  400acc:	4798      	blx	r3
  400ace:	4602      	mov	r2, r0
  400ad0:	4613      	mov	r3, r2
  400ad2:	ea4f 0383 	mov.w	r3, r3, lsl #2
  400ad6:	189b      	adds	r3, r3, r2
  400ad8:	ea4f 0383 	mov.w	r3, r3, lsl #2
	
	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
  400adc:	4618      	mov	r0, r3
  400ade:	bd80      	pop	{r7, pc}

00400ae0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
  400ae0:	b580      	push	{r7, lr}
  400ae2:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediat value. */
	return sysclk_get_main_hz() / ((CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos) + 1);
  400ae4:	f640 23bd 	movw	r3, #2749	; 0xabd
  400ae8:	f2c0 0340 	movt	r3, #64	; 0x40
  400aec:	4798      	blx	r3
  400aee:	4603      	mov	r3, r0
  400af0:	ea4f 0353 	mov.w	r3, r3, lsr #1
}
  400af4:	4618      	mov	r0, r3
  400af6:	bd80      	pop	{r7, pc}

00400af8 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  400af8:	b590      	push	{r4, r7, lr}
  400afa:	b083      	sub	sp, #12
  400afc:	af00      	add	r7, sp, #0
	struct pll_config pllcfg;

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  400afe:	f640 23e1 	movw	r3, #2785	; 0xae1
  400b02:	f2c0 0340 	movt	r3, #64	; 0x40
  400b06:	4798      	blx	r3
  400b08:	4603      	mov	r3, r0
  400b0a:	4618      	mov	r0, r3
  400b0c:	f641 138d 	movw	r3, #6541	; 0x198d
  400b10:	f2c0 0340 	movt	r3, #64	; 0x40
  400b14:	4798      	blx	r3
		pmc_switch_mck_to_mainck(CONFIG_SYSCLK_PRES);
		break;

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLLACK:
		pll_enable_source(CONFIG_PLL0_SOURCE);
  400b16:	f04f 0006 	mov.w	r0, #6
  400b1a:	f640 2355 	movw	r3, #2645	; 0xa55
  400b1e:	f2c0 0340 	movt	r3, #64	; 0x40
  400b22:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
  400b24:	f107 0304 	add.w	r3, r7, #4
  400b28:	4618      	mov	r0, r3
  400b2a:	f04f 0106 	mov.w	r1, #6
  400b2e:	f04f 0201 	mov.w	r2, #1
  400b32:	f04f 0314 	mov.w	r3, #20
  400b36:	f640 1475 	movw	r4, #2421	; 0x975
  400b3a:	f2c0 0440 	movt	r4, #64	; 0x40
  400b3e:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
  400b40:	f107 0304 	add.w	r3, r7, #4
  400b44:	4618      	mov	r0, r3
  400b46:	f04f 0100 	mov.w	r1, #0
  400b4a:	f640 13d1 	movw	r3, #2513	; 0x9d1
  400b4e:	f2c0 0340 	movt	r3, #64	; 0x40
  400b52:	4798      	blx	r3
		pll_wait_for_lock(0);
  400b54:	f04f 0000 	mov.w	r0, #0
  400b58:	f640 2391 	movw	r3, #2705	; 0xa91
  400b5c:	f2c0 0340 	movt	r3, #64	; 0x40
  400b60:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  400b62:	f04f 0010 	mov.w	r0, #16
  400b66:	f241 23c5 	movw	r3, #4805	; 0x12c5
  400b6a:	f2c0 0340 	movt	r3, #64	; 0x40
  400b6e:	4798      	blx	r3
		break;	
  400b70:	bf00      	nop
		break;
#endif	
	}

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  400b72:	f241 63d9 	movw	r3, #5849	; 0x16d9
  400b76:	f2c0 0340 	movt	r3, #64	; 0x40
  400b7a:	4798      	blx	r3
	
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
  400b7c:	f107 070c 	add.w	r7, r7, #12
  400b80:	46bd      	mov	sp, r7
  400b82:	bd90      	pop	{r4, r7, pc}

00400b84 <board_init>:
#include "board.h"
#include "conf_board.h"
#include "gpio.h"

void board_init(void)
{
  400b84:	b580      	push	{r7, lr}
  400b86:	af00      	add	r7, sp, #0
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT 
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
  400b88:	f241 4350 	movw	r3, #5200	; 0x1450
  400b8c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  400b90:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  400b94:	605a      	str	r2, [r3, #4]
#endif

	/* Configure LED pins */
	gpio_configure_pin(LED0_GPIO, LED0_FLAGS);
  400b96:	f04f 0013 	mov.w	r0, #19
  400b9a:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  400b9e:	f640 7389 	movw	r3, #3977	; 0xf89
  400ba2:	f2c0 0340 	movt	r3, #64	; 0x40
  400ba6:	4798      	blx	r3
	gpio_configure_pin(LED1_GPIO, LED1_FLAGS);
  400ba8:	f04f 0014 	mov.w	r0, #20
  400bac:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  400bb0:	f640 7389 	movw	r3, #3977	; 0xf89
  400bb4:	f2c0 0340 	movt	r3, #64	; 0x40
  400bb8:	4798      	blx	r3
	
	/* Configure Push Button pins */
	gpio_configure_pin(GPIO_PUSH_BUTTON_1, GPIO_PUSH_BUTTON_1_FLAGS);
  400bba:	f04f 0023 	mov.w	r0, #35	; 0x23
  400bbe:	f04f 0179 	mov.w	r1, #121	; 0x79
  400bc2:	f6c2 0100 	movt	r1, #10240	; 0x2800
  400bc6:	f640 7389 	movw	r3, #3977	; 0xf89
  400bca:	f2c0 0340 	movt	r3, #64	; 0x40
  400bce:	4798      	blx	r3
	gpio_configure_pin(GPIO_PUSH_BUTTON_2, GPIO_PUSH_BUTTON_2_FLAGS);
  400bd0:	f04f 004c 	mov.w	r0, #76	; 0x4c
  400bd4:	f04f 0159 	mov.w	r1, #89	; 0x59
  400bd8:	f6c2 0100 	movt	r1, #10240	; 0x2800
  400bdc:	f640 7389 	movw	r3, #3977	; 0xf89
  400be0:	f2c0 0340 	movt	r3, #64	; 0x40
  400be4:	4798      	blx	r3
	#endif
#endif

#ifdef CONF_BOARD_USART_RXD
	/* Configure USART RXD pin */
	gpio_configure_pin(PIN_USART1_RXD_IDX, PIN_USART1_RXD_FLAGS);
  400be6:	f04f 0015 	mov.w	r0, #21
  400bea:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  400bee:	f640 7389 	movw	r3, #3977	; 0xf89
  400bf2:	f2c0 0340 	movt	r3, #64	; 0x40
  400bf6:	4798      	blx	r3
#endif

#ifdef CONF_BOARD_USART_TXD
	/* Configure USART TXD pin */
	gpio_configure_pin(PIN_USART1_TXD_IDX, PIN_USART1_TXD_FLAGS);
  400bf8:	f04f 0016 	mov.w	r0, #22
  400bfc:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  400c00:	f640 7389 	movw	r3, #3977	; 0xf89
  400c04:	f2c0 0340 	movt	r3, #64	; 0x40
  400c08:	4798      	blx	r3
	gpio_configure_pin(PIN_USART1_SCK_IDX, PIN_USART1_SCK_FLAGS);
#endif

#ifdef CONF_BOARD_ADM3312_EN
	/* Configure ADM33312 enable pin */
	gpio_configure_pin(PIN_USART1_EN_IDX, PIN_USART1_EN_FLAGS);
  400c0a:	f04f 0017 	mov.w	r0, #23
  400c0e:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  400c12:	f640 7389 	movw	r3, #3977	; 0xf89
  400c16:	f2c0 0340 	movt	r3, #64	; 0x40
  400c1a:	4798      	blx	r3
	gpio_set_pin_low(PIN_USART1_EN_IDX);
  400c1c:	f04f 0017 	mov.w	r0, #23
  400c20:	f640 63e5 	movw	r3, #3813	; 0xee5
  400c24:	f2c0 0340 	movt	r3, #64	; 0x40
  400c28:	4798      	blx	r3
	gpio_configure_pin(SPI_MOSI_GPIO, SPI_MOSI_FLAGS);
	gpio_configure_pin(SPI_SPCK_GPIO, SPI_SPCK_FLAGS);
	gpio_configure_pin(SPI_NPCS0_GPIO, SPI_NPCS0_FLAGS);
	gpio_configure_pin(PIN_TSC_BUSY_IDX, PIN_TSC_BUSY_FLAG);
#endif
}
  400c2a:	bd80      	pop	{r7, pc}

00400c2c <pio_pull_up>:
 * \param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be
 * configured.
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
  400c2c:	b480      	push	{r7}
  400c2e:	b085      	sub	sp, #20
  400c30:	af00      	add	r7, sp, #0
  400c32:	60f8      	str	r0, [r7, #12]
  400c34:	60b9      	str	r1, [r7, #8]
  400c36:	607a      	str	r2, [r7, #4]
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  400c38:	687b      	ldr	r3, [r7, #4]
  400c3a:	2b00      	cmp	r3, #0
  400c3c:	d003      	beq.n	400c46 <pio_pull_up+0x1a>
		p_pio->PIO_PUER = ul_mask;
  400c3e:	68fb      	ldr	r3, [r7, #12]
  400c40:	68ba      	ldr	r2, [r7, #8]
  400c42:	665a      	str	r2, [r3, #100]	; 0x64
  400c44:	e002      	b.n	400c4c <pio_pull_up+0x20>
	} else {
		p_pio->PIO_PUDR = ul_mask;
  400c46:	68fb      	ldr	r3, [r7, #12]
  400c48:	68ba      	ldr	r2, [r7, #8]
  400c4a:	661a      	str	r2, [r3, #96]	; 0x60
	}
}
  400c4c:	f107 0714 	add.w	r7, r7, #20
  400c50:	46bd      	mov	sp, r7
  400c52:	bc80      	pop	{r7}
  400c54:	4770      	bx	lr
  400c56:	bf00      	nop

00400c58 <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  400c58:	b480      	push	{r7}
  400c5a:	b087      	sub	sp, #28
  400c5c:	af00      	add	r7, sp, #0
  400c5e:	60f8      	str	r0, [r7, #12]
  400c60:	60b9      	str	r1, [r7, #8]
  400c62:	607a      	str	r2, [r7, #4]
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  400c64:	68fb      	ldr	r3, [r7, #12]
  400c66:	687a      	ldr	r2, [r7, #4]
  400c68:	645a      	str	r2, [r3, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S)
	switch (ul_type) {
  400c6a:	68bb      	ldr	r3, [r7, #8]
  400c6c:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  400c70:	d04d      	beq.n	400d0e <pio_set_peripheral+0xb6>
  400c72:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  400c76:	d808      	bhi.n	400c8a <pio_set_peripheral+0x32>
  400c78:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  400c7c:	d016      	beq.n	400cac <pio_set_peripheral+0x54>
  400c7e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  400c82:	d02e      	beq.n	400ce2 <pio_set_peripheral+0x8a>
  400c84:	2b00      	cmp	r3, #0
  400c86:	d06d      	beq.n	400d64 <pio_set_peripheral+0x10c>
  400c88:	e068      	b.n	400d5c <pio_set_peripheral+0x104>
  400c8a:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  400c8e:	d069      	beq.n	400d64 <pio_set_peripheral+0x10c>
  400c90:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  400c94:	d803      	bhi.n	400c9e <pio_set_peripheral+0x46>
  400c96:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  400c9a:	d04e      	beq.n	400d3a <pio_set_peripheral+0xe2>
  400c9c:	e05e      	b.n	400d5c <pio_set_peripheral+0x104>
  400c9e:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  400ca2:	d05f      	beq.n	400d64 <pio_set_peripheral+0x10c>
  400ca4:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  400ca8:	d05c      	beq.n	400d64 <pio_set_peripheral+0x10c>
  400caa:	e057      	b.n	400d5c <pio_set_peripheral+0x104>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  400cac:	68fb      	ldr	r3, [r7, #12]
  400cae:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  400cb0:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  400cb2:	68fb      	ldr	r3, [r7, #12]
  400cb4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400cb6:	687b      	ldr	r3, [r7, #4]
  400cb8:	ea6f 0103 	mvn.w	r1, r3
  400cbc:	697b      	ldr	r3, [r7, #20]
  400cbe:	400b      	ands	r3, r1
  400cc0:	401a      	ands	r2, r3
  400cc2:	68fb      	ldr	r3, [r7, #12]
  400cc4:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400cc6:	68fb      	ldr	r3, [r7, #12]
  400cc8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  400cca:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  400ccc:	68fb      	ldr	r3, [r7, #12]
  400cce:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400cd0:	687b      	ldr	r3, [r7, #4]
  400cd2:	ea6f 0103 	mvn.w	r1, r3
  400cd6:	697b      	ldr	r3, [r7, #20]
  400cd8:	400b      	ands	r3, r1
  400cda:	401a      	ands	r2, r3
  400cdc:	68fb      	ldr	r3, [r7, #12]
  400cde:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  400ce0:	e03c      	b.n	400d5c <pio_set_peripheral+0x104>

	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  400ce2:	68fb      	ldr	r3, [r7, #12]
  400ce4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  400ce6:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  400ce8:	687a      	ldr	r2, [r7, #4]
  400cea:	697b      	ldr	r3, [r7, #20]
  400cec:	431a      	orrs	r2, r3
  400cee:	68fb      	ldr	r3, [r7, #12]
  400cf0:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400cf2:	68fb      	ldr	r3, [r7, #12]
  400cf4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  400cf6:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  400cf8:	68fb      	ldr	r3, [r7, #12]
  400cfa:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400cfc:	687b      	ldr	r3, [r7, #4]
  400cfe:	ea6f 0103 	mvn.w	r1, r3
  400d02:	697b      	ldr	r3, [r7, #20]
  400d04:	400b      	ands	r3, r1
  400d06:	401a      	ands	r2, r3
  400d08:	68fb      	ldr	r3, [r7, #12]
  400d0a:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  400d0c:	e026      	b.n	400d5c <pio_set_peripheral+0x104>

	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  400d0e:	68fb      	ldr	r3, [r7, #12]
  400d10:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  400d12:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  400d14:	68fb      	ldr	r3, [r7, #12]
  400d16:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400d18:	687b      	ldr	r3, [r7, #4]
  400d1a:	ea6f 0103 	mvn.w	r1, r3
  400d1e:	697b      	ldr	r3, [r7, #20]
  400d20:	400b      	ands	r3, r1
  400d22:	401a      	ands	r2, r3
  400d24:	68fb      	ldr	r3, [r7, #12]
  400d26:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400d28:	68fb      	ldr	r3, [r7, #12]
  400d2a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  400d2c:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  400d2e:	687a      	ldr	r2, [r7, #4]
  400d30:	697b      	ldr	r3, [r7, #20]
  400d32:	431a      	orrs	r2, r3
  400d34:	68fb      	ldr	r3, [r7, #12]
  400d36:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  400d38:	e010      	b.n	400d5c <pio_set_peripheral+0x104>

	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  400d3a:	68fb      	ldr	r3, [r7, #12]
  400d3c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  400d3e:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  400d40:	687a      	ldr	r2, [r7, #4]
  400d42:	697b      	ldr	r3, [r7, #20]
  400d44:	431a      	orrs	r2, r3
  400d46:	68fb      	ldr	r3, [r7, #12]
  400d48:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400d4a:	68fb      	ldr	r3, [r7, #12]
  400d4c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  400d4e:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  400d50:	687a      	ldr	r2, [r7, #4]
  400d52:	697b      	ldr	r3, [r7, #20]
  400d54:	431a      	orrs	r2, r3
  400d56:	68fb      	ldr	r3, [r7, #12]
  400d58:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  400d5a:	bf00      	nop
#else
#error "Unsupported device"
#endif

	// Remove the pins from under the control of PIO
	p_pio->PIO_PDR = ul_mask;
  400d5c:	68fb      	ldr	r3, [r7, #12]
  400d5e:	687a      	ldr	r2, [r7, #4]
  400d60:	605a      	str	r2, [r3, #4]
  400d62:	e000      	b.n	400d66 <pio_set_peripheral+0x10e>
		// other types are invalid in this function
	case PIO_INPUT:
	case PIO_OUTPUT_0:
	case PIO_OUTPUT_1:
	case PIO_NOT_A_PIN:
		return;
  400d64:	bf00      	nop
#error "Unsupported device"
#endif

	// Remove the pins from under the control of PIO
	p_pio->PIO_PDR = ul_mask;
}
  400d66:	f107 071c 	add.w	r7, r7, #28
  400d6a:	46bd      	mov	sp, r7
  400d6c:	bc80      	pop	{r7}
  400d6e:	4770      	bx	lr

00400d70 <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
  400d70:	b580      	push	{r7, lr}
  400d72:	b084      	sub	sp, #16
  400d74:	af00      	add	r7, sp, #0
  400d76:	60f8      	str	r0, [r7, #12]
  400d78:	60b9      	str	r1, [r7, #8]
  400d7a:	607a      	str	r2, [r7, #4]
	pio_disable_interrupt(p_pio, ul_mask);
  400d7c:	68f8      	ldr	r0, [r7, #12]
  400d7e:	68b9      	ldr	r1, [r7, #8]
  400d80:	f640 635d 	movw	r3, #3677	; 0xe5d
  400d84:	f2c0 0340 	movt	r3, #64	; 0x40
  400d88:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);
  400d8a:	687b      	ldr	r3, [r7, #4]
  400d8c:	f003 0301 	and.w	r3, r3, #1
  400d90:	68f8      	ldr	r0, [r7, #12]
  400d92:	68b9      	ldr	r1, [r7, #8]
  400d94:	461a      	mov	r2, r3
  400d96:	f640 432d 	movw	r3, #3117	; 0xc2d
  400d9a:	f2c0 0340 	movt	r3, #64	; 0x40
  400d9e:	4798      	blx	r3

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  400da0:	687b      	ldr	r3, [r7, #4]
  400da2:	f003 030a 	and.w	r3, r3, #10
  400da6:	2b00      	cmp	r3, #0
  400da8:	d003      	beq.n	400db2 <pio_set_input+0x42>
		p_pio->PIO_IFER = ul_mask;
  400daa:	68fb      	ldr	r3, [r7, #12]
  400dac:	68ba      	ldr	r2, [r7, #8]
  400dae:	621a      	str	r2, [r3, #32]
  400db0:	e002      	b.n	400db8 <pio_set_input+0x48>
	} else {
		p_pio->PIO_IFDR = ul_mask;
  400db2:	68fb      	ldr	r3, [r7, #12]
  400db4:	68ba      	ldr	r2, [r7, #8]
  400db6:	625a      	str	r2, [r3, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  400db8:	687b      	ldr	r3, [r7, #4]
  400dba:	f003 0302 	and.w	r3, r3, #2
  400dbe:	2b00      	cmp	r3, #0
  400dc0:	d004      	beq.n	400dcc <pio_set_input+0x5c>
		p_pio->PIO_IFSCDR = ul_mask;
  400dc2:	68fb      	ldr	r3, [r7, #12]
  400dc4:	68ba      	ldr	r2, [r7, #8]
  400dc6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  400dca:	e008      	b.n	400dde <pio_set_input+0x6e>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  400dcc:	687b      	ldr	r3, [r7, #4]
  400dce:	f003 0308 	and.w	r3, r3, #8
  400dd2:	2b00      	cmp	r3, #0
  400dd4:	d003      	beq.n	400dde <pio_set_input+0x6e>
			p_pio->PIO_IFSCER = ul_mask;
  400dd6:	68fb      	ldr	r3, [r7, #12]
  400dd8:	68ba      	ldr	r2, [r7, #8]
  400dda:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  400dde:	68fb      	ldr	r3, [r7, #12]
  400de0:	68ba      	ldr	r2, [r7, #8]
  400de2:	615a      	str	r2, [r3, #20]
	p_pio->PIO_PER = ul_mask;
  400de4:	68fb      	ldr	r3, [r7, #12]
  400de6:	68ba      	ldr	r2, [r7, #8]
  400de8:	601a      	str	r2, [r3, #0]
}
  400dea:	f107 0710 	add.w	r7, r7, #16
  400dee:	46bd      	mov	sp, r7
  400df0:	bd80      	pop	{r7, pc}
  400df2:	bf00      	nop

00400df4 <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
  400df4:	b580      	push	{r7, lr}
  400df6:	b084      	sub	sp, #16
  400df8:	af00      	add	r7, sp, #0
  400dfa:	60f8      	str	r0, [r7, #12]
  400dfc:	60b9      	str	r1, [r7, #8]
  400dfe:	607a      	str	r2, [r7, #4]
  400e00:	603b      	str	r3, [r7, #0]
	pio_disable_interrupt(p_pio, ul_mask);
  400e02:	68f8      	ldr	r0, [r7, #12]
  400e04:	68b9      	ldr	r1, [r7, #8]
  400e06:	f640 635d 	movw	r3, #3677	; 0xe5d
  400e0a:	f2c0 0340 	movt	r3, #64	; 0x40
  400e0e:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);
  400e10:	68f8      	ldr	r0, [r7, #12]
  400e12:	68b9      	ldr	r1, [r7, #8]
  400e14:	69ba      	ldr	r2, [r7, #24]
  400e16:	f640 432d 	movw	r3, #3117	; 0xc2d
  400e1a:	f2c0 0340 	movt	r3, #64	; 0x40
  400e1e:	4798      	blx	r3

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  400e20:	683b      	ldr	r3, [r7, #0]
  400e22:	2b00      	cmp	r3, #0
  400e24:	d003      	beq.n	400e2e <pio_set_output+0x3a>
		p_pio->PIO_MDER = ul_mask;
  400e26:	68fb      	ldr	r3, [r7, #12]
  400e28:	68ba      	ldr	r2, [r7, #8]
  400e2a:	651a      	str	r2, [r3, #80]	; 0x50
  400e2c:	e002      	b.n	400e34 <pio_set_output+0x40>
	} else {
		p_pio->PIO_MDDR = ul_mask;
  400e2e:	68fb      	ldr	r3, [r7, #12]
  400e30:	68ba      	ldr	r2, [r7, #8]
  400e32:	655a      	str	r2, [r3, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
  400e34:	687b      	ldr	r3, [r7, #4]
  400e36:	2b00      	cmp	r3, #0
  400e38:	d003      	beq.n	400e42 <pio_set_output+0x4e>
		p_pio->PIO_SODR = ul_mask;
  400e3a:	68fb      	ldr	r3, [r7, #12]
  400e3c:	68ba      	ldr	r2, [r7, #8]
  400e3e:	631a      	str	r2, [r3, #48]	; 0x30
  400e40:	e002      	b.n	400e48 <pio_set_output+0x54>
	} else {
		p_pio->PIO_CODR = ul_mask;
  400e42:	68fb      	ldr	r3, [r7, #12]
  400e44:	68ba      	ldr	r2, [r7, #8]
  400e46:	635a      	str	r2, [r3, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  400e48:	68fb      	ldr	r3, [r7, #12]
  400e4a:	68ba      	ldr	r2, [r7, #8]
  400e4c:	611a      	str	r2, [r3, #16]
	p_pio->PIO_PER = ul_mask;
  400e4e:	68fb      	ldr	r3, [r7, #12]
  400e50:	68ba      	ldr	r2, [r7, #8]
  400e52:	601a      	str	r2, [r3, #0]
}
  400e54:	f107 0710 	add.w	r7, r7, #16
  400e58:	46bd      	mov	sp, r7
  400e5a:	bd80      	pop	{r7, pc}

00400e5c <pio_disable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  400e5c:	b480      	push	{r7}
  400e5e:	b083      	sub	sp, #12
  400e60:	af00      	add	r7, sp, #0
  400e62:	6078      	str	r0, [r7, #4]
  400e64:	6039      	str	r1, [r7, #0]
	p_pio->PIO_IDR = ul_mask;
  400e66:	687b      	ldr	r3, [r7, #4]
  400e68:	683a      	ldr	r2, [r7, #0]
  400e6a:	645a      	str	r2, [r3, #68]	; 0x44
}
  400e6c:	f107 070c 	add.w	r7, r7, #12
  400e70:	46bd      	mov	sp, r7
  400e72:	bc80      	pop	{r7}
  400e74:	4770      	bx	lr
  400e76:	bf00      	nop

00400e78 <pio_get_interrupt_status>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
  400e78:	b480      	push	{r7}
  400e7a:	b083      	sub	sp, #12
  400e7c:	af00      	add	r7, sp, #0
  400e7e:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_ISR;
  400e80:	687b      	ldr	r3, [r7, #4]
  400e82:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
  400e84:	4618      	mov	r0, r3
  400e86:	f107 070c 	add.w	r7, r7, #12
  400e8a:	46bd      	mov	sp, r7
  400e8c:	bc80      	pop	{r7}
  400e8e:	4770      	bx	lr

00400e90 <pio_get_interrupt_mask>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
  400e90:	b480      	push	{r7}
  400e92:	b083      	sub	sp, #12
  400e94:	af00      	add	r7, sp, #0
  400e96:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_IMR;
  400e98:	687b      	ldr	r3, [r7, #4]
  400e9a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
  400e9c:	4618      	mov	r0, r3
  400e9e:	f107 070c 	add.w	r7, r7, #12
  400ea2:	46bd      	mov	sp, r7
  400ea4:	bc80      	pop	{r7}
  400ea6:	4770      	bx	lr

00400ea8 <pio_set_pin_high>:
 * \param ul_pin The pin index.
 *
 * \note The function \ref pio_configure_pin must be called beforehand.
 */
void pio_set_pin_high(uint32_t ul_pin)
{
  400ea8:	b480      	push	{r7}
  400eaa:	b085      	sub	sp, #20
  400eac:	af00      	add	r7, sp, #0
  400eae:	6078      	str	r0, [r7, #4]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  400eb0:	687b      	ldr	r3, [r7, #4]
  400eb2:	ea4f 1353 	mov.w	r3, r3, lsr #5
  400eb6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400eba:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400ebe:	ea4f 2343 	mov.w	r3, r3, lsl #9
  400ec2:	60fb      	str	r3, [r7, #12]
	// Value to be driven on the I/O line: 1.
	p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  400ec4:	687b      	ldr	r3, [r7, #4]
  400ec6:	f003 031f 	and.w	r3, r3, #31
  400eca:	f04f 0201 	mov.w	r2, #1
  400ece:	fa02 f303 	lsl.w	r3, r2, r3
  400ed2:	461a      	mov	r2, r3
  400ed4:	68fb      	ldr	r3, [r7, #12]
  400ed6:	631a      	str	r2, [r3, #48]	; 0x30
}
  400ed8:	f107 0714 	add.w	r7, r7, #20
  400edc:	46bd      	mov	sp, r7
  400ede:	bc80      	pop	{r7}
  400ee0:	4770      	bx	lr
  400ee2:	bf00      	nop

00400ee4 <pio_set_pin_low>:
 * \param ul_pin The pin index.
 *
 * \note The function \ref pio_configure_pin must be called before.
 */
void pio_set_pin_low(uint32_t ul_pin)
{
  400ee4:	b480      	push	{r7}
  400ee6:	b085      	sub	sp, #20
  400ee8:	af00      	add	r7, sp, #0
  400eea:	6078      	str	r0, [r7, #4]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  400eec:	687b      	ldr	r3, [r7, #4]
  400eee:	ea4f 1353 	mov.w	r3, r3, lsr #5
  400ef2:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400ef6:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400efa:	ea4f 2343 	mov.w	r3, r3, lsl #9
  400efe:	60fb      	str	r3, [r7, #12]
	// Value to be driven on the I/O line: 0.
	p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  400f00:	687b      	ldr	r3, [r7, #4]
  400f02:	f003 031f 	and.w	r3, r3, #31
  400f06:	f04f 0201 	mov.w	r2, #1
  400f0a:	fa02 f303 	lsl.w	r3, r2, r3
  400f0e:	461a      	mov	r2, r3
  400f10:	68fb      	ldr	r3, [r7, #12]
  400f12:	635a      	str	r2, [r3, #52]	; 0x34
}
  400f14:	f107 0714 	add.w	r7, r7, #20
  400f18:	46bd      	mov	sp, r7
  400f1a:	bc80      	pop	{r7}
  400f1c:	4770      	bx	lr
  400f1e:	bf00      	nop

00400f20 <pio_toggle_pin>:
 * \param ul_pin The pin index.
 *
 * \note The function \ref pio_configure_pin must be called before.
 */
void pio_toggle_pin(uint32_t ul_pin)
{
  400f20:	b480      	push	{r7}
  400f22:	b085      	sub	sp, #20
  400f24:	af00      	add	r7, sp, #0
  400f26:	6078      	str	r0, [r7, #4]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  400f28:	687b      	ldr	r3, [r7, #4]
  400f2a:	ea4f 1353 	mov.w	r3, r3, lsr #5
  400f2e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400f32:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400f36:	ea4f 2343 	mov.w	r3, r3, lsl #9
  400f3a:	60fb      	str	r3, [r7, #12]
	if (p_pio->PIO_ODSR & (1 << (ul_pin & 0x1F))) {
  400f3c:	68fb      	ldr	r3, [r7, #12]
  400f3e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  400f40:	687b      	ldr	r3, [r7, #4]
  400f42:	f003 031f 	and.w	r3, r3, #31
  400f46:	f04f 0101 	mov.w	r1, #1
  400f4a:	fa01 f303 	lsl.w	r3, r1, r3
  400f4e:	4013      	ands	r3, r2
  400f50:	2b00      	cmp	r3, #0
  400f52:	d00a      	beq.n	400f6a <pio_toggle_pin+0x4a>
		// Value to be driven on the I/O line: 0.
		p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  400f54:	687b      	ldr	r3, [r7, #4]
  400f56:	f003 031f 	and.w	r3, r3, #31
  400f5a:	f04f 0201 	mov.w	r2, #1
  400f5e:	fa02 f303 	lsl.w	r3, r2, r3
  400f62:	461a      	mov	r2, r3
  400f64:	68fb      	ldr	r3, [r7, #12]
  400f66:	635a      	str	r2, [r3, #52]	; 0x34
  400f68:	e009      	b.n	400f7e <pio_toggle_pin+0x5e>
	} else {
		// Value to be driven on the I/O line: 1.
		p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  400f6a:	687b      	ldr	r3, [r7, #4]
  400f6c:	f003 031f 	and.w	r3, r3, #31
  400f70:	f04f 0201 	mov.w	r2, #1
  400f74:	fa02 f303 	lsl.w	r3, r2, r3
  400f78:	461a      	mov	r2, r3
  400f7a:	68fb      	ldr	r3, [r7, #12]
  400f7c:	631a      	str	r2, [r3, #48]	; 0x30
	}
}
  400f7e:	f107 0714 	add.w	r7, r7, #20
  400f82:	46bd      	mov	sp, r7
  400f84:	bc80      	pop	{r7}
  400f86:	4770      	bx	lr

00400f88 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  400f88:	b590      	push	{r4, r7, lr}
  400f8a:	b087      	sub	sp, #28
  400f8c:	af02      	add	r7, sp, #8
  400f8e:	6078      	str	r0, [r7, #4]
  400f90:	6039      	str	r1, [r7, #0]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  400f92:	687b      	ldr	r3, [r7, #4]
  400f94:	ea4f 1353 	mov.w	r3, r3, lsr #5
  400f98:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400f9c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400fa0:	ea4f 2343 	mov.w	r3, r3, lsl #9
  400fa4:	60fb      	str	r3, [r7, #12]

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  400fa6:	683b      	ldr	r3, [r7, #0]
  400fa8:	f003 43f0 	and.w	r3, r3, #2013265920	; 0x78000000
  400fac:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  400fb0:	f000 8086 	beq.w	4010c0 <pio_configure_pin+0x138>
  400fb4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  400fb8:	d809      	bhi.n	400fce <pio_configure_pin+0x46>
  400fba:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  400fbe:	d037      	beq.n	401030 <pio_configure_pin+0xa8>
  400fc0:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  400fc4:	d058      	beq.n	401078 <pio_configure_pin+0xf0>
  400fc6:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  400fca:	d00d      	beq.n	400fe8 <pio_configure_pin+0x60>
  400fcc:	e0cf      	b.n	40116e <pio_configure_pin+0x1e6>
  400fce:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  400fd2:	f000 80a9 	beq.w	401128 <pio_configure_pin+0x1a0>
  400fd6:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  400fda:	f000 80a5 	beq.w	401128 <pio_configure_pin+0x1a0>
  400fde:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  400fe2:	f000 8091 	beq.w	401108 <pio_configure_pin+0x180>
  400fe6:	e0c2      	b.n	40116e <pio_configure_pin+0x1e6>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
  400fe8:	687b      	ldr	r3, [r7, #4]
  400fea:	f003 031f 	and.w	r3, r3, #31
  400fee:	f04f 0201 	mov.w	r2, #1
  400ff2:	fa02 f303 	lsl.w	r3, r2, r3
  400ff6:	68f8      	ldr	r0, [r7, #12]
  400ff8:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  400ffc:	461a      	mov	r2, r3
  400ffe:	f640 4359 	movw	r3, #3161	; 0xc59
  401002:	f2c0 0340 	movt	r3, #64	; 0x40
  401006:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401008:	687b      	ldr	r3, [r7, #4]
  40100a:	f003 031f 	and.w	r3, r3, #31
  40100e:	f04f 0201 	mov.w	r2, #1
  401012:	fa02 f303 	lsl.w	r3, r2, r3
  401016:	461a      	mov	r2, r3
  401018:	683b      	ldr	r3, [r7, #0]
  40101a:	f003 0301 	and.w	r3, r3, #1
  40101e:	68f8      	ldr	r0, [r7, #12]
  401020:	4611      	mov	r1, r2
  401022:	461a      	mov	r2, r3
  401024:	f640 432d 	movw	r3, #3117	; 0xc2d
  401028:	f2c0 0340 	movt	r3, #64	; 0x40
  40102c:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
  40102e:	e0a1      	b.n	401174 <pio_configure_pin+0x1ec>
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
  401030:	687b      	ldr	r3, [r7, #4]
  401032:	f003 031f 	and.w	r3, r3, #31
  401036:	f04f 0201 	mov.w	r2, #1
  40103a:	fa02 f303 	lsl.w	r3, r2, r3
  40103e:	68f8      	ldr	r0, [r7, #12]
  401040:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  401044:	461a      	mov	r2, r3
  401046:	f640 4359 	movw	r3, #3161	; 0xc59
  40104a:	f2c0 0340 	movt	r3, #64	; 0x40
  40104e:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401050:	687b      	ldr	r3, [r7, #4]
  401052:	f003 031f 	and.w	r3, r3, #31
  401056:	f04f 0201 	mov.w	r2, #1
  40105a:	fa02 f303 	lsl.w	r3, r2, r3
  40105e:	461a      	mov	r2, r3
  401060:	683b      	ldr	r3, [r7, #0]
  401062:	f003 0301 	and.w	r3, r3, #1
  401066:	68f8      	ldr	r0, [r7, #12]
  401068:	4611      	mov	r1, r2
  40106a:	461a      	mov	r2, r3
  40106c:	f640 432d 	movw	r3, #3117	; 0xc2d
  401070:	f2c0 0340 	movt	r3, #64	; 0x40
  401074:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
  401076:	e07d      	b.n	401174 <pio_configure_pin+0x1ec>
#     if (SAM3S || SAM3N || SAM4S)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
  401078:	687b      	ldr	r3, [r7, #4]
  40107a:	f003 031f 	and.w	r3, r3, #31
  40107e:	f04f 0201 	mov.w	r2, #1
  401082:	fa02 f303 	lsl.w	r3, r2, r3
  401086:	68f8      	ldr	r0, [r7, #12]
  401088:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40108c:	461a      	mov	r2, r3
  40108e:	f640 4359 	movw	r3, #3161	; 0xc59
  401092:	f2c0 0340 	movt	r3, #64	; 0x40
  401096:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401098:	687b      	ldr	r3, [r7, #4]
  40109a:	f003 031f 	and.w	r3, r3, #31
  40109e:	f04f 0201 	mov.w	r2, #1
  4010a2:	fa02 f303 	lsl.w	r3, r2, r3
  4010a6:	461a      	mov	r2, r3
  4010a8:	683b      	ldr	r3, [r7, #0]
  4010aa:	f003 0301 	and.w	r3, r3, #1
  4010ae:	68f8      	ldr	r0, [r7, #12]
  4010b0:	4611      	mov	r1, r2
  4010b2:	461a      	mov	r2, r3
  4010b4:	f640 432d 	movw	r3, #3117	; 0xc2d
  4010b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4010bc:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
  4010be:	e059      	b.n	401174 <pio_configure_pin+0x1ec>
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  4010c0:	687b      	ldr	r3, [r7, #4]
  4010c2:	f003 031f 	and.w	r3, r3, #31
  4010c6:	f04f 0201 	mov.w	r2, #1
  4010ca:	fa02 f303 	lsl.w	r3, r2, r3
  4010ce:	68f8      	ldr	r0, [r7, #12]
  4010d0:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  4010d4:	461a      	mov	r2, r3
  4010d6:	f640 4359 	movw	r3, #3161	; 0xc59
  4010da:	f2c0 0340 	movt	r3, #64	; 0x40
  4010de:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  4010e0:	687b      	ldr	r3, [r7, #4]
  4010e2:	f003 031f 	and.w	r3, r3, #31
  4010e6:	f04f 0201 	mov.w	r2, #1
  4010ea:	fa02 f303 	lsl.w	r3, r2, r3
  4010ee:	461a      	mov	r2, r3
  4010f0:	683b      	ldr	r3, [r7, #0]
  4010f2:	f003 0301 	and.w	r3, r3, #1
  4010f6:	68f8      	ldr	r0, [r7, #12]
  4010f8:	4611      	mov	r1, r2
  4010fa:	461a      	mov	r2, r3
  4010fc:	f640 432d 	movw	r3, #3117	; 0xc2d
  401100:	f2c0 0340 	movt	r3, #64	; 0x40
  401104:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
  401106:	e035      	b.n	401174 <pio_configure_pin+0x1ec>
#     endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  401108:	687b      	ldr	r3, [r7, #4]
  40110a:	f003 031f 	and.w	r3, r3, #31
  40110e:	f04f 0201 	mov.w	r2, #1
  401112:	fa02 f303 	lsl.w	r3, r2, r3
  401116:	68f8      	ldr	r0, [r7, #12]
  401118:	4619      	mov	r1, r3
  40111a:	683a      	ldr	r2, [r7, #0]
  40111c:	f640 5371 	movw	r3, #3441	; 0xd71
  401120:	f2c0 0340 	movt	r3, #64	; 0x40
  401124:	4798      	blx	r3
		break;
  401126:	e025      	b.n	401174 <pio_configure_pin+0x1ec>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  401128:	687b      	ldr	r3, [r7, #4]
  40112a:	f003 031f 	and.w	r3, r3, #31
  40112e:	f04f 0201 	mov.w	r2, #1
  401132:	fa02 f303 	lsl.w	r3, r2, r3
  401136:	4619      	mov	r1, r3
  401138:	683b      	ldr	r3, [r7, #0]
  40113a:	f003 5260 	and.w	r2, r3, #939524096	; 0x38000000
				(ul_flags & PIO_TYPE_PIO_OUTPUT_1),
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  40113e:	683b      	ldr	r3, [r7, #0]
  401140:	f003 0304 	and.w	r3, r3, #4
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  401144:	2b00      	cmp	r3, #0
  401146:	bf0c      	ite	eq
  401148:	2300      	moveq	r3, #0
  40114a:	2301      	movne	r3, #1
  40114c:	b2db      	uxtb	r3, r3
				(ul_flags & PIO_TYPE_PIO_OUTPUT_1),
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
  40114e:	6838      	ldr	r0, [r7, #0]
  401150:	f000 0001 	and.w	r0, r0, #1
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  401154:	2800      	cmp	r0, #0
  401156:	bf0c      	ite	eq
  401158:	2000      	moveq	r0, #0
  40115a:	2001      	movne	r0, #1
  40115c:	b2c0      	uxtb	r0, r0
  40115e:	9000      	str	r0, [sp, #0]
  401160:	68f8      	ldr	r0, [r7, #12]
  401162:	f640 54f5 	movw	r4, #3573	; 0xdf5
  401166:	f2c0 0440 	movt	r4, #64	; 0x40
  40116a:	47a0      	blx	r4
				(ul_flags & PIO_TYPE_PIO_OUTPUT_1),
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
  40116c:	e002      	b.n	401174 <pio_configure_pin+0x1ec>

	default:
		return 0;
  40116e:	f04f 0300 	mov.w	r3, #0
  401172:	e001      	b.n	401178 <pio_configure_pin+0x1f0>
	}

	return 1;
  401174:	f04f 0301 	mov.w	r3, #1
}
  401178:	4618      	mov	r0, r3
  40117a:	f107 0714 	add.w	r7, r7, #20
  40117e:	46bd      	mov	sp, r7
  401180:	bd90      	pop	{r4, r7, pc}
  401182:	bf00      	nop

00401184 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  401184:	b580      	push	{r7, lr}
  401186:	b084      	sub	sp, #16
  401188:	af00      	add	r7, sp, #0
  40118a:	6078      	str	r0, [r7, #4]
  40118c:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40118e:	6878      	ldr	r0, [r7, #4]
  401190:	f640 6379 	movw	r3, #3705	; 0xe79
  401194:	f2c0 0340 	movt	r3, #64	; 0x40
  401198:	4798      	blx	r3
  40119a:	60f8      	str	r0, [r7, #12]
	status &= pio_get_interrupt_mask(p_pio);
  40119c:	6878      	ldr	r0, [r7, #4]
  40119e:	f640 6391 	movw	r3, #3729	; 0xe91
  4011a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4011a6:	4798      	blx	r3
  4011a8:	4603      	mov	r3, r0
  4011aa:	68fa      	ldr	r2, [r7, #12]
  4011ac:	4013      	ands	r3, r2
  4011ae:	60fb      	str	r3, [r7, #12]

	/* Check pending events */
	if (status != 0) {
  4011b0:	68fb      	ldr	r3, [r7, #12]
  4011b2:	2b00      	cmp	r3, #0
  4011b4:	d057      	beq.n	401266 <pio_handler_process+0xe2>
		/* Find triggering source */
		i = 0;
  4011b6:	f04f 0300 	mov.w	r3, #0
  4011ba:	60bb      	str	r3, [r7, #8]
		while (status != 0) {
  4011bc:	e050      	b.n	401260 <pio_handler_process+0xdc>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  4011be:	f24a 4374 	movw	r3, #42100	; 0xa474
  4011c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4011c6:	68ba      	ldr	r2, [r7, #8]
  4011c8:	ea4f 1202 	mov.w	r2, r2, lsl #4
  4011cc:	189b      	adds	r3, r3, r2
  4011ce:	681a      	ldr	r2, [r3, #0]
  4011d0:	683b      	ldr	r3, [r7, #0]
  4011d2:	429a      	cmp	r2, r3
  4011d4:	d140      	bne.n	401258 <pio_handler_process+0xd4>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  4011d6:	f24a 4374 	movw	r3, #42100	; 0xa474
  4011da:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4011de:	68ba      	ldr	r2, [r7, #8]
  4011e0:	ea4f 1202 	mov.w	r2, r2, lsl #4
  4011e4:	189b      	adds	r3, r3, r2
  4011e6:	f103 0304 	add.w	r3, r3, #4
  4011ea:	681a      	ldr	r2, [r3, #0]
  4011ec:	68fb      	ldr	r3, [r7, #12]
  4011ee:	4013      	ands	r3, r2
  4011f0:	2b00      	cmp	r3, #0
  4011f2:	d031      	beq.n	401258 <pio_handler_process+0xd4>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  4011f4:	f24a 4374 	movw	r3, #42100	; 0xa474
  4011f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4011fc:	68ba      	ldr	r2, [r7, #8]
  4011fe:	ea4f 1202 	mov.w	r2, r2, lsl #4
  401202:	189b      	adds	r3, r3, r2
  401204:	f103 030c 	add.w	r3, r3, #12
  401208:	681a      	ldr	r2, [r3, #0]
  40120a:	f24a 4374 	movw	r3, #42100	; 0xa474
  40120e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401212:	68b9      	ldr	r1, [r7, #8]
  401214:	ea4f 1101 	mov.w	r1, r1, lsl #4
  401218:	185b      	adds	r3, r3, r1
  40121a:	6819      	ldr	r1, [r3, #0]
  40121c:	f24a 4374 	movw	r3, #42100	; 0xa474
  401220:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401224:	68b8      	ldr	r0, [r7, #8]
  401226:	ea4f 1000 	mov.w	r0, r0, lsl #4
  40122a:	181b      	adds	r3, r3, r0
  40122c:	f103 0304 	add.w	r3, r3, #4
  401230:	681b      	ldr	r3, [r3, #0]
  401232:	4608      	mov	r0, r1
  401234:	4619      	mov	r1, r3
  401236:	4790      	blx	r2
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  401238:	f24a 4374 	movw	r3, #42100	; 0xa474
  40123c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401240:	68ba      	ldr	r2, [r7, #8]
  401242:	ea4f 1202 	mov.w	r2, r2, lsl #4
  401246:	189b      	adds	r3, r3, r2
  401248:	f103 0304 	add.w	r3, r3, #4
  40124c:	681b      	ldr	r3, [r3, #0]
  40124e:	ea6f 0303 	mvn.w	r3, r3
  401252:	68fa      	ldr	r2, [r7, #12]
  401254:	4013      	ands	r3, r2
  401256:	60fb      	str	r3, [r7, #12]
				}
			}
			i++;
  401258:	68bb      	ldr	r3, [r7, #8]
  40125a:	f103 0301 	add.w	r3, r3, #1
  40125e:	60bb      	str	r3, [r7, #8]

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  401260:	68fb      	ldr	r3, [r7, #12]
  401262:	2b00      	cmp	r3, #0
  401264:	d1ab      	bne.n	4011be <pio_handler_process+0x3a>
				}
			}
			i++;
		}
	}
}
  401266:	f107 0710 	add.w	r7, r7, #16
  40126a:	46bd      	mov	sp, r7
  40126c:	bd80      	pop	{r7, pc}
  40126e:	bf00      	nop

00401270 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  401270:	b580      	push	{r7, lr}
  401272:	af00      	add	r7, sp, #0
	pio_handler_process(PIOA, ID_PIOA);
  401274:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  401278:	f2c4 000e 	movt	r0, #16398	; 0x400e
  40127c:	f04f 010b 	mov.w	r1, #11
  401280:	f241 1385 	movw	r3, #4485	; 0x1185
  401284:	f2c0 0340 	movt	r3, #64	; 0x40
  401288:	4798      	blx	r3
}
  40128a:	bd80      	pop	{r7, pc}

0040128c <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  40128c:	b580      	push	{r7, lr}
  40128e:	af00      	add	r7, sp, #0
    pio_handler_process(PIOB, ID_PIOB);
  401290:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  401294:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401298:	f04f 010c 	mov.w	r1, #12
  40129c:	f241 1385 	movw	r3, #4485	; 0x1185
  4012a0:	f2c0 0340 	movt	r3, #64	; 0x40
  4012a4:	4798      	blx	r3
}
  4012a6:	bd80      	pop	{r7, pc}

004012a8 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  4012a8:	b580      	push	{r7, lr}
  4012aa:	af00      	add	r7, sp, #0
	pio_handler_process(PIOC, ID_PIOC);
  4012ac:	f44f 5090 	mov.w	r0, #4608	; 0x1200
  4012b0:	f2c4 000e 	movt	r0, #16398	; 0x400e
  4012b4:	f04f 010d 	mov.w	r1, #13
  4012b8:	f241 1385 	movw	r3, #4485	; 0x1185
  4012bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4012c0:	4798      	blx	r3
}
  4012c2:	bd80      	pop	{r7, pc}

004012c4 <pmc_switch_mck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
  4012c4:	b480      	push	{r7}
  4012c6:	b085      	sub	sp, #20
  4012c8:	af00      	add	r7, sp, #0
  4012ca:	6078      	str	r0, [r7, #4]
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  4012cc:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4012d0:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4012d4:	f44f 6280 	mov.w	r2, #1024	; 0x400
  4012d8:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4012dc:	6b12      	ldr	r2, [r2, #48]	; 0x30
  4012de:	f022 0170 	bic.w	r1, r2, #112	; 0x70
  4012e2:	687a      	ldr	r2, [r7, #4]
  4012e4:	430a      	orrs	r2, r1
  4012e6:	631a      	str	r2, [r3, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4012e8:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4012ec:	60fb      	str	r3, [r7, #12]
  4012ee:	e009      	b.n	401304 <pmc_switch_mck_to_pllack+0x40>
			--ul_timeout) {
		if (ul_timeout == 0) {
  4012f0:	68fb      	ldr	r3, [r7, #12]
  4012f2:	2b00      	cmp	r3, #0
  4012f4:	d102      	bne.n	4012fc <pmc_switch_mck_to_pllack+0x38>
			return 1;
  4012f6:	f04f 0301 	mov.w	r3, #1
  4012fa:	e033      	b.n	401364 <pmc_switch_mck_to_pllack+0xa0>
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
  4012fc:	68fb      	ldr	r3, [r7, #12]
  4012fe:	f103 33ff 	add.w	r3, r3, #4294967295
  401302:	60fb      	str	r3, [r7, #12]
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401304:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401308:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40130c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40130e:	f003 0308 	and.w	r3, r3, #8
  401312:	2b00      	cmp	r3, #0
  401314:	d0ec      	beq.n	4012f0 <pmc_switch_mck_to_pllack+0x2c>
		if (ul_timeout == 0) {
			return 1;
		}
	}
	
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  401316:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40131a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40131e:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401322:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401326:	6b12      	ldr	r2, [r2, #48]	; 0x30
  401328:	f022 0203 	bic.w	r2, r2, #3
  40132c:	f042 0202 	orr.w	r2, r2, #2
  401330:	631a      	str	r2, [r3, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401332:	f44f 6300 	mov.w	r3, #2048	; 0x800
  401336:	60fb      	str	r3, [r7, #12]
  401338:	e009      	b.n	40134e <pmc_switch_mck_to_pllack+0x8a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40133a:	68fb      	ldr	r3, [r7, #12]
  40133c:	2b00      	cmp	r3, #0
  40133e:	d102      	bne.n	401346 <pmc_switch_mck_to_pllack+0x82>
			return 1;
  401340:	f04f 0301 	mov.w	r3, #1
  401344:	e00e      	b.n	401364 <pmc_switch_mck_to_pllack+0xa0>
	
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
  401346:	68fb      	ldr	r3, [r7, #12]
  401348:	f103 33ff 	add.w	r3, r3, #4294967295
  40134c:	60fb      	str	r3, [r7, #12]
	}
	
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40134e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401352:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401356:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  401358:	f003 0308 	and.w	r3, r3, #8
  40135c:	2b00      	cmp	r3, #0
  40135e:	d0ec      	beq.n	40133a <pmc_switch_mck_to_pllack+0x76>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  401360:	f04f 0300 	mov.w	r3, #0
}
  401364:	4618      	mov	r0, r3
  401366:	f107 0714 	add.w	r7, r7, #20
  40136a:	46bd      	mov	sp, r7
  40136c:	bc80      	pop	{r7}
  40136e:	4770      	bx	lr

00401370 <pmc_switch_sclk_to_32kxtal>:
 * power supply.
 *
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
  401370:	b480      	push	{r7}
  401372:	b083      	sub	sp, #12
  401374:	af00      	add	r7, sp, #0
  401376:	6078      	str	r0, [r7, #4]
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  401378:	687b      	ldr	r3, [r7, #4]
  40137a:	2b01      	cmp	r3, #1
  40137c:	d10d      	bne.n	40139a <pmc_switch_sclk_to_32kxtal+0x2a>
		SUPC->SUPC_MR |= SUPC_MR_KEY(SUPC_KEY_VALUE) |
  40137e:	f241 4310 	movw	r3, #5136	; 0x1410
  401382:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401386:	f241 4210 	movw	r2, #5136	; 0x1410
  40138a:	f2c4 020e 	movt	r2, #16398	; 0x400e
  40138e:	6892      	ldr	r2, [r2, #8]
  401390:	f042 4225 	orr.w	r2, r2, #2768240640	; 0xa5000000
  401394:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
  401398:	609a      	str	r2, [r3, #8]
				SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR |= SUPC_CR_KEY(SUPC_KEY_VALUE) | SUPC_CR_XTALSEL;
  40139a:	f241 4310 	movw	r3, #5136	; 0x1410
  40139e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4013a2:	f241 4210 	movw	r2, #5136	; 0x1410
  4013a6:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4013aa:	6812      	ldr	r2, [r2, #0]
  4013ac:	f042 4225 	orr.w	r2, r2, #2768240640	; 0xa5000000
  4013b0:	f042 0208 	orr.w	r2, r2, #8
  4013b4:	601a      	str	r2, [r3, #0]
}
  4013b6:	f107 070c 	add.w	r7, r7, #12
  4013ba:	46bd      	mov	sp, r7
  4013bc:	bc80      	pop	{r7}
  4013be:	4770      	bx	lr

004013c0 <pmc_osc_is_ready_32kxtal>:
 *
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
  4013c0:	b480      	push	{r7}
  4013c2:	af00      	add	r7, sp, #0
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  4013c4:	f241 4310 	movw	r3, #5136	; 0x1410
  4013c8:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4013cc:	695b      	ldr	r3, [r3, #20]
  4013ce:	f003 0380 	and.w	r3, r3, #128	; 0x80
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  4013d2:	2b00      	cmp	r3, #0
  4013d4:	d00b      	beq.n	4013ee <pmc_osc_is_ready_32kxtal+0x2e>
  4013d6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4013da:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4013de:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4013e0:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4013e4:	2b00      	cmp	r3, #0
  4013e6:	d002      	beq.n	4013ee <pmc_osc_is_ready_32kxtal+0x2e>
  4013e8:	f04f 0301 	mov.w	r3, #1
  4013ec:	e001      	b.n	4013f2 <pmc_osc_is_ready_32kxtal+0x32>
  4013ee:	f04f 0300 	mov.w	r3, #0
}
  4013f2:	4618      	mov	r0, r3
  4013f4:	46bd      	mov	sp, r7
  4013f6:	bc80      	pop	{r7}
  4013f8:	4770      	bx	lr
  4013fa:	bf00      	nop

004013fc <pmc_switch_mainck_to_fastrc>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
  4013fc:	b480      	push	{r7}
  4013fe:	b085      	sub	sp, #20
  401400:	af00      	add	r7, sp, #0
  401402:	6078      	str	r0, [r7, #4]
	uint32_t ul_needXTEN = 0;
  401404:	f04f 0300 	mov.w	r3, #0
  401408:	60fb      	str	r3, [r7, #12]

	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	if (PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN) {
  40140a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40140e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401412:	6a1b      	ldr	r3, [r3, #32]
  401414:	f003 0301 	and.w	r3, r3, #1
  401418:	2b00      	cmp	r3, #0
  40141a:	d014      	beq.n	401446 <pmc_switch_mainck_to_fastrc+0x4a>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  40141c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401420:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401424:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401428:	f2c4 020e 	movt	r2, #16398	; 0x400e
  40142c:	6a12      	ldr	r2, [r2, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
  40142e:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  401432:	f022 0278 	bic.w	r2, r2, #120	; 0x78
  401436:	6879      	ldr	r1, [r7, #4]
  401438:	430a      	orrs	r2, r1
  40143a:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  40143e:	f042 0208 	orr.w	r2, r2, #8
{
	uint32_t ul_needXTEN = 0;

	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	if (PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  401442:	621a      	str	r2, [r3, #32]
				CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME) |
				ul_moscrcf;
	}

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  401444:	e018      	b.n	401478 <pmc_switch_mainck_to_fastrc+0x7c>
	if (PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
				ul_moscrcf;
	} else {
		ul_needXTEN = 1;
  401446:	f04f 0301 	mov.w	r3, #1
  40144a:	60fb      	str	r3, [r7, #12]
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  40144c:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401450:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401454:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401458:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40145c:	6a19      	ldr	r1, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
				CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME) |
  40145e:	f24c 0386 	movw	r3, #49286	; 0xc086
  401462:	f6cf 73c8 	movt	r3, #65480	; 0xffc8
  401466:	400b      	ands	r3, r1
  401468:	6879      	ldr	r1, [r7, #4]
  40146a:	4319      	orrs	r1, r3
  40146c:	f643 7309 	movw	r3, #16137	; 0x3f09
  401470:	f2c0 0337 	movt	r3, #55	; 0x37
  401474:	430b      	orrs	r3, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
				ul_moscrcf;
	} else {
		ul_needXTEN = 1;
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  401476:	6213      	str	r3, [r2, #32]
				CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME) |
				ul_moscrcf;
	}

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  401478:	bf00      	nop
  40147a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40147e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401482:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  401484:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  401488:	2b00      	cmp	r3, #0
  40148a:	d0f6      	beq.n	40147a <pmc_switch_mainck_to_fastrc+0x7e>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) | PMC_CKGR_MOR_KEY_VALUE;
  40148c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401490:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401494:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401498:	f2c4 020e 	movt	r2, #16398	; 0x400e
  40149c:	6a12      	ldr	r2, [r2, #32]
  40149e:	f022 729b 	bic.w	r2, r2, #20316160	; 0x1360000
  4014a2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  4014a6:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  4014aa:	621a      	str	r2, [r3, #32]

	// BUG FIX : clock_example3_sam3s does not switch sclk->mainck with XT disabled.
	if (ul_needXTEN) {
  4014ac:	68fb      	ldr	r3, [r7, #12]
  4014ae:	2b00      	cmp	r3, #0
  4014b0:	d00f      	beq.n	4014d2 <pmc_switch_mainck_to_fastrc+0xd6>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4014b2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4014b6:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4014ba:	f44f 6280 	mov.w	r2, #1024	; 0x400
  4014be:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4014c2:	6a12      	ldr	r2, [r2, #32]
  4014c4:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  4014c8:	f022 0201 	bic.w	r2, r2, #1
  4014cc:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  4014d0:	621a      	str	r2, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE;
	}
}
  4014d2:	f107 0714 	add.w	r7, r7, #20
  4014d6:	46bd      	mov	sp, r7
  4014d8:	bc80      	pop	{r7}
  4014da:	4770      	bx	lr

004014dc <pmc_switch_mainck_to_xtal>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass)
{
  4014dc:	b480      	push	{r7}
  4014de:	b083      	sub	sp, #12
  4014e0:	af00      	add	r7, sp, #0
  4014e2:	6078      	str	r0, [r7, #4]
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  4014e4:	687b      	ldr	r3, [r7, #4]
  4014e6:	2b00      	cmp	r3, #0
  4014e8:	d014      	beq.n	401514 <pmc_switch_mainck_to_xtal+0x38>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4014ea:	f44f 6180 	mov.w	r1, #1024	; 0x400
  4014ee:	f2c4 010e 	movt	r1, #16398	; 0x400e
  4014f2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4014f6:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4014fa:	6a1b      	ldr	r3, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
  4014fc:	f64f 72fc 	movw	r2, #65532	; 0xfffc
  401500:	f6cf 62c8 	movt	r2, #65224	; 0xfec8
  401504:	401a      	ands	r2, r3
  401506:	f04f 0302 	mov.w	r3, #2
  40150a:	f2c0 1337 	movt	r3, #311	; 0x137
  40150e:	4313      	orrs	r3, r2
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  401510:	620b      	str	r3, [r1, #32]
  401512:	e02b      	b.n	40156c <pmc_switch_mainck_to_xtal+0x90>
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  401514:	f44f 6180 	mov.w	r1, #1024	; 0x400
  401518:	f2c4 010e 	movt	r1, #16398	; 0x400e
  40151c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401520:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401524:	6a1b      	ldr	r3, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
  401526:	f24c 02fc 	movw	r2, #49404	; 0xc0fc
  40152a:	f6cf 72c8 	movt	r2, #65480	; 0xffc8
  40152e:	401a      	ands	r2, r3
  401530:	f643 7301 	movw	r3, #16129	; 0x3f01
  401534:	f2c0 0337 	movt	r3, #55	; 0x37
  401538:	4313      	orrs	r3, r2
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40153a:	620b      	str	r3, [r1, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  40153c:	bf00      	nop
  40153e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401542:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401546:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  401548:	f003 0301 	and.w	r3, r3, #1
  40154c:	2b00      	cmp	r3, #0
  40154e:	d0f6      	beq.n	40153e <pmc_switch_mainck_to_xtal+0x62>

		PMC->CKGR_MOR |= PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCSEL;
  401550:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401554:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401558:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40155c:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401560:	6a12      	ldr	r2, [r2, #32]
  401562:	f042 729b 	orr.w	r2, r2, #20316160	; 0x1360000
  401566:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  40156a:	621a      	str	r2, [r3, #32]
	}
}
  40156c:	f107 070c 	add.w	r7, r7, #12
  401570:	46bd      	mov	sp, r7
  401572:	bc80      	pop	{r7}
  401574:	4770      	bx	lr
  401576:	bf00      	nop

00401578 <pmc_osc_is_ready_mainck>:
 *
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
  401578:	b480      	push	{r7}
  40157a:	af00      	add	r7, sp, #0
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  40157c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401580:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401584:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  401586:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
  40158a:	4618      	mov	r0, r3
  40158c:	46bd      	mov	sp, r7
  40158e:	bc80      	pop	{r7}
  401590:	4770      	bx	lr
  401592:	bf00      	nop

00401594 <pmc_disable_pllack>:

/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
  401594:	b480      	push	{r7}
  401596:	af00      	add	r7, sp, #0
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  401598:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40159c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4015a0:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  4015a4:	629a      	str	r2, [r3, #40]	; 0x28
}
  4015a6:	46bd      	mov	sp, r7
  4015a8:	bc80      	pop	{r7}
  4015aa:	4770      	bx	lr

004015ac <pmc_is_locked_pllack>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
  4015ac:	b480      	push	{r7}
  4015ae:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  4015b0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4015b4:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4015b8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4015ba:	f003 0302 	and.w	r3, r3, #2
}
  4015be:	4618      	mov	r0, r3
  4015c0:	46bd      	mov	sp, r7
  4015c2:	bc80      	pop	{r7}
  4015c4:	4770      	bx	lr
  4015c6:	bf00      	nop

004015c8 <pmc_disable_pllbck>:

/**
 * \brief Disable PLLB clock.
 */
void pmc_disable_pllbck(void)
{
  4015c8:	b480      	push	{r7}
  4015ca:	af00      	add	r7, sp, #0
	PMC->CKGR_PLLBR = CKGR_PLLBR_MULB(0);
  4015cc:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4015d0:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4015d4:	f04f 0200 	mov.w	r2, #0
  4015d8:	62da      	str	r2, [r3, #44]	; 0x2c
}
  4015da:	46bd      	mov	sp, r7
  4015dc:	bc80      	pop	{r7}
  4015de:	4770      	bx	lr

004015e0 <pmc_is_locked_pllbck>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllbck(void)
{
  4015e0:	b480      	push	{r7}
  4015e2:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKB);
  4015e4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4015e8:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4015ec:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4015ee:	f003 0304 	and.w	r3, r3, #4
}
  4015f2:	4618      	mov	r0, r3
  4015f4:	46bd      	mov	sp, r7
  4015f6:	bc80      	pop	{r7}
  4015f8:	4770      	bx	lr
  4015fa:	bf00      	nop

004015fc <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4015fc:	b480      	push	{r7}
  4015fe:	af00      	add	r7, sp, #0
	while (1) {
	}
  401600:	e7fe      	b.n	401600 <Dummy_Handler+0x4>
  401602:	bf00      	nop

00401604 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  401604:	b580      	push	{r7, lr}
  401606:	b082      	sub	sp, #8
  401608:	af00      	add	r7, sp, #0
	uint32_t *pSrc, *pDest;

	/* Initialize the relocate segment */
	pSrc = &_etext;
  40160a:	f644 333c 	movw	r3, #19260	; 0x4b3c
  40160e:	f2c0 0340 	movt	r3, #64	; 0x40
  401612:	607b      	str	r3, [r7, #4]
	pDest = &_srelocate;
  401614:	f240 0300 	movw	r3, #0
  401618:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40161c:	603b      	str	r3, [r7, #0]

	if (pSrc != pDest) {
  40161e:	687a      	ldr	r2, [r7, #4]
  401620:	683b      	ldr	r3, [r7, #0]
  401622:	429a      	cmp	r2, r3
  401624:	d013      	beq.n	40164e <Reset_Handler+0x4a>
		for (; pDest < &_erelocate;) {
  401626:	e00b      	b.n	401640 <Reset_Handler+0x3c>
			*pDest++ = *pSrc++;
  401628:	687b      	ldr	r3, [r7, #4]
  40162a:	681a      	ldr	r2, [r3, #0]
  40162c:	683b      	ldr	r3, [r7, #0]
  40162e:	601a      	str	r2, [r3, #0]
  401630:	683b      	ldr	r3, [r7, #0]
  401632:	f103 0304 	add.w	r3, r3, #4
  401636:	603b      	str	r3, [r7, #0]
  401638:	687b      	ldr	r3, [r7, #4]
  40163a:	f103 0304 	add.w	r3, r3, #4
  40163e:	607b      	str	r3, [r7, #4]
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
  401640:	683a      	ldr	r2, [r7, #0]
  401642:	f240 4340 	movw	r3, #1088	; 0x440
  401646:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40164a:	429a      	cmp	r2, r3
  40164c:	d3ec      	bcc.n	401628 <Reset_Handler+0x24>
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40164e:	f240 4340 	movw	r3, #1088	; 0x440
  401652:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401656:	603b      	str	r3, [r7, #0]
  401658:	e007      	b.n	40166a <Reset_Handler+0x66>
		*pDest++ = 0;
  40165a:	683b      	ldr	r3, [r7, #0]
  40165c:	f04f 0200 	mov.w	r2, #0
  401660:	601a      	str	r2, [r3, #0]
  401662:	683b      	ldr	r3, [r7, #0]
  401664:	f103 0304 	add.w	r3, r3, #4
  401668:	603b      	str	r3, [r7, #0]
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40166a:	683a      	ldr	r2, [r7, #0]
  40166c:	f24a 6324 	movw	r3, #42532	; 0xa624
  401670:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401674:	429a      	cmp	r2, r3
  401676:	d3f0      	bcc.n	40165a <Reset_Handler+0x56>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
  401678:	f240 0300 	movw	r3, #0
  40167c:	f2c0 0340 	movt	r3, #64	; 0x40
  401680:	607b      	str	r3, [r7, #4]
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  401682:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  401686:	f2ce 0300 	movt	r3, #57344	; 0xe000
  40168a:	687a      	ldr	r2, [r7, #4]
  40168c:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
  401690:	609a      	str	r2, [r3, #8]

	if (((uint32_t) pSrc >= IRAM_ADDR) && ((uint32_t) pSrc < IRAM_ADDR + IRAM_SIZE)) {
  401692:	687a      	ldr	r2, [r7, #4]
  401694:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
  401698:	429a      	cmp	r2, r3
  40169a:	d912      	bls.n	4016c2 <Reset_Handler+0xbe>
  40169c:	687a      	ldr	r2, [r7, #4]
  40169e:	f64f 73ff 	movw	r3, #65535	; 0xffff
  4016a2:	f2c2 0301 	movt	r3, #8193	; 0x2001
  4016a6:	429a      	cmp	r2, r3
  4016a8:	d80b      	bhi.n	4016c2 <Reset_Handler+0xbe>
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
  4016aa:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  4016ae:	f2ce 0300 	movt	r3, #57344	; 0xe000
  4016b2:	f44f 426d 	mov.w	r2, #60672	; 0xed00
  4016b6:	f2ce 0200 	movt	r2, #57344	; 0xe000
  4016ba:	6892      	ldr	r2, [r2, #8]
  4016bc:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  4016c0:	609a      	str	r2, [r3, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
  4016c2:	f644 2321 	movw	r3, #18977	; 0x4a21
  4016c6:	f2c0 0340 	movt	r3, #64	; 0x40
  4016ca:	4798      	blx	r3

	/* Branch to main function */
	main();
  4016cc:	f244 6329 	movw	r3, #17961	; 0x4629
  4016d0:	f2c0 0340 	movt	r3, #64	; 0x40
  4016d4:	4798      	blx	r3

	/* Infinite loop */
	while (1);
  4016d6:	e7fe      	b.n	4016d6 <Reset_Handler+0xd2>

004016d8 <SystemCoreClockUpdate>:

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate(void)
{
  4016d8:	b480      	push	{r7}
  4016da:	af00      	add	r7, sp, #0
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  4016dc:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4016e0:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4016e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4016e6:	f003 0303 	and.w	r3, r3, #3
  4016ea:	2b03      	cmp	r3, #3
  4016ec:	f200 8119 	bhi.w	401922 <SystemCoreClockUpdate+0x24a>
  4016f0:	a101      	add	r1, pc, #4	; (adr r1, 4016f8 <SystemCoreClockUpdate+0x20>)
  4016f2:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
  4016f6:	bf00      	nop
  4016f8:	00401709 	.word	0x00401709
  4016fc:	0040173b 	.word	0x0040173b
  401700:	004017cd 	.word	0x004017cd
  401704:	004017cd 	.word	0x004017cd
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  401708:	f241 4310 	movw	r3, #5136	; 0x1410
  40170c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401710:	695b      	ldr	r3, [r3, #20]
  401712:	f003 0380 	and.w	r3, r3, #128	; 0x80
  401716:	2b00      	cmp	r3, #0
  401718:	d007      	beq.n	40172a <SystemCoreClockUpdate+0x52>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  40171a:	f240 0304 	movw	r3, #4
  40171e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401722:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  401726:	601a      	str	r2, [r3, #0]
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
		}
		break;
  401728:	e0fc      	b.n	401924 <SystemCoreClockUpdate+0x24c>
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  40172a:	f240 0304 	movw	r3, #4
  40172e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401732:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  401736:	601a      	str	r2, [r3, #0]
		}
		break;
  401738:	e0f4      	b.n	401924 <SystemCoreClockUpdate+0x24c>
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  40173a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40173e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401742:	6a1b      	ldr	r3, [r3, #32]
  401744:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  401748:	2b00      	cmp	r3, #0
  40174a:	d009      	beq.n	401760 <SystemCoreClockUpdate+0x88>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  40174c:	f240 0304 	movw	r3, #4
  401750:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401754:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  401758:	f2c0 02b7 	movt	r2, #183	; 0xb7
  40175c:	601a      	str	r2, [r3, #0]
				break;
			default:
				break;
			}
		}
		break;
  40175e:	e0e1      	b.n	401924 <SystemCoreClockUpdate+0x24c>
		break;
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  401760:	f240 0304 	movw	r3, #4
  401764:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401768:	f44f 6210 	mov.w	r2, #2304	; 0x900
  40176c:	f2c0 023d 	movt	r2, #61	; 0x3d
  401770:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  401772:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401776:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40177a:	6a1b      	ldr	r3, [r3, #32]
  40177c:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401780:	2b10      	cmp	r3, #16
  401782:	d004      	beq.n	40178e <SystemCoreClockUpdate+0xb6>
  401784:	2b20      	cmp	r3, #32
  401786:	d00f      	beq.n	4017a8 <SystemCoreClockUpdate+0xd0>
  401788:	2b00      	cmp	r3, #0
  40178a:	d01d      	beq.n	4017c8 <SystemCoreClockUpdate+0xf0>
  40178c:	e01b      	b.n	4017c6 <SystemCoreClockUpdate+0xee>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
  40178e:	f240 0304 	movw	r3, #4
  401792:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401796:	681b      	ldr	r3, [r3, #0]
  401798:	ea4f 0243 	mov.w	r2, r3, lsl #1
  40179c:	f240 0304 	movw	r3, #4
  4017a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4017a4:	601a      	str	r2, [r3, #0]
				break;
  4017a6:	e010      	b.n	4017ca <SystemCoreClockUpdate+0xf2>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
  4017a8:	f240 0304 	movw	r3, #4
  4017ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4017b0:	681a      	ldr	r2, [r3, #0]
  4017b2:	4613      	mov	r3, r2
  4017b4:	ea4f 0343 	mov.w	r3, r3, lsl #1
  4017b8:	189a      	adds	r2, r3, r2
  4017ba:	f240 0304 	movw	r3, #4
  4017be:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4017c2:	601a      	str	r2, [r3, #0]
				break;
  4017c4:	e001      	b.n	4017ca <SystemCoreClockUpdate+0xf2>
			default:
				break;
  4017c6:	e000      	b.n	4017ca <SystemCoreClockUpdate+0xf2>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
  4017c8:	bf00      	nop
				break;
			default:
				break;
			}
		}
		break;
  4017ca:	e0ab      	b.n	401924 <SystemCoreClockUpdate+0x24c>
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  4017cc:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4017d0:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4017d4:	6a1b      	ldr	r3, [r3, #32]
  4017d6:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  4017da:	2b00      	cmp	r3, #0
  4017dc:	d009      	beq.n	4017f2 <SystemCoreClockUpdate+0x11a>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  4017de:	f240 0304 	movw	r3, #4
  4017e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4017e6:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  4017ea:	f2c0 02b7 	movt	r2, #183	; 0xb7
  4017ee:	601a      	str	r2, [r3, #0]
  4017f0:	e034      	b.n	40185c <SystemCoreClockUpdate+0x184>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  4017f2:	f240 0304 	movw	r3, #4
  4017f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4017fa:	f44f 6210 	mov.w	r2, #2304	; 0x900
  4017fe:	f2c0 023d 	movt	r2, #61	; 0x3d
  401802:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  401804:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401808:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40180c:	6a1b      	ldr	r3, [r3, #32]
  40180e:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401812:	2b10      	cmp	r3, #16
  401814:	d004      	beq.n	401820 <SystemCoreClockUpdate+0x148>
  401816:	2b20      	cmp	r3, #32
  401818:	d00f      	beq.n	40183a <SystemCoreClockUpdate+0x162>
  40181a:	2b00      	cmp	r3, #0
  40181c:	d01d      	beq.n	40185a <SystemCoreClockUpdate+0x182>
  40181e:	e01b      	b.n	401858 <SystemCoreClockUpdate+0x180>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
  401820:	f240 0304 	movw	r3, #4
  401824:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401828:	681b      	ldr	r3, [r3, #0]
  40182a:	ea4f 0243 	mov.w	r2, r3, lsl #1
  40182e:	f240 0304 	movw	r3, #4
  401832:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401836:	601a      	str	r2, [r3, #0]
				break;
  401838:	e010      	b.n	40185c <SystemCoreClockUpdate+0x184>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
  40183a:	f240 0304 	movw	r3, #4
  40183e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401842:	681a      	ldr	r2, [r3, #0]
  401844:	4613      	mov	r3, r2
  401846:	ea4f 0343 	mov.w	r3, r3, lsl #1
  40184a:	189a      	adds	r2, r3, r2
  40184c:	f240 0304 	movw	r3, #4
  401850:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401854:	601a      	str	r2, [r3, #0]
				break;
  401856:	e001      	b.n	40185c <SystemCoreClockUpdate+0x184>
			default:
				break;
  401858:	e000      	b.n	40185c <SystemCoreClockUpdate+0x184>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
  40185a:	bf00      	nop
				break;
			default:
				break;
			}
		}
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
  40185c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401860:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401864:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401866:	f003 0303 	and.w	r3, r3, #3
  40186a:	2b02      	cmp	r3, #2
  40186c:	d12c      	bne.n	4018c8 <SystemCoreClockUpdate+0x1f0>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  40186e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401872:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401876:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  401878:	f04f 0300 	mov.w	r3, #0
  40187c:	f2c0 73ff 	movt	r3, #2047	; 0x7ff
  401880:	4013      	ands	r3, r2
  401882:	ea4f 4313 	mov.w	r3, r3, lsr #16
				                          CKGR_PLLAR_MULA_Pos) + 1U);
  401886:	f103 0201 	add.w	r2, r3, #1
			default:
				break;
			}
		}
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  40188a:	f240 0304 	movw	r3, #4
  40188e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401892:	681b      	ldr	r3, [r3, #0]
  401894:	fb03 f202 	mul.w	r2, r3, r2
  401898:	f240 0304 	movw	r3, #4
  40189c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4018a0:	601a      	str	r2, [r3, #0]
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
  4018a2:	f240 0304 	movw	r3, #4
  4018a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4018aa:	681a      	ldr	r2, [r3, #0]
  4018ac:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4018b0:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4018b4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  4018b6:	b2db      	uxtb	r3, r3
  4018b8:	fbb2 f2f3 	udiv	r2, r2, r3
  4018bc:	f240 0304 	movw	r3, #4
  4018c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4018c4:	601a      	str	r2, [r3, #0]
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
				                           CKGR_PLLBR_MULB_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk) >> 
				                               CKGR_PLLBR_DIVB_Pos));
		}
		break;
  4018c6:	e02d      	b.n	401924 <SystemCoreClockUpdate+0x24c>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
				                          CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
  4018c8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4018cc:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4018d0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4018d2:	f04f 0300 	mov.w	r3, #0
  4018d6:	f2c0 73ff 	movt	r3, #2047	; 0x7ff
  4018da:	4013      	ands	r3, r2
  4018dc:	ea4f 4313 	mov.w	r3, r3, lsr #16
				                           CKGR_PLLBR_MULB_Pos) + 1U);
  4018e0:	f103 0201 	add.w	r2, r3, #1
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
				                          CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
  4018e4:	f240 0304 	movw	r3, #4
  4018e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4018ec:	681b      	ldr	r3, [r3, #0]
  4018ee:	fb03 f202 	mul.w	r2, r3, r2
  4018f2:	f240 0304 	movw	r3, #4
  4018f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4018fa:	601a      	str	r2, [r3, #0]
				                           CKGR_PLLBR_MULB_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk) >> 
  4018fc:	f240 0304 	movw	r3, #4
  401900:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401904:	681a      	ldr	r2, [r3, #0]
  401906:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40190a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40190e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401910:	b2db      	uxtb	r3, r3
  401912:	fbb2 f2f3 	udiv	r2, r2, r3
  401916:	f240 0304 	movw	r3, #4
  40191a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40191e:	601a      	str	r2, [r3, #0]
				                               CKGR_PLLBR_DIVB_Pos));
		}
		break;
  401920:	e000      	b.n	401924 <SystemCoreClockUpdate+0x24c>
	default:
		break;
  401922:	bf00      	nop
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  401924:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401928:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40192c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40192e:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401932:	2b70      	cmp	r3, #112	; 0x70
  401934:	d112      	bne.n	40195c <SystemCoreClockUpdate+0x284>
		SystemCoreClock /= 3U;
  401936:	f240 0304 	movw	r3, #4
  40193a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40193e:	681a      	ldr	r2, [r3, #0]
  401940:	f64a 23ab 	movw	r3, #43691	; 0xaaab
  401944:	f6ca 23aa 	movt	r3, #43690	; 0xaaaa
  401948:	fba3 1302 	umull	r1, r3, r3, r2
  40194c:	ea4f 0253 	mov.w	r2, r3, lsr #1
  401950:	f240 0304 	movw	r3, #4
  401954:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401958:	601a      	str	r2, [r3, #0]
  40195a:	e014      	b.n	401986 <SystemCoreClockUpdate+0x2ae>
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  40195c:	f240 0304 	movw	r3, #4
  401960:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401964:	681a      	ldr	r2, [r3, #0]
  401966:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40196a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40196e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401970:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401974:	ea4f 1313 	mov.w	r3, r3, lsr #4
  401978:	fa22 f203 	lsr.w	r2, r2, r3
  40197c:	f240 0304 	movw	r3, #4
  401980:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401984:	601a      	str	r2, [r3, #0]
	}
}
  401986:	46bd      	mov	sp, r7
  401988:	bc80      	pop	{r7}
  40198a:	4770      	bx	lr

0040198c <system_init_flash>:

/** 
 * Initialize flash.
 */
void system_init_flash(uint32_t ul_clk)
{
  40198c:	b480      	push	{r7}
  40198e:	b083      	sub	sp, #12
  401990:	af00      	add	r7, sp, #0
  401992:	6078      	str	r0, [r7, #4]
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
  401994:	687a      	ldr	r2, [r7, #4]
  401996:	f642 43ff 	movw	r3, #11519	; 0x2cff
  40199a:	f2c0 1331 	movt	r3, #305	; 0x131
  40199e:	429a      	cmp	r2, r3
  4019a0:	d807      	bhi.n	4019b2 <system_init_flash+0x26>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0);
  4019a2:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  4019a6:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4019aa:	f04f 0200 	mov.w	r2, #0
  4019ae:	601a      	str	r2, [r3, #0]
  4019b0:	e033      	b.n	401a1a <system_init_flash+0x8e>
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
  4019b2:	687a      	ldr	r2, [r7, #4]
  4019b4:	f645 13ff 	movw	r3, #23039	; 0x59ff
  4019b8:	f2c0 2362 	movt	r3, #610	; 0x262
  4019bc:	429a      	cmp	r2, r3
  4019be:	d807      	bhi.n	4019d0 <system_init_flash+0x44>
		EFC->EEFC_FMR = EEFC_FMR_FWS(1);
  4019c0:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  4019c4:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4019c8:	f44f 7280 	mov.w	r2, #256	; 0x100
  4019cc:	601a      	str	r2, [r3, #0]
  4019ce:	e024      	b.n	401a1a <system_init_flash+0x8e>
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
  4019d0:	687a      	ldr	r2, [r7, #4]
  4019d2:	f248 63ff 	movw	r3, #34559	; 0x86ff
  4019d6:	f2c0 3393 	movt	r3, #915	; 0x393
  4019da:	429a      	cmp	r2, r3
  4019dc:	d807      	bhi.n	4019ee <system_init_flash+0x62>
		EFC->EEFC_FMR = EEFC_FMR_FWS(2);
  4019de:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  4019e2:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4019e6:	f44f 7200 	mov.w	r2, #512	; 0x200
  4019ea:	601a      	str	r2, [r3, #0]
  4019ec:	e015      	b.n	401a1a <system_init_flash+0x8e>
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
  4019ee:	687a      	ldr	r2, [r7, #4]
  4019f0:	f24b 33ff 	movw	r3, #46079	; 0xb3ff
  4019f4:	f2c0 43c4 	movt	r3, #1220	; 0x4c4
  4019f8:	429a      	cmp	r2, r3
  4019fa:	d807      	bhi.n	401a0c <system_init_flash+0x80>
		EFC->EEFC_FMR = EEFC_FMR_FWS(3);
  4019fc:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  401a00:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401a04:	f44f 7240 	mov.w	r2, #768	; 0x300
  401a08:	601a      	str	r2, [r3, #0]
  401a0a:	e006      	b.n	401a1a <system_init_flash+0x8e>
	} else {
		EFC->EEFC_FMR = EEFC_FMR_FWS(4);
  401a0c:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  401a10:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401a14:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401a18:	601a      	str	r2, [r3, #0]
	}
}
  401a1a:	f107 070c 	add.w	r7, r7, #12
  401a1e:	46bd      	mov	sp, r7
  401a20:	bc80      	pop	{r7}
  401a22:	4770      	bx	lr

00401a24 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList * const pxList )
{
  401a24:	b480      	push	{r7}
  401a26:	b083      	sub	sp, #12
  401a28:	af00      	add	r7, sp, #0
  401a2a:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  401a2c:	687b      	ldr	r3, [r7, #4]
  401a2e:	f103 0208 	add.w	r2, r3, #8
  401a32:	687b      	ldr	r3, [r7, #4]
  401a34:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  401a36:	687b      	ldr	r3, [r7, #4]
  401a38:	f04f 32ff 	mov.w	r2, #4294967295
  401a3c:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  401a3e:	687b      	ldr	r3, [r7, #4]
  401a40:	f103 0208 	add.w	r2, r3, #8
  401a44:	687b      	ldr	r3, [r7, #4]
  401a46:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  401a48:	687b      	ldr	r3, [r7, #4]
  401a4a:	f103 0208 	add.w	r2, r3, #8
  401a4e:	687b      	ldr	r3, [r7, #4]
  401a50:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  401a52:	687b      	ldr	r3, [r7, #4]
  401a54:	f04f 0200 	mov.w	r2, #0
  401a58:	601a      	str	r2, [r3, #0]
}
  401a5a:	f107 070c 	add.w	r7, r7, #12
  401a5e:	46bd      	mov	sp, r7
  401a60:	bc80      	pop	{r7}
  401a62:	4770      	bx	lr

00401a64 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem * const pxItem )
{
  401a64:	b480      	push	{r7}
  401a66:	b083      	sub	sp, #12
  401a68:	af00      	add	r7, sp, #0
  401a6a:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  401a6c:	687b      	ldr	r3, [r7, #4]
  401a6e:	f04f 0200 	mov.w	r2, #0
  401a72:	611a      	str	r2, [r3, #16]
}
  401a74:	f107 070c 	add.w	r7, r7, #12
  401a78:	46bd      	mov	sp, r7
  401a7a:	bc80      	pop	{r7}
  401a7c:	4770      	bx	lr
  401a7e:	bf00      	nop

00401a80 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList * const pxList, xListItem * const pxNewListItem )
{
  401a80:	b480      	push	{r7}
  401a82:	b085      	sub	sp, #20
  401a84:	af00      	add	r7, sp, #0
  401a86:	6078      	str	r0, [r7, #4]
  401a88:	6039      	str	r1, [r7, #0]
xListItem * pxIndex;

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry. */
	pxIndex = pxList->pxIndex;
  401a8a:	687b      	ldr	r3, [r7, #4]
  401a8c:	685b      	ldr	r3, [r3, #4]
  401a8e:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex;
  401a90:	683b      	ldr	r3, [r7, #0]
  401a92:	68fa      	ldr	r2, [r7, #12]
  401a94:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  401a96:	68fb      	ldr	r3, [r7, #12]
  401a98:	689a      	ldr	r2, [r3, #8]
  401a9a:	683b      	ldr	r3, [r7, #0]
  401a9c:	609a      	str	r2, [r3, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
  401a9e:	68fb      	ldr	r3, [r7, #12]
  401aa0:	689b      	ldr	r3, [r3, #8]
  401aa2:	683a      	ldr	r2, [r7, #0]
  401aa4:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
  401aa6:	68fb      	ldr	r3, [r7, #12]
  401aa8:	683a      	ldr	r2, [r7, #0]
  401aaa:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  401aac:	683b      	ldr	r3, [r7, #0]
  401aae:	687a      	ldr	r2, [r7, #4]
  401ab0:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  401ab2:	687b      	ldr	r3, [r7, #4]
  401ab4:	681b      	ldr	r3, [r3, #0]
  401ab6:	f103 0201 	add.w	r2, r3, #1
  401aba:	687b      	ldr	r3, [r7, #4]
  401abc:	601a      	str	r2, [r3, #0]
}
  401abe:	f107 0714 	add.w	r7, r7, #20
  401ac2:	46bd      	mov	sp, r7
  401ac4:	bc80      	pop	{r7}
  401ac6:	4770      	bx	lr

00401ac8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList * const pxList, xListItem * const pxNewListItem )
{
  401ac8:	b480      	push	{r7}
  401aca:	b085      	sub	sp, #20
  401acc:	af00      	add	r7, sp, #0
  401ace:	6078      	str	r0, [r7, #4]
  401ad0:	6039      	str	r1, [r7, #0]
xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
  401ad2:	683b      	ldr	r3, [r7, #0]
  401ad4:	681b      	ldr	r3, [r3, #0]
  401ad6:	60bb      	str	r3, [r7, #8]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  401ad8:	68bb      	ldr	r3, [r7, #8]
  401ada:	f1b3 3fff 	cmp.w	r3, #4294967295
  401ade:	d103      	bne.n	401ae8 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  401ae0:	687b      	ldr	r3, [r7, #4]
  401ae2:	691b      	ldr	r3, [r3, #16]
  401ae4:	60fb      	str	r3, [r7, #12]
  401ae6:	e00d      	b.n	401b04 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  401ae8:	687b      	ldr	r3, [r7, #4]
  401aea:	f103 0308 	add.w	r3, r3, #8
  401aee:	60fb      	str	r3, [r7, #12]
  401af0:	e002      	b.n	401af8 <vListInsert+0x30>
  401af2:	68fb      	ldr	r3, [r7, #12]
  401af4:	685b      	ldr	r3, [r3, #4]
  401af6:	60fb      	str	r3, [r7, #12]
  401af8:	68fb      	ldr	r3, [r7, #12]
  401afa:	685b      	ldr	r3, [r3, #4]
  401afc:	681a      	ldr	r2, [r3, #0]
  401afe:	68bb      	ldr	r3, [r7, #8]
  401b00:	429a      	cmp	r2, r3
  401b02:	d9f6      	bls.n	401af2 <vListInsert+0x2a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  401b04:	68fb      	ldr	r3, [r7, #12]
  401b06:	685a      	ldr	r2, [r3, #4]
  401b08:	683b      	ldr	r3, [r7, #0]
  401b0a:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  401b0c:	683b      	ldr	r3, [r7, #0]
  401b0e:	685b      	ldr	r3, [r3, #4]
  401b10:	683a      	ldr	r2, [r7, #0]
  401b12:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
  401b14:	683b      	ldr	r3, [r7, #0]
  401b16:	68fa      	ldr	r2, [r7, #12]
  401b18:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
  401b1a:	68fb      	ldr	r3, [r7, #12]
  401b1c:	683a      	ldr	r2, [r7, #0]
  401b1e:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  401b20:	683b      	ldr	r3, [r7, #0]
  401b22:	687a      	ldr	r2, [r7, #4]
  401b24:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  401b26:	687b      	ldr	r3, [r7, #4]
  401b28:	681b      	ldr	r3, [r3, #0]
  401b2a:	f103 0201 	add.w	r2, r3, #1
  401b2e:	687b      	ldr	r3, [r7, #4]
  401b30:	601a      	str	r2, [r3, #0]
}
  401b32:	f107 0714 	add.w	r7, r7, #20
  401b36:	46bd      	mov	sp, r7
  401b38:	bc80      	pop	{r7}
  401b3a:	4770      	bx	lr

00401b3c <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove )
{
  401b3c:	b480      	push	{r7}
  401b3e:	b085      	sub	sp, #20
  401b40:	af00      	add	r7, sp, #0
  401b42:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  401b44:	687b      	ldr	r3, [r7, #4]
  401b46:	685b      	ldr	r3, [r3, #4]
  401b48:	687a      	ldr	r2, [r7, #4]
  401b4a:	6892      	ldr	r2, [r2, #8]
  401b4c:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  401b4e:	687b      	ldr	r3, [r7, #4]
  401b50:	689b      	ldr	r3, [r3, #8]
  401b52:	687a      	ldr	r2, [r7, #4]
  401b54:	6852      	ldr	r2, [r2, #4]
  401b56:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  401b58:	687b      	ldr	r3, [r7, #4]
  401b5a:	691b      	ldr	r3, [r3, #16]
  401b5c:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  401b5e:	68fb      	ldr	r3, [r7, #12]
  401b60:	685a      	ldr	r2, [r3, #4]
  401b62:	687b      	ldr	r3, [r7, #4]
  401b64:	429a      	cmp	r2, r3
  401b66:	d103      	bne.n	401b70 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  401b68:	687b      	ldr	r3, [r7, #4]
  401b6a:	689a      	ldr	r2, [r3, #8]
  401b6c:	68fb      	ldr	r3, [r7, #12]
  401b6e:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  401b70:	687b      	ldr	r3, [r7, #4]
  401b72:	f04f 0200 	mov.w	r2, #0
  401b76:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
  401b78:	68fb      	ldr	r3, [r7, #12]
  401b7a:	681b      	ldr	r3, [r3, #0]
  401b7c:	f103 32ff 	add.w	r2, r3, #4294967295
  401b80:	68fb      	ldr	r3, [r7, #12]
  401b82:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  401b84:	68fb      	ldr	r3, [r7, #12]
  401b86:	681b      	ldr	r3, [r3, #0]
}
  401b88:	4618      	mov	r0, r3
  401b8a:	f107 0714 	add.w	r7, r7, #20
  401b8e:	46bd      	mov	sp, r7
  401b90:	bc80      	pop	{r7}
  401b92:	4770      	bx	lr

00401b94 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
  401b94:	b480      	push	{r7}
  401b96:	b085      	sub	sp, #20
  401b98:	af00      	add	r7, sp, #0
  401b9a:	60f8      	str	r0, [r7, #12]
  401b9c:	60b9      	str	r1, [r7, #8]
  401b9e:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
  401ba0:	68fb      	ldr	r3, [r7, #12]
  401ba2:	f1a3 0304 	sub.w	r3, r3, #4
  401ba6:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
  401ba8:	68fb      	ldr	r3, [r7, #12]
  401baa:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  401bae:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  401bb0:	68fb      	ldr	r3, [r7, #12]
  401bb2:	f1a3 0304 	sub.w	r3, r3, #4
  401bb6:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
  401bb8:	68ba      	ldr	r2, [r7, #8]
  401bba:	68fb      	ldr	r3, [r7, #12]
  401bbc:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  401bbe:	68fb      	ldr	r3, [r7, #12]
  401bc0:	f1a3 0304 	sub.w	r3, r3, #4
  401bc4:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) portTASK_RETURN_ADDRESS;	/* LR */
  401bc6:	f641 33f9 	movw	r3, #7161	; 0x1bf9
  401bca:	f2c0 0340 	movt	r3, #64	; 0x40
  401bce:	68fa      	ldr	r2, [r7, #12]
  401bd0:	6013      	str	r3, [r2, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
  401bd2:	68fb      	ldr	r3, [r7, #12]
  401bd4:	f1a3 0314 	sub.w	r3, r3, #20
  401bd8:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
  401bda:	687a      	ldr	r2, [r7, #4]
  401bdc:	68fb      	ldr	r3, [r7, #12]
  401bde:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
  401be0:	68fb      	ldr	r3, [r7, #12]
  401be2:	f1a3 0320 	sub.w	r3, r3, #32
  401be6:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
  401be8:	68fb      	ldr	r3, [r7, #12]
}
  401bea:	4618      	mov	r0, r3
  401bec:	f107 0714 	add.w	r7, r7, #20
  401bf0:	46bd      	mov	sp, r7
  401bf2:	bc80      	pop	{r7}
  401bf4:	4770      	bx	lr
  401bf6:	bf00      	nop

00401bf8 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
  401bf8:	b580      	push	{r7, lr}
  401bfa:	af00      	add	r7, sp, #0
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
  401bfc:	f240 0308 	movw	r3, #8
  401c00:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401c04:	681b      	ldr	r3, [r3, #0]
  401c06:	f1b3 3fff 	cmp.w	r3, #4294967295
  401c0a:	d005      	beq.n	401c18 <prvTaskExitError+0x20>
  401c0c:	f641 6305 	movw	r3, #7685	; 0x1e05
  401c10:	f2c0 0340 	movt	r3, #64	; 0x40
  401c14:	4798      	blx	r3
  401c16:	e7fe      	b.n	401c16 <prvTaskExitError+0x1e>
	portDISABLE_INTERRUPTS();
  401c18:	f641 6305 	movw	r3, #7685	; 0x1e05
  401c1c:	f2c0 0340 	movt	r3, #64	; 0x40
  401c20:	4798      	blx	r3
	for( ;; );
  401c22:	e7fe      	b.n	401c22 <prvTaskExitError+0x2a>

00401c24 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
  401c24:	4b06      	ldr	r3, [pc, #24]	; (401c40 <pxCurrentTCBConst2>)
  401c26:	6819      	ldr	r1, [r3, #0]
  401c28:	6808      	ldr	r0, [r1, #0]
  401c2a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  401c2e:	f380 8809 	msr	PSP, r0
  401c32:	f04f 0000 	mov.w	r0, #0
  401c36:	f380 8811 	msr	BASEPRI, r0
  401c3a:	f04e 0e0d 	orr.w	lr, lr, #13
  401c3e:	4770      	bx	lr

00401c40 <pxCurrentTCBConst2>:
  401c40:	2000a4ec 	.word	0x2000a4ec

00401c44 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
  401c44:	4803      	ldr	r0, [pc, #12]	; (401c54 <prvPortStartFirstTask+0x10>)
  401c46:	6800      	ldr	r0, [r0, #0]
  401c48:	6800      	ldr	r0, [r0, #0]
  401c4a:	f380 8808 	msr	MSP, r0
  401c4e:	b662      	cpsie	i
  401c50:	df00      	svc	0
  401c52:	bf00      	nop
  401c54:	e000ed08 	.word	0xe000ed08

00401c58 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
  401c58:	b580      	push	{r7, lr}
  401c5a:	b084      	sub	sp, #16
  401c5c:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile unsigned long ulOriginalPriority;
		volatile char * const pcFirstUserPriorityRegister = ( volatile char * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
  401c5e:	f44f 4364 	mov.w	r3, #58368	; 0xe400
  401c62:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401c66:	60fb      	str	r3, [r7, #12]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pcFirstUserPriorityRegister;
  401c68:	68fb      	ldr	r3, [r7, #12]
  401c6a:	781b      	ldrb	r3, [r3, #0]
  401c6c:	b2db      	uxtb	r3, r3
  401c6e:	60bb      	str	r3, [r7, #8]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pcFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  401c70:	68fb      	ldr	r3, [r7, #12]
  401c72:	f04f 02ff 	mov.w	r2, #255	; 0xff
  401c76:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pcFirstUserPriorityRegister;
  401c78:	68fb      	ldr	r3, [r7, #12]
  401c7a:	781b      	ldrb	r3, [r3, #0]
  401c7c:	b2db      	uxtb	r3, r3
  401c7e:	71fb      	strb	r3, [r7, #7]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
  401c80:	79fb      	ldrb	r3, [r7, #7]
  401c82:	b2db      	uxtb	r3, r3
  401c84:	f023 035f 	bic.w	r3, r3, #95	; 0x5f
  401c88:	b2da      	uxtb	r2, r3
  401c8a:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  401c8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401c92:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
  401c94:	f24a 43e8 	movw	r3, #42216	; 0xa4e8
  401c98:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401c9c:	f04f 0207 	mov.w	r2, #7
  401ca0:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  401ca2:	e011      	b.n	401cc8 <xPortStartScheduler+0x70>
		{
			ulMaxPRIGROUPValue--;
  401ca4:	f24a 43e8 	movw	r3, #42216	; 0xa4e8
  401ca8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401cac:	681b      	ldr	r3, [r3, #0]
  401cae:	f103 32ff 	add.w	r2, r3, #4294967295
  401cb2:	f24a 43e8 	movw	r3, #42216	; 0xa4e8
  401cb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401cba:	601a      	str	r2, [r3, #0]
			ucMaxPriorityValue <<= ( unsigned char ) 0x01;
  401cbc:	79fb      	ldrb	r3, [r7, #7]
  401cbe:	b2db      	uxtb	r3, r3
  401cc0:	ea4f 0343 	mov.w	r3, r3, lsl #1
  401cc4:	b2db      	uxtb	r3, r3
  401cc6:	71fb      	strb	r3, [r7, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  401cc8:	79fb      	ldrb	r3, [r7, #7]
  401cca:	b2db      	uxtb	r3, r3
  401ccc:	b2db      	uxtb	r3, r3
  401cce:	b25b      	sxtb	r3, r3
  401cd0:	2b00      	cmp	r3, #0
  401cd2:	dbe7      	blt.n	401ca4 <xPortStartScheduler+0x4c>
			ucMaxPriorityValue <<= ( unsigned char ) 0x01;
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
  401cd4:	f24a 43e8 	movw	r3, #42216	; 0xa4e8
  401cd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401cdc:	681b      	ldr	r3, [r3, #0]
  401cde:	ea4f 2203 	mov.w	r2, r3, lsl #8
  401ce2:	f24a 43e8 	movw	r3, #42216	; 0xa4e8
  401ce6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401cea:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
  401cec:	f24a 43e8 	movw	r3, #42216	; 0xa4e8
  401cf0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401cf4:	681b      	ldr	r3, [r3, #0]
  401cf6:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  401cfa:	f24a 43e8 	movw	r3, #42216	; 0xa4e8
  401cfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401d02:	601a      	str	r2, [r3, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pcFirstUserPriorityRegister = ulOriginalPriority;
  401d04:	68bb      	ldr	r3, [r7, #8]
  401d06:	b2da      	uxtb	r2, r3
  401d08:	68fb      	ldr	r3, [r7, #12]
  401d0a:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  401d0c:	f64e 5320 	movw	r3, #60704	; 0xed20
  401d10:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401d14:	f64e 5220 	movw	r2, #60704	; 0xed20
  401d18:	f2ce 0200 	movt	r2, #57344	; 0xe000
  401d1c:	6812      	ldr	r2, [r2, #0]
  401d1e:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
  401d22:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  401d24:	f64e 5320 	movw	r3, #60704	; 0xed20
  401d28:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401d2c:	f64e 5220 	movw	r2, #60704	; 0xed20
  401d30:	f2ce 0200 	movt	r2, #57344	; 0xe000
  401d34:	6812      	ldr	r2, [r2, #0]
  401d36:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
  401d3a:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
  401d3c:	f641 6399 	movw	r3, #7833	; 0x1e99
  401d40:	f2c0 0340 	movt	r3, #64	; 0x40
  401d44:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  401d46:	f240 0308 	movw	r3, #8
  401d4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401d4e:	f04f 0200 	mov.w	r2, #0
  401d52:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
  401d54:	f641 4345 	movw	r3, #7237	; 0x1c45
  401d58:	f2c0 0340 	movt	r3, #64	; 0x40
  401d5c:	4798      	blx	r3

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
  401d5e:	f641 33f9 	movw	r3, #7161	; 0x1bf9
  401d62:	f2c0 0340 	movt	r3, #64	; 0x40
  401d66:	4798      	blx	r3

	/* Should not get here! */
	return 0;
  401d68:	f04f 0300 	mov.w	r3, #0
}
  401d6c:	4618      	mov	r0, r3
  401d6e:	f107 0710 	add.w	r7, r7, #16
  401d72:	46bd      	mov	sp, r7
  401d74:	bd80      	pop	{r7, pc}
  401d76:	bf00      	nop

00401d78 <vPortYield>:
	is nothing to return to.  */
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
  401d78:	b480      	push	{r7}
  401d7a:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  401d7c:	f64e 5304 	movw	r3, #60676	; 0xed04
  401d80:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401d84:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401d88:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
  401d8a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
  401d8e:	f3bf 8f6f 	isb	sy
}
  401d92:	46bd      	mov	sp, r7
  401d94:	bc80      	pop	{r7}
  401d96:	4770      	bx	lr

00401d98 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
  401d98:	b580      	push	{r7, lr}
  401d9a:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
  401d9c:	f641 6305 	movw	r3, #7685	; 0x1e05
  401da0:	f2c0 0340 	movt	r3, #64	; 0x40
  401da4:	4798      	blx	r3
	uxCriticalNesting++;
  401da6:	f240 0308 	movw	r3, #8
  401daa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401dae:	681b      	ldr	r3, [r3, #0]
  401db0:	f103 0201 	add.w	r2, r3, #1
  401db4:	f240 0308 	movw	r3, #8
  401db8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401dbc:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" );
  401dbe:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
  401dc2:	f3bf 8f6f 	isb	sy
}
  401dc6:	bd80      	pop	{r7, pc}

00401dc8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
  401dc8:	b580      	push	{r7, lr}
  401dca:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
  401dcc:	f240 0308 	movw	r3, #8
  401dd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401dd4:	681b      	ldr	r3, [r3, #0]
  401dd6:	f103 32ff 	add.w	r2, r3, #4294967295
  401dda:	f240 0308 	movw	r3, #8
  401dde:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401de2:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
  401de4:	f240 0308 	movw	r3, #8
  401de8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401dec:	681b      	ldr	r3, [r3, #0]
  401dee:	2b00      	cmp	r3, #0
  401df0:	d106      	bne.n	401e00 <vPortExitCritical+0x38>
	{
		portENABLE_INTERRUPTS();
  401df2:	f04f 0000 	mov.w	r0, #0
  401df6:	f641 6319 	movw	r3, #7705	; 0x1e19
  401dfa:	f2c0 0340 	movt	r3, #64	; 0x40
  401dfe:	4798      	blx	r3
	}
}
  401e00:	bd80      	pop	{r7, pc}
  401e02:	bf00      	nop

00401e04 <ulPortSetInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
  401e04:	f3ef 8011 	mrs	r0, BASEPRI
  401e08:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  401e0c:	f381 8811 	msr	BASEPRI, r1
  401e10:	4770      	bx	lr
		:: "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "r0", "r1"	\
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
  401e12:	f04f 0300 	mov.w	r3, #0
}
  401e16:	4618      	mov	r0, r3

00401e18 <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
  401e18:	f380 8811 	msr	BASEPRI, r0
  401e1c:	4770      	bx	lr
  401e1e:	bf00      	nop

00401e20 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
  401e20:	f3ef 8009 	mrs	r0, PSP
  401e24:	4b0c      	ldr	r3, [pc, #48]	; (401e58 <pxCurrentTCBConst>)
  401e26:	681a      	ldr	r2, [r3, #0]
  401e28:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  401e2c:	6010      	str	r0, [r2, #0]
  401e2e:	e92d 4008 	stmdb	sp!, {r3, lr}
  401e32:	f04f 00a0 	mov.w	r0, #160	; 0xa0
  401e36:	f380 8811 	msr	BASEPRI, r0
  401e3a:	f001 fab9 	bl	4033b0 <vTaskSwitchContext>
  401e3e:	f04f 0000 	mov.w	r0, #0
  401e42:	f380 8811 	msr	BASEPRI, r0
  401e46:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  401e4a:	6819      	ldr	r1, [r3, #0]
  401e4c:	6808      	ldr	r0, [r1, #0]
  401e4e:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  401e52:	f380 8809 	msr	PSP, r0
  401e56:	4770      	bx	lr

00401e58 <pxCurrentTCBConst>:
  401e58:	2000a4ec 	.word	0x2000a4ec

00401e5c <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
  401e5c:	b580      	push	{r7, lr}
  401e5e:	af00      	add	r7, sp, #0
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
  401e60:	f641 6305 	movw	r3, #7685	; 0x1e05
  401e64:	f2c0 0340 	movt	r3, #64	; 0x40
  401e68:	4798      	blx	r3
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
  401e6a:	f243 132d 	movw	r3, #12589	; 0x312d
  401e6e:	f2c0 0340 	movt	r3, #64	; 0x40
  401e72:	4798      	blx	r3
  401e74:	4603      	mov	r3, r0
  401e76:	2b00      	cmp	r3, #0
  401e78:	d006      	beq.n	401e88 <SysTick_Handler+0x2c>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  401e7a:	f64e 5304 	movw	r3, #60676	; 0xed04
  401e7e:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401e82:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401e86:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
  401e88:	f04f 0000 	mov.w	r0, #0
  401e8c:	f641 6319 	movw	r3, #7705	; 0x1e19
  401e90:	f2c0 0340 	movt	r3, #64	; 0x40
  401e94:	4798      	blx	r3
}
  401e96:	bd80      	pop	{r7, pc}

00401e98 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
  401e98:	b480      	push	{r7}
  401e9a:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
  401e9c:	f24e 0314 	movw	r3, #57364	; 0xe014
  401ea0:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401ea4:	f240 0204 	movw	r2, #4
  401ea8:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401eac:	6811      	ldr	r1, [r2, #0]
  401eae:	f644 52d3 	movw	r2, #19923	; 0x4dd3
  401eb2:	f2c1 0262 	movt	r2, #4194	; 0x1062
  401eb6:	fba2 0201 	umull	r0, r2, r2, r1
  401eba:	ea4f 1292 	mov.w	r2, r2, lsr #6
  401ebe:	f102 32ff 	add.w	r2, r2, #4294967295
  401ec2:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
  401ec4:	f24e 0310 	movw	r3, #57360	; 0xe010
  401ec8:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401ecc:	f04f 0207 	mov.w	r2, #7
  401ed0:	601a      	str	r2, [r3, #0]
}
  401ed2:	46bd      	mov	sp, r7
  401ed4:	bc80      	pop	{r7}
  401ed6:	4770      	bx	lr

00401ed8 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
  401ed8:	b590      	push	{r4, r7, lr}
  401eda:	b083      	sub	sp, #12
  401edc:	af00      	add	r7, sp, #0
	unsigned long ulCurrentInterrupt;
	unsigned char ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
  401ede:	f3ef 8405 	mrs	r4, IPSR
  401ee2:	607c      	str	r4, [r7, #4]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
  401ee4:	687b      	ldr	r3, [r7, #4]
  401ee6:	2b0f      	cmp	r3, #15
  401ee8:	d916      	bls.n	401f18 <vPortValidateInterruptPriority+0x40>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
  401eea:	f644 23d4 	movw	r3, #19156	; 0x4ad4
  401eee:	f2c0 0340 	movt	r3, #64	; 0x40
  401ef2:	681a      	ldr	r2, [r3, #0]
  401ef4:	687b      	ldr	r3, [r7, #4]
  401ef6:	18d3      	adds	r3, r2, r3
  401ef8:	781b      	ldrb	r3, [r3, #0]
  401efa:	70fb      	strb	r3, [r7, #3]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
  401efc:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  401f00:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401f04:	781b      	ldrb	r3, [r3, #0]
  401f06:	78fa      	ldrb	r2, [r7, #3]
  401f08:	429a      	cmp	r2, r3
  401f0a:	d205      	bcs.n	401f18 <vPortValidateInterruptPriority+0x40>
  401f0c:	f641 6305 	movw	r3, #7685	; 0x1e05
  401f10:	f2c0 0340 	movt	r3, #64	; 0x40
  401f14:	4798      	blx	r3
  401f16:	e7fe      	b.n	401f16 <vPortValidateInterruptPriority+0x3e>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
  401f18:	f64e 530c 	movw	r3, #60684	; 0xed0c
  401f1c:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401f20:	681b      	ldr	r3, [r3, #0]
  401f22:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  401f26:	f24a 43e8 	movw	r3, #42216	; 0xa4e8
  401f2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401f2e:	681b      	ldr	r3, [r3, #0]
  401f30:	429a      	cmp	r2, r3
  401f32:	d905      	bls.n	401f40 <vPortValidateInterruptPriority+0x68>
  401f34:	f641 6305 	movw	r3, #7685	; 0x1e05
  401f38:	f2c0 0340 	movt	r3, #64	; 0x40
  401f3c:	4798      	blx	r3
  401f3e:	e7fe      	b.n	401f3e <vPortValidateInterruptPriority+0x66>
	}
  401f40:	f107 070c 	add.w	r7, r7, #12
  401f44:	46bd      	mov	sp, r7
  401f46:	bd90      	pop	{r4, r7, pc}

00401f48 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
  401f48:	b580      	push	{r7, lr}
  401f4a:	b084      	sub	sp, #16
  401f4c:	af00      	add	r7, sp, #0
  401f4e:	6078      	str	r0, [r7, #4]
  401f50:	6039      	str	r1, [r7, #0]
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  401f52:	687b      	ldr	r3, [r7, #4]
  401f54:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
  401f56:	68fb      	ldr	r3, [r7, #12]
  401f58:	2b00      	cmp	r3, #0
  401f5a:	d105      	bne.n	401f68 <xQueueGenericReset+0x20>
  401f5c:	f641 6305 	movw	r3, #7685	; 0x1e05
  401f60:	f2c0 0340 	movt	r3, #64	; 0x40
  401f64:	4798      	blx	r3
  401f66:	e7fe      	b.n	401f66 <xQueueGenericReset+0x1e>

	taskENTER_CRITICAL();
  401f68:	f641 5399 	movw	r3, #7577	; 0x1d99
  401f6c:	f2c0 0340 	movt	r3, #64	; 0x40
  401f70:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  401f72:	68fb      	ldr	r3, [r7, #12]
  401f74:	681a      	ldr	r2, [r3, #0]
  401f76:	68fb      	ldr	r3, [r7, #12]
  401f78:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  401f7a:	68f9      	ldr	r1, [r7, #12]
  401f7c:	6c09      	ldr	r1, [r1, #64]	; 0x40
  401f7e:	fb01 f303 	mul.w	r3, r1, r3
  401f82:	18d2      	adds	r2, r2, r3
  401f84:	68fb      	ldr	r3, [r7, #12]
  401f86:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  401f88:	68fb      	ldr	r3, [r7, #12]
  401f8a:	f04f 0200 	mov.w	r2, #0
  401f8e:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  401f90:	68fb      	ldr	r3, [r7, #12]
  401f92:	681a      	ldr	r2, [r3, #0]
  401f94:	68fb      	ldr	r3, [r7, #12]
  401f96:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
  401f98:	68fb      	ldr	r3, [r7, #12]
  401f9a:	681a      	ldr	r2, [r3, #0]
  401f9c:	68fb      	ldr	r3, [r7, #12]
  401f9e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  401fa0:	f103 33ff 	add.w	r3, r3, #4294967295
  401fa4:	68f9      	ldr	r1, [r7, #12]
  401fa6:	6c09      	ldr	r1, [r1, #64]	; 0x40
  401fa8:	fb01 f303 	mul.w	r3, r1, r3
  401fac:	18d2      	adds	r2, r2, r3
  401fae:	68fb      	ldr	r3, [r7, #12]
  401fb0:	60da      	str	r2, [r3, #12]
		pxQueue->xRxLock = queueUNLOCKED;
  401fb2:	68fb      	ldr	r3, [r7, #12]
  401fb4:	f04f 32ff 	mov.w	r2, #4294967295
  401fb8:	645a      	str	r2, [r3, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
  401fba:	68fb      	ldr	r3, [r7, #12]
  401fbc:	f04f 32ff 	mov.w	r2, #4294967295
  401fc0:	649a      	str	r2, [r3, #72]	; 0x48

		if( xNewQueue == pdFALSE )
  401fc2:	683b      	ldr	r3, [r7, #0]
  401fc4:	2b00      	cmp	r3, #0
  401fc6:	d115      	bne.n	401ff4 <xQueueGenericReset+0xac>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  401fc8:	68fb      	ldr	r3, [r7, #12]
  401fca:	691b      	ldr	r3, [r3, #16]
  401fcc:	2b00      	cmp	r3, #0
  401fce:	d023      	beq.n	402018 <xQueueGenericReset+0xd0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  401fd0:	68fb      	ldr	r3, [r7, #12]
  401fd2:	f103 0310 	add.w	r3, r3, #16
  401fd6:	4618      	mov	r0, r3
  401fd8:	f243 6395 	movw	r3, #13973	; 0x3695
  401fdc:	f2c0 0340 	movt	r3, #64	; 0x40
  401fe0:	4798      	blx	r3
  401fe2:	4603      	mov	r3, r0
  401fe4:	2b01      	cmp	r3, #1
  401fe6:	d117      	bne.n	402018 <xQueueGenericReset+0xd0>
				{
					queueYIELD_IF_USING_PREEMPTION();
  401fe8:	f641 5379 	movw	r3, #7545	; 0x1d79
  401fec:	f2c0 0340 	movt	r3, #64	; 0x40
  401ff0:	4798      	blx	r3
  401ff2:	e011      	b.n	402018 <xQueueGenericReset+0xd0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  401ff4:	68fb      	ldr	r3, [r7, #12]
  401ff6:	f103 0310 	add.w	r3, r3, #16
  401ffa:	4618      	mov	r0, r3
  401ffc:	f641 2325 	movw	r3, #6693	; 0x1a25
  402000:	f2c0 0340 	movt	r3, #64	; 0x40
  402004:	4798      	blx	r3
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  402006:	68fb      	ldr	r3, [r7, #12]
  402008:	f103 0324 	add.w	r3, r3, #36	; 0x24
  40200c:	4618      	mov	r0, r3
  40200e:	f641 2325 	movw	r3, #6693	; 0x1a25
  402012:	f2c0 0340 	movt	r3, #64	; 0x40
  402016:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
  402018:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  40201c:	f2c0 0340 	movt	r3, #64	; 0x40
  402020:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
  402022:	f04f 0301 	mov.w	r3, #1
}
  402026:	4618      	mov	r0, r3
  402028:	f107 0710 	add.w	r7, r7, #16
  40202c:	46bd      	mov	sp, r7
  40202e:	bd80      	pop	{r7, pc}

00402030 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
  402030:	b580      	push	{r7, lr}
  402032:	b088      	sub	sp, #32
  402034:	af00      	add	r7, sp, #0
  402036:	60f8      	str	r0, [r7, #12]
  402038:	60b9      	str	r1, [r7, #8]
  40203a:	4613      	mov	r3, r2
  40203c:	71fb      	strb	r3, [r7, #7]
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
  40203e:	f04f 0300 	mov.w	r3, #0
  402042:	61fb      	str	r3, [r7, #28]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  402044:	68fb      	ldr	r3, [r7, #12]
  402046:	2b00      	cmp	r3, #0
  402048:	d039      	beq.n	4020be <xQueueGenericCreate+0x8e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  40204a:	f04f 0050 	mov.w	r0, #80	; 0x50
  40204e:	f240 2385 	movw	r3, #645	; 0x285
  402052:	f2c0 0340 	movt	r3, #64	; 0x40
  402056:	4798      	blx	r3
  402058:	61b8      	str	r0, [r7, #24]
		if( pxNewQueue != NULL )
  40205a:	69bb      	ldr	r3, [r7, #24]
  40205c:	2b00      	cmp	r3, #0
  40205e:	d02e      	beq.n	4020be <xQueueGenericCreate+0x8e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  402060:	68fb      	ldr	r3, [r7, #12]
  402062:	68ba      	ldr	r2, [r7, #8]
  402064:	fb02 f303 	mul.w	r3, r2, r3
  402068:	f103 0301 	add.w	r3, r3, #1
  40206c:	617b      	str	r3, [r7, #20]

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  40206e:	6978      	ldr	r0, [r7, #20]
  402070:	f240 2385 	movw	r3, #645	; 0x285
  402074:	f2c0 0340 	movt	r3, #64	; 0x40
  402078:	4798      	blx	r3
  40207a:	4602      	mov	r2, r0
  40207c:	69bb      	ldr	r3, [r7, #24]
  40207e:	601a      	str	r2, [r3, #0]
			if( pxNewQueue->pcHead != NULL )
  402080:	69bb      	ldr	r3, [r7, #24]
  402082:	681b      	ldr	r3, [r3, #0]
  402084:	2b00      	cmp	r3, #0
  402086:	d014      	beq.n	4020b2 <xQueueGenericCreate+0x82>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
  402088:	69bb      	ldr	r3, [r7, #24]
  40208a:	68fa      	ldr	r2, [r7, #12]
  40208c:	63da      	str	r2, [r3, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
  40208e:	69bb      	ldr	r3, [r7, #24]
  402090:	68ba      	ldr	r2, [r7, #8]
  402092:	641a      	str	r2, [r3, #64]	; 0x40
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  402094:	69b8      	ldr	r0, [r7, #24]
  402096:	f04f 0101 	mov.w	r1, #1
  40209a:	f641 7349 	movw	r3, #8009	; 0x1f49
  40209e:	f2c0 0340 	movt	r3, #64	; 0x40
  4020a2:	4798      	blx	r3
				}
				#endif /* configUSE_TRACE_FACILITY */

				#if( configUSE_QUEUE_SETS == 1 )
				{
					pxNewQueue->pxQueueSetContainer = NULL;
  4020a4:	69bb      	ldr	r3, [r7, #24]
  4020a6:	f04f 0200 	mov.w	r2, #0
  4020aa:	64da      	str	r2, [r3, #76]	; 0x4c
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
  4020ac:	69bb      	ldr	r3, [r7, #24]
  4020ae:	61fb      	str	r3, [r7, #28]
  4020b0:	e005      	b.n	4020be <xQueueGenericCreate+0x8e>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
  4020b2:	69b8      	ldr	r0, [r7, #24]
  4020b4:	f240 4305 	movw	r3, #1029	; 0x405
  4020b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4020bc:	4798      	blx	r3
			}
		}
	}

	configASSERT( xReturn );
  4020be:	69fb      	ldr	r3, [r7, #28]
  4020c0:	2b00      	cmp	r3, #0
  4020c2:	d105      	bne.n	4020d0 <xQueueGenericCreate+0xa0>
  4020c4:	f641 6305 	movw	r3, #7685	; 0x1e05
  4020c8:	f2c0 0340 	movt	r3, #64	; 0x40
  4020cc:	4798      	blx	r3
  4020ce:	e7fe      	b.n	4020ce <xQueueGenericCreate+0x9e>

	return xReturn;
  4020d0:	69fb      	ldr	r3, [r7, #28]
}
  4020d2:	4618      	mov	r0, r3
  4020d4:	f107 0720 	add.w	r7, r7, #32
  4020d8:	46bd      	mov	sp, r7
  4020da:	bd80      	pop	{r7, pc}

004020dc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  4020dc:	b580      	push	{r7, lr}
  4020de:	b088      	sub	sp, #32
  4020e0:	af00      	add	r7, sp, #0
  4020e2:	60f8      	str	r0, [r7, #12]
  4020e4:	60b9      	str	r1, [r7, #8]
  4020e6:	607a      	str	r2, [r7, #4]
  4020e8:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  4020ea:	f04f 0300 	mov.w	r3, #0
  4020ee:	61fb      	str	r3, [r7, #28]
xTimeOutType xTimeOut;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  4020f0:	68fb      	ldr	r3, [r7, #12]
  4020f2:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
  4020f4:	69bb      	ldr	r3, [r7, #24]
  4020f6:	2b00      	cmp	r3, #0
  4020f8:	d105      	bne.n	402106 <xQueueGenericSend+0x2a>
  4020fa:	f641 6305 	movw	r3, #7685	; 0x1e05
  4020fe:	f2c0 0340 	movt	r3, #64	; 0x40
  402102:	4798      	blx	r3
  402104:	e7fe      	b.n	402104 <xQueueGenericSend+0x28>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  402106:	68bb      	ldr	r3, [r7, #8]
  402108:	2b00      	cmp	r3, #0
  40210a:	d103      	bne.n	402114 <xQueueGenericSend+0x38>
  40210c:	69bb      	ldr	r3, [r7, #24]
  40210e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402110:	2b00      	cmp	r3, #0
  402112:	d102      	bne.n	40211a <xQueueGenericSend+0x3e>
  402114:	f04f 0301 	mov.w	r3, #1
  402118:	e001      	b.n	40211e <xQueueGenericSend+0x42>
  40211a:	f04f 0300 	mov.w	r3, #0
  40211e:	2b00      	cmp	r3, #0
  402120:	d105      	bne.n	40212e <xQueueGenericSend+0x52>
  402122:	f641 6305 	movw	r3, #7685	; 0x1e05
  402126:	f2c0 0340 	movt	r3, #64	; 0x40
  40212a:	4798      	blx	r3
  40212c:	e7fe      	b.n	40212c <xQueueGenericSend+0x50>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  40212e:	683b      	ldr	r3, [r7, #0]
  402130:	2b02      	cmp	r3, #2
  402132:	d103      	bne.n	40213c <xQueueGenericSend+0x60>
  402134:	69bb      	ldr	r3, [r7, #24]
  402136:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  402138:	2b01      	cmp	r3, #1
  40213a:	d102      	bne.n	402142 <xQueueGenericSend+0x66>
  40213c:	f04f 0301 	mov.w	r3, #1
  402140:	e001      	b.n	402146 <xQueueGenericSend+0x6a>
  402142:	f04f 0300 	mov.w	r3, #0
  402146:	2b00      	cmp	r3, #0
  402148:	d106      	bne.n	402158 <xQueueGenericSend+0x7c>
  40214a:	f641 6305 	movw	r3, #7685	; 0x1e05
  40214e:	f2c0 0340 	movt	r3, #64	; 0x40
  402152:	4798      	blx	r3
  402154:	e7fe      	b.n	402154 <xQueueGenericSend+0x78>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
  402156:	bf00      	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  402158:	f641 5399 	movw	r3, #7577	; 0x1d99
  40215c:	f2c0 0340 	movt	r3, #64	; 0x40
  402160:	4798      	blx	r3
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  402162:	69bb      	ldr	r3, [r7, #24]
  402164:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  402166:	69bb      	ldr	r3, [r7, #24]
  402168:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  40216a:	429a      	cmp	r2, r3
  40216c:	d302      	bcc.n	402174 <xQueueGenericSend+0x98>
  40216e:	683b      	ldr	r3, [r7, #0]
  402170:	2b02      	cmp	r3, #2
  402172:	d138      	bne.n	4021e6 <xQueueGenericSend+0x10a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  402174:	69b8      	ldr	r0, [r7, #24]
  402176:	68b9      	ldr	r1, [r7, #8]
  402178:	683a      	ldr	r2, [r7, #0]
  40217a:	f242 73a9 	movw	r3, #10153	; 0x27a9
  40217e:	f2c0 0340 	movt	r3, #64	; 0x40
  402182:	4798      	blx	r3

				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
  402184:	69bb      	ldr	r3, [r7, #24]
  402186:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  402188:	2b00      	cmp	r3, #0
  40218a:	d00f      	beq.n	4021ac <xQueueGenericSend+0xd0>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
  40218c:	69b8      	ldr	r0, [r7, #24]
  40218e:	6839      	ldr	r1, [r7, #0]
  402190:	f642 23e5 	movw	r3, #10981	; 0x2ae5
  402194:	f2c0 0340 	movt	r3, #64	; 0x40
  402198:	4798      	blx	r3
  40219a:	4603      	mov	r3, r0
  40219c:	2b01      	cmp	r3, #1
  40219e:	d11a      	bne.n	4021d6 <xQueueGenericSend+0xfa>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock. A context switch is required. */
							queueYIELD_IF_USING_PREEMPTION();
  4021a0:	f641 5379 	movw	r3, #7545	; 0x1d79
  4021a4:	f2c0 0340 	movt	r3, #64	; 0x40
  4021a8:	4798      	blx	r3
  4021aa:	e014      	b.n	4021d6 <xQueueGenericSend+0xfa>
					}
					else
					{
						/* If there was a task waiting for data to arrive on the
						queue then unblock it now. */
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4021ac:	69bb      	ldr	r3, [r7, #24]
  4021ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4021b0:	2b00      	cmp	r3, #0
  4021b2:	d010      	beq.n	4021d6 <xQueueGenericSend+0xfa>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
  4021b4:	69bb      	ldr	r3, [r7, #24]
  4021b6:	f103 0324 	add.w	r3, r3, #36	; 0x24
  4021ba:	4618      	mov	r0, r3
  4021bc:	f243 6395 	movw	r3, #13973	; 0x3695
  4021c0:	f2c0 0340 	movt	r3, #64	; 0x40
  4021c4:	4798      	blx	r3
  4021c6:	4603      	mov	r3, r0
  4021c8:	2b01      	cmp	r3, #1
  4021ca:	d104      	bne.n	4021d6 <xQueueGenericSend+0xfa>
							{
								/* The unblocked task has a priority higher than
								our own so yield immediately.  Yes it is ok to
								do this from within the critical section - the
								kernel takes care of that. */
								queueYIELD_IF_USING_PREEMPTION();
  4021cc:	f641 5379 	movw	r3, #7545	; 0x1d79
  4021d0:	f2c0 0340 	movt	r3, #64	; 0x40
  4021d4:	4798      	blx	r3
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
  4021d6:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  4021da:	f2c0 0340 	movt	r3, #64	; 0x40
  4021de:	4798      	blx	r3

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
  4021e0:	f04f 0301 	mov.w	r3, #1
  4021e4:	e08e      	b.n	402304 <xQueueGenericSend+0x228>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  4021e6:	687b      	ldr	r3, [r7, #4]
  4021e8:	2b00      	cmp	r3, #0
  4021ea:	d107      	bne.n	4021fc <xQueueGenericSend+0x120>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  4021ec:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  4021f0:	f2c0 0340 	movt	r3, #64	; 0x40
  4021f4:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  4021f6:	f04f 0300 	mov.w	r3, #0
  4021fa:	e083      	b.n	402304 <xQueueGenericSend+0x228>
				}
				else if( xEntryTimeSet == pdFALSE )
  4021fc:	69fb      	ldr	r3, [r7, #28]
  4021fe:	2b00      	cmp	r3, #0
  402200:	d10a      	bne.n	402218 <xQueueGenericSend+0x13c>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  402202:	f107 0310 	add.w	r3, r7, #16
  402206:	4618      	mov	r0, r3
  402208:	f243 7391 	movw	r3, #14225	; 0x3791
  40220c:	f2c0 0340 	movt	r3, #64	; 0x40
  402210:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  402212:	f04f 0301 	mov.w	r3, #1
  402216:	61fb      	str	r3, [r7, #28]
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
  402218:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  40221c:	f2c0 0340 	movt	r3, #64	; 0x40
  402220:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  402222:	f642 7331 	movw	r3, #12081	; 0x2f31
  402226:	f2c0 0340 	movt	r3, #64	; 0x40
  40222a:	4798      	blx	r3
		prvLockQueue( pxQueue );
  40222c:	f641 5399 	movw	r3, #7577	; 0x1d99
  402230:	f2c0 0340 	movt	r3, #64	; 0x40
  402234:	4798      	blx	r3
  402236:	69bb      	ldr	r3, [r7, #24]
  402238:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  40223a:	f1b3 3fff 	cmp.w	r3, #4294967295
  40223e:	d103      	bne.n	402248 <xQueueGenericSend+0x16c>
  402240:	69bb      	ldr	r3, [r7, #24]
  402242:	f04f 0200 	mov.w	r2, #0
  402246:	645a      	str	r2, [r3, #68]	; 0x44
  402248:	69bb      	ldr	r3, [r7, #24]
  40224a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  40224c:	f1b3 3fff 	cmp.w	r3, #4294967295
  402250:	d103      	bne.n	40225a <xQueueGenericSend+0x17e>
  402252:	69bb      	ldr	r3, [r7, #24]
  402254:	f04f 0200 	mov.w	r2, #0
  402258:	649a      	str	r2, [r3, #72]	; 0x48
  40225a:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  40225e:	f2c0 0340 	movt	r3, #64	; 0x40
  402262:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  402264:	f107 0210 	add.w	r2, r7, #16
  402268:	f107 0304 	add.w	r3, r7, #4
  40226c:	4610      	mov	r0, r2
  40226e:	4619      	mov	r1, r3
  402270:	f243 73d1 	movw	r3, #14289	; 0x37d1
  402274:	f2c0 0340 	movt	r3, #64	; 0x40
  402278:	4798      	blx	r3
  40227a:	4603      	mov	r3, r0
  40227c:	2b00      	cmp	r3, #0
  40227e:	d134      	bne.n	4022ea <xQueueGenericSend+0x20e>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  402280:	69b8      	ldr	r0, [r7, #24]
  402282:	f642 2329 	movw	r3, #10793	; 0x2a29
  402286:	f2c0 0340 	movt	r3, #64	; 0x40
  40228a:	4798      	blx	r3
  40228c:	4603      	mov	r3, r0
  40228e:	2b00      	cmp	r3, #0
  402290:	d01f      	beq.n	4022d2 <xQueueGenericSend+0x1f6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  402292:	69bb      	ldr	r3, [r7, #24]
  402294:	f103 0210 	add.w	r2, r3, #16
  402298:	687b      	ldr	r3, [r7, #4]
  40229a:	4610      	mov	r0, r2
  40229c:	4619      	mov	r1, r3
  40229e:	f243 5311 	movw	r3, #13585	; 0x3511
  4022a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4022a6:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  4022a8:	69b8      	ldr	r0, [r7, #24]
  4022aa:	f642 03ed 	movw	r3, #10477	; 0x28ed
  4022ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4022b2:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  4022b4:	f642 7355 	movw	r3, #12117	; 0x2f55
  4022b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4022bc:	4798      	blx	r3
  4022be:	4603      	mov	r3, r0
  4022c0:	2b00      	cmp	r3, #0
  4022c2:	f47f af48 	bne.w	402156 <xQueueGenericSend+0x7a>
				{
					portYIELD_WITHIN_API();
  4022c6:	f641 5379 	movw	r3, #7545	; 0x1d79
  4022ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4022ce:	4798      	blx	r3
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
  4022d0:	e741      	b.n	402156 <xQueueGenericSend+0x7a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  4022d2:	69b8      	ldr	r0, [r7, #24]
  4022d4:	f642 03ed 	movw	r3, #10477	; 0x28ed
  4022d8:	f2c0 0340 	movt	r3, #64	; 0x40
  4022dc:	4798      	blx	r3
				( void ) xTaskResumeAll();
  4022de:	f642 7355 	movw	r3, #12117	; 0x2f55
  4022e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4022e6:	4798      	blx	r3
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
  4022e8:	e735      	b.n	402156 <xQueueGenericSend+0x7a>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  4022ea:	69b8      	ldr	r0, [r7, #24]
  4022ec:	f642 03ed 	movw	r3, #10477	; 0x28ed
  4022f0:	f2c0 0340 	movt	r3, #64	; 0x40
  4022f4:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4022f6:	f642 7355 	movw	r3, #12117	; 0x2f55
  4022fa:	f2c0 0340 	movt	r3, #64	; 0x40
  4022fe:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  402300:	f04f 0300 	mov.w	r3, #0
		}
	}
}
  402304:	4618      	mov	r0, r3
  402306:	f107 0720 	add.w	r7, r7, #32
  40230a:	46bd      	mov	sp, r7
  40230c:	bd80      	pop	{r7, pc}
  40230e:	bf00      	nop

00402310 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
  402310:	b580      	push	{r7, lr}
  402312:	b088      	sub	sp, #32
  402314:	af00      	add	r7, sp, #0
  402316:	60f8      	str	r0, [r7, #12]
  402318:	60b9      	str	r1, [r7, #8]
  40231a:	607a      	str	r2, [r7, #4]
  40231c:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  40231e:	68fb      	ldr	r3, [r7, #12]
  402320:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
  402322:	69bb      	ldr	r3, [r7, #24]
  402324:	2b00      	cmp	r3, #0
  402326:	d105      	bne.n	402334 <xQueueGenericSendFromISR+0x24>
  402328:	f641 6305 	movw	r3, #7685	; 0x1e05
  40232c:	f2c0 0340 	movt	r3, #64	; 0x40
  402330:	4798      	blx	r3
  402332:	e7fe      	b.n	402332 <xQueueGenericSendFromISR+0x22>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  402334:	68bb      	ldr	r3, [r7, #8]
  402336:	2b00      	cmp	r3, #0
  402338:	d103      	bne.n	402342 <xQueueGenericSendFromISR+0x32>
  40233a:	69bb      	ldr	r3, [r7, #24]
  40233c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40233e:	2b00      	cmp	r3, #0
  402340:	d102      	bne.n	402348 <xQueueGenericSendFromISR+0x38>
  402342:	f04f 0301 	mov.w	r3, #1
  402346:	e001      	b.n	40234c <xQueueGenericSendFromISR+0x3c>
  402348:	f04f 0300 	mov.w	r3, #0
  40234c:	2b00      	cmp	r3, #0
  40234e:	d105      	bne.n	40235c <xQueueGenericSendFromISR+0x4c>
  402350:	f641 6305 	movw	r3, #7685	; 0x1e05
  402354:	f2c0 0340 	movt	r3, #64	; 0x40
  402358:	4798      	blx	r3
  40235a:	e7fe      	b.n	40235a <xQueueGenericSendFromISR+0x4a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  40235c:	683b      	ldr	r3, [r7, #0]
  40235e:	2b02      	cmp	r3, #2
  402360:	d103      	bne.n	40236a <xQueueGenericSendFromISR+0x5a>
  402362:	69bb      	ldr	r3, [r7, #24]
  402364:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  402366:	2b01      	cmp	r3, #1
  402368:	d102      	bne.n	402370 <xQueueGenericSendFromISR+0x60>
  40236a:	f04f 0301 	mov.w	r3, #1
  40236e:	e001      	b.n	402374 <xQueueGenericSendFromISR+0x64>
  402370:	f04f 0300 	mov.w	r3, #0
  402374:	2b00      	cmp	r3, #0
  402376:	d105      	bne.n	402384 <xQueueGenericSendFromISR+0x74>
  402378:	f641 6305 	movw	r3, #7685	; 0x1e05
  40237c:	f2c0 0340 	movt	r3, #64	; 0x40
  402380:	4798      	blx	r3
  402382:	e7fe      	b.n	402382 <xQueueGenericSendFromISR+0x72>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  402384:	f641 63d9 	movw	r3, #7897	; 0x1ed9
  402388:	f2c0 0340 	movt	r3, #64	; 0x40
  40238c:	4798      	blx	r3
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  40238e:	f641 6305 	movw	r3, #7685	; 0x1e05
  402392:	f2c0 0340 	movt	r3, #64	; 0x40
  402396:	4798      	blx	r3
  402398:	6178      	str	r0, [r7, #20]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  40239a:	69bb      	ldr	r3, [r7, #24]
  40239c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40239e:	69bb      	ldr	r3, [r7, #24]
  4023a0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  4023a2:	429a      	cmp	r2, r3
  4023a4:	d302      	bcc.n	4023ac <xQueueGenericSendFromISR+0x9c>
  4023a6:	683b      	ldr	r3, [r7, #0]
  4023a8:	2b02      	cmp	r3, #2
  4023aa:	d144      	bne.n	402436 <xQueueGenericSendFromISR+0x126>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  4023ac:	69b8      	ldr	r0, [r7, #24]
  4023ae:	68b9      	ldr	r1, [r7, #8]
  4023b0:	683a      	ldr	r2, [r7, #0]
  4023b2:	f242 73a9 	movw	r3, #10153	; 0x27a9
  4023b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4023ba:	4798      	blx	r3

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
  4023bc:	69bb      	ldr	r3, [r7, #24]
  4023be:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  4023c0:	f1b3 3fff 	cmp.w	r3, #4294967295
  4023c4:	d12d      	bne.n	402422 <xQueueGenericSendFromISR+0x112>
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
  4023c6:	69bb      	ldr	r3, [r7, #24]
  4023c8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  4023ca:	2b00      	cmp	r3, #0
  4023cc:	d011      	beq.n	4023f2 <xQueueGenericSendFromISR+0xe2>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
  4023ce:	69b8      	ldr	r0, [r7, #24]
  4023d0:	6839      	ldr	r1, [r7, #0]
  4023d2:	f642 23e5 	movw	r3, #10981	; 0x2ae5
  4023d6:	f2c0 0340 	movt	r3, #64	; 0x40
  4023da:	4798      	blx	r3
  4023dc:	4603      	mov	r3, r0
  4023de:	2b01      	cmp	r3, #1
  4023e0:	d125      	bne.n	40242e <xQueueGenericSendFromISR+0x11e>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  4023e2:	687b      	ldr	r3, [r7, #4]
  4023e4:	2b00      	cmp	r3, #0
  4023e6:	d022      	beq.n	40242e <xQueueGenericSendFromISR+0x11e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  4023e8:	687b      	ldr	r3, [r7, #4]
  4023ea:	f04f 0201 	mov.w	r2, #1
  4023ee:	601a      	str	r2, [r3, #0]
  4023f0:	e01d      	b.n	40242e <xQueueGenericSendFromISR+0x11e>
							}
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4023f2:	69bb      	ldr	r3, [r7, #24]
  4023f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4023f6:	2b00      	cmp	r3, #0
  4023f8:	d019      	beq.n	40242e <xQueueGenericSendFromISR+0x11e>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4023fa:	69bb      	ldr	r3, [r7, #24]
  4023fc:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402400:	4618      	mov	r0, r3
  402402:	f243 6395 	movw	r3, #13973	; 0x3695
  402406:	f2c0 0340 	movt	r3, #64	; 0x40
  40240a:	4798      	blx	r3
  40240c:	4603      	mov	r3, r0
  40240e:	2b00      	cmp	r3, #0
  402410:	d00d      	beq.n	40242e <xQueueGenericSendFromISR+0x11e>
							{
								/* The task waiting has a higher priority so record that a
								context	switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
  402412:	687b      	ldr	r3, [r7, #4]
  402414:	2b00      	cmp	r3, #0
  402416:	d00a      	beq.n	40242e <xQueueGenericSendFromISR+0x11e>
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
  402418:	687b      	ldr	r3, [r7, #4]
  40241a:	f04f 0201 	mov.w	r2, #1
  40241e:	601a      	str	r2, [r3, #0]
  402420:	e005      	b.n	40242e <xQueueGenericSendFromISR+0x11e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
  402422:	69bb      	ldr	r3, [r7, #24]
  402424:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  402426:	f103 0201 	add.w	r2, r3, #1
  40242a:	69bb      	ldr	r3, [r7, #24]
  40242c:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
  40242e:	f04f 0301 	mov.w	r3, #1
  402432:	61fb      	str	r3, [r7, #28]
  402434:	e002      	b.n	40243c <xQueueGenericSendFromISR+0x12c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  402436:	f04f 0300 	mov.w	r3, #0
  40243a:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  40243c:	6978      	ldr	r0, [r7, #20]
  40243e:	f641 6319 	movw	r3, #7705	; 0x1e19
  402442:	f2c0 0340 	movt	r3, #64	; 0x40
  402446:	4798      	blx	r3

	return xReturn;
  402448:	69fb      	ldr	r3, [r7, #28]
}
  40244a:	4618      	mov	r0, r3
  40244c:	f107 0720 	add.w	r7, r7, #32
  402450:	46bd      	mov	sp, r7
  402452:	bd80      	pop	{r7, pc}

00402454 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  402454:	b580      	push	{r7, lr}
  402456:	b08a      	sub	sp, #40	; 0x28
  402458:	af00      	add	r7, sp, #0
  40245a:	60f8      	str	r0, [r7, #12]
  40245c:	60b9      	str	r1, [r7, #8]
  40245e:	607a      	str	r2, [r7, #4]
  402460:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  402462:	f04f 0300 	mov.w	r3, #0
  402466:	627b      	str	r3, [r7, #36]	; 0x24
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  402468:	68fb      	ldr	r3, [r7, #12]
  40246a:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
  40246c:	6a3b      	ldr	r3, [r7, #32]
  40246e:	2b00      	cmp	r3, #0
  402470:	d105      	bne.n	40247e <xQueueGenericReceive+0x2a>
  402472:	f641 6305 	movw	r3, #7685	; 0x1e05
  402476:	f2c0 0340 	movt	r3, #64	; 0x40
  40247a:	4798      	blx	r3
  40247c:	e7fe      	b.n	40247c <xQueueGenericReceive+0x28>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  40247e:	68bb      	ldr	r3, [r7, #8]
  402480:	2b00      	cmp	r3, #0
  402482:	d103      	bne.n	40248c <xQueueGenericReceive+0x38>
  402484:	6a3b      	ldr	r3, [r7, #32]
  402486:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402488:	2b00      	cmp	r3, #0
  40248a:	d102      	bne.n	402492 <xQueueGenericReceive+0x3e>
  40248c:	f04f 0301 	mov.w	r3, #1
  402490:	e001      	b.n	402496 <xQueueGenericReceive+0x42>
  402492:	f04f 0300 	mov.w	r3, #0
  402496:	2b00      	cmp	r3, #0
  402498:	d106      	bne.n	4024a8 <xQueueGenericReceive+0x54>
  40249a:	f641 6305 	movw	r3, #7685	; 0x1e05
  40249e:	f2c0 0340 	movt	r3, #64	; 0x40
  4024a2:	4798      	blx	r3
  4024a4:	e7fe      	b.n	4024a4 <xQueueGenericReceive+0x50>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
  4024a6:	bf00      	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  4024a8:	f641 5399 	movw	r3, #7577	; 0x1d99
  4024ac:	f2c0 0340 	movt	r3, #64	; 0x40
  4024b0:	4798      	blx	r3
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  4024b2:	6a3b      	ldr	r3, [r7, #32]
  4024b4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  4024b6:	2b00      	cmp	r3, #0
  4024b8:	d054      	beq.n	402564 <xQueueGenericReceive+0x110>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
  4024ba:	6a3b      	ldr	r3, [r7, #32]
  4024bc:	68db      	ldr	r3, [r3, #12]
  4024be:	61fb      	str	r3, [r7, #28]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  4024c0:	6a38      	ldr	r0, [r7, #32]
  4024c2:	68b9      	ldr	r1, [r7, #8]
  4024c4:	f642 0399 	movw	r3, #10393	; 0x2899
  4024c8:	f2c0 0340 	movt	r3, #64	; 0x40
  4024cc:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
  4024ce:	683b      	ldr	r3, [r7, #0]
  4024d0:	2b00      	cmp	r3, #0
  4024d2:	d127      	bne.n	402524 <xQueueGenericReceive+0xd0>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
  4024d4:	6a3b      	ldr	r3, [r7, #32]
  4024d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  4024d8:	f103 32ff 	add.w	r2, r3, #4294967295
  4024dc:	6a3b      	ldr	r3, [r7, #32]
  4024de:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4024e0:	6a3b      	ldr	r3, [r7, #32]
  4024e2:	681b      	ldr	r3, [r3, #0]
  4024e4:	2b00      	cmp	r3, #0
  4024e6:	d107      	bne.n	4024f8 <xQueueGenericReceive+0xa4>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
  4024e8:	f643 4365 	movw	r3, #15461	; 0x3c65
  4024ec:	f2c0 0340 	movt	r3, #64	; 0x40
  4024f0:	4798      	blx	r3
  4024f2:	4602      	mov	r2, r0
  4024f4:	6a3b      	ldr	r3, [r7, #32]
  4024f6:	605a      	str	r2, [r3, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4024f8:	6a3b      	ldr	r3, [r7, #32]
  4024fa:	691b      	ldr	r3, [r3, #16]
  4024fc:	2b00      	cmp	r3, #0
  4024fe:	d029      	beq.n	402554 <xQueueGenericReceive+0x100>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  402500:	6a3b      	ldr	r3, [r7, #32]
  402502:	f103 0310 	add.w	r3, r3, #16
  402506:	4618      	mov	r0, r3
  402508:	f243 6395 	movw	r3, #13973	; 0x3695
  40250c:	f2c0 0340 	movt	r3, #64	; 0x40
  402510:	4798      	blx	r3
  402512:	4603      	mov	r3, r0
  402514:	2b01      	cmp	r3, #1
  402516:	d11d      	bne.n	402554 <xQueueGenericReceive+0x100>
						{
							queueYIELD_IF_USING_PREEMPTION();
  402518:	f641 5379 	movw	r3, #7545	; 0x1d79
  40251c:	f2c0 0340 	movt	r3, #64	; 0x40
  402520:	4798      	blx	r3
  402522:	e017      	b.n	402554 <xQueueGenericReceive+0x100>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
  402524:	6a3b      	ldr	r3, [r7, #32]
  402526:	69fa      	ldr	r2, [r7, #28]
  402528:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  40252a:	6a3b      	ldr	r3, [r7, #32]
  40252c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40252e:	2b00      	cmp	r3, #0
  402530:	d010      	beq.n	402554 <xQueueGenericReceive+0x100>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  402532:	6a3b      	ldr	r3, [r7, #32]
  402534:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402538:	4618      	mov	r0, r3
  40253a:	f243 6395 	movw	r3, #13973	; 0x3695
  40253e:	f2c0 0340 	movt	r3, #64	; 0x40
  402542:	4798      	blx	r3
  402544:	4603      	mov	r3, r0
  402546:	2b00      	cmp	r3, #0
  402548:	d004      	beq.n	402554 <xQueueGenericReceive+0x100>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
  40254a:	f641 5379 	movw	r3, #7545	; 0x1d79
  40254e:	f2c0 0340 	movt	r3, #64	; 0x40
  402552:	4798      	blx	r3
						}
					}
				}

				taskEXIT_CRITICAL();
  402554:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  402558:	f2c0 0340 	movt	r3, #64	; 0x40
  40255c:	4798      	blx	r3
				return pdPASS;
  40255e:	f04f 0301 	mov.w	r3, #1
  402562:	e0a4      	b.n	4026ae <xQueueGenericReceive+0x25a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  402564:	687b      	ldr	r3, [r7, #4]
  402566:	2b00      	cmp	r3, #0
  402568:	d107      	bne.n	40257a <xQueueGenericReceive+0x126>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  40256a:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  40256e:	f2c0 0340 	movt	r3, #64	; 0x40
  402572:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  402574:	f04f 0300 	mov.w	r3, #0
  402578:	e099      	b.n	4026ae <xQueueGenericReceive+0x25a>
				}
				else if( xEntryTimeSet == pdFALSE )
  40257a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40257c:	2b00      	cmp	r3, #0
  40257e:	d10a      	bne.n	402596 <xQueueGenericReceive+0x142>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  402580:	f107 0314 	add.w	r3, r7, #20
  402584:	4618      	mov	r0, r3
  402586:	f243 7391 	movw	r3, #14225	; 0x3791
  40258a:	f2c0 0340 	movt	r3, #64	; 0x40
  40258e:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  402590:	f04f 0301 	mov.w	r3, #1
  402594:	627b      	str	r3, [r7, #36]	; 0x24
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
  402596:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  40259a:	f2c0 0340 	movt	r3, #64	; 0x40
  40259e:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  4025a0:	f642 7331 	movw	r3, #12081	; 0x2f31
  4025a4:	f2c0 0340 	movt	r3, #64	; 0x40
  4025a8:	4798      	blx	r3
		prvLockQueue( pxQueue );
  4025aa:	f641 5399 	movw	r3, #7577	; 0x1d99
  4025ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4025b2:	4798      	blx	r3
  4025b4:	6a3b      	ldr	r3, [r7, #32]
  4025b6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  4025b8:	f1b3 3fff 	cmp.w	r3, #4294967295
  4025bc:	d103      	bne.n	4025c6 <xQueueGenericReceive+0x172>
  4025be:	6a3b      	ldr	r3, [r7, #32]
  4025c0:	f04f 0200 	mov.w	r2, #0
  4025c4:	645a      	str	r2, [r3, #68]	; 0x44
  4025c6:	6a3b      	ldr	r3, [r7, #32]
  4025c8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  4025ca:	f1b3 3fff 	cmp.w	r3, #4294967295
  4025ce:	d103      	bne.n	4025d8 <xQueueGenericReceive+0x184>
  4025d0:	6a3b      	ldr	r3, [r7, #32]
  4025d2:	f04f 0200 	mov.w	r2, #0
  4025d6:	649a      	str	r2, [r3, #72]	; 0x48
  4025d8:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  4025dc:	f2c0 0340 	movt	r3, #64	; 0x40
  4025e0:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  4025e2:	f107 0214 	add.w	r2, r7, #20
  4025e6:	f107 0304 	add.w	r3, r7, #4
  4025ea:	4610      	mov	r0, r2
  4025ec:	4619      	mov	r1, r3
  4025ee:	f243 73d1 	movw	r3, #14289	; 0x37d1
  4025f2:	f2c0 0340 	movt	r3, #64	; 0x40
  4025f6:	4798      	blx	r3
  4025f8:	4603      	mov	r3, r0
  4025fa:	2b00      	cmp	r3, #0
  4025fc:	d14a      	bne.n	402694 <xQueueGenericReceive+0x240>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  4025fe:	6a38      	ldr	r0, [r7, #32]
  402600:	f642 13e9 	movw	r3, #10729	; 0x29e9
  402604:	f2c0 0340 	movt	r3, #64	; 0x40
  402608:	4798      	blx	r3
  40260a:	4603      	mov	r3, r0
  40260c:	2b00      	cmp	r3, #0
  40260e:	d035      	beq.n	40267c <xQueueGenericReceive+0x228>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  402610:	6a3b      	ldr	r3, [r7, #32]
  402612:	681b      	ldr	r3, [r3, #0]
  402614:	2b00      	cmp	r3, #0
  402616:	d111      	bne.n	40263c <xQueueGenericReceive+0x1e8>
					{
						portENTER_CRITICAL();
  402618:	f641 5399 	movw	r3, #7577	; 0x1d99
  40261c:	f2c0 0340 	movt	r3, #64	; 0x40
  402620:	4798      	blx	r3
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  402622:	6a3b      	ldr	r3, [r7, #32]
  402624:	685b      	ldr	r3, [r3, #4]
  402626:	4618      	mov	r0, r3
  402628:	f643 43cd 	movw	r3, #15565	; 0x3ccd
  40262c:	f2c0 0340 	movt	r3, #64	; 0x40
  402630:	4798      	blx	r3
						}
						portEXIT_CRITICAL();
  402632:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  402636:	f2c0 0340 	movt	r3, #64	; 0x40
  40263a:	4798      	blx	r3
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  40263c:	6a3b      	ldr	r3, [r7, #32]
  40263e:	f103 0224 	add.w	r2, r3, #36	; 0x24
  402642:	687b      	ldr	r3, [r7, #4]
  402644:	4610      	mov	r0, r2
  402646:	4619      	mov	r1, r3
  402648:	f243 5311 	movw	r3, #13585	; 0x3511
  40264c:	f2c0 0340 	movt	r3, #64	; 0x40
  402650:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  402652:	6a38      	ldr	r0, [r7, #32]
  402654:	f642 03ed 	movw	r3, #10477	; 0x28ed
  402658:	f2c0 0340 	movt	r3, #64	; 0x40
  40265c:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  40265e:	f642 7355 	movw	r3, #12117	; 0x2f55
  402662:	f2c0 0340 	movt	r3, #64	; 0x40
  402666:	4798      	blx	r3
  402668:	4603      	mov	r3, r0
  40266a:	2b00      	cmp	r3, #0
  40266c:	f47f af1b 	bne.w	4024a6 <xQueueGenericReceive+0x52>
				{
					portYIELD_WITHIN_API();
  402670:	f641 5379 	movw	r3, #7545	; 0x1d79
  402674:	f2c0 0340 	movt	r3, #64	; 0x40
  402678:	4798      	blx	r3
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
  40267a:	e714      	b.n	4024a6 <xQueueGenericReceive+0x52>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  40267c:	6a38      	ldr	r0, [r7, #32]
  40267e:	f642 03ed 	movw	r3, #10477	; 0x28ed
  402682:	f2c0 0340 	movt	r3, #64	; 0x40
  402686:	4798      	blx	r3
				( void ) xTaskResumeAll();
  402688:	f642 7355 	movw	r3, #12117	; 0x2f55
  40268c:	f2c0 0340 	movt	r3, #64	; 0x40
  402690:	4798      	blx	r3
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
  402692:	e708      	b.n	4024a6 <xQueueGenericReceive+0x52>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  402694:	6a38      	ldr	r0, [r7, #32]
  402696:	f642 03ed 	movw	r3, #10477	; 0x28ed
  40269a:	f2c0 0340 	movt	r3, #64	; 0x40
  40269e:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4026a0:	f642 7355 	movw	r3, #12117	; 0x2f55
  4026a4:	f2c0 0340 	movt	r3, #64	; 0x40
  4026a8:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
  4026aa:	f04f 0300 	mov.w	r3, #0
		}
	}
}
  4026ae:	4618      	mov	r0, r3
  4026b0:	f107 0728 	add.w	r7, r7, #40	; 0x28
  4026b4:	46bd      	mov	sp, r7
  4026b6:	bd80      	pop	{r7, pc}

004026b8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
  4026b8:	b580      	push	{r7, lr}
  4026ba:	b088      	sub	sp, #32
  4026bc:	af00      	add	r7, sp, #0
  4026be:	60f8      	str	r0, [r7, #12]
  4026c0:	60b9      	str	r1, [r7, #8]
  4026c2:	607a      	str	r2, [r7, #4]
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  4026c4:	68fb      	ldr	r3, [r7, #12]
  4026c6:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
  4026c8:	69bb      	ldr	r3, [r7, #24]
  4026ca:	2b00      	cmp	r3, #0
  4026cc:	d105      	bne.n	4026da <xQueueReceiveFromISR+0x22>
  4026ce:	f641 6305 	movw	r3, #7685	; 0x1e05
  4026d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4026d6:	4798      	blx	r3
  4026d8:	e7fe      	b.n	4026d8 <xQueueReceiveFromISR+0x20>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  4026da:	68bb      	ldr	r3, [r7, #8]
  4026dc:	2b00      	cmp	r3, #0
  4026de:	d103      	bne.n	4026e8 <xQueueReceiveFromISR+0x30>
  4026e0:	69bb      	ldr	r3, [r7, #24]
  4026e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4026e4:	2b00      	cmp	r3, #0
  4026e6:	d102      	bne.n	4026ee <xQueueReceiveFromISR+0x36>
  4026e8:	f04f 0301 	mov.w	r3, #1
  4026ec:	e001      	b.n	4026f2 <xQueueReceiveFromISR+0x3a>
  4026ee:	f04f 0300 	mov.w	r3, #0
  4026f2:	2b00      	cmp	r3, #0
  4026f4:	d105      	bne.n	402702 <xQueueReceiveFromISR+0x4a>
  4026f6:	f641 6305 	movw	r3, #7685	; 0x1e05
  4026fa:	f2c0 0340 	movt	r3, #64	; 0x40
  4026fe:	4798      	blx	r3
  402700:	e7fe      	b.n	402700 <xQueueReceiveFromISR+0x48>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  402702:	f641 63d9 	movw	r3, #7897	; 0x1ed9
  402706:	f2c0 0340 	movt	r3, #64	; 0x40
  40270a:	4798      	blx	r3

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  40270c:	f641 6305 	movw	r3, #7685	; 0x1e05
  402710:	f2c0 0340 	movt	r3, #64	; 0x40
  402714:	4798      	blx	r3
  402716:	6178      	str	r0, [r7, #20]
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  402718:	69bb      	ldr	r3, [r7, #24]
  40271a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40271c:	2b00      	cmp	r3, #0
  40271e:	d033      	beq.n	402788 <xQueueReceiveFromISR+0xd0>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
  402720:	69b8      	ldr	r0, [r7, #24]
  402722:	68b9      	ldr	r1, [r7, #8]
  402724:	f642 0399 	movw	r3, #10393	; 0x2899
  402728:	f2c0 0340 	movt	r3, #64	; 0x40
  40272c:	4798      	blx	r3
			--( pxQueue->uxMessagesWaiting );
  40272e:	69bb      	ldr	r3, [r7, #24]
  402730:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  402732:	f103 32ff 	add.w	r2, r3, #4294967295
  402736:	69bb      	ldr	r3, [r7, #24]
  402738:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
  40273a:	69bb      	ldr	r3, [r7, #24]
  40273c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  40273e:	f1b3 3fff 	cmp.w	r3, #4294967295
  402742:	d117      	bne.n	402774 <xQueueReceiveFromISR+0xbc>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  402744:	69bb      	ldr	r3, [r7, #24]
  402746:	691b      	ldr	r3, [r3, #16]
  402748:	2b00      	cmp	r3, #0
  40274a:	d019      	beq.n	402780 <xQueueReceiveFromISR+0xc8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  40274c:	69bb      	ldr	r3, [r7, #24]
  40274e:	f103 0310 	add.w	r3, r3, #16
  402752:	4618      	mov	r0, r3
  402754:	f243 6395 	movw	r3, #13973	; 0x3695
  402758:	f2c0 0340 	movt	r3, #64	; 0x40
  40275c:	4798      	blx	r3
  40275e:	4603      	mov	r3, r0
  402760:	2b00      	cmp	r3, #0
  402762:	d00d      	beq.n	402780 <xQueueReceiveFromISR+0xc8>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
  402764:	687b      	ldr	r3, [r7, #4]
  402766:	2b00      	cmp	r3, #0
  402768:	d00a      	beq.n	402780 <xQueueReceiveFromISR+0xc8>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
  40276a:	687b      	ldr	r3, [r7, #4]
  40276c:	f04f 0201 	mov.w	r2, #1
  402770:	601a      	str	r2, [r3, #0]
  402772:	e005      	b.n	402780 <xQueueReceiveFromISR+0xc8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
  402774:	69bb      	ldr	r3, [r7, #24]
  402776:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  402778:	f103 0201 	add.w	r2, r3, #1
  40277c:	69bb      	ldr	r3, [r7, #24]
  40277e:	645a      	str	r2, [r3, #68]	; 0x44
			}

			xReturn = pdPASS;
  402780:	f04f 0301 	mov.w	r3, #1
  402784:	61fb      	str	r3, [r7, #28]
  402786:	e002      	b.n	40278e <xQueueReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
  402788:	f04f 0300 	mov.w	r3, #0
  40278c:	61fb      	str	r3, [r7, #28]
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  40278e:	6978      	ldr	r0, [r7, #20]
  402790:	f641 6319 	movw	r3, #7705	; 0x1e19
  402794:	f2c0 0340 	movt	r3, #64	; 0x40
  402798:	4798      	blx	r3

	return xReturn;
  40279a:	69fb      	ldr	r3, [r7, #28]
}
  40279c:	4618      	mov	r0, r3
  40279e:	f107 0720 	add.w	r7, r7, #32
  4027a2:	46bd      	mov	sp, r7
  4027a4:	bd80      	pop	{r7, pc}
  4027a6:	bf00      	nop

004027a8 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  4027a8:	b580      	push	{r7, lr}
  4027aa:	b084      	sub	sp, #16
  4027ac:	af00      	add	r7, sp, #0
  4027ae:	60f8      	str	r0, [r7, #12]
  4027b0:	60b9      	str	r1, [r7, #8]
  4027b2:	607a      	str	r2, [r7, #4]
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  4027b4:	68fb      	ldr	r3, [r7, #12]
  4027b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4027b8:	2b00      	cmp	r3, #0
  4027ba:	d110      	bne.n	4027de <prvCopyDataToQueue+0x36>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4027bc:	68fb      	ldr	r3, [r7, #12]
  4027be:	681b      	ldr	r3, [r3, #0]
  4027c0:	2b00      	cmp	r3, #0
  4027c2:	d15e      	bne.n	402882 <prvCopyDataToQueue+0xda>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  4027c4:	68fb      	ldr	r3, [r7, #12]
  4027c6:	685b      	ldr	r3, [r3, #4]
  4027c8:	4618      	mov	r0, r3
  4027ca:	f643 6315 	movw	r3, #15893	; 0x3e15
  4027ce:	f2c0 0340 	movt	r3, #64	; 0x40
  4027d2:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  4027d4:	68fb      	ldr	r3, [r7, #12]
  4027d6:	f04f 0200 	mov.w	r2, #0
  4027da:	605a      	str	r2, [r3, #4]
  4027dc:	e051      	b.n	402882 <prvCopyDataToQueue+0xda>
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
  4027de:	687b      	ldr	r3, [r7, #4]
  4027e0:	2b00      	cmp	r3, #0
  4027e2:	d11d      	bne.n	402820 <prvCopyDataToQueue+0x78>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
  4027e4:	68fb      	ldr	r3, [r7, #12]
  4027e6:	689a      	ldr	r2, [r3, #8]
  4027e8:	68fb      	ldr	r3, [r7, #12]
  4027ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4027ec:	4610      	mov	r0, r2
  4027ee:	68b9      	ldr	r1, [r7, #8]
  4027f0:	461a      	mov	r2, r3
  4027f2:	f644 238b 	movw	r3, #19083	; 0x4a8b
  4027f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4027fa:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  4027fc:	68fb      	ldr	r3, [r7, #12]
  4027fe:	689a      	ldr	r2, [r3, #8]
  402800:	68fb      	ldr	r3, [r7, #12]
  402802:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402804:	18d2      	adds	r2, r2, r3
  402806:	68fb      	ldr	r3, [r7, #12]
  402808:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  40280a:	68fb      	ldr	r3, [r7, #12]
  40280c:	689a      	ldr	r2, [r3, #8]
  40280e:	68fb      	ldr	r3, [r7, #12]
  402810:	685b      	ldr	r3, [r3, #4]
  402812:	429a      	cmp	r2, r3
  402814:	d335      	bcc.n	402882 <prvCopyDataToQueue+0xda>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  402816:	68fb      	ldr	r3, [r7, #12]
  402818:	681a      	ldr	r2, [r3, #0]
  40281a:	68fb      	ldr	r3, [r7, #12]
  40281c:	609a      	str	r2, [r3, #8]
  40281e:	e030      	b.n	402882 <prvCopyDataToQueue+0xda>
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  402820:	68fb      	ldr	r3, [r7, #12]
  402822:	68da      	ldr	r2, [r3, #12]
  402824:	68fb      	ldr	r3, [r7, #12]
  402826:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402828:	4610      	mov	r0, r2
  40282a:	68b9      	ldr	r1, [r7, #8]
  40282c:	461a      	mov	r2, r3
  40282e:	f644 238b 	movw	r3, #19083	; 0x4a8b
  402832:	f2c0 0340 	movt	r3, #64	; 0x40
  402836:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
  402838:	68fb      	ldr	r3, [r7, #12]
  40283a:	68da      	ldr	r2, [r3, #12]
  40283c:	68fb      	ldr	r3, [r7, #12]
  40283e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402840:	f1c3 0300 	rsb	r3, r3, #0
  402844:	18d2      	adds	r2, r2, r3
  402846:	68fb      	ldr	r3, [r7, #12]
  402848:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  40284a:	68fb      	ldr	r3, [r7, #12]
  40284c:	68da      	ldr	r2, [r3, #12]
  40284e:	68fb      	ldr	r3, [r7, #12]
  402850:	681b      	ldr	r3, [r3, #0]
  402852:	429a      	cmp	r2, r3
  402854:	d208      	bcs.n	402868 <prvCopyDataToQueue+0xc0>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  402856:	68fb      	ldr	r3, [r7, #12]
  402858:	685a      	ldr	r2, [r3, #4]
  40285a:	68fb      	ldr	r3, [r7, #12]
  40285c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40285e:	f1c3 0300 	rsb	r3, r3, #0
  402862:	18d2      	adds	r2, r2, r3
  402864:	68fb      	ldr	r3, [r7, #12]
  402866:	60da      	str	r2, [r3, #12]
		}

		if( xPosition == queueOVERWRITE )
  402868:	687b      	ldr	r3, [r7, #4]
  40286a:	2b02      	cmp	r3, #2
  40286c:	d109      	bne.n	402882 <prvCopyDataToQueue+0xda>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  40286e:	68fb      	ldr	r3, [r7, #12]
  402870:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  402872:	2b00      	cmp	r3, #0
  402874:	d005      	beq.n	402882 <prvCopyDataToQueue+0xda>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
  402876:	68fb      	ldr	r3, [r7, #12]
  402878:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40287a:	f103 32ff 	add.w	r2, r3, #4294967295
  40287e:	68fb      	ldr	r3, [r7, #12]
  402880:	639a      	str	r2, [r3, #56]	; 0x38
			}
		}
	}

	++( pxQueue->uxMessagesWaiting );
  402882:	68fb      	ldr	r3, [r7, #12]
  402884:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  402886:	f103 0201 	add.w	r2, r3, #1
  40288a:	68fb      	ldr	r3, [r7, #12]
  40288c:	639a      	str	r2, [r3, #56]	; 0x38
}
  40288e:	f107 0710 	add.w	r7, r7, #16
  402892:	46bd      	mov	sp, r7
  402894:	bd80      	pop	{r7, pc}
  402896:	bf00      	nop

00402898 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
{
  402898:	b580      	push	{r7, lr}
  40289a:	b082      	sub	sp, #8
  40289c:	af00      	add	r7, sp, #0
  40289e:	6078      	str	r0, [r7, #4]
  4028a0:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  4028a2:	687b      	ldr	r3, [r7, #4]
  4028a4:	681b      	ldr	r3, [r3, #0]
  4028a6:	2b00      	cmp	r3, #0
  4028a8:	d01c      	beq.n	4028e4 <prvCopyDataFromQueue+0x4c>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
  4028aa:	687b      	ldr	r3, [r7, #4]
  4028ac:	68da      	ldr	r2, [r3, #12]
  4028ae:	687b      	ldr	r3, [r7, #4]
  4028b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4028b2:	18d2      	adds	r2, r2, r3
  4028b4:	687b      	ldr	r3, [r7, #4]
  4028b6:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  4028b8:	687b      	ldr	r3, [r7, #4]
  4028ba:	68da      	ldr	r2, [r3, #12]
  4028bc:	687b      	ldr	r3, [r7, #4]
  4028be:	685b      	ldr	r3, [r3, #4]
  4028c0:	429a      	cmp	r2, r3
  4028c2:	d303      	bcc.n	4028cc <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
  4028c4:	687b      	ldr	r3, [r7, #4]
  4028c6:	681a      	ldr	r2, [r3, #0]
  4028c8:	687b      	ldr	r3, [r7, #4]
  4028ca:	60da      	str	r2, [r3, #12]
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
  4028cc:	687b      	ldr	r3, [r7, #4]
  4028ce:	68da      	ldr	r2, [r3, #12]
  4028d0:	687b      	ldr	r3, [r7, #4]
  4028d2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4028d4:	6838      	ldr	r0, [r7, #0]
  4028d6:	4611      	mov	r1, r2
  4028d8:	461a      	mov	r2, r3
  4028da:	f644 238b 	movw	r3, #19083	; 0x4a8b
  4028de:	f2c0 0340 	movt	r3, #64	; 0x40
  4028e2:	4798      	blx	r3
	}
}
  4028e4:	f107 0708 	add.w	r7, r7, #8
  4028e8:	46bd      	mov	sp, r7
  4028ea:	bd80      	pop	{r7, pc}

004028ec <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
  4028ec:	b580      	push	{r7, lr}
  4028ee:	b082      	sub	sp, #8
  4028f0:	af00      	add	r7, sp, #0
  4028f2:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  4028f4:	f641 5399 	movw	r3, #7577	; 0x1d99
  4028f8:	f2c0 0340 	movt	r3, #64	; 0x40
  4028fc:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  4028fe:	e02f      	b.n	402960 <prvUnlockQueue+0x74>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			#if ( configUSE_QUEUE_SETS == 1 )
			{
				if( pxQueue->pxQueueSetContainer != NULL )
  402900:	687b      	ldr	r3, [r7, #4]
  402902:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  402904:	2b00      	cmp	r3, #0
  402906:	d010      	beq.n	40292a <prvUnlockQueue+0x3e>
				{
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
  402908:	6878      	ldr	r0, [r7, #4]
  40290a:	f04f 0100 	mov.w	r1, #0
  40290e:	f642 23e5 	movw	r3, #10981	; 0x2ae5
  402912:	f2c0 0340 	movt	r3, #64	; 0x40
  402916:	4798      	blx	r3
  402918:	4603      	mov	r3, r0
  40291a:	2b01      	cmp	r3, #1
  40291c:	d11a      	bne.n	402954 <prvUnlockQueue+0x68>
					{
						/* The queue is a member of a queue set, and posting to
						the queue set caused a higher priority task to unblock.
						A context switch is required. */
						vTaskMissedYield();
  40291e:	f643 039d 	movw	r3, #14493	; 0x389d
  402922:	f2c0 0340 	movt	r3, #64	; 0x40
  402926:	4798      	blx	r3
  402928:	e014      	b.n	402954 <prvUnlockQueue+0x68>
				}
				else
				{
					/* Tasks that are removed from the event list will get added to
					the pending ready list as the scheduler is still suspended. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  40292a:	687b      	ldr	r3, [r7, #4]
  40292c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40292e:	2b00      	cmp	r3, #0
  402930:	d01b      	beq.n	40296a <prvUnlockQueue+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  402932:	687b      	ldr	r3, [r7, #4]
  402934:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402938:	4618      	mov	r0, r3
  40293a:	f243 6395 	movw	r3, #13973	; 0x3695
  40293e:	f2c0 0340 	movt	r3, #64	; 0x40
  402942:	4798      	blx	r3
  402944:	4603      	mov	r3, r0
  402946:	2b00      	cmp	r3, #0
  402948:	d004      	beq.n	402954 <prvUnlockQueue+0x68>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							vTaskMissedYield();
  40294a:	f643 039d 	movw	r3, #14493	; 0x389d
  40294e:	f2c0 0340 	movt	r3, #64	; 0x40
  402952:	4798      	blx	r3
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
  402954:	687b      	ldr	r3, [r7, #4]
  402956:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  402958:	f103 32ff 	add.w	r2, r3, #4294967295
  40295c:	687b      	ldr	r3, [r7, #4]
  40295e:	649a      	str	r2, [r3, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  402960:	687b      	ldr	r3, [r7, #4]
  402962:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  402964:	2b00      	cmp	r3, #0
  402966:	dccb      	bgt.n	402900 <prvUnlockQueue+0x14>
  402968:	e000      	b.n	40296c <prvUnlockQueue+0x80>
							vTaskMissedYield();
						}
					}
					else
					{
						break;
  40296a:	bf00      	nop
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
  40296c:	687b      	ldr	r3, [r7, #4]
  40296e:	f04f 32ff 	mov.w	r2, #4294967295
  402972:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
  402974:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  402978:	f2c0 0340 	movt	r3, #64	; 0x40
  40297c:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  40297e:	f641 5399 	movw	r3, #7577	; 0x1d99
  402982:	f2c0 0340 	movt	r3, #64	; 0x40
  402986:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  402988:	e01a      	b.n	4029c0 <prvUnlockQueue+0xd4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  40298a:	687b      	ldr	r3, [r7, #4]
  40298c:	691b      	ldr	r3, [r3, #16]
  40298e:	2b00      	cmp	r3, #0
  402990:	d01b      	beq.n	4029ca <prvUnlockQueue+0xde>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  402992:	687b      	ldr	r3, [r7, #4]
  402994:	f103 0310 	add.w	r3, r3, #16
  402998:	4618      	mov	r0, r3
  40299a:	f243 6395 	movw	r3, #13973	; 0x3695
  40299e:	f2c0 0340 	movt	r3, #64	; 0x40
  4029a2:	4798      	blx	r3
  4029a4:	4603      	mov	r3, r0
  4029a6:	2b00      	cmp	r3, #0
  4029a8:	d004      	beq.n	4029b4 <prvUnlockQueue+0xc8>
				{
					vTaskMissedYield();
  4029aa:	f643 039d 	movw	r3, #14493	; 0x389d
  4029ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4029b2:	4798      	blx	r3
				}

				--( pxQueue->xRxLock );
  4029b4:	687b      	ldr	r3, [r7, #4]
  4029b6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  4029b8:	f103 32ff 	add.w	r2, r3, #4294967295
  4029bc:	687b      	ldr	r3, [r7, #4]
  4029be:	645a      	str	r2, [r3, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4029c0:	687b      	ldr	r3, [r7, #4]
  4029c2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  4029c4:	2b00      	cmp	r3, #0
  4029c6:	dce0      	bgt.n	40298a <prvUnlockQueue+0x9e>
  4029c8:	e000      	b.n	4029cc <prvUnlockQueue+0xe0>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
  4029ca:	bf00      	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
  4029cc:	687b      	ldr	r3, [r7, #4]
  4029ce:	f04f 32ff 	mov.w	r2, #4294967295
  4029d2:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  4029d4:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  4029d8:	f2c0 0340 	movt	r3, #64	; 0x40
  4029dc:	4798      	blx	r3
}
  4029de:	f107 0708 	add.w	r7, r7, #8
  4029e2:	46bd      	mov	sp, r7
  4029e4:	bd80      	pop	{r7, pc}
  4029e6:	bf00      	nop

004029e8 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
  4029e8:	b580      	push	{r7, lr}
  4029ea:	b084      	sub	sp, #16
  4029ec:	af00      	add	r7, sp, #0
  4029ee:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  4029f0:	f641 5399 	movw	r3, #7577	; 0x1d99
  4029f4:	f2c0 0340 	movt	r3, #64	; 0x40
  4029f8:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
  4029fa:	687b      	ldr	r3, [r7, #4]
  4029fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  4029fe:	2b00      	cmp	r3, #0
  402a00:	d103      	bne.n	402a0a <prvIsQueueEmpty+0x22>
		{
			xReturn = pdTRUE;
  402a02:	f04f 0301 	mov.w	r3, #1
  402a06:	60fb      	str	r3, [r7, #12]
  402a08:	e002      	b.n	402a10 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
  402a0a:	f04f 0300 	mov.w	r3, #0
  402a0e:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  402a10:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  402a14:	f2c0 0340 	movt	r3, #64	; 0x40
  402a18:	4798      	blx	r3

	return xReturn;
  402a1a:	68fb      	ldr	r3, [r7, #12]
}
  402a1c:	4618      	mov	r0, r3
  402a1e:	f107 0710 	add.w	r7, r7, #16
  402a22:	46bd      	mov	sp, r7
  402a24:	bd80      	pop	{r7, pc}
  402a26:	bf00      	nop

00402a28 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
  402a28:	b580      	push	{r7, lr}
  402a2a:	b084      	sub	sp, #16
  402a2c:	af00      	add	r7, sp, #0
  402a2e:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  402a30:	f641 5399 	movw	r3, #7577	; 0x1d99
  402a34:	f2c0 0340 	movt	r3, #64	; 0x40
  402a38:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  402a3a:	687b      	ldr	r3, [r7, #4]
  402a3c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  402a3e:	687b      	ldr	r3, [r7, #4]
  402a40:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  402a42:	429a      	cmp	r2, r3
  402a44:	d103      	bne.n	402a4e <prvIsQueueFull+0x26>
		{
			xReturn = pdTRUE;
  402a46:	f04f 0301 	mov.w	r3, #1
  402a4a:	60fb      	str	r3, [r7, #12]
  402a4c:	e002      	b.n	402a54 <prvIsQueueFull+0x2c>
		}
		else
		{
			xReturn = pdFALSE;
  402a4e:	f04f 0300 	mov.w	r3, #0
  402a52:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  402a54:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  402a58:	f2c0 0340 	movt	r3, #64	; 0x40
  402a5c:	4798      	blx	r3

	return xReturn;
  402a5e:	68fb      	ldr	r3, [r7, #12]
}
  402a60:	4618      	mov	r0, r3
  402a62:	f107 0710 	add.w	r7, r7, #16
  402a66:	46bd      	mov	sp, r7
  402a68:	bd80      	pop	{r7, pc}
  402a6a:	bf00      	nop

00402a6c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
	{
  402a6c:	b580      	push	{r7, lr}
  402a6e:	b084      	sub	sp, #16
  402a70:	af00      	add	r7, sp, #0
  402a72:	6078      	str	r0, [r7, #4]
  402a74:	6039      	str	r1, [r7, #0]
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  402a76:	687b      	ldr	r3, [r7, #4]
  402a78:	60fb      	str	r3, [r7, #12]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
  402a7a:	f641 5399 	movw	r3, #7577	; 0x1d99
  402a7e:	f2c0 0340 	movt	r3, #64	; 0x40
  402a82:	4798      	blx	r3
  402a84:	68fb      	ldr	r3, [r7, #12]
  402a86:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  402a88:	f1b3 3fff 	cmp.w	r3, #4294967295
  402a8c:	d103      	bne.n	402a96 <vQueueWaitForMessageRestricted+0x2a>
  402a8e:	68fb      	ldr	r3, [r7, #12]
  402a90:	f04f 0200 	mov.w	r2, #0
  402a94:	645a      	str	r2, [r3, #68]	; 0x44
  402a96:	68fb      	ldr	r3, [r7, #12]
  402a98:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  402a9a:	f1b3 3fff 	cmp.w	r3, #4294967295
  402a9e:	d103      	bne.n	402aa8 <vQueueWaitForMessageRestricted+0x3c>
  402aa0:	68fb      	ldr	r3, [r7, #12]
  402aa2:	f04f 0200 	mov.w	r2, #0
  402aa6:	649a      	str	r2, [r3, #72]	; 0x48
  402aa8:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  402aac:	f2c0 0340 	movt	r3, #64	; 0x40
  402ab0:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
  402ab2:	68fb      	ldr	r3, [r7, #12]
  402ab4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  402ab6:	2b00      	cmp	r3, #0
  402ab8:	d109      	bne.n	402ace <vQueueWaitForMessageRestricted+0x62>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  402aba:	68fb      	ldr	r3, [r7, #12]
  402abc:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402ac0:	4618      	mov	r0, r3
  402ac2:	6839      	ldr	r1, [r7, #0]
  402ac4:	f243 53e9 	movw	r3, #13801	; 0x35e9
  402ac8:	f2c0 0340 	movt	r3, #64	; 0x40
  402acc:	4798      	blx	r3
		}
		prvUnlockQueue( pxQueue );
  402ace:	68f8      	ldr	r0, [r7, #12]
  402ad0:	f642 03ed 	movw	r3, #10477	; 0x28ed
  402ad4:	f2c0 0340 	movt	r3, #64	; 0x40
  402ad8:	4798      	blx	r3
	}
  402ada:	f107 0710 	add.w	r7, r7, #16
  402ade:	46bd      	mov	sp, r7
  402ae0:	bd80      	pop	{r7, pc}
  402ae2:	bf00      	nop

00402ae4 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static portBASE_TYPE prvNotifyQueueSetContainer( const xQUEUE * const pxQueue, portBASE_TYPE xCopyPosition )
	{
  402ae4:	b580      	push	{r7, lr}
  402ae6:	b084      	sub	sp, #16
  402ae8:	af00      	add	r7, sp, #0
  402aea:	6078      	str	r0, [r7, #4]
  402aec:	6039      	str	r1, [r7, #0]
	xQUEUE *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
  402aee:	687b      	ldr	r3, [r7, #4]
  402af0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  402af2:	60bb      	str	r3, [r7, #8]
	portBASE_TYPE xReturn = pdFALSE;
  402af4:	f04f 0300 	mov.w	r3, #0
  402af8:	60fb      	str	r3, [r7, #12]

		configASSERT( pxQueueSetContainer );
  402afa:	68bb      	ldr	r3, [r7, #8]
  402afc:	2b00      	cmp	r3, #0
  402afe:	d105      	bne.n	402b0c <prvNotifyQueueSetContainer+0x28>
  402b00:	f641 6305 	movw	r3, #7685	; 0x1e05
  402b04:	f2c0 0340 	movt	r3, #64	; 0x40
  402b08:	4798      	blx	r3
  402b0a:	e7fe      	b.n	402b0a <prvNotifyQueueSetContainer+0x26>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
  402b0c:	68bb      	ldr	r3, [r7, #8]
  402b0e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  402b10:	68bb      	ldr	r3, [r7, #8]
  402b12:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  402b14:	429a      	cmp	r2, r3
  402b16:	d305      	bcc.n	402b24 <prvNotifyQueueSetContainer+0x40>
  402b18:	f641 6305 	movw	r3, #7685	; 0x1e05
  402b1c:	f2c0 0340 	movt	r3, #64	; 0x40
  402b20:	4798      	blx	r3
  402b22:	e7fe      	b.n	402b22 <prvNotifyQueueSetContainer+0x3e>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
  402b24:	68bb      	ldr	r3, [r7, #8]
  402b26:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  402b28:	68bb      	ldr	r3, [r7, #8]
  402b2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  402b2c:	429a      	cmp	r2, r3
  402b2e:	d21c      	bcs.n	402b6a <prvNotifyQueueSetContainer+0x86>
		{
			traceQUEUE_SEND( pxQueueSetContainer );
			/* The data copies is the handle of the queue that contains data. */
			prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
  402b30:	f107 0304 	add.w	r3, r7, #4
  402b34:	68b8      	ldr	r0, [r7, #8]
  402b36:	4619      	mov	r1, r3
  402b38:	683a      	ldr	r2, [r7, #0]
  402b3a:	f242 73a9 	movw	r3, #10153	; 0x27a9
  402b3e:	f2c0 0340 	movt	r3, #64	; 0x40
  402b42:	4798      	blx	r3
			if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
  402b44:	68bb      	ldr	r3, [r7, #8]
  402b46:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  402b48:	2b00      	cmp	r3, #0
  402b4a:	d00e      	beq.n	402b6a <prvNotifyQueueSetContainer+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
  402b4c:	68bb      	ldr	r3, [r7, #8]
  402b4e:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402b52:	4618      	mov	r0, r3
  402b54:	f243 6395 	movw	r3, #13973	; 0x3695
  402b58:	f2c0 0340 	movt	r3, #64	; 0x40
  402b5c:	4798      	blx	r3
  402b5e:	4603      	mov	r3, r0
  402b60:	2b00      	cmp	r3, #0
  402b62:	d002      	beq.n	402b6a <prvNotifyQueueSetContainer+0x86>
				{
					/* The task waiting has a higher priority */
					xReturn = pdTRUE;
  402b64:	f04f 0301 	mov.w	r3, #1
  402b68:	60fb      	str	r3, [r7, #12]
				}
			}
		}

		return xReturn;
  402b6a:	68fb      	ldr	r3, [r7, #12]
	}
  402b6c:	4618      	mov	r0, r3
  402b6e:	f107 0710 	add.w	r7, r7, #16
  402b72:	46bd      	mov	sp, r7
  402b74:	bd80      	pop	{r7, pc}
  402b76:	bf00      	nop

00402b78 <xTaskGenericCreate>:
	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
  402b78:	b590      	push	{r4, r7, lr}
  402b7a:	b08b      	sub	sp, #44	; 0x2c
  402b7c:	af02      	add	r7, sp, #8
  402b7e:	60f8      	str	r0, [r7, #12]
  402b80:	60b9      	str	r1, [r7, #8]
  402b82:	603b      	str	r3, [r7, #0]
  402b84:	4613      	mov	r3, r2
  402b86:	80fb      	strh	r3, [r7, #6]
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
  402b88:	68fb      	ldr	r3, [r7, #12]
  402b8a:	2b00      	cmp	r3, #0
  402b8c:	d105      	bne.n	402b9a <xTaskGenericCreate+0x22>
  402b8e:	f641 6305 	movw	r3, #7685	; 0x1e05
  402b92:	f2c0 0340 	movt	r3, #64	; 0x40
  402b96:	4798      	blx	r3
  402b98:	e7fe      	b.n	402b98 <xTaskGenericCreate+0x20>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
  402b9a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  402b9c:	2b04      	cmp	r3, #4
  402b9e:	d905      	bls.n	402bac <xTaskGenericCreate+0x34>
  402ba0:	f641 6305 	movw	r3, #7685	; 0x1e05
  402ba4:	f2c0 0340 	movt	r3, #64	; 0x40
  402ba8:	4798      	blx	r3
  402baa:	e7fe      	b.n	402baa <xTaskGenericCreate+0x32>

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
  402bac:	88fb      	ldrh	r3, [r7, #6]
  402bae:	4618      	mov	r0, r3
  402bb0:	6bb9      	ldr	r1, [r7, #56]	; 0x38
  402bb2:	f643 33b1 	movw	r3, #15281	; 0x3bb1
  402bb6:	f2c0 0340 	movt	r3, #64	; 0x40
  402bba:	4798      	blx	r3
  402bbc:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
  402bbe:	69bb      	ldr	r3, [r7, #24]
  402bc0:	2b00      	cmp	r3, #0
  402bc2:	f000 80b2 	beq.w	402d2a <xTaskGenericCreate+0x1b2>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
  402bc6:	69bb      	ldr	r3, [r7, #24]
  402bc8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  402bca:	88fb      	ldrh	r3, [r7, #6]
  402bcc:	f103 33ff 	add.w	r3, r3, #4294967295
  402bd0:	ea4f 0383 	mov.w	r3, r3, lsl #2
  402bd4:	18d3      	adds	r3, r2, r3
  402bd6:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
  402bd8:	697b      	ldr	r3, [r7, #20]
  402bda:	f023 0307 	bic.w	r3, r3, #7
  402bde:	617b      	str	r3, [r7, #20]

			/* Check the alignment of the calculated top of stack is correct. */
			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
  402be0:	697b      	ldr	r3, [r7, #20]
  402be2:	f003 0307 	and.w	r3, r3, #7
  402be6:	2b00      	cmp	r3, #0
  402be8:	d005      	beq.n	402bf6 <xTaskGenericCreate+0x7e>
  402bea:	f641 6305 	movw	r3, #7685	; 0x1e05
  402bee:	f2c0 0340 	movt	r3, #64	; 0x40
  402bf2:	4798      	blx	r3
  402bf4:	e7fe      	b.n	402bf4 <xTaskGenericCreate+0x7c>
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
  402bf6:	88fb      	ldrh	r3, [r7, #6]
  402bf8:	9300      	str	r3, [sp, #0]
  402bfa:	69b8      	ldr	r0, [r7, #24]
  402bfc:	68b9      	ldr	r1, [r7, #8]
  402bfe:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  402c00:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  402c02:	f643 04e5 	movw	r4, #14565	; 0x38e5
  402c06:	f2c0 0440 	movt	r4, #64	; 0x40
  402c0a:	47a0      	blx	r4
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  402c0c:	6978      	ldr	r0, [r7, #20]
  402c0e:	68f9      	ldr	r1, [r7, #12]
  402c10:	683a      	ldr	r2, [r7, #0]
  402c12:	f641 3395 	movw	r3, #7061	; 0x1b95
  402c16:	f2c0 0340 	movt	r3, #64	; 0x40
  402c1a:	4798      	blx	r3
  402c1c:	4602      	mov	r2, r0
  402c1e:	69bb      	ldr	r3, [r7, #24]
  402c20:	601a      	str	r2, [r3, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
  402c22:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  402c24:	2b00      	cmp	r3, #0
  402c26:	d002      	beq.n	402c2e <xTaskGenericCreate+0xb6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
  402c28:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  402c2a:	69ba      	ldr	r2, [r7, #24]
  402c2c:	601a      	str	r2, [r3, #0]
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
  402c2e:	f641 5399 	movw	r3, #7577	; 0x1d99
  402c32:	f2c0 0340 	movt	r3, #64	; 0x40
  402c36:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
  402c38:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  402c3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402c40:	681b      	ldr	r3, [r3, #0]
  402c42:	f103 0201 	add.w	r2, r3, #1
  402c46:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  402c4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402c4e:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
  402c50:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  402c54:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402c58:	681b      	ldr	r3, [r3, #0]
  402c5a:	2b00      	cmp	r3, #0
  402c5c:	d112      	bne.n	402c84 <xTaskGenericCreate+0x10c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
  402c5e:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  402c62:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402c66:	69ba      	ldr	r2, [r7, #24]
  402c68:	601a      	str	r2, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
  402c6a:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  402c6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402c72:	681b      	ldr	r3, [r3, #0]
  402c74:	2b01      	cmp	r3, #1
  402c76:	d11b      	bne.n	402cb0 <xTaskGenericCreate+0x138>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
  402c78:	f643 1391 	movw	r3, #14737	; 0x3991
  402c7c:	f2c0 0340 	movt	r3, #64	; 0x40
  402c80:	4798      	blx	r3
  402c82:	e015      	b.n	402cb0 <xTaskGenericCreate+0x138>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
  402c84:	f24a 53d0 	movw	r3, #42448	; 0xa5d0
  402c88:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402c8c:	681b      	ldr	r3, [r3, #0]
  402c8e:	2b00      	cmp	r3, #0
  402c90:	d10e      	bne.n	402cb0 <xTaskGenericCreate+0x138>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
  402c92:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  402c96:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402c9a:	681b      	ldr	r3, [r3, #0]
  402c9c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402c9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  402ca0:	429a      	cmp	r2, r3
  402ca2:	d805      	bhi.n	402cb0 <xTaskGenericCreate+0x138>
					{
						pxCurrentTCB = pxNewTCB;
  402ca4:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  402ca8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402cac:	69ba      	ldr	r2, [r7, #24]
  402cae:	601a      	str	r2, [r3, #0]
					}
				}
			}

			uxTaskNumber++;
  402cb0:	f24a 53e4 	movw	r3, #42468	; 0xa5e4
  402cb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402cb8:	681b      	ldr	r3, [r3, #0]
  402cba:	f103 0201 	add.w	r2, r3, #1
  402cbe:	f24a 53e4 	movw	r3, #42468	; 0xa5e4
  402cc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402cc6:	601a      	str	r2, [r3, #0]
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
  402cc8:	69bb      	ldr	r3, [r7, #24]
  402cca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402ccc:	f04f 0201 	mov.w	r2, #1
  402cd0:	fa02 f203 	lsl.w	r2, r2, r3
  402cd4:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  402cd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402cdc:	681b      	ldr	r3, [r3, #0]
  402cde:	431a      	orrs	r2, r3
  402ce0:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  402ce4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402ce8:	601a      	str	r2, [r3, #0]
  402cea:	69bb      	ldr	r3, [r7, #24]
  402cec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402cee:	4613      	mov	r3, r2
  402cf0:	ea4f 0383 	mov.w	r3, r3, lsl #2
  402cf4:	189b      	adds	r3, r3, r2
  402cf6:	ea4f 0383 	mov.w	r3, r3, lsl #2
  402cfa:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  402cfe:	f2c2 0200 	movt	r2, #8192	; 0x2000
  402d02:	189a      	adds	r2, r3, r2
  402d04:	69bb      	ldr	r3, [r7, #24]
  402d06:	f103 0304 	add.w	r3, r3, #4
  402d0a:	4610      	mov	r0, r2
  402d0c:	4619      	mov	r1, r3
  402d0e:	f641 2381 	movw	r3, #6785	; 0x1a81
  402d12:	f2c0 0340 	movt	r3, #64	; 0x40
  402d16:	4798      	blx	r3

			xReturn = pdPASS;
  402d18:	f04f 0301 	mov.w	r3, #1
  402d1c:	61fb      	str	r3, [r7, #28]
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
  402d1e:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  402d22:	f2c0 0340 	movt	r3, #64	; 0x40
  402d26:	4798      	blx	r3
  402d28:	e002      	b.n	402d30 <xTaskGenericCreate+0x1b8>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  402d2a:	f04f 33ff 	mov.w	r3, #4294967295
  402d2e:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
  402d30:	69fb      	ldr	r3, [r7, #28]
  402d32:	2b01      	cmp	r3, #1
  402d34:	d114      	bne.n	402d60 <xTaskGenericCreate+0x1e8>
	{
		if( xSchedulerRunning != pdFALSE )
  402d36:	f24a 53d0 	movw	r3, #42448	; 0xa5d0
  402d3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402d3e:	681b      	ldr	r3, [r3, #0]
  402d40:	2b00      	cmp	r3, #0
  402d42:	d00d      	beq.n	402d60 <xTaskGenericCreate+0x1e8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
  402d44:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  402d48:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402d4c:	681b      	ldr	r3, [r3, #0]
  402d4e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402d50:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  402d52:	429a      	cmp	r2, r3
  402d54:	d204      	bcs.n	402d60 <xTaskGenericCreate+0x1e8>
			{
				taskYIELD_IF_USING_PREEMPTION();
  402d56:	f641 5379 	movw	r3, #7545	; 0x1d79
  402d5a:	f2c0 0340 	movt	r3, #64	; 0x40
  402d5e:	4798      	blx	r3
			}
		}
	}

	return xReturn;
  402d60:	69fb      	ldr	r3, [r7, #28]
}
  402d62:	4618      	mov	r0, r3
  402d64:	f107 0724 	add.w	r7, r7, #36	; 0x24
  402d68:	46bd      	mov	sp, r7
  402d6a:	bd90      	pop	{r4, r7, pc}

00402d6c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
  402d6c:	b580      	push	{r7, lr}
  402d6e:	b086      	sub	sp, #24
  402d70:	af00      	add	r7, sp, #0
  402d72:	6078      	str	r0, [r7, #4]
  402d74:	6039      	str	r1, [r7, #0]
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
  402d76:	f04f 0300 	mov.w	r3, #0
  402d7a:	617b      	str	r3, [r7, #20]

		configASSERT( pxPreviousWakeTime );
  402d7c:	687b      	ldr	r3, [r7, #4]
  402d7e:	2b00      	cmp	r3, #0
  402d80:	d105      	bne.n	402d8e <vTaskDelayUntil+0x22>
  402d82:	f641 6305 	movw	r3, #7685	; 0x1e05
  402d86:	f2c0 0340 	movt	r3, #64	; 0x40
  402d8a:	4798      	blx	r3
  402d8c:	e7fe      	b.n	402d8c <vTaskDelayUntil+0x20>
		configASSERT( ( xTimeIncrement > 0U ) );
  402d8e:	683b      	ldr	r3, [r7, #0]
  402d90:	2b00      	cmp	r3, #0
  402d92:	d105      	bne.n	402da0 <vTaskDelayUntil+0x34>
  402d94:	f641 6305 	movw	r3, #7685	; 0x1e05
  402d98:	f2c0 0340 	movt	r3, #64	; 0x40
  402d9c:	4798      	blx	r3
  402d9e:	e7fe      	b.n	402d9e <vTaskDelayUntil+0x32>

		vTaskSuspendAll();
  402da0:	f642 7331 	movw	r3, #12081	; 0x2f31
  402da4:	f2c0 0340 	movt	r3, #64	; 0x40
  402da8:	4798      	blx	r3
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
  402daa:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  402dae:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402db2:	681b      	ldr	r3, [r3, #0]
  402db4:	613b      	str	r3, [r7, #16]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
  402db6:	687b      	ldr	r3, [r7, #4]
  402db8:	681a      	ldr	r2, [r3, #0]
  402dba:	683b      	ldr	r3, [r7, #0]
  402dbc:	18d3      	adds	r3, r2, r3
  402dbe:	60fb      	str	r3, [r7, #12]

			if( xConstTickCount < *pxPreviousWakeTime )
  402dc0:	687b      	ldr	r3, [r7, #4]
  402dc2:	681a      	ldr	r2, [r3, #0]
  402dc4:	693b      	ldr	r3, [r7, #16]
  402dc6:	429a      	cmp	r2, r3
  402dc8:	d90c      	bls.n	402de4 <vTaskDelayUntil+0x78>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
  402dca:	687b      	ldr	r3, [r7, #4]
  402dcc:	681a      	ldr	r2, [r3, #0]
  402dce:	68fb      	ldr	r3, [r7, #12]
  402dd0:	429a      	cmp	r2, r3
  402dd2:	d913      	bls.n	402dfc <vTaskDelayUntil+0x90>
  402dd4:	68fa      	ldr	r2, [r7, #12]
  402dd6:	693b      	ldr	r3, [r7, #16]
  402dd8:	429a      	cmp	r2, r3
  402dda:	d90f      	bls.n	402dfc <vTaskDelayUntil+0x90>
				{
					xShouldDelay = pdTRUE;
  402ddc:	f04f 0301 	mov.w	r3, #1
  402de0:	617b      	str	r3, [r7, #20]
  402de2:	e00b      	b.n	402dfc <vTaskDelayUntil+0x90>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
  402de4:	687b      	ldr	r3, [r7, #4]
  402de6:	681a      	ldr	r2, [r3, #0]
  402de8:	68fb      	ldr	r3, [r7, #12]
  402dea:	429a      	cmp	r2, r3
  402dec:	d803      	bhi.n	402df6 <vTaskDelayUntil+0x8a>
  402dee:	68fa      	ldr	r2, [r7, #12]
  402df0:	693b      	ldr	r3, [r7, #16]
  402df2:	429a      	cmp	r2, r3
  402df4:	d902      	bls.n	402dfc <vTaskDelayUntil+0x90>
				{
					xShouldDelay = pdTRUE;
  402df6:	f04f 0301 	mov.w	r3, #1
  402dfa:	617b      	str	r3, [r7, #20]
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
  402dfc:	687b      	ldr	r3, [r7, #4]
  402dfe:	68fa      	ldr	r2, [r7, #12]
  402e00:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
  402e02:	697b      	ldr	r3, [r7, #20]
  402e04:	2b00      	cmp	r3, #0
  402e06:	d02c      	beq.n	402e62 <vTaskDelayUntil+0xf6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  402e08:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  402e0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402e10:	681b      	ldr	r3, [r3, #0]
  402e12:	f103 0304 	add.w	r3, r3, #4
  402e16:	4618      	mov	r0, r3
  402e18:	f641 333d 	movw	r3, #6973	; 0x1b3d
  402e1c:	f2c0 0340 	movt	r3, #64	; 0x40
  402e20:	4798      	blx	r3
  402e22:	4603      	mov	r3, r0
  402e24:	2b00      	cmp	r3, #0
  402e26:	d116      	bne.n	402e56 <vTaskDelayUntil+0xea>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  402e28:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  402e2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402e30:	681b      	ldr	r3, [r3, #0]
  402e32:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402e34:	f04f 0201 	mov.w	r2, #1
  402e38:	fa02 f303 	lsl.w	r3, r2, r3
  402e3c:	ea6f 0203 	mvn.w	r2, r3
  402e40:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  402e44:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402e48:	681b      	ldr	r3, [r3, #0]
  402e4a:	401a      	ands	r2, r3
  402e4c:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  402e50:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402e54:	601a      	str	r2, [r3, #0]
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
  402e56:	68f8      	ldr	r0, [r7, #12]
  402e58:	f643 3319 	movw	r3, #15129	; 0x3b19
  402e5c:	f2c0 0340 	movt	r3, #64	; 0x40
  402e60:	4798      	blx	r3
			}
		}
		xAlreadyYielded = xTaskResumeAll();
  402e62:	f642 7355 	movw	r3, #12117	; 0x2f55
  402e66:	f2c0 0340 	movt	r3, #64	; 0x40
  402e6a:	4798      	blx	r3
  402e6c:	60b8      	str	r0, [r7, #8]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  402e6e:	68bb      	ldr	r3, [r7, #8]
  402e70:	2b00      	cmp	r3, #0
  402e72:	d104      	bne.n	402e7e <vTaskDelayUntil+0x112>
		{
			portYIELD_WITHIN_API();
  402e74:	f641 5379 	movw	r3, #7545	; 0x1d79
  402e78:	f2c0 0340 	movt	r3, #64	; 0x40
  402e7c:	4798      	blx	r3
		}
	}
  402e7e:	f107 0718 	add.w	r7, r7, #24
  402e82:	46bd      	mov	sp, r7
  402e84:	bd80      	pop	{r7, pc}
  402e86:	bf00      	nop

00402e88 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
  402e88:	b590      	push	{r4, r7, lr}
  402e8a:	b087      	sub	sp, #28
  402e8c:	af04      	add	r7, sp, #16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
  402e8e:	f04f 0300 	mov.w	r3, #0
  402e92:	9300      	str	r3, [sp, #0]
  402e94:	f04f 0300 	mov.w	r3, #0
  402e98:	9301      	str	r3, [sp, #4]
  402e9a:	f04f 0300 	mov.w	r3, #0
  402e9e:	9302      	str	r3, [sp, #8]
  402ea0:	f04f 0300 	mov.w	r3, #0
  402ea4:	9303      	str	r3, [sp, #12]
  402ea6:	f643 00b5 	movw	r0, #14517	; 0x38b5
  402eaa:	f2c0 0040 	movt	r0, #64	; 0x40
  402eae:	f644 21d8 	movw	r1, #19160	; 0x4ad8
  402eb2:	f2c0 0140 	movt	r1, #64	; 0x40
  402eb6:	f04f 0282 	mov.w	r2, #130	; 0x82
  402eba:	f04f 0300 	mov.w	r3, #0
  402ebe:	f642 3479 	movw	r4, #11129	; 0x2b79
  402ec2:	f2c0 0440 	movt	r4, #64	; 0x40
  402ec6:	47a0      	blx	r4
  402ec8:	6078      	str	r0, [r7, #4]
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
  402eca:	687b      	ldr	r3, [r7, #4]
  402ecc:	2b01      	cmp	r3, #1
  402ece:	d105      	bne.n	402edc <vTaskStartScheduler+0x54>
		{
			xReturn = xTimerCreateTimerTask();
  402ed0:	f643 63fd 	movw	r3, #16125	; 0x3efd
  402ed4:	f2c0 0340 	movt	r3, #64	; 0x40
  402ed8:	4798      	blx	r3
  402eda:	6078      	str	r0, [r7, #4]
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
  402edc:	687b      	ldr	r3, [r7, #4]
  402ede:	2b01      	cmp	r3, #1
  402ee0:	d118      	bne.n	402f14 <vTaskStartScheduler+0x8c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
  402ee2:	f641 6305 	movw	r3, #7685	; 0x1e05
  402ee6:	f2c0 0340 	movt	r3, #64	; 0x40
  402eea:	4798      	blx	r3
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
  402eec:	f24a 53d0 	movw	r3, #42448	; 0xa5d0
  402ef0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402ef4:	f04f 0201 	mov.w	r2, #1
  402ef8:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
  402efa:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  402efe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402f02:	f04f 0200 	mov.w	r2, #0
  402f06:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  402f08:	f641 4359 	movw	r3, #7257	; 0x1c59
  402f0c:	f2c0 0340 	movt	r3, #64	; 0x40
  402f10:	4798      	blx	r3
  402f12:	e008      	b.n	402f26 <vTaskStartScheduler+0x9e>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
  402f14:	687b      	ldr	r3, [r7, #4]
  402f16:	2b00      	cmp	r3, #0
  402f18:	d105      	bne.n	402f26 <vTaskStartScheduler+0x9e>
  402f1a:	f641 6305 	movw	r3, #7685	; 0x1e05
  402f1e:	f2c0 0340 	movt	r3, #64	; 0x40
  402f22:	4798      	blx	r3
  402f24:	e7fe      	b.n	402f24 <vTaskStartScheduler+0x9c>
	}
}
  402f26:	f107 070c 	add.w	r7, r7, #12
  402f2a:	46bd      	mov	sp, r7
  402f2c:	bd90      	pop	{r4, r7, pc}
  402f2e:	bf00      	nop

00402f30 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
  402f30:	b480      	push	{r7}
  402f32:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  402f34:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  402f38:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402f3c:	681b      	ldr	r3, [r3, #0]
  402f3e:	f103 0201 	add.w	r2, r3, #1
  402f42:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  402f46:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402f4a:	601a      	str	r2, [r3, #0]
}
  402f4c:	46bd      	mov	sp, r7
  402f4e:	bc80      	pop	{r7}
  402f50:	4770      	bx	lr
  402f52:	bf00      	nop

00402f54 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
  402f54:	b580      	push	{r7, lr}
  402f56:	b082      	sub	sp, #8
  402f58:	af00      	add	r7, sp, #0
tskTCB *pxTCB;
portBASE_TYPE xAlreadyYielded = pdFALSE;
  402f5a:	f04f 0300 	mov.w	r3, #0
  402f5e:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
  402f60:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  402f64:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402f68:	681b      	ldr	r3, [r3, #0]
  402f6a:	2b00      	cmp	r3, #0
  402f6c:	d105      	bne.n	402f7a <xTaskResumeAll+0x26>
  402f6e:	f641 6305 	movw	r3, #7685	; 0x1e05
  402f72:	f2c0 0340 	movt	r3, #64	; 0x40
  402f76:	4798      	blx	r3
  402f78:	e7fe      	b.n	402f78 <xTaskResumeAll+0x24>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  402f7a:	f641 5399 	movw	r3, #7577	; 0x1d99
  402f7e:	f2c0 0340 	movt	r3, #64	; 0x40
  402f82:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  402f84:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  402f88:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402f8c:	681b      	ldr	r3, [r3, #0]
  402f8e:	f103 32ff 	add.w	r2, r3, #4294967295
  402f92:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  402f96:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402f9a:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  402f9c:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  402fa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402fa4:	681b      	ldr	r3, [r3, #0]
  402fa6:	2b00      	cmp	r3, #0
  402fa8:	f040 809b 	bne.w	4030e2 <xTaskResumeAll+0x18e>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
  402fac:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  402fb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402fb4:	681b      	ldr	r3, [r3, #0]
  402fb6:	2b00      	cmp	r3, #0
  402fb8:	f000 8093 	beq.w	4030e2 <xTaskResumeAll+0x18e>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  402fbc:	e051      	b.n	403062 <xTaskResumeAll+0x10e>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
  402fbe:	f24a 5384 	movw	r3, #42372	; 0xa584
  402fc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402fc6:	68db      	ldr	r3, [r3, #12]
  402fc8:	68db      	ldr	r3, [r3, #12]
  402fca:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  402fcc:	683b      	ldr	r3, [r7, #0]
  402fce:	f103 0318 	add.w	r3, r3, #24
  402fd2:	4618      	mov	r0, r3
  402fd4:	f641 333d 	movw	r3, #6973	; 0x1b3d
  402fd8:	f2c0 0340 	movt	r3, #64	; 0x40
  402fdc:	4798      	blx	r3
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
  402fde:	683b      	ldr	r3, [r7, #0]
  402fe0:	f103 0304 	add.w	r3, r3, #4
  402fe4:	4618      	mov	r0, r3
  402fe6:	f641 333d 	movw	r3, #6973	; 0x1b3d
  402fea:	f2c0 0340 	movt	r3, #64	; 0x40
  402fee:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
  402ff0:	683b      	ldr	r3, [r7, #0]
  402ff2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402ff4:	f04f 0201 	mov.w	r2, #1
  402ff8:	fa02 f203 	lsl.w	r2, r2, r3
  402ffc:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403000:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403004:	681b      	ldr	r3, [r3, #0]
  403006:	431a      	orrs	r2, r3
  403008:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  40300c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403010:	601a      	str	r2, [r3, #0]
  403012:	683b      	ldr	r3, [r7, #0]
  403014:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403016:	4613      	mov	r3, r2
  403018:	ea4f 0383 	mov.w	r3, r3, lsl #2
  40301c:	189b      	adds	r3, r3, r2
  40301e:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403022:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  403026:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40302a:	189a      	adds	r2, r3, r2
  40302c:	683b      	ldr	r3, [r7, #0]
  40302e:	f103 0304 	add.w	r3, r3, #4
  403032:	4610      	mov	r0, r2
  403034:	4619      	mov	r1, r3
  403036:	f641 2381 	movw	r3, #6785	; 0x1a81
  40303a:	f2c0 0340 	movt	r3, #64	; 0x40
  40303e:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  403040:	683b      	ldr	r3, [r7, #0]
  403042:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403044:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403048:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40304c:	681b      	ldr	r3, [r3, #0]
  40304e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403050:	429a      	cmp	r2, r3
  403052:	d306      	bcc.n	403062 <xTaskResumeAll+0x10e>
					{
						xYieldPending = pdTRUE;
  403054:	f24a 53dc 	movw	r3, #42460	; 0xa5dc
  403058:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40305c:	f04f 0201 	mov.w	r2, #1
  403060:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  403062:	f24a 5384 	movw	r3, #42372	; 0xa584
  403066:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40306a:	681b      	ldr	r3, [r3, #0]
  40306c:	2b00      	cmp	r3, #0
  40306e:	d1a6      	bne.n	402fbe <xTaskResumeAll+0x6a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
  403070:	f24a 53d8 	movw	r3, #42456	; 0xa5d8
  403074:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403078:	681b      	ldr	r3, [r3, #0]
  40307a:	2b00      	cmp	r3, #0
  40307c:	d022      	beq.n	4030c4 <xTaskResumeAll+0x170>
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
  40307e:	e01a      	b.n	4030b6 <xTaskResumeAll+0x162>
					{
						if( xTaskIncrementTick() != pdFALSE )
  403080:	f243 132d 	movw	r3, #12589	; 0x312d
  403084:	f2c0 0340 	movt	r3, #64	; 0x40
  403088:	4798      	blx	r3
  40308a:	4603      	mov	r3, r0
  40308c:	2b00      	cmp	r3, #0
  40308e:	d006      	beq.n	40309e <xTaskResumeAll+0x14a>
						{
							xYieldPending = pdTRUE;
  403090:	f24a 53dc 	movw	r3, #42460	; 0xa5dc
  403094:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403098:	f04f 0201 	mov.w	r2, #1
  40309c:	601a      	str	r2, [r3, #0]
						}
						--uxPendedTicks;
  40309e:	f24a 53d8 	movw	r3, #42456	; 0xa5d8
  4030a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4030a6:	681b      	ldr	r3, [r3, #0]
  4030a8:	f103 32ff 	add.w	r2, r3, #4294967295
  4030ac:	f24a 53d8 	movw	r3, #42456	; 0xa5d8
  4030b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4030b4:	601a      	str	r2, [r3, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
  4030b6:	f24a 53d8 	movw	r3, #42456	; 0xa5d8
  4030ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4030be:	681b      	ldr	r3, [r3, #0]
  4030c0:	2b00      	cmp	r3, #0
  4030c2:	d1dd      	bne.n	403080 <xTaskResumeAll+0x12c>
						}
						--uxPendedTicks;
					}
				}

				if( xYieldPending == pdTRUE )
  4030c4:	f24a 53dc 	movw	r3, #42460	; 0xa5dc
  4030c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4030cc:	681b      	ldr	r3, [r3, #0]
  4030ce:	2b01      	cmp	r3, #1
  4030d0:	d107      	bne.n	4030e2 <xTaskResumeAll+0x18e>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
  4030d2:	f04f 0301 	mov.w	r3, #1
  4030d6:	607b      	str	r3, [r7, #4]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
  4030d8:	f641 5379 	movw	r3, #7545	; 0x1d79
  4030dc:	f2c0 0340 	movt	r3, #64	; 0x40
  4030e0:	4798      	blx	r3
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  4030e2:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  4030e6:	f2c0 0340 	movt	r3, #64	; 0x40
  4030ea:	4798      	blx	r3

	return xAlreadyYielded;
  4030ec:	687b      	ldr	r3, [r7, #4]
}
  4030ee:	4618      	mov	r0, r3
  4030f0:	f107 0708 	add.w	r7, r7, #8
  4030f4:	46bd      	mov	sp, r7
  4030f6:	bd80      	pop	{r7, pc}

004030f8 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCount( void )
{
  4030f8:	b580      	push	{r7, lr}
  4030fa:	b082      	sub	sp, #8
  4030fc:	af00      	add	r7, sp, #0
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
  4030fe:	f641 5399 	movw	r3, #7577	; 0x1d99
  403102:	f2c0 0340 	movt	r3, #64	; 0x40
  403106:	4798      	blx	r3
	{
		xTicks = xTickCount;
  403108:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  40310c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403110:	681b      	ldr	r3, [r3, #0]
  403112:	607b      	str	r3, [r7, #4]
	}
	taskEXIT_CRITICAL();
  403114:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  403118:	f2c0 0340 	movt	r3, #64	; 0x40
  40311c:	4798      	blx	r3

	return xTicks;
  40311e:	687b      	ldr	r3, [r7, #4]
}
  403120:	4618      	mov	r0, r3
  403122:	f107 0708 	add.w	r7, r7, #8
  403126:	46bd      	mov	sp, r7
  403128:	bd80      	pop	{r7, pc}
  40312a:	bf00      	nop

0040312c <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

portBASE_TYPE xTaskIncrementTick( void )
{
  40312c:	b580      	push	{r7, lr}
  40312e:	b086      	sub	sp, #24
  403130:	af00      	add	r7, sp, #0
tskTCB * pxTCB;
portTickType xItemValue;
portBASE_TYPE xSwitchRequired = pdFALSE;
  403132:	f04f 0300 	mov.w	r3, #0
  403136:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  403138:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  40313c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403140:	681b      	ldr	r3, [r3, #0]
  403142:	2b00      	cmp	r3, #0
  403144:	f040 8112 	bne.w	40336c <xTaskIncrementTick+0x240>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
  403148:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  40314c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403150:	681b      	ldr	r3, [r3, #0]
  403152:	f103 0201 	add.w	r2, r3, #1
  403156:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  40315a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40315e:	601a      	str	r2, [r3, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
  403160:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  403164:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403168:	681b      	ldr	r3, [r3, #0]
  40316a:	613b      	str	r3, [r7, #16]

			if( xConstTickCount == ( portTickType ) 0U )
  40316c:	693b      	ldr	r3, [r7, #16]
  40316e:	2b00      	cmp	r3, #0
  403170:	d155      	bne.n	40321e <xTaskIncrementTick+0xf2>
			{
				taskSWITCH_DELAYED_LISTS();
  403172:	f24a 537c 	movw	r3, #42364	; 0xa57c
  403176:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40317a:	681b      	ldr	r3, [r3, #0]
  40317c:	681b      	ldr	r3, [r3, #0]
  40317e:	2b00      	cmp	r3, #0
  403180:	d005      	beq.n	40318e <xTaskIncrementTick+0x62>
  403182:	f641 6305 	movw	r3, #7685	; 0x1e05
  403186:	f2c0 0340 	movt	r3, #64	; 0x40
  40318a:	4798      	blx	r3
  40318c:	e7fe      	b.n	40318c <xTaskIncrementTick+0x60>
  40318e:	f24a 537c 	movw	r3, #42364	; 0xa57c
  403192:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403196:	681b      	ldr	r3, [r3, #0]
  403198:	60fb      	str	r3, [r7, #12]
  40319a:	f24a 5380 	movw	r3, #42368	; 0xa580
  40319e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031a2:	681a      	ldr	r2, [r3, #0]
  4031a4:	f24a 537c 	movw	r3, #42364	; 0xa57c
  4031a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031ac:	601a      	str	r2, [r3, #0]
  4031ae:	f24a 5380 	movw	r3, #42368	; 0xa580
  4031b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031b6:	68fa      	ldr	r2, [r7, #12]
  4031b8:	601a      	str	r2, [r3, #0]
  4031ba:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  4031be:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031c2:	681b      	ldr	r3, [r3, #0]
  4031c4:	f103 0201 	add.w	r2, r3, #1
  4031c8:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  4031cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031d0:	601a      	str	r2, [r3, #0]
  4031d2:	f24a 537c 	movw	r3, #42364	; 0xa57c
  4031d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031da:	681b      	ldr	r3, [r3, #0]
  4031dc:	681b      	ldr	r3, [r3, #0]
  4031de:	2b00      	cmp	r3, #0
  4031e0:	d102      	bne.n	4031e8 <xTaskIncrementTick+0xbc>
  4031e2:	f04f 0301 	mov.w	r3, #1
  4031e6:	e001      	b.n	4031ec <xTaskIncrementTick+0xc0>
  4031e8:	f04f 0300 	mov.w	r3, #0
  4031ec:	2b00      	cmp	r3, #0
  4031ee:	d007      	beq.n	403200 <xTaskIncrementTick+0xd4>
  4031f0:	f240 030c 	movw	r3, #12
  4031f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031f8:	f04f 32ff 	mov.w	r2, #4294967295
  4031fc:	601a      	str	r2, [r3, #0]
  4031fe:	e00e      	b.n	40321e <xTaskIncrementTick+0xf2>
  403200:	f24a 537c 	movw	r3, #42364	; 0xa57c
  403204:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403208:	681b      	ldr	r3, [r3, #0]
  40320a:	68db      	ldr	r3, [r3, #12]
  40320c:	68db      	ldr	r3, [r3, #12]
  40320e:	60bb      	str	r3, [r7, #8]
  403210:	68bb      	ldr	r3, [r7, #8]
  403212:	685a      	ldr	r2, [r3, #4]
  403214:	f240 030c 	movw	r3, #12
  403218:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40321c:	601a      	str	r2, [r3, #0]

			/* See if this tick has made a timeout expire.  Tasks are stored in the
			queue in the order of their wake time - meaning once one tasks has been
			found whose block time has not expired there is no need not look any
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
  40321e:	f240 030c 	movw	r3, #12
  403222:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403226:	681b      	ldr	r3, [r3, #0]
  403228:	693a      	ldr	r2, [r7, #16]
  40322a:	429a      	cmp	r2, r3
  40322c:	d37a      	bcc.n	403324 <xTaskIncrementTick+0x1f8>
  40322e:	e000      	b.n	403232 <xTaskIncrementTick+0x106>
								xSwitchRequired = pdTRUE;
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
  403230:	bf00      	nop
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  403232:	f24a 537c 	movw	r3, #42364	; 0xa57c
  403236:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40323a:	681b      	ldr	r3, [r3, #0]
  40323c:	681b      	ldr	r3, [r3, #0]
  40323e:	2b00      	cmp	r3, #0
  403240:	d102      	bne.n	403248 <xTaskIncrementTick+0x11c>
  403242:	f04f 0301 	mov.w	r3, #1
  403246:	e001      	b.n	40324c <xTaskIncrementTick+0x120>
  403248:	f04f 0300 	mov.w	r3, #0
  40324c:	2b00      	cmp	r3, #0
  40324e:	d007      	beq.n	403260 <xTaskIncrementTick+0x134>
					{
						/* The delayed list is empty.  Set xNextTaskUnblockTime to
						the	maximum possible value so it is extremely unlikely that
						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
  403250:	f240 030c 	movw	r3, #12
  403254:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403258:	f04f 32ff 	mov.w	r2, #4294967295
  40325c:	601a      	str	r2, [r3, #0]
						break;
  40325e:	e061      	b.n	403324 <xTaskIncrementTick+0x1f8>
					{
						/* The delayed list is not empty, get the value of the item
						at the head of the delayed list.  This is the time at which
						the task at the head of the delayed list must be removed
						from the Blocked state. */
						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  403260:	f24a 537c 	movw	r3, #42364	; 0xa57c
  403264:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403268:	681b      	ldr	r3, [r3, #0]
  40326a:	68db      	ldr	r3, [r3, #12]
  40326c:	68db      	ldr	r3, [r3, #12]
  40326e:	60bb      	str	r3, [r7, #8]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  403270:	68bb      	ldr	r3, [r7, #8]
  403272:	685b      	ldr	r3, [r3, #4]
  403274:	607b      	str	r3, [r7, #4]

						if( xConstTickCount < xItemValue )
  403276:	693a      	ldr	r2, [r7, #16]
  403278:	687b      	ldr	r3, [r7, #4]
  40327a:	429a      	cmp	r2, r3
  40327c:	d206      	bcs.n	40328c <xTaskIncrementTick+0x160>
						{
							/* It is not time to unblock this item yet, but the item
							value is the time at which the task at the head of the
							blocked list must be removed from the Blocked state -
							so record the item value in xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
  40327e:	f240 030c 	movw	r3, #12
  403282:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403286:	687a      	ldr	r2, [r7, #4]
  403288:	601a      	str	r2, [r3, #0]
							break;
  40328a:	e04b      	b.n	403324 <xTaskIncrementTick+0x1f8>
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
  40328c:	68bb      	ldr	r3, [r7, #8]
  40328e:	f103 0304 	add.w	r3, r3, #4
  403292:	4618      	mov	r0, r3
  403294:	f641 333d 	movw	r3, #6973	; 0x1b3d
  403298:	f2c0 0340 	movt	r3, #64	; 0x40
  40329c:	4798      	blx	r3

						/* Is the task waiting on an event also?  If so remove it
						from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  40329e:	68bb      	ldr	r3, [r7, #8]
  4032a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  4032a2:	2b00      	cmp	r3, #0
  4032a4:	d008      	beq.n	4032b8 <xTaskIncrementTick+0x18c>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  4032a6:	68bb      	ldr	r3, [r7, #8]
  4032a8:	f103 0318 	add.w	r3, r3, #24
  4032ac:	4618      	mov	r0, r3
  4032ae:	f641 333d 	movw	r3, #6973	; 0x1b3d
  4032b2:	f2c0 0340 	movt	r3, #64	; 0x40
  4032b6:	4798      	blx	r3
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
  4032b8:	68bb      	ldr	r3, [r7, #8]
  4032ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4032bc:	f04f 0201 	mov.w	r2, #1
  4032c0:	fa02 f203 	lsl.w	r2, r2, r3
  4032c4:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  4032c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4032cc:	681b      	ldr	r3, [r3, #0]
  4032ce:	431a      	orrs	r2, r3
  4032d0:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  4032d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4032d8:	601a      	str	r2, [r3, #0]
  4032da:	68bb      	ldr	r3, [r7, #8]
  4032dc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4032de:	4613      	mov	r3, r2
  4032e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4032e4:	189b      	adds	r3, r3, r2
  4032e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4032ea:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  4032ee:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4032f2:	189a      	adds	r2, r3, r2
  4032f4:	68bb      	ldr	r3, [r7, #8]
  4032f6:	f103 0304 	add.w	r3, r3, #4
  4032fa:	4610      	mov	r0, r2
  4032fc:	4619      	mov	r1, r3
  4032fe:	f641 2381 	movw	r3, #6785	; 0x1a81
  403302:	f2c0 0340 	movt	r3, #64	; 0x40
  403306:	4798      	blx	r3
						{
							/* Preemption is on, but a context switch should only
							be performed if the unblocked task has a priority that
							is equal to or higher than the currently executing
							task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  403308:	68bb      	ldr	r3, [r7, #8]
  40330a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40330c:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403310:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403314:	681b      	ldr	r3, [r3, #0]
  403316:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403318:	429a      	cmp	r2, r3
  40331a:	d389      	bcc.n	403230 <xTaskIncrementTick+0x104>
							{
								xSwitchRequired = pdTRUE;
  40331c:	f04f 0301 	mov.w	r3, #1
  403320:	617b      	str	r3, [r7, #20]
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
  403322:	e785      	b.n	403230 <xTaskIncrementTick+0x104>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  403324:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403328:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40332c:	681b      	ldr	r3, [r3, #0]
  40332e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  403330:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  403334:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403338:	460b      	mov	r3, r1
  40333a:	ea4f 0383 	mov.w	r3, r3, lsl #2
  40333e:	185b      	adds	r3, r3, r1
  403340:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403344:	18d3      	adds	r3, r2, r3
  403346:	681b      	ldr	r3, [r3, #0]
  403348:	2b01      	cmp	r3, #1
  40334a:	d902      	bls.n	403352 <xTaskIncrementTick+0x226>
			{
				xSwitchRequired = pdTRUE;
  40334c:	f04f 0301 	mov.w	r3, #1
  403350:	617b      	str	r3, [r7, #20]

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( unsigned portBASE_TYPE ) 0U )
  403352:	f24a 53d8 	movw	r3, #42456	; 0xa5d8
  403356:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40335a:	681b      	ldr	r3, [r3, #0]
  40335c:	2b00      	cmp	r3, #0
  40335e:	d116      	bne.n	40338e <xTaskIncrementTick+0x262>
			{
				vApplicationTickHook();
  403360:	f244 63a5 	movw	r3, #18085	; 0x46a5
  403364:	f2c0 0340 	movt	r3, #64	; 0x40
  403368:	4798      	blx	r3
  40336a:	e010      	b.n	40338e <xTaskIncrementTick+0x262>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
  40336c:	f24a 53d8 	movw	r3, #42456	; 0xa5d8
  403370:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403374:	681b      	ldr	r3, [r3, #0]
  403376:	f103 0201 	add.w	r2, r3, #1
  40337a:	f24a 53d8 	movw	r3, #42456	; 0xa5d8
  40337e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403382:	601a      	str	r2, [r3, #0]

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
  403384:	f244 63a5 	movw	r3, #18085	; 0x46a5
  403388:	f2c0 0340 	movt	r3, #64	; 0x40
  40338c:	4798      	blx	r3
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
  40338e:	f24a 53dc 	movw	r3, #42460	; 0xa5dc
  403392:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403396:	681b      	ldr	r3, [r3, #0]
  403398:	2b00      	cmp	r3, #0
  40339a:	d002      	beq.n	4033a2 <xTaskIncrementTick+0x276>
		{
			xSwitchRequired = pdTRUE;
  40339c:	f04f 0301 	mov.w	r3, #1
  4033a0:	617b      	str	r3, [r7, #20]
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
  4033a2:	697b      	ldr	r3, [r7, #20]
}
  4033a4:	4618      	mov	r0, r3
  4033a6:	f107 0718 	add.w	r7, r7, #24
  4033aa:	46bd      	mov	sp, r7
  4033ac:	bd80      	pop	{r7, pc}
  4033ae:	bf00      	nop

004033b0 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  4033b0:	b590      	push	{r4, r7, lr}
  4033b2:	b085      	sub	sp, #20
  4033b4:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  4033b6:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  4033ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4033be:	681b      	ldr	r3, [r3, #0]
  4033c0:	2b00      	cmp	r3, #0
  4033c2:	d007      	beq.n	4033d4 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
  4033c4:	f24a 53dc 	movw	r3, #42460	; 0xa5dc
  4033c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4033cc:	f04f 0201 	mov.w	r2, #1
  4033d0:	601a      	str	r2, [r3, #0]
  4033d2:	e098      	b.n	403506 <vTaskSwitchContext+0x156>
	}
	else
	{
		xYieldPending = pdFALSE;
  4033d4:	f24a 53dc 	movw	r3, #42460	; 0xa5dc
  4033d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4033dc:	f04f 0200 	mov.w	r2, #0
  4033e0:	601a      	str	r2, [r3, #0]
				}
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
  4033e2:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  4033e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4033ea:	681b      	ldr	r3, [r3, #0]
  4033ec:	681a      	ldr	r2, [r3, #0]
  4033ee:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  4033f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4033f6:	681b      	ldr	r3, [r3, #0]
  4033f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4033fa:	429a      	cmp	r2, r3
  4033fc:	d812      	bhi.n	403424 <vTaskSwitchContext+0x74>
  4033fe:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403402:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403406:	681a      	ldr	r2, [r3, #0]
  403408:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  40340c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403410:	681b      	ldr	r3, [r3, #0]
  403412:	f103 0334 	add.w	r3, r3, #52	; 0x34
  403416:	4610      	mov	r0, r2
  403418:	4619      	mov	r1, r3
  40341a:	f244 638d 	movw	r3, #18061	; 0x468d
  40341e:	f2c0 0340 	movt	r3, #64	; 0x40
  403422:	4798      	blx	r3
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
  403424:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403428:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40342c:	681b      	ldr	r3, [r3, #0]
  40342e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  403430:	4618      	mov	r0, r3
  403432:	f644 21e0 	movw	r1, #19168	; 0x4ae0
  403436:	f2c0 0140 	movt	r1, #64	; 0x40
  40343a:	f04f 0214 	mov.w	r2, #20
  40343e:	f644 236d 	movw	r3, #19053	; 0x4a6d
  403442:	f2c0 0340 	movt	r3, #64	; 0x40
  403446:	4798      	blx	r3
  403448:	4603      	mov	r3, r0
  40344a:	2b00      	cmp	r3, #0
  40344c:	d012      	beq.n	403474 <vTaskSwitchContext+0xc4>
  40344e:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403452:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403456:	681a      	ldr	r2, [r3, #0]
  403458:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  40345c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403460:	681b      	ldr	r3, [r3, #0]
  403462:	f103 0334 	add.w	r3, r3, #52	; 0x34
  403466:	4610      	mov	r0, r2
  403468:	4619      	mov	r1, r3
  40346a:	f244 638d 	movw	r3, #18061	; 0x468d
  40346e:	f2c0 0340 	movt	r3, #64	; 0x40
  403472:	4798      	blx	r3

		taskSELECT_HIGHEST_PRIORITY_TASK();
  403474:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403478:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40347c:	681b      	ldr	r3, [r3, #0]
  40347e:	607b      	str	r3, [r7, #4]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline unsigned char ucPortCountLeadingZeros( unsigned long ulBitmap )
	{
	unsigned char ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
  403480:	687b      	ldr	r3, [r7, #4]
  403482:	fab3 f483 	clz	r4, r3
  403486:	70fc      	strb	r4, [r7, #3]
		return ucReturn;
  403488:	78fb      	ldrb	r3, [r7, #3]
  40348a:	f1c3 031f 	rsb	r3, r3, #31
  40348e:	60fb      	str	r3, [r7, #12]
  403490:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  403494:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403498:	68f9      	ldr	r1, [r7, #12]
  40349a:	460b      	mov	r3, r1
  40349c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4034a0:	185b      	adds	r3, r3, r1
  4034a2:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4034a6:	18d3      	adds	r3, r2, r3
  4034a8:	681b      	ldr	r3, [r3, #0]
  4034aa:	2b00      	cmp	r3, #0
  4034ac:	d105      	bne.n	4034ba <vTaskSwitchContext+0x10a>
  4034ae:	f641 6305 	movw	r3, #7685	; 0x1e05
  4034b2:	f2c0 0340 	movt	r3, #64	; 0x40
  4034b6:	4798      	blx	r3
  4034b8:	e7fe      	b.n	4034b8 <vTaskSwitchContext+0x108>
  4034ba:	68fa      	ldr	r2, [r7, #12]
  4034bc:	4613      	mov	r3, r2
  4034be:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4034c2:	189b      	adds	r3, r3, r2
  4034c4:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4034c8:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  4034cc:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4034d0:	189b      	adds	r3, r3, r2
  4034d2:	60bb      	str	r3, [r7, #8]
  4034d4:	68bb      	ldr	r3, [r7, #8]
  4034d6:	685b      	ldr	r3, [r3, #4]
  4034d8:	685a      	ldr	r2, [r3, #4]
  4034da:	68bb      	ldr	r3, [r7, #8]
  4034dc:	605a      	str	r2, [r3, #4]
  4034de:	68bb      	ldr	r3, [r7, #8]
  4034e0:	685a      	ldr	r2, [r3, #4]
  4034e2:	68bb      	ldr	r3, [r7, #8]
  4034e4:	f103 0308 	add.w	r3, r3, #8
  4034e8:	429a      	cmp	r2, r3
  4034ea:	d104      	bne.n	4034f6 <vTaskSwitchContext+0x146>
  4034ec:	68bb      	ldr	r3, [r7, #8]
  4034ee:	685b      	ldr	r3, [r3, #4]
  4034f0:	685a      	ldr	r2, [r3, #4]
  4034f2:	68bb      	ldr	r3, [r7, #8]
  4034f4:	605a      	str	r2, [r3, #4]
  4034f6:	68bb      	ldr	r3, [r7, #8]
  4034f8:	685b      	ldr	r3, [r3, #4]
  4034fa:	68da      	ldr	r2, [r3, #12]
  4034fc:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403500:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403504:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  403506:	f107 0714 	add.w	r7, r7, #20
  40350a:	46bd      	mov	sp, r7
  40350c:	bd90      	pop	{r4, r7, pc}
  40350e:	bf00      	nop

00403510 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
{
  403510:	b580      	push	{r7, lr}
  403512:	b084      	sub	sp, #16
  403514:	af00      	add	r7, sp, #0
  403516:	6078      	str	r0, [r7, #4]
  403518:	6039      	str	r1, [r7, #0]
portTickType xTimeToWake;

	configASSERT( pxEventList );
  40351a:	687b      	ldr	r3, [r7, #4]
  40351c:	2b00      	cmp	r3, #0
  40351e:	d105      	bne.n	40352c <vTaskPlaceOnEventList+0x1c>
  403520:	f641 6305 	movw	r3, #7685	; 0x1e05
  403524:	f2c0 0340 	movt	r3, #64	; 0x40
  403528:	4798      	blx	r3
  40352a:	e7fe      	b.n	40352a <vTaskPlaceOnEventList+0x1a>
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  40352c:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403530:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403534:	681b      	ldr	r3, [r3, #0]
  403536:	f103 0318 	add.w	r3, r3, #24
  40353a:	6878      	ldr	r0, [r7, #4]
  40353c:	4619      	mov	r1, r3
  40353e:	f641 23c9 	movw	r3, #6857	; 0x1ac9
  403542:	f2c0 0340 	movt	r3, #64	; 0x40
  403546:	4798      	blx	r3

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  403548:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  40354c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403550:	681b      	ldr	r3, [r3, #0]
  403552:	f103 0304 	add.w	r3, r3, #4
  403556:	4618      	mov	r0, r3
  403558:	f641 333d 	movw	r3, #6973	; 0x1b3d
  40355c:	f2c0 0340 	movt	r3, #64	; 0x40
  403560:	4798      	blx	r3
  403562:	4603      	mov	r3, r0
  403564:	2b00      	cmp	r3, #0
  403566:	d116      	bne.n	403596 <vTaskPlaceOnEventList+0x86>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  403568:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  40356c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403570:	681b      	ldr	r3, [r3, #0]
  403572:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403574:	f04f 0201 	mov.w	r2, #1
  403578:	fa02 f303 	lsl.w	r3, r2, r3
  40357c:	ea6f 0203 	mvn.w	r2, r3
  403580:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403584:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403588:	681b      	ldr	r3, [r3, #0]
  40358a:	401a      	ands	r2, r3
  40358c:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403590:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403594:	601a      	str	r2, [r3, #0]
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
  403596:	683b      	ldr	r3, [r7, #0]
  403598:	f1b3 3fff 	cmp.w	r3, #4294967295
  40359c:	d111      	bne.n	4035c2 <vTaskPlaceOnEventList+0xb2>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
  40359e:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  4035a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4035a6:	681b      	ldr	r3, [r3, #0]
  4035a8:	f103 0304 	add.w	r3, r3, #4
  4035ac:	f24a 50b0 	movw	r0, #42416	; 0xa5b0
  4035b0:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4035b4:	4619      	mov	r1, r3
  4035b6:	f641 2381 	movw	r3, #6785	; 0x1a81
  4035ba:	f2c0 0340 	movt	r3, #64	; 0x40
  4035be:	4798      	blx	r3
  4035c0:	e00d      	b.n	4035de <vTaskPlaceOnEventList+0xce>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  4035c2:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  4035c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4035ca:	681a      	ldr	r2, [r3, #0]
  4035cc:	683b      	ldr	r3, [r7, #0]
  4035ce:	18d3      	adds	r3, r2, r3
  4035d0:	60fb      	str	r3, [r7, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  4035d2:	68f8      	ldr	r0, [r7, #12]
  4035d4:	f643 3319 	movw	r3, #15129	; 0x3b19
  4035d8:	f2c0 0340 	movt	r3, #64	; 0x40
  4035dc:	4798      	blx	r3
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  4035de:	f107 0710 	add.w	r7, r7, #16
  4035e2:	46bd      	mov	sp, r7
  4035e4:	bd80      	pop	{r7, pc}
  4035e6:	bf00      	nop

004035e8 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait )
	{
  4035e8:	b580      	push	{r7, lr}
  4035ea:	b084      	sub	sp, #16
  4035ec:	af00      	add	r7, sp, #0
  4035ee:	6078      	str	r0, [r7, #4]
  4035f0:	6039      	str	r1, [r7, #0]
	portTickType xTimeToWake;

		configASSERT( pxEventList );
  4035f2:	687b      	ldr	r3, [r7, #4]
  4035f4:	2b00      	cmp	r3, #0
  4035f6:	d105      	bne.n	403604 <vTaskPlaceOnEventListRestricted+0x1c>
  4035f8:	f641 6305 	movw	r3, #7685	; 0x1e05
  4035fc:	f2c0 0340 	movt	r3, #64	; 0x40
  403600:	4798      	blx	r3
  403602:	e7fe      	b.n	403602 <vTaskPlaceOnEventListRestricted+0x1a>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  403604:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403608:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40360c:	681b      	ldr	r3, [r3, #0]
  40360e:	f103 0318 	add.w	r3, r3, #24
  403612:	6878      	ldr	r0, [r7, #4]
  403614:	4619      	mov	r1, r3
  403616:	f641 2381 	movw	r3, #6785	; 0x1a81
  40361a:	f2c0 0340 	movt	r3, #64	; 0x40
  40361e:	4798      	blx	r3

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  403620:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403624:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403628:	681b      	ldr	r3, [r3, #0]
  40362a:	f103 0304 	add.w	r3, r3, #4
  40362e:	4618      	mov	r0, r3
  403630:	f641 333d 	movw	r3, #6973	; 0x1b3d
  403634:	f2c0 0340 	movt	r3, #64	; 0x40
  403638:	4798      	blx	r3
  40363a:	4603      	mov	r3, r0
  40363c:	2b00      	cmp	r3, #0
  40363e:	d116      	bne.n	40366e <vTaskPlaceOnEventListRestricted+0x86>
		{
			/* The current task must be in a ready list, so there is no need to
			check, and the port reset macro can be called directly. */
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  403640:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403644:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403648:	681b      	ldr	r3, [r3, #0]
  40364a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40364c:	f04f 0201 	mov.w	r2, #1
  403650:	fa02 f303 	lsl.w	r3, r2, r3
  403654:	ea6f 0203 	mvn.w	r2, r3
  403658:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  40365c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403660:	681b      	ldr	r3, [r3, #0]
  403662:	401a      	ands	r2, r3
  403664:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403668:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40366c:	601a      	str	r2, [r3, #0]
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
  40366e:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  403672:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403676:	681a      	ldr	r2, [r3, #0]
  403678:	683b      	ldr	r3, [r7, #0]
  40367a:	18d3      	adds	r3, r2, r3
  40367c:	60fb      	str	r3, [r7, #12]

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
  40367e:	68f8      	ldr	r0, [r7, #12]
  403680:	f643 3319 	movw	r3, #15129	; 0x3b19
  403684:	f2c0 0340 	movt	r3, #64	; 0x40
  403688:	4798      	blx	r3
	}
  40368a:	f107 0710 	add.w	r7, r7, #16
  40368e:	46bd      	mov	sp, r7
  403690:	bd80      	pop	{r7, pc}
  403692:	bf00      	nop

00403694 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
  403694:	b580      	push	{r7, lr}
  403696:	b084      	sub	sp, #16
  403698:	af00      	add	r7, sp, #0
  40369a:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  40369c:	687b      	ldr	r3, [r7, #4]
  40369e:	68db      	ldr	r3, [r3, #12]
  4036a0:	68db      	ldr	r3, [r3, #12]
  4036a2:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
  4036a4:	68bb      	ldr	r3, [r7, #8]
  4036a6:	2b00      	cmp	r3, #0
  4036a8:	d105      	bne.n	4036b6 <xTaskRemoveFromEventList+0x22>
  4036aa:	f641 6305 	movw	r3, #7685	; 0x1e05
  4036ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4036b2:	4798      	blx	r3
  4036b4:	e7fe      	b.n	4036b4 <xTaskRemoveFromEventList+0x20>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  4036b6:	68bb      	ldr	r3, [r7, #8]
  4036b8:	f103 0318 	add.w	r3, r3, #24
  4036bc:	4618      	mov	r0, r3
  4036be:	f641 333d 	movw	r3, #6973	; 0x1b3d
  4036c2:	f2c0 0340 	movt	r3, #64	; 0x40
  4036c6:	4798      	blx	r3

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4036c8:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  4036cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4036d0:	681b      	ldr	r3, [r3, #0]
  4036d2:	2b00      	cmp	r3, #0
  4036d4:	d131      	bne.n	40373a <xTaskRemoveFromEventList+0xa6>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  4036d6:	68bb      	ldr	r3, [r7, #8]
  4036d8:	f103 0304 	add.w	r3, r3, #4
  4036dc:	4618      	mov	r0, r3
  4036de:	f641 333d 	movw	r3, #6973	; 0x1b3d
  4036e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4036e6:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
  4036e8:	68bb      	ldr	r3, [r7, #8]
  4036ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4036ec:	f04f 0201 	mov.w	r2, #1
  4036f0:	fa02 f203 	lsl.w	r2, r2, r3
  4036f4:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  4036f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4036fc:	681b      	ldr	r3, [r3, #0]
  4036fe:	431a      	orrs	r2, r3
  403700:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403704:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403708:	601a      	str	r2, [r3, #0]
  40370a:	68bb      	ldr	r3, [r7, #8]
  40370c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40370e:	4613      	mov	r3, r2
  403710:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403714:	189b      	adds	r3, r3, r2
  403716:	ea4f 0383 	mov.w	r3, r3, lsl #2
  40371a:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  40371e:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403722:	189a      	adds	r2, r3, r2
  403724:	68bb      	ldr	r3, [r7, #8]
  403726:	f103 0304 	add.w	r3, r3, #4
  40372a:	4610      	mov	r0, r2
  40372c:	4619      	mov	r1, r3
  40372e:	f641 2381 	movw	r3, #6785	; 0x1a81
  403732:	f2c0 0340 	movt	r3, #64	; 0x40
  403736:	4798      	blx	r3
  403738:	e00c      	b.n	403754 <xTaskRemoveFromEventList+0xc0>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  40373a:	68bb      	ldr	r3, [r7, #8]
  40373c:	f103 0318 	add.w	r3, r3, #24
  403740:	f24a 5084 	movw	r0, #42372	; 0xa584
  403744:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403748:	4619      	mov	r1, r3
  40374a:	f641 2381 	movw	r3, #6785	; 0x1a81
  40374e:	f2c0 0340 	movt	r3, #64	; 0x40
  403752:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  403754:	68bb      	ldr	r3, [r7, #8]
  403756:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403758:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  40375c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403760:	681b      	ldr	r3, [r3, #0]
  403762:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403764:	429a      	cmp	r2, r3
  403766:	d30a      	bcc.n	40377e <xTaskRemoveFromEventList+0xea>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
  403768:	f04f 0301 	mov.w	r3, #1
  40376c:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
  40376e:	f24a 53dc 	movw	r3, #42460	; 0xa5dc
  403772:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403776:	f04f 0201 	mov.w	r2, #1
  40377a:	601a      	str	r2, [r3, #0]
  40377c:	e002      	b.n	403784 <xTaskRemoveFromEventList+0xf0>
	}
	else
	{
		xReturn = pdFALSE;
  40377e:	f04f 0300 	mov.w	r3, #0
  403782:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
  403784:	68fb      	ldr	r3, [r7, #12]
}
  403786:	4618      	mov	r0, r3
  403788:	f107 0710 	add.w	r7, r7, #16
  40378c:	46bd      	mov	sp, r7
  40378e:	bd80      	pop	{r7, pc}

00403790 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
  403790:	b580      	push	{r7, lr}
  403792:	b082      	sub	sp, #8
  403794:	af00      	add	r7, sp, #0
  403796:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
  403798:	687b      	ldr	r3, [r7, #4]
  40379a:	2b00      	cmp	r3, #0
  40379c:	d105      	bne.n	4037aa <vTaskSetTimeOutState+0x1a>
  40379e:	f641 6305 	movw	r3, #7685	; 0x1e05
  4037a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4037a6:	4798      	blx	r3
  4037a8:	e7fe      	b.n	4037a8 <vTaskSetTimeOutState+0x18>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  4037aa:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  4037ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4037b2:	681a      	ldr	r2, [r3, #0]
  4037b4:	687b      	ldr	r3, [r7, #4]
  4037b6:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  4037b8:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  4037bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4037c0:	681a      	ldr	r2, [r3, #0]
  4037c2:	687b      	ldr	r3, [r7, #4]
  4037c4:	605a      	str	r2, [r3, #4]
}
  4037c6:	f107 0708 	add.w	r7, r7, #8
  4037ca:	46bd      	mov	sp, r7
  4037cc:	bd80      	pop	{r7, pc}
  4037ce:	bf00      	nop

004037d0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  4037d0:	b580      	push	{r7, lr}
  4037d2:	b084      	sub	sp, #16
  4037d4:	af00      	add	r7, sp, #0
  4037d6:	6078      	str	r0, [r7, #4]
  4037d8:	6039      	str	r1, [r7, #0]
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
  4037da:	687b      	ldr	r3, [r7, #4]
  4037dc:	2b00      	cmp	r3, #0
  4037de:	d105      	bne.n	4037ec <xTaskCheckForTimeOut+0x1c>
  4037e0:	f641 6305 	movw	r3, #7685	; 0x1e05
  4037e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4037e8:	4798      	blx	r3
  4037ea:	e7fe      	b.n	4037ea <xTaskCheckForTimeOut+0x1a>
	configASSERT( pxTicksToWait );
  4037ec:	683b      	ldr	r3, [r7, #0]
  4037ee:	2b00      	cmp	r3, #0
  4037f0:	d105      	bne.n	4037fe <xTaskCheckForTimeOut+0x2e>
  4037f2:	f641 6305 	movw	r3, #7685	; 0x1e05
  4037f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4037fa:	4798      	blx	r3
  4037fc:	e7fe      	b.n	4037fc <xTaskCheckForTimeOut+0x2c>

	taskENTER_CRITICAL();
  4037fe:	f641 5399 	movw	r3, #7577	; 0x1d99
  403802:	f2c0 0340 	movt	r3, #64	; 0x40
  403806:	4798      	blx	r3
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const portTickType xConstTickCount = xTickCount;
  403808:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  40380c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403810:	681b      	ldr	r3, [r3, #0]
  403812:	60bb      	str	r3, [r7, #8]

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
  403814:	683b      	ldr	r3, [r7, #0]
  403816:	681b      	ldr	r3, [r3, #0]
  403818:	f1b3 3fff 	cmp.w	r3, #4294967295
  40381c:	d103      	bne.n	403826 <xTaskCheckForTimeOut+0x56>
			{
				xReturn = pdFALSE;
  40381e:	f04f 0300 	mov.w	r3, #0
  403822:	60fb      	str	r3, [r7, #12]
  403824:	e02f      	b.n	403886 <xTaskCheckForTimeOut+0xb6>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  403826:	687b      	ldr	r3, [r7, #4]
  403828:	681a      	ldr	r2, [r3, #0]
  40382a:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  40382e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403832:	681b      	ldr	r3, [r3, #0]
  403834:	429a      	cmp	r2, r3
  403836:	d008      	beq.n	40384a <xTaskCheckForTimeOut+0x7a>
  403838:	687b      	ldr	r3, [r7, #4]
  40383a:	685a      	ldr	r2, [r3, #4]
  40383c:	68bb      	ldr	r3, [r7, #8]
  40383e:	429a      	cmp	r2, r3
  403840:	d803      	bhi.n	40384a <xTaskCheckForTimeOut+0x7a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
  403842:	f04f 0301 	mov.w	r3, #1
  403846:	60fb      	str	r3, [r7, #12]
  403848:	e01d      	b.n	403886 <xTaskCheckForTimeOut+0xb6>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
  40384a:	687b      	ldr	r3, [r7, #4]
  40384c:	685b      	ldr	r3, [r3, #4]
  40384e:	68ba      	ldr	r2, [r7, #8]
  403850:	1ad2      	subs	r2, r2, r3
  403852:	683b      	ldr	r3, [r7, #0]
  403854:	681b      	ldr	r3, [r3, #0]
  403856:	429a      	cmp	r2, r3
  403858:	d212      	bcs.n	403880 <xTaskCheckForTimeOut+0xb0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
  40385a:	683b      	ldr	r3, [r7, #0]
  40385c:	681a      	ldr	r2, [r3, #0]
  40385e:	687b      	ldr	r3, [r7, #4]
  403860:	6859      	ldr	r1, [r3, #4]
  403862:	68bb      	ldr	r3, [r7, #8]
  403864:	1acb      	subs	r3, r1, r3
  403866:	18d2      	adds	r2, r2, r3
  403868:	683b      	ldr	r3, [r7, #0]
  40386a:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
  40386c:	6878      	ldr	r0, [r7, #4]
  40386e:	f243 7391 	movw	r3, #14225	; 0x3791
  403872:	f2c0 0340 	movt	r3, #64	; 0x40
  403876:	4798      	blx	r3
			xReturn = pdFALSE;
  403878:	f04f 0300 	mov.w	r3, #0
  40387c:	60fb      	str	r3, [r7, #12]
  40387e:	e002      	b.n	403886 <xTaskCheckForTimeOut+0xb6>
		}
		else
		{
			xReturn = pdTRUE;
  403880:	f04f 0301 	mov.w	r3, #1
  403884:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  403886:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  40388a:	f2c0 0340 	movt	r3, #64	; 0x40
  40388e:	4798      	blx	r3

	return xReturn;
  403890:	68fb      	ldr	r3, [r7, #12]
}
  403892:	4618      	mov	r0, r3
  403894:	f107 0710 	add.w	r7, r7, #16
  403898:	46bd      	mov	sp, r7
  40389a:	bd80      	pop	{r7, pc}

0040389c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
  40389c:	b480      	push	{r7}
  40389e:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
  4038a0:	f24a 53dc 	movw	r3, #42460	; 0xa5dc
  4038a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4038a8:	f04f 0201 	mov.w	r2, #1
  4038ac:	601a      	str	r2, [r3, #0]
}
  4038ae:	46bd      	mov	sp, r7
  4038b0:	bc80      	pop	{r7}
  4038b2:	4770      	bx	lr

004038b4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  4038b4:	b580      	push	{r7, lr}
  4038b6:	b082      	sub	sp, #8
  4038b8:	af00      	add	r7, sp, #0
  4038ba:	6078      	str	r0, [r7, #4]
  4038bc:	e000      	b.n	4038c0 <prvIdleTask+0xc>
				}
				( void ) xTaskResumeAll();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
  4038be:	bf00      	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
  4038c0:	f643 2359 	movw	r3, #14937	; 0x3a59
  4038c4:	f2c0 0340 	movt	r3, #64	; 0x40
  4038c8:	4798      	blx	r3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  4038ca:	f24a 43f0 	movw	r3, #42224	; 0xa4f0
  4038ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4038d2:	681b      	ldr	r3, [r3, #0]
  4038d4:	2b01      	cmp	r3, #1
  4038d6:	d9f2      	bls.n	4038be <prvIdleTask+0xa>
			{
				taskYIELD();
  4038d8:	f641 5379 	movw	r3, #7545	; 0x1d79
  4038dc:	f2c0 0340 	movt	r3, #64	; 0x40
  4038e0:	4798      	blx	r3
				}
				( void ) xTaskResumeAll();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
  4038e2:	e7ec      	b.n	4038be <prvIdleTask+0xa>

004038e4 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
  4038e4:	b580      	push	{r7, lr}
  4038e6:	b086      	sub	sp, #24
  4038e8:	af00      	add	r7, sp, #0
  4038ea:	60f8      	str	r0, [r7, #12]
  4038ec:	60b9      	str	r1, [r7, #8]
  4038ee:	607a      	str	r2, [r7, #4]
  4038f0:	603b      	str	r3, [r7, #0]
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
  4038f2:	f04f 0300 	mov.w	r3, #0
  4038f6:	617b      	str	r3, [r7, #20]
  4038f8:	e013      	b.n	403922 <prvInitialiseTCBVariables+0x3e>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
  4038fa:	68ba      	ldr	r2, [r7, #8]
  4038fc:	697b      	ldr	r3, [r7, #20]
  4038fe:	18d3      	adds	r3, r2, r3
  403900:	781a      	ldrb	r2, [r3, #0]
  403902:	68f9      	ldr	r1, [r7, #12]
  403904:	697b      	ldr	r3, [r7, #20]
  403906:	18cb      	adds	r3, r1, r3
  403908:	f103 0330 	add.w	r3, r3, #48	; 0x30
  40390c:	711a      	strb	r2, [r3, #4]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
  40390e:	68ba      	ldr	r2, [r7, #8]
  403910:	697b      	ldr	r3, [r7, #20]
  403912:	18d3      	adds	r3, r2, r3
  403914:	781b      	ldrb	r3, [r3, #0]
  403916:	2b00      	cmp	r3, #0
  403918:	d007      	beq.n	40392a <prvInitialiseTCBVariables+0x46>
static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
  40391a:	697b      	ldr	r3, [r7, #20]
  40391c:	f103 0301 	add.w	r3, r3, #1
  403920:	617b      	str	r3, [r7, #20]
  403922:	697b      	ldr	r3, [r7, #20]
  403924:	2b09      	cmp	r3, #9
  403926:	d9e8      	bls.n	4038fa <prvInitialiseTCBVariables+0x16>
  403928:	e000      	b.n	40392c <prvInitialiseTCBVariables+0x48>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
  40392a:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
  40392c:	68fb      	ldr	r3, [r7, #12]
  40392e:	f04f 0200 	mov.w	r2, #0
  403932:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
  403936:	687b      	ldr	r3, [r7, #4]
  403938:	2b04      	cmp	r3, #4
  40393a:	d902      	bls.n	403942 <prvInitialiseTCBVariables+0x5e>
	{
		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
  40393c:	f04f 0304 	mov.w	r3, #4
  403940:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
  403942:	68fb      	ldr	r3, [r7, #12]
  403944:	687a      	ldr	r2, [r7, #4]
  403946:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
  403948:	68fb      	ldr	r3, [r7, #12]
  40394a:	687a      	ldr	r2, [r7, #4]
  40394c:	641a      	str	r2, [r3, #64]	; 0x40
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  40394e:	68fb      	ldr	r3, [r7, #12]
  403950:	f103 0304 	add.w	r3, r3, #4
  403954:	4618      	mov	r0, r3
  403956:	f641 2365 	movw	r3, #6757	; 0x1a65
  40395a:	f2c0 0340 	movt	r3, #64	; 0x40
  40395e:	4798      	blx	r3
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
  403960:	68fb      	ldr	r3, [r7, #12]
  403962:	f103 0318 	add.w	r3, r3, #24
  403966:	4618      	mov	r0, r3
  403968:	f641 2365 	movw	r3, #6757	; 0x1a65
  40396c:	f2c0 0340 	movt	r3, #64	; 0x40
  403970:	4798      	blx	r3

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
  403972:	68fb      	ldr	r3, [r7, #12]
  403974:	68fa      	ldr	r2, [r7, #12]
  403976:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  403978:	687b      	ldr	r3, [r7, #4]
  40397a:	f1c3 0205 	rsb	r2, r3, #5
  40397e:	68fb      	ldr	r3, [r7, #12]
  403980:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
  403982:	68fb      	ldr	r3, [r7, #12]
  403984:	68fa      	ldr	r2, [r7, #12]
  403986:	625a      	str	r2, [r3, #36]	; 0x24
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
  403988:	f107 0718 	add.w	r7, r7, #24
  40398c:	46bd      	mov	sp, r7
  40398e:	bd80      	pop	{r7, pc}

00403990 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
  403990:	b580      	push	{r7, lr}
  403992:	b082      	sub	sp, #8
  403994:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
  403996:	f04f 0300 	mov.w	r3, #0
  40399a:	607b      	str	r3, [r7, #4]
  40399c:	e015      	b.n	4039ca <prvInitialiseTaskLists+0x3a>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  40399e:	687a      	ldr	r2, [r7, #4]
  4039a0:	4613      	mov	r3, r2
  4039a2:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4039a6:	189b      	adds	r3, r3, r2
  4039a8:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4039ac:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  4039b0:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4039b4:	189b      	adds	r3, r3, r2
  4039b6:	4618      	mov	r0, r3
  4039b8:	f641 2325 	movw	r3, #6693	; 0x1a25
  4039bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4039c0:	4798      	blx	r3

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
  4039c2:	687b      	ldr	r3, [r7, #4]
  4039c4:	f103 0301 	add.w	r3, r3, #1
  4039c8:	607b      	str	r3, [r7, #4]
  4039ca:	687b      	ldr	r3, [r7, #4]
  4039cc:	2b04      	cmp	r3, #4
  4039ce:	d9e6      	bls.n	40399e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
  4039d0:	f24a 5054 	movw	r0, #42324	; 0xa554
  4039d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4039d8:	f641 2325 	movw	r3, #6693	; 0x1a25
  4039dc:	f2c0 0340 	movt	r3, #64	; 0x40
  4039e0:	4798      	blx	r3
	vListInitialise( &xDelayedTaskList2 );
  4039e2:	f24a 5068 	movw	r0, #42344	; 0xa568
  4039e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4039ea:	f641 2325 	movw	r3, #6693	; 0x1a25
  4039ee:	f2c0 0340 	movt	r3, #64	; 0x40
  4039f2:	4798      	blx	r3
	vListInitialise( &xPendingReadyList );
  4039f4:	f24a 5084 	movw	r0, #42372	; 0xa584
  4039f8:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4039fc:	f641 2325 	movw	r3, #6693	; 0x1a25
  403a00:	f2c0 0340 	movt	r3, #64	; 0x40
  403a04:	4798      	blx	r3

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
  403a06:	f24a 5098 	movw	r0, #42392	; 0xa598
  403a0a:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403a0e:	f641 2325 	movw	r3, #6693	; 0x1a25
  403a12:	f2c0 0340 	movt	r3, #64	; 0x40
  403a16:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
  403a18:	f24a 50b0 	movw	r0, #42416	; 0xa5b0
  403a1c:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403a20:	f641 2325 	movw	r3, #6693	; 0x1a25
  403a24:	f2c0 0340 	movt	r3, #64	; 0x40
  403a28:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  403a2a:	f24a 537c 	movw	r3, #42364	; 0xa57c
  403a2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403a32:	f24a 5254 	movw	r2, #42324	; 0xa554
  403a36:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403a3a:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  403a3c:	f24a 5380 	movw	r3, #42368	; 0xa580
  403a40:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403a44:	f24a 5268 	movw	r2, #42344	; 0xa568
  403a48:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403a4c:	601a      	str	r2, [r3, #0]
}
  403a4e:	f107 0708 	add.w	r7, r7, #8
  403a52:	46bd      	mov	sp, r7
  403a54:	bd80      	pop	{r7, pc}
  403a56:	bf00      	nop

00403a58 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
  403a58:	b580      	push	{r7, lr}
  403a5a:	b082      	sub	sp, #8
  403a5c:	af00      	add	r7, sp, #0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  403a5e:	e04f      	b.n	403b00 <prvCheckTasksWaitingTermination+0xa8>
		{
			vTaskSuspendAll();
  403a60:	f642 7331 	movw	r3, #12081	; 0x2f31
  403a64:	f2c0 0340 	movt	r3, #64	; 0x40
  403a68:	4798      	blx	r3
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  403a6a:	f24a 5398 	movw	r3, #42392	; 0xa598
  403a6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403a72:	681b      	ldr	r3, [r3, #0]
  403a74:	2b00      	cmp	r3, #0
  403a76:	bf14      	ite	ne
  403a78:	2300      	movne	r3, #0
  403a7a:	2301      	moveq	r3, #1
  403a7c:	b2db      	uxtb	r3, r3
  403a7e:	607b      	str	r3, [r7, #4]
			( void ) xTaskResumeAll();
  403a80:	f642 7355 	movw	r3, #12117	; 0x2f55
  403a84:	f2c0 0340 	movt	r3, #64	; 0x40
  403a88:	4798      	blx	r3

			if( xListIsEmpty == pdFALSE )
  403a8a:	687b      	ldr	r3, [r7, #4]
  403a8c:	2b00      	cmp	r3, #0
  403a8e:	d137      	bne.n	403b00 <prvCheckTasksWaitingTermination+0xa8>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
  403a90:	f641 5399 	movw	r3, #7577	; 0x1d99
  403a94:	f2c0 0340 	movt	r3, #64	; 0x40
  403a98:	4798      	blx	r3
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
  403a9a:	f24a 5398 	movw	r3, #42392	; 0xa598
  403a9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403aa2:	68db      	ldr	r3, [r3, #12]
  403aa4:	68db      	ldr	r3, [r3, #12]
  403aa6:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
  403aa8:	683b      	ldr	r3, [r7, #0]
  403aaa:	f103 0304 	add.w	r3, r3, #4
  403aae:	4618      	mov	r0, r3
  403ab0:	f641 333d 	movw	r3, #6973	; 0x1b3d
  403ab4:	f2c0 0340 	movt	r3, #64	; 0x40
  403ab8:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
  403aba:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403abe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ac2:	681b      	ldr	r3, [r3, #0]
  403ac4:	f103 32ff 	add.w	r2, r3, #4294967295
  403ac8:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403acc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ad0:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
  403ad2:	f24a 53ac 	movw	r3, #42412	; 0xa5ac
  403ad6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ada:	681b      	ldr	r3, [r3, #0]
  403adc:	f103 32ff 	add.w	r2, r3, #4294967295
  403ae0:	f24a 53ac 	movw	r3, #42412	; 0xa5ac
  403ae4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ae8:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
  403aea:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  403aee:	f2c0 0340 	movt	r3, #64	; 0x40
  403af2:	4798      	blx	r3

				prvDeleteTCB( pxTCB );
  403af4:	6838      	ldr	r0, [r7, #0]
  403af6:	f643 4339 	movw	r3, #15417	; 0x3c39
  403afa:	f2c0 0340 	movt	r3, #64	; 0x40
  403afe:	4798      	blx	r3
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  403b00:	f24a 53ac 	movw	r3, #42412	; 0xa5ac
  403b04:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b08:	681b      	ldr	r3, [r3, #0]
  403b0a:	2b00      	cmp	r3, #0
  403b0c:	d1a8      	bne.n	403a60 <prvCheckTasksWaitingTermination+0x8>
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif /* vTaskDelete */
}
  403b0e:	f107 0708 	add.w	r7, r7, #8
  403b12:	46bd      	mov	sp, r7
  403b14:	bd80      	pop	{r7, pc}
  403b16:	bf00      	nop

00403b18 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  403b18:	b580      	push	{r7, lr}
  403b1a:	b082      	sub	sp, #8
  403b1c:	af00      	add	r7, sp, #0
  403b1e:	6078      	str	r0, [r7, #4]
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  403b20:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403b24:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b28:	681b      	ldr	r3, [r3, #0]
  403b2a:	687a      	ldr	r2, [r7, #4]
  403b2c:	605a      	str	r2, [r3, #4]

	if( xTimeToWake < xTickCount )
  403b2e:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  403b32:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b36:	681b      	ldr	r3, [r3, #0]
  403b38:	687a      	ldr	r2, [r7, #4]
  403b3a:	429a      	cmp	r2, r3
  403b3c:	d213      	bcs.n	403b66 <prvAddCurrentTaskToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
  403b3e:	f24a 5380 	movw	r3, #42368	; 0xa580
  403b42:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b46:	681a      	ldr	r2, [r3, #0]
  403b48:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403b4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b50:	681b      	ldr	r3, [r3, #0]
  403b52:	f103 0304 	add.w	r3, r3, #4
  403b56:	4610      	mov	r0, r2
  403b58:	4619      	mov	r1, r3
  403b5a:	f641 23c9 	movw	r3, #6857	; 0x1ac9
  403b5e:	f2c0 0340 	movt	r3, #64	; 0x40
  403b62:	4798      	blx	r3
  403b64:	e020      	b.n	403ba8 <prvAddCurrentTaskToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
  403b66:	f24a 537c 	movw	r3, #42364	; 0xa57c
  403b6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b6e:	681a      	ldr	r2, [r3, #0]
  403b70:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403b74:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b78:	681b      	ldr	r3, [r3, #0]
  403b7a:	f103 0304 	add.w	r3, r3, #4
  403b7e:	4610      	mov	r0, r2
  403b80:	4619      	mov	r1, r3
  403b82:	f641 23c9 	movw	r3, #6857	; 0x1ac9
  403b86:	f2c0 0340 	movt	r3, #64	; 0x40
  403b8a:	4798      	blx	r3

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
  403b8c:	f240 030c 	movw	r3, #12
  403b90:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b94:	681b      	ldr	r3, [r3, #0]
  403b96:	687a      	ldr	r2, [r7, #4]
  403b98:	429a      	cmp	r2, r3
  403b9a:	d205      	bcs.n	403ba8 <prvAddCurrentTaskToDelayedList+0x90>
		{
			xNextTaskUnblockTime = xTimeToWake;
  403b9c:	f240 030c 	movw	r3, #12
  403ba0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ba4:	687a      	ldr	r2, [r7, #4]
  403ba6:	601a      	str	r2, [r3, #0]
		}
	}
}
  403ba8:	f107 0708 	add.w	r7, r7, #8
  403bac:	46bd      	mov	sp, r7
  403bae:	bd80      	pop	{r7, pc}

00403bb0 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
  403bb0:	b580      	push	{r7, lr}
  403bb2:	b084      	sub	sp, #16
  403bb4:	af00      	add	r7, sp, #0
  403bb6:	4603      	mov	r3, r0
  403bb8:	6039      	str	r1, [r7, #0]
  403bba:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
  403bbc:	f04f 0044 	mov.w	r0, #68	; 0x44
  403bc0:	f240 2385 	movw	r3, #645	; 0x285
  403bc4:	f2c0 0340 	movt	r3, #64	; 0x40
  403bc8:	4798      	blx	r3
  403bca:	60f8      	str	r0, [r7, #12]

	if( pxNewTCB != NULL )
  403bcc:	68fb      	ldr	r3, [r7, #12]
  403bce:	2b00      	cmp	r3, #0
  403bd0:	d02c      	beq.n	403c2c <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  403bd2:	683b      	ldr	r3, [r7, #0]
  403bd4:	2b00      	cmp	r3, #0
  403bd6:	d10a      	bne.n	403bee <prvAllocateTCBAndStack+0x3e>
  403bd8:	88fb      	ldrh	r3, [r7, #6]
  403bda:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403bde:	4618      	mov	r0, r3
  403be0:	f240 2385 	movw	r3, #645	; 0x285
  403be4:	f2c0 0340 	movt	r3, #64	; 0x40
  403be8:	4798      	blx	r3
  403bea:	4603      	mov	r3, r0
  403bec:	e000      	b.n	403bf0 <prvAllocateTCBAndStack+0x40>
  403bee:	683b      	ldr	r3, [r7, #0]
  403bf0:	68fa      	ldr	r2, [r7, #12]
  403bf2:	6313      	str	r3, [r2, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
  403bf4:	68fb      	ldr	r3, [r7, #12]
  403bf6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  403bf8:	2b00      	cmp	r3, #0
  403bfa:	d109      	bne.n	403c10 <prvAllocateTCBAndStack+0x60>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
  403bfc:	68f8      	ldr	r0, [r7, #12]
  403bfe:	f240 4305 	movw	r3, #1029	; 0x405
  403c02:	f2c0 0340 	movt	r3, #64	; 0x40
  403c06:	4798      	blx	r3
			pxNewTCB = NULL;
  403c08:	f04f 0300 	mov.w	r3, #0
  403c0c:	60fb      	str	r3, [r7, #12]
  403c0e:	e00d      	b.n	403c2c <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
  403c10:	68fb      	ldr	r3, [r7, #12]
  403c12:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  403c14:	88fb      	ldrh	r3, [r7, #6]
  403c16:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403c1a:	4610      	mov	r0, r2
  403c1c:	f04f 01a5 	mov.w	r1, #165	; 0xa5
  403c20:	461a      	mov	r2, r3
  403c22:	f644 239d 	movw	r3, #19101	; 0x4a9d
  403c26:	f2c0 0340 	movt	r3, #64	; 0x40
  403c2a:	4798      	blx	r3
		}
	}

	return pxNewTCB;
  403c2c:	68fb      	ldr	r3, [r7, #12]
}
  403c2e:	4618      	mov	r0, r3
  403c30:	f107 0710 	add.w	r7, r7, #16
  403c34:	46bd      	mov	sp, r7
  403c36:	bd80      	pop	{r7, pc}

00403c38 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
  403c38:	b580      	push	{r7, lr}
  403c3a:	b082      	sub	sp, #8
  403c3c:	af00      	add	r7, sp, #0
  403c3e:	6078      	str	r0, [r7, #4]
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
  403c40:	687b      	ldr	r3, [r7, #4]
  403c42:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  403c44:	4618      	mov	r0, r3
  403c46:	f240 4305 	movw	r3, #1029	; 0x405
  403c4a:	f2c0 0340 	movt	r3, #64	; 0x40
  403c4e:	4798      	blx	r3
		vPortFree( pxTCB );
  403c50:	6878      	ldr	r0, [r7, #4]
  403c52:	f240 4305 	movw	r3, #1029	; 0x405
  403c56:	f2c0 0340 	movt	r3, #64	; 0x40
  403c5a:	4798      	blx	r3
	}
  403c5c:	f107 0708 	add.w	r7, r7, #8
  403c60:	46bd      	mov	sp, r7
  403c62:	bd80      	pop	{r7, pc}

00403c64 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
  403c64:	b480      	push	{r7}
  403c66:	b083      	sub	sp, #12
  403c68:	af00      	add	r7, sp, #0
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  403c6a:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403c6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403c72:	681b      	ldr	r3, [r3, #0]
  403c74:	607b      	str	r3, [r7, #4]

		return xReturn;
  403c76:	687b      	ldr	r3, [r7, #4]
	}
  403c78:	4618      	mov	r0, r3
  403c7a:	f107 070c 	add.w	r7, r7, #12
  403c7e:	46bd      	mov	sp, r7
  403c80:	bc80      	pop	{r7}
  403c82:	4770      	bx	lr

00403c84 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
  403c84:	b480      	push	{r7}
  403c86:	b083      	sub	sp, #12
  403c88:	af00      	add	r7, sp, #0
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
  403c8a:	f24a 53d0 	movw	r3, #42448	; 0xa5d0
  403c8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403c92:	681b      	ldr	r3, [r3, #0]
  403c94:	2b00      	cmp	r3, #0
  403c96:	d103      	bne.n	403ca0 <xTaskGetSchedulerState+0x1c>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
  403c98:	f04f 0300 	mov.w	r3, #0
  403c9c:	607b      	str	r3, [r7, #4]
  403c9e:	e00d      	b.n	403cbc <xTaskGetSchedulerState+0x38>
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  403ca0:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  403ca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ca8:	681b      	ldr	r3, [r3, #0]
  403caa:	2b00      	cmp	r3, #0
  403cac:	d103      	bne.n	403cb6 <xTaskGetSchedulerState+0x32>
			{
				xReturn = taskSCHEDULER_RUNNING;
  403cae:	f04f 0301 	mov.w	r3, #1
  403cb2:	607b      	str	r3, [r7, #4]
  403cb4:	e002      	b.n	403cbc <xTaskGetSchedulerState+0x38>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
  403cb6:	f04f 0302 	mov.w	r3, #2
  403cba:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
  403cbc:	687b      	ldr	r3, [r7, #4]
	}
  403cbe:	4618      	mov	r0, r3
  403cc0:	f107 070c 	add.w	r7, r7, #12
  403cc4:	46bd      	mov	sp, r7
  403cc6:	bc80      	pop	{r7}
  403cc8:	4770      	bx	lr
  403cca:	bf00      	nop

00403ccc <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle const pxMutexHolder )
	{
  403ccc:	b580      	push	{r7, lr}
  403cce:	b084      	sub	sp, #16
  403cd0:	af00      	add	r7, sp, #0
  403cd2:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
  403cd4:	687b      	ldr	r3, [r7, #4]
  403cd6:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
  403cd8:	687b      	ldr	r3, [r7, #4]
  403cda:	2b00      	cmp	r3, #0
  403cdc:	f000 8095 	beq.w	403e0a <vTaskPriorityInherit+0x13e>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  403ce0:	68fb      	ldr	r3, [r7, #12]
  403ce2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403ce4:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403ce8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403cec:	681b      	ldr	r3, [r3, #0]
  403cee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403cf0:	429a      	cmp	r2, r3
  403cf2:	f080 808a 	bcs.w	403e0a <vTaskPriorityInherit+0x13e>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  403cf6:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403cfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403cfe:	681b      	ldr	r3, [r3, #0]
  403d00:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403d02:	f1c3 0205 	rsb	r2, r3, #5
  403d06:	68fb      	ldr	r3, [r7, #12]
  403d08:	619a      	str	r2, [r3, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
  403d0a:	68fb      	ldr	r3, [r7, #12]
  403d0c:	6959      	ldr	r1, [r3, #20]
  403d0e:	68fb      	ldr	r3, [r7, #12]
  403d10:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403d12:	4613      	mov	r3, r2
  403d14:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403d18:	189b      	adds	r3, r3, r2
  403d1a:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403d1e:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  403d22:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403d26:	189b      	adds	r3, r3, r2
  403d28:	4299      	cmp	r1, r3
  403d2a:	d102      	bne.n	403d32 <vTaskPriorityInherit+0x66>
  403d2c:	f04f 0301 	mov.w	r3, #1
  403d30:	e001      	b.n	403d36 <vTaskPriorityInherit+0x6a>
  403d32:	f04f 0300 	mov.w	r3, #0
  403d36:	2b00      	cmp	r3, #0
  403d38:	d05f      	beq.n	403dfa <vTaskPriorityInherit+0x12e>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  403d3a:	68fb      	ldr	r3, [r7, #12]
  403d3c:	f103 0304 	add.w	r3, r3, #4
  403d40:	4618      	mov	r0, r3
  403d42:	f641 333d 	movw	r3, #6973	; 0x1b3d
  403d46:	f2c0 0340 	movt	r3, #64	; 0x40
  403d4a:	4798      	blx	r3
  403d4c:	4603      	mov	r3, r0
  403d4e:	2b00      	cmp	r3, #0
  403d50:	d122      	bne.n	403d98 <vTaskPriorityInherit+0xcc>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  403d52:	68fb      	ldr	r3, [r7, #12]
  403d54:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  403d56:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  403d5a:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403d5e:	460b      	mov	r3, r1
  403d60:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403d64:	185b      	adds	r3, r3, r1
  403d66:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403d6a:	18d3      	adds	r3, r2, r3
  403d6c:	681b      	ldr	r3, [r3, #0]
  403d6e:	2b00      	cmp	r3, #0
  403d70:	d112      	bne.n	403d98 <vTaskPriorityInherit+0xcc>
  403d72:	68fb      	ldr	r3, [r7, #12]
  403d74:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403d76:	f04f 0201 	mov.w	r2, #1
  403d7a:	fa02 f303 	lsl.w	r3, r2, r3
  403d7e:	ea6f 0203 	mvn.w	r2, r3
  403d82:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403d86:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d8a:	681b      	ldr	r3, [r3, #0]
  403d8c:	401a      	ands	r2, r3
  403d8e:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403d92:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d96:	601a      	str	r2, [r3, #0]
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  403d98:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403d9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403da0:	681b      	ldr	r3, [r3, #0]
  403da2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403da4:	68fb      	ldr	r3, [r7, #12]
  403da6:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
  403da8:	68fb      	ldr	r3, [r7, #12]
  403daa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403dac:	f04f 0201 	mov.w	r2, #1
  403db0:	fa02 f203 	lsl.w	r2, r2, r3
  403db4:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403db8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403dbc:	681b      	ldr	r3, [r3, #0]
  403dbe:	431a      	orrs	r2, r3
  403dc0:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403dc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403dc8:	601a      	str	r2, [r3, #0]
  403dca:	68fb      	ldr	r3, [r7, #12]
  403dcc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403dce:	4613      	mov	r3, r2
  403dd0:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403dd4:	189b      	adds	r3, r3, r2
  403dd6:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403dda:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  403dde:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403de2:	189a      	adds	r2, r3, r2
  403de4:	68fb      	ldr	r3, [r7, #12]
  403de6:	f103 0304 	add.w	r3, r3, #4
  403dea:	4610      	mov	r0, r2
  403dec:	4619      	mov	r1, r3
  403dee:	f641 2381 	movw	r3, #6785	; 0x1a81
  403df2:	f2c0 0340 	movt	r3, #64	; 0x40
  403df6:	4798      	blx	r3
  403df8:	e007      	b.n	403e0a <vTaskPriorityInherit+0x13e>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  403dfa:	f24a 43ec 	movw	r3, #42220	; 0xa4ec
  403dfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e02:	681b      	ldr	r3, [r3, #0]
  403e04:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403e06:	68fb      	ldr	r3, [r7, #12]
  403e08:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
  403e0a:	f107 0710 	add.w	r7, r7, #16
  403e0e:	46bd      	mov	sp, r7
  403e10:	bd80      	pop	{r7, pc}
  403e12:	bf00      	nop

00403e14 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder )
	{
  403e14:	b580      	push	{r7, lr}
  403e16:	b084      	sub	sp, #16
  403e18:	af00      	add	r7, sp, #0
  403e1a:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
  403e1c:	687b      	ldr	r3, [r7, #4]
  403e1e:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
  403e20:	687b      	ldr	r3, [r7, #4]
  403e22:	2b00      	cmp	r3, #0
  403e24:	d066      	beq.n	403ef4 <vTaskPriorityDisinherit+0xe0>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  403e26:	68fb      	ldr	r3, [r7, #12]
  403e28:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403e2a:	68fb      	ldr	r3, [r7, #12]
  403e2c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  403e2e:	429a      	cmp	r2, r3
  403e30:	d060      	beq.n	403ef4 <vTaskPriorityDisinherit+0xe0>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  403e32:	68fb      	ldr	r3, [r7, #12]
  403e34:	f103 0304 	add.w	r3, r3, #4
  403e38:	4618      	mov	r0, r3
  403e3a:	f641 333d 	movw	r3, #6973	; 0x1b3d
  403e3e:	f2c0 0340 	movt	r3, #64	; 0x40
  403e42:	4798      	blx	r3
  403e44:	4603      	mov	r3, r0
  403e46:	2b00      	cmp	r3, #0
  403e48:	d122      	bne.n	403e90 <vTaskPriorityDisinherit+0x7c>
				{
					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  403e4a:	68fb      	ldr	r3, [r7, #12]
  403e4c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  403e4e:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  403e52:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403e56:	460b      	mov	r3, r1
  403e58:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403e5c:	185b      	adds	r3, r3, r1
  403e5e:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403e62:	18d3      	adds	r3, r2, r3
  403e64:	681b      	ldr	r3, [r3, #0]
  403e66:	2b00      	cmp	r3, #0
  403e68:	d112      	bne.n	403e90 <vTaskPriorityDisinherit+0x7c>
  403e6a:	68fb      	ldr	r3, [r7, #12]
  403e6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403e6e:	f04f 0201 	mov.w	r2, #1
  403e72:	fa02 f303 	lsl.w	r3, r2, r3
  403e76:	ea6f 0203 	mvn.w	r2, r3
  403e7a:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403e7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e82:	681b      	ldr	r3, [r3, #0]
  403e84:	401a      	ands	r2, r3
  403e86:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403e8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e8e:	601a      	str	r2, [r3, #0]
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  403e90:	68fb      	ldr	r3, [r7, #12]
  403e92:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  403e94:	68fb      	ldr	r3, [r7, #12]
  403e96:	62da      	str	r2, [r3, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  403e98:	68fb      	ldr	r3, [r7, #12]
  403e9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403e9c:	f1c3 0205 	rsb	r2, r3, #5
  403ea0:	68fb      	ldr	r3, [r7, #12]
  403ea2:	619a      	str	r2, [r3, #24]
				prvAddTaskToReadyList( pxTCB );
  403ea4:	68fb      	ldr	r3, [r7, #12]
  403ea6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403ea8:	f04f 0201 	mov.w	r2, #1
  403eac:	fa02 f203 	lsl.w	r2, r2, r3
  403eb0:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403eb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403eb8:	681b      	ldr	r3, [r3, #0]
  403eba:	431a      	orrs	r2, r3
  403ebc:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403ec0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ec4:	601a      	str	r2, [r3, #0]
  403ec6:	68fb      	ldr	r3, [r7, #12]
  403ec8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403eca:	4613      	mov	r3, r2
  403ecc:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403ed0:	189b      	adds	r3, r3, r2
  403ed2:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403ed6:	f24a 42f0 	movw	r2, #42224	; 0xa4f0
  403eda:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403ede:	189a      	adds	r2, r3, r2
  403ee0:	68fb      	ldr	r3, [r7, #12]
  403ee2:	f103 0304 	add.w	r3, r3, #4
  403ee6:	4610      	mov	r0, r2
  403ee8:	4619      	mov	r1, r3
  403eea:	f641 2381 	movw	r3, #6785	; 0x1a81
  403eee:	f2c0 0340 	movt	r3, #64	; 0x40
  403ef2:	4798      	blx	r3
			}
		}
	}
  403ef4:	f107 0710 	add.w	r7, r7, #16
  403ef8:	46bd      	mov	sp, r7
  403efa:	bd80      	pop	{r7, pc}

00403efc <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
  403efc:	b590      	push	{r4, r7, lr}
  403efe:	b087      	sub	sp, #28
  403f00:	af04      	add	r7, sp, #16
portBASE_TYPE xReturn = pdFAIL;
  403f02:	f04f 0300 	mov.w	r3, #0
  403f06:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
  403f08:	f244 5345 	movw	r3, #17733	; 0x4545
  403f0c:	f2c0 0340 	movt	r3, #64	; 0x40
  403f10:	4798      	blx	r3

	if( xTimerQueue != NULL )
  403f12:	f24a 6318 	movw	r3, #42520	; 0xa618
  403f16:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403f1a:	681b      	ldr	r3, [r3, #0]
  403f1c:	2b00      	cmp	r3, #0
  403f1e:	d01d      	beq.n	403f5c <xTimerCreateTimerTask+0x60>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
  403f20:	f04f 0302 	mov.w	r3, #2
  403f24:	9300      	str	r3, [sp, #0]
  403f26:	f04f 0300 	mov.w	r3, #0
  403f2a:	9301      	str	r3, [sp, #4]
  403f2c:	f04f 0300 	mov.w	r3, #0
  403f30:	9302      	str	r3, [sp, #8]
  403f32:	f04f 0300 	mov.w	r3, #0
  403f36:	9303      	str	r3, [sp, #12]
  403f38:	f244 00d5 	movw	r0, #16597	; 0x40d5
  403f3c:	f2c0 0040 	movt	r0, #64	; 0x40
  403f40:	f644 21f4 	movw	r1, #19188	; 0x4af4
  403f44:	f2c0 0140 	movt	r1, #64	; 0x40
  403f48:	f44f 7282 	mov.w	r2, #260	; 0x104
  403f4c:	f04f 0300 	mov.w	r3, #0
  403f50:	f642 3479 	movw	r4, #11129	; 0x2b79
  403f54:	f2c0 0440 	movt	r4, #64	; 0x40
  403f58:	47a0      	blx	r4
  403f5a:	6078      	str	r0, [r7, #4]
		}
		#endif
	}

	configASSERT( xReturn );
  403f5c:	687b      	ldr	r3, [r7, #4]
  403f5e:	2b00      	cmp	r3, #0
  403f60:	d105      	bne.n	403f6e <xTimerCreateTimerTask+0x72>
  403f62:	f641 6305 	movw	r3, #7685	; 0x1e05
  403f66:	f2c0 0340 	movt	r3, #64	; 0x40
  403f6a:	4798      	blx	r3
  403f6c:	e7fe      	b.n	403f6c <xTimerCreateTimerTask+0x70>
	return xReturn;
  403f6e:	687b      	ldr	r3, [r7, #4]
}
  403f70:	4618      	mov	r0, r3
  403f72:	f107 070c 	add.w	r7, r7, #12
  403f76:	46bd      	mov	sp, r7
  403f78:	bd90      	pop	{r4, r7, pc}
  403f7a:	bf00      	nop

00403f7c <xTimerGenericCommand>:
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
  403f7c:	b590      	push	{r4, r7, lr}
  403f7e:	b089      	sub	sp, #36	; 0x24
  403f80:	af00      	add	r7, sp, #0
  403f82:	60f8      	str	r0, [r7, #12]
  403f84:	60b9      	str	r1, [r7, #8]
  403f86:	607a      	str	r2, [r7, #4]
  403f88:	603b      	str	r3, [r7, #0]
portBASE_TYPE xReturn = pdFAIL;
  403f8a:	f04f 0300 	mov.w	r3, #0
  403f8e:	61fb      	str	r3, [r7, #28]
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
  403f90:	f24a 6318 	movw	r3, #42520	; 0xa618
  403f94:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403f98:	681b      	ldr	r3, [r3, #0]
  403f9a:	2b00      	cmp	r3, #0
  403f9c:	d049      	beq.n	404032 <xTimerGenericCommand+0xb6>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
  403f9e:	68bb      	ldr	r3, [r7, #8]
  403fa0:	613b      	str	r3, [r7, #16]
		xMessage.xMessageValue = xOptionalValue;
  403fa2:	687b      	ldr	r3, [r7, #4]
  403fa4:	617b      	str	r3, [r7, #20]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
  403fa6:	68fb      	ldr	r3, [r7, #12]
  403fa8:	61bb      	str	r3, [r7, #24]

		if( pxHigherPriorityTaskWoken == NULL )
  403faa:	683b      	ldr	r3, [r7, #0]
  403fac:	2b00      	cmp	r3, #0
  403fae:	d12e      	bne.n	40400e <xTimerGenericCommand+0x92>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  403fb0:	f643 4385 	movw	r3, #15493	; 0x3c85
  403fb4:	f2c0 0340 	movt	r3, #64	; 0x40
  403fb8:	4798      	blx	r3
  403fba:	4603      	mov	r3, r0
  403fbc:	2b01      	cmp	r3, #1
  403fbe:	d112      	bne.n	403fe6 <xTimerGenericCommand+0x6a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
  403fc0:	f24a 6318 	movw	r3, #42520	; 0xa618
  403fc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403fc8:	681a      	ldr	r2, [r3, #0]
  403fca:	f107 0310 	add.w	r3, r7, #16
  403fce:	4610      	mov	r0, r2
  403fd0:	4619      	mov	r1, r3
  403fd2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  403fd4:	f04f 0300 	mov.w	r3, #0
  403fd8:	f242 04dd 	movw	r4, #8413	; 0x20dd
  403fdc:	f2c0 0440 	movt	r4, #64	; 0x40
  403fe0:	47a0      	blx	r4
  403fe2:	61f8      	str	r0, [r7, #28]
  403fe4:	e025      	b.n	404032 <xTimerGenericCommand+0xb6>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  403fe6:	f24a 6318 	movw	r3, #42520	; 0xa618
  403fea:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403fee:	681a      	ldr	r2, [r3, #0]
  403ff0:	f107 0310 	add.w	r3, r7, #16
  403ff4:	4610      	mov	r0, r2
  403ff6:	4619      	mov	r1, r3
  403ff8:	f04f 0200 	mov.w	r2, #0
  403ffc:	f04f 0300 	mov.w	r3, #0
  404000:	f242 04dd 	movw	r4, #8413	; 0x20dd
  404004:	f2c0 0440 	movt	r4, #64	; 0x40
  404008:	47a0      	blx	r4
  40400a:	61f8      	str	r0, [r7, #28]
  40400c:	e011      	b.n	404032 <xTimerGenericCommand+0xb6>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  40400e:	f24a 6318 	movw	r3, #42520	; 0xa618
  404012:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404016:	681a      	ldr	r2, [r3, #0]
  404018:	f107 0310 	add.w	r3, r7, #16
  40401c:	4610      	mov	r0, r2
  40401e:	4619      	mov	r1, r3
  404020:	683a      	ldr	r2, [r7, #0]
  404022:	f04f 0300 	mov.w	r3, #0
  404026:	f242 3411 	movw	r4, #8977	; 0x2311
  40402a:	f2c0 0440 	movt	r4, #64	; 0x40
  40402e:	47a0      	blx	r4
  404030:	61f8      	str	r0, [r7, #28]
		}

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
  404032:	69fb      	ldr	r3, [r7, #28]
}
  404034:	4618      	mov	r0, r3
  404036:	f107 0724 	add.w	r7, r7, #36	; 0x24
  40403a:	46bd      	mov	sp, r7
  40403c:	bd90      	pop	{r4, r7, pc}
  40403e:	bf00      	nop

00404040 <prvProcessExpiredTimer>:

#endif
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
{
  404040:	b590      	push	{r4, r7, lr}
  404042:	b087      	sub	sp, #28
  404044:	af02      	add	r7, sp, #8
  404046:	6078      	str	r0, [r7, #4]
  404048:	6039      	str	r1, [r7, #0]
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  40404a:	f24a 6310 	movw	r3, #42512	; 0xa610
  40404e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404052:	681b      	ldr	r3, [r3, #0]
  404054:	68db      	ldr	r3, [r3, #12]
  404056:	68db      	ldr	r3, [r3, #12]
  404058:	60fb      	str	r3, [r7, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  40405a:	68fb      	ldr	r3, [r7, #12]
  40405c:	f103 0304 	add.w	r3, r3, #4
  404060:	4618      	mov	r0, r3
  404062:	f641 333d 	movw	r3, #6973	; 0x1b3d
  404066:	f2c0 0340 	movt	r3, #64	; 0x40
  40406a:	4798      	blx	r3
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  40406c:	68fb      	ldr	r3, [r7, #12]
  40406e:	69db      	ldr	r3, [r3, #28]
  404070:	2b01      	cmp	r3, #1
  404072:	d127      	bne.n	4040c4 <prvProcessExpiredTimer+0x84>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
  404074:	68fb      	ldr	r3, [r7, #12]
  404076:	699a      	ldr	r2, [r3, #24]
  404078:	687b      	ldr	r3, [r7, #4]
  40407a:	18d3      	adds	r3, r2, r3
  40407c:	68f8      	ldr	r0, [r7, #12]
  40407e:	4619      	mov	r1, r3
  404080:	683a      	ldr	r2, [r7, #0]
  404082:	687b      	ldr	r3, [r7, #4]
  404084:	f244 2469 	movw	r4, #17001	; 0x4269
  404088:	f2c0 0440 	movt	r4, #64	; 0x40
  40408c:	47a0      	blx	r4
  40408e:	4603      	mov	r3, r0
  404090:	2b01      	cmp	r3, #1
  404092:	d117      	bne.n	4040c4 <prvProcessExpiredTimer+0x84>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  404094:	f04f 0300 	mov.w	r3, #0
  404098:	9300      	str	r3, [sp, #0]
  40409a:	68f8      	ldr	r0, [r7, #12]
  40409c:	f04f 0100 	mov.w	r1, #0
  4040a0:	687a      	ldr	r2, [r7, #4]
  4040a2:	f04f 0300 	mov.w	r3, #0
  4040a6:	f643 747d 	movw	r4, #16253	; 0x3f7d
  4040aa:	f2c0 0440 	movt	r4, #64	; 0x40
  4040ae:	47a0      	blx	r4
  4040b0:	60b8      	str	r0, [r7, #8]
			configASSERT( xResult );
  4040b2:	68bb      	ldr	r3, [r7, #8]
  4040b4:	2b00      	cmp	r3, #0
  4040b6:	d105      	bne.n	4040c4 <prvProcessExpiredTimer+0x84>
  4040b8:	f641 6305 	movw	r3, #7685	; 0x1e05
  4040bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4040c0:	4798      	blx	r3
  4040c2:	e7fe      	b.n	4040c2 <prvProcessExpiredTimer+0x82>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  4040c4:	68fb      	ldr	r3, [r7, #12]
  4040c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4040c8:	68f8      	ldr	r0, [r7, #12]
  4040ca:	4798      	blx	r3
}
  4040cc:	f107 0714 	add.w	r7, r7, #20
  4040d0:	46bd      	mov	sp, r7
  4040d2:	bd90      	pop	{r4, r7, pc}

004040d4 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
  4040d4:	b580      	push	{r7, lr}
  4040d6:	b084      	sub	sp, #16
  4040d8:	af00      	add	r7, sp, #0
  4040da:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
  4040dc:	f107 0308 	add.w	r3, r7, #8
  4040e0:	4618      	mov	r0, r3
  4040e2:	f244 13b1 	movw	r3, #16817	; 0x41b1
  4040e6:	f2c0 0340 	movt	r3, #64	; 0x40
  4040ea:	4798      	blx	r3
  4040ec:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
  4040ee:	68bb      	ldr	r3, [r7, #8]
  4040f0:	68f8      	ldr	r0, [r7, #12]
  4040f2:	4619      	mov	r1, r3
  4040f4:	f244 130d 	movw	r3, #16653	; 0x410d
  4040f8:	f2c0 0340 	movt	r3, #64	; 0x40
  4040fc:	4798      	blx	r3

		/* Empty the command queue. */
		prvProcessReceivedCommands();
  4040fe:	f244 3309 	movw	r3, #17161	; 0x4309
  404102:	f2c0 0340 	movt	r3, #64	; 0x40
  404106:	4798      	blx	r3
	}
  404108:	e7e8      	b.n	4040dc <prvTimerTask+0x8>
  40410a:	bf00      	nop

0040410c <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
  40410c:	b580      	push	{r7, lr}
  40410e:	b084      	sub	sp, #16
  404110:	af00      	add	r7, sp, #0
  404112:	6078      	str	r0, [r7, #4]
  404114:	6039      	str	r1, [r7, #0]
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  404116:	f642 7331 	movw	r3, #12081	; 0x2f31
  40411a:	f2c0 0340 	movt	r3, #64	; 0x40
  40411e:	4798      	blx	r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  404120:	f107 0308 	add.w	r3, r7, #8
  404124:	4618      	mov	r0, r3
  404126:	f244 2305 	movw	r3, #16901	; 0x4205
  40412a:	f2c0 0340 	movt	r3, #64	; 0x40
  40412e:	4798      	blx	r3
  404130:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
  404132:	68bb      	ldr	r3, [r7, #8]
  404134:	2b00      	cmp	r3, #0
  404136:	d130      	bne.n	40419a <prvProcessTimerOrBlockTask+0x8e>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  404138:	683b      	ldr	r3, [r7, #0]
  40413a:	2b00      	cmp	r3, #0
  40413c:	d110      	bne.n	404160 <prvProcessTimerOrBlockTask+0x54>
  40413e:	687a      	ldr	r2, [r7, #4]
  404140:	68fb      	ldr	r3, [r7, #12]
  404142:	429a      	cmp	r2, r3
  404144:	d80c      	bhi.n	404160 <prvProcessTimerOrBlockTask+0x54>
			{
				( void ) xTaskResumeAll();
  404146:	f642 7355 	movw	r3, #12117	; 0x2f55
  40414a:	f2c0 0340 	movt	r3, #64	; 0x40
  40414e:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
  404150:	6878      	ldr	r0, [r7, #4]
  404152:	68f9      	ldr	r1, [r7, #12]
  404154:	f244 0341 	movw	r3, #16449	; 0x4041
  404158:	f2c0 0340 	movt	r3, #64	; 0x40
  40415c:	4798      	blx	r3
  40415e:	e023      	b.n	4041a8 <prvProcessTimerOrBlockTask+0x9c>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
  404160:	f24a 6318 	movw	r3, #42520	; 0xa618
  404164:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404168:	681a      	ldr	r2, [r3, #0]
  40416a:	6879      	ldr	r1, [r7, #4]
  40416c:	68fb      	ldr	r3, [r7, #12]
  40416e:	1acb      	subs	r3, r1, r3
  404170:	4610      	mov	r0, r2
  404172:	4619      	mov	r1, r3
  404174:	f642 236d 	movw	r3, #10861	; 0x2a6d
  404178:	f2c0 0340 	movt	r3, #64	; 0x40
  40417c:	4798      	blx	r3

				if( xTaskResumeAll() == pdFALSE )
  40417e:	f642 7355 	movw	r3, #12117	; 0x2f55
  404182:	f2c0 0340 	movt	r3, #64	; 0x40
  404186:	4798      	blx	r3
  404188:	4603      	mov	r3, r0
  40418a:	2b00      	cmp	r3, #0
  40418c:	d10b      	bne.n	4041a6 <prvProcessTimerOrBlockTask+0x9a>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
  40418e:	f641 5379 	movw	r3, #7545	; 0x1d79
  404192:	f2c0 0340 	movt	r3, #64	; 0x40
  404196:	4798      	blx	r3
  404198:	e005      	b.n	4041a6 <prvProcessTimerOrBlockTask+0x9a>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
  40419a:	f642 7355 	movw	r3, #12117	; 0x2f55
  40419e:	f2c0 0340 	movt	r3, #64	; 0x40
  4041a2:	4798      	blx	r3
  4041a4:	e000      	b.n	4041a8 <prvProcessTimerOrBlockTask+0x9c>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
  4041a6:	bf00      	nop
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
  4041a8:	f107 0710 	add.w	r7, r7, #16
  4041ac:	46bd      	mov	sp, r7
  4041ae:	bd80      	pop	{r7, pc}

004041b0 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
{
  4041b0:	b480      	push	{r7}
  4041b2:	b085      	sub	sp, #20
  4041b4:	af00      	add	r7, sp, #0
  4041b6:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  4041b8:	f24a 6310 	movw	r3, #42512	; 0xa610
  4041bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4041c0:	681b      	ldr	r3, [r3, #0]
  4041c2:	681b      	ldr	r3, [r3, #0]
  4041c4:	2b00      	cmp	r3, #0
  4041c6:	bf14      	ite	ne
  4041c8:	2300      	movne	r3, #0
  4041ca:	2301      	moveq	r3, #1
  4041cc:	b2db      	uxtb	r3, r3
  4041ce:	461a      	mov	r2, r3
  4041d0:	687b      	ldr	r3, [r7, #4]
  4041d2:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
  4041d4:	687b      	ldr	r3, [r7, #4]
  4041d6:	681b      	ldr	r3, [r3, #0]
  4041d8:	2b00      	cmp	r3, #0
  4041da:	d108      	bne.n	4041ee <prvGetNextExpireTime+0x3e>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  4041dc:	f24a 6310 	movw	r3, #42512	; 0xa610
  4041e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4041e4:	681b      	ldr	r3, [r3, #0]
  4041e6:	68db      	ldr	r3, [r3, #12]
  4041e8:	681b      	ldr	r3, [r3, #0]
  4041ea:	60fb      	str	r3, [r7, #12]
  4041ec:	e002      	b.n	4041f4 <prvGetNextExpireTime+0x44>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
  4041ee:	f04f 0300 	mov.w	r3, #0
  4041f2:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
  4041f4:	68fb      	ldr	r3, [r7, #12]
}
  4041f6:	4618      	mov	r0, r3
  4041f8:	f107 0714 	add.w	r7, r7, #20
  4041fc:	46bd      	mov	sp, r7
  4041fe:	bc80      	pop	{r7}
  404200:	4770      	bx	lr
  404202:	bf00      	nop

00404204 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
  404204:	b580      	push	{r7, lr}
  404206:	b084      	sub	sp, #16
  404208:	af00      	add	r7, sp, #0
  40420a:	6078      	str	r0, [r7, #4]
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
  40420c:	f243 03f9 	movw	r3, #12537	; 0x30f9
  404210:	f2c0 0340 	movt	r3, #64	; 0x40
  404214:	4798      	blx	r3
  404216:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
  404218:	f24a 631c 	movw	r3, #42524	; 0xa61c
  40421c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404220:	681b      	ldr	r3, [r3, #0]
  404222:	68fa      	ldr	r2, [r7, #12]
  404224:	429a      	cmp	r2, r3
  404226:	d20f      	bcs.n	404248 <prvSampleTimeNow+0x44>
	{
		prvSwitchTimerLists( xLastTime );
  404228:	f24a 631c 	movw	r3, #42524	; 0xa61c
  40422c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404230:	681b      	ldr	r3, [r3, #0]
  404232:	4618      	mov	r0, r3
  404234:	f244 4345 	movw	r3, #17477	; 0x4445
  404238:	f2c0 0340 	movt	r3, #64	; 0x40
  40423c:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
  40423e:	687b      	ldr	r3, [r7, #4]
  404240:	f04f 0201 	mov.w	r2, #1
  404244:	601a      	str	r2, [r3, #0]
  404246:	e003      	b.n	404250 <prvSampleTimeNow+0x4c>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
  404248:	687b      	ldr	r3, [r7, #4]
  40424a:	f04f 0200 	mov.w	r2, #0
  40424e:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
  404250:	f24a 631c 	movw	r3, #42524	; 0xa61c
  404254:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404258:	68fa      	ldr	r2, [r7, #12]
  40425a:	601a      	str	r2, [r3, #0]

	return xTimeNow;
  40425c:	68fb      	ldr	r3, [r7, #12]
}
  40425e:	4618      	mov	r0, r3
  404260:	f107 0710 	add.w	r7, r7, #16
  404264:	46bd      	mov	sp, r7
  404266:	bd80      	pop	{r7, pc}

00404268 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
  404268:	b580      	push	{r7, lr}
  40426a:	b086      	sub	sp, #24
  40426c:	af00      	add	r7, sp, #0
  40426e:	60f8      	str	r0, [r7, #12]
  404270:	60b9      	str	r1, [r7, #8]
  404272:	607a      	str	r2, [r7, #4]
  404274:	603b      	str	r3, [r7, #0]
portBASE_TYPE xProcessTimerNow = pdFALSE;
  404276:	f04f 0300 	mov.w	r3, #0
  40427a:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  40427c:	68fb      	ldr	r3, [r7, #12]
  40427e:	68ba      	ldr	r2, [r7, #8]
  404280:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  404282:	68fb      	ldr	r3, [r7, #12]
  404284:	68fa      	ldr	r2, [r7, #12]
  404286:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
  404288:	68ba      	ldr	r2, [r7, #8]
  40428a:	687b      	ldr	r3, [r7, #4]
  40428c:	429a      	cmp	r2, r3
  40428e:	d81a      	bhi.n	4042c6 <prvInsertTimerInActiveList+0x5e>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
  404290:	687a      	ldr	r2, [r7, #4]
  404292:	683b      	ldr	r3, [r7, #0]
  404294:	1ad2      	subs	r2, r2, r3
  404296:	68fb      	ldr	r3, [r7, #12]
  404298:	699b      	ldr	r3, [r3, #24]
  40429a:	429a      	cmp	r2, r3
  40429c:	d303      	bcc.n	4042a6 <prvInsertTimerInActiveList+0x3e>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  40429e:	f04f 0301 	mov.w	r3, #1
  4042a2:	617b      	str	r3, [r7, #20]
  4042a4:	e02a      	b.n	4042fc <prvInsertTimerInActiveList+0x94>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  4042a6:	f24a 6314 	movw	r3, #42516	; 0xa614
  4042aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4042ae:	681a      	ldr	r2, [r3, #0]
  4042b0:	68fb      	ldr	r3, [r7, #12]
  4042b2:	f103 0304 	add.w	r3, r3, #4
  4042b6:	4610      	mov	r0, r2
  4042b8:	4619      	mov	r1, r3
  4042ba:	f641 23c9 	movw	r3, #6857	; 0x1ac9
  4042be:	f2c0 0340 	movt	r3, #64	; 0x40
  4042c2:	4798      	blx	r3
  4042c4:	e01a      	b.n	4042fc <prvInsertTimerInActiveList+0x94>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  4042c6:	687a      	ldr	r2, [r7, #4]
  4042c8:	683b      	ldr	r3, [r7, #0]
  4042ca:	429a      	cmp	r2, r3
  4042cc:	d207      	bcs.n	4042de <prvInsertTimerInActiveList+0x76>
  4042ce:	68ba      	ldr	r2, [r7, #8]
  4042d0:	683b      	ldr	r3, [r7, #0]
  4042d2:	429a      	cmp	r2, r3
  4042d4:	d303      	bcc.n	4042de <prvInsertTimerInActiveList+0x76>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
  4042d6:	f04f 0301 	mov.w	r3, #1
  4042da:	617b      	str	r3, [r7, #20]
  4042dc:	e00e      	b.n	4042fc <prvInsertTimerInActiveList+0x94>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  4042de:	f24a 6310 	movw	r3, #42512	; 0xa610
  4042e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4042e6:	681a      	ldr	r2, [r3, #0]
  4042e8:	68fb      	ldr	r3, [r7, #12]
  4042ea:	f103 0304 	add.w	r3, r3, #4
  4042ee:	4610      	mov	r0, r2
  4042f0:	4619      	mov	r1, r3
  4042f2:	f641 23c9 	movw	r3, #6857	; 0x1ac9
  4042f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4042fa:	4798      	blx	r3
		}
	}

	return xProcessTimerNow;
  4042fc:	697b      	ldr	r3, [r7, #20]
}
  4042fe:	4618      	mov	r0, r3
  404300:	f107 0718 	add.w	r7, r7, #24
  404304:	46bd      	mov	sp, r7
  404306:	bd80      	pop	{r7, pc}

00404308 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
  404308:	b590      	push	{r4, r7, lr}
  40430a:	b08b      	sub	sp, #44	; 0x2c
  40430c:	af02      	add	r7, sp, #8
xTIMER_MESSAGE xMessage;
xTIMER *pxTimer;
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  40430e:	e07e      	b.n	40440e <prvProcessReceivedCommands+0x106>
	{
		pxTimer = xMessage.pxTimer;
  404310:	693b      	ldr	r3, [r7, #16]
  404312:	61fb      	str	r3, [r7, #28]

		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
  404314:	69fb      	ldr	r3, [r7, #28]
  404316:	695b      	ldr	r3, [r3, #20]
  404318:	2b00      	cmp	r3, #0
  40431a:	d008      	beq.n	40432e <prvProcessReceivedCommands+0x26>
		{
			/* The timer is in a list, remove it. */
			( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  40431c:	69fb      	ldr	r3, [r7, #28]
  40431e:	f103 0304 	add.w	r3, r3, #4
  404322:	4618      	mov	r0, r3
  404324:	f641 333d 	movw	r3, #6973	; 0x1b3d
  404328:	f2c0 0340 	movt	r3, #64	; 0x40
  40432c:	4798      	blx	r3
		it must be present in the function call.  prvSampleTimeNow() must be 
		called after the message is received from xTimerQueue so there is no 
		possibility of a higher priority task adding a message to the message
		queue with a time that is ahead of the timer daemon task (because it
		pre-empted the timer daemon task after the xTimeNow value was set). */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  40432e:	f107 0304 	add.w	r3, r7, #4
  404332:	4618      	mov	r0, r3
  404334:	f244 2305 	movw	r3, #16901	; 0x4205
  404338:	f2c0 0340 	movt	r3, #64	; 0x40
  40433c:	4798      	blx	r3
  40433e:	61b8      	str	r0, [r7, #24]

		switch( xMessage.xMessageID )
  404340:	68bb      	ldr	r3, [r7, #8]
  404342:	2b03      	cmp	r3, #3
  404344:	d860      	bhi.n	404408 <prvProcessReceivedCommands+0x100>
  404346:	a201      	add	r2, pc, #4	; (adr r2, 40434c <prvProcessReceivedCommands+0x44>)
  404348:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40434c:	0040435d 	.word	0x0040435d
  404350:	00404409 	.word	0x00404409
  404354:	004043c5 	.word	0x004043c5
  404358:	004043fb 	.word	0x004043fb
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
  40435c:	68fa      	ldr	r2, [r7, #12]
  40435e:	69fb      	ldr	r3, [r7, #28]
  404360:	699b      	ldr	r3, [r3, #24]
  404362:	18d2      	adds	r2, r2, r3
  404364:	68fb      	ldr	r3, [r7, #12]
  404366:	69f8      	ldr	r0, [r7, #28]
  404368:	4611      	mov	r1, r2
  40436a:	69ba      	ldr	r2, [r7, #24]
  40436c:	f244 2469 	movw	r4, #17001	; 0x4269
  404370:	f2c0 0440 	movt	r4, #64	; 0x40
  404374:	47a0      	blx	r4
  404376:	4603      	mov	r3, r0
  404378:	2b01      	cmp	r3, #1
  40437a:	d147      	bne.n	40440c <prvProcessReceivedCommands+0x104>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  40437c:	69fb      	ldr	r3, [r7, #28]
  40437e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  404380:	69f8      	ldr	r0, [r7, #28]
  404382:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  404384:	69fb      	ldr	r3, [r7, #28]
  404386:	69db      	ldr	r3, [r3, #28]
  404388:	2b01      	cmp	r3, #1
  40438a:	d13f      	bne.n	40440c <prvProcessReceivedCommands+0x104>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  40438c:	68fa      	ldr	r2, [r7, #12]
  40438e:	69fb      	ldr	r3, [r7, #28]
  404390:	699b      	ldr	r3, [r3, #24]
  404392:	18d3      	adds	r3, r2, r3
  404394:	f04f 0200 	mov.w	r2, #0
  404398:	9200      	str	r2, [sp, #0]
  40439a:	69f8      	ldr	r0, [r7, #28]
  40439c:	f04f 0100 	mov.w	r1, #0
  4043a0:	461a      	mov	r2, r3
  4043a2:	f04f 0300 	mov.w	r3, #0
  4043a6:	f643 747d 	movw	r4, #16253	; 0x3f7d
  4043aa:	f2c0 0440 	movt	r4, #64	; 0x40
  4043ae:	47a0      	blx	r4
  4043b0:	6178      	str	r0, [r7, #20]
						configASSERT( xResult );
  4043b2:	697b      	ldr	r3, [r7, #20]
  4043b4:	2b00      	cmp	r3, #0
  4043b6:	d129      	bne.n	40440c <prvProcessReceivedCommands+0x104>
  4043b8:	f641 6305 	movw	r3, #7685	; 0x1e05
  4043bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4043c0:	4798      	blx	r3
  4043c2:	e7fe      	b.n	4043c2 <prvProcessReceivedCommands+0xba>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
  4043c4:	68fa      	ldr	r2, [r7, #12]
  4043c6:	69fb      	ldr	r3, [r7, #28]
  4043c8:	619a      	str	r2, [r3, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  4043ca:	69fb      	ldr	r3, [r7, #28]
  4043cc:	699b      	ldr	r3, [r3, #24]
  4043ce:	2b00      	cmp	r3, #0
  4043d0:	d105      	bne.n	4043de <prvProcessReceivedCommands+0xd6>
  4043d2:	f641 6305 	movw	r3, #7685	; 0x1e05
  4043d6:	f2c0 0340 	movt	r3, #64	; 0x40
  4043da:	4798      	blx	r3
  4043dc:	e7fe      	b.n	4043dc <prvProcessReceivedCommands+0xd4>
				longer or shorter than the old one.  The command time is 
				therefore set to the current time, and as the period cannot be
				zero the next expiry time can only be in the future, meaning
				(unlike for the xTimerStart() case above) there is no fail case
				that needs to be handled here. */
				( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  4043de:	69fb      	ldr	r3, [r7, #28]
  4043e0:	699a      	ldr	r2, [r3, #24]
  4043e2:	69bb      	ldr	r3, [r7, #24]
  4043e4:	18d3      	adds	r3, r2, r3
  4043e6:	69f8      	ldr	r0, [r7, #28]
  4043e8:	4619      	mov	r1, r3
  4043ea:	69ba      	ldr	r2, [r7, #24]
  4043ec:	69bb      	ldr	r3, [r7, #24]
  4043ee:	f244 2469 	movw	r4, #17001	; 0x4269
  4043f2:	f2c0 0440 	movt	r4, #64	; 0x40
  4043f6:	47a0      	blx	r4
				break;
  4043f8:	e009      	b.n	40440e <prvProcessReceivedCommands+0x106>

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
  4043fa:	69f8      	ldr	r0, [r7, #28]
  4043fc:	f240 4305 	movw	r3, #1029	; 0x405
  404400:	f2c0 0340 	movt	r3, #64	; 0x40
  404404:	4798      	blx	r3
				break;
  404406:	e002      	b.n	40440e <prvProcessReceivedCommands+0x106>

			default	:
				/* Don't expect to get here. */
				break;
  404408:	bf00      	nop
  40440a:	e000      	b.n	40440e <prvProcessReceivedCommands+0x106>
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
						configASSERT( xResult );
						( void ) xResult;
					}
				}
				break;
  40440c:	bf00      	nop
xTIMER_MESSAGE xMessage;
xTIMER *pxTimer;
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  40440e:	f24a 6318 	movw	r3, #42520	; 0xa618
  404412:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404416:	681a      	ldr	r2, [r3, #0]
  404418:	f107 0308 	add.w	r3, r7, #8
  40441c:	4610      	mov	r0, r2
  40441e:	4619      	mov	r1, r3
  404420:	f04f 0200 	mov.w	r2, #0
  404424:	f04f 0300 	mov.w	r3, #0
  404428:	f242 4455 	movw	r4, #9301	; 0x2455
  40442c:	f2c0 0440 	movt	r4, #64	; 0x40
  404430:	47a0      	blx	r4
  404432:	4603      	mov	r3, r0
  404434:	2b00      	cmp	r3, #0
  404436:	f47f af6b 	bne.w	404310 <prvProcessReceivedCommands+0x8>
			default	:
				/* Don't expect to get here. */
				break;
		}
	}
}
  40443a:	f107 0724 	add.w	r7, r7, #36	; 0x24
  40443e:	46bd      	mov	sp, r7
  404440:	bd90      	pop	{r4, r7, pc}
  404442:	bf00      	nop

00404444 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
{
  404444:	b590      	push	{r4, r7, lr}
  404446:	b08b      	sub	sp, #44	; 0x2c
  404448:	af02      	add	r7, sp, #8
  40444a:	6078      	str	r0, [r7, #4]

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  40444c:	e057      	b.n	4044fe <prvSwitchTimerLists+0xba>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  40444e:	f24a 6310 	movw	r3, #42512	; 0xa610
  404452:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404456:	681b      	ldr	r3, [r3, #0]
  404458:	68db      	ldr	r3, [r3, #12]
  40445a:	681b      	ldr	r3, [r3, #0]
  40445c:	61fb      	str	r3, [r7, #28]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  40445e:	f24a 6310 	movw	r3, #42512	; 0xa610
  404462:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404466:	681b      	ldr	r3, [r3, #0]
  404468:	68db      	ldr	r3, [r3, #12]
  40446a:	68db      	ldr	r3, [r3, #12]
  40446c:	61bb      	str	r3, [r7, #24]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  40446e:	69bb      	ldr	r3, [r7, #24]
  404470:	f103 0304 	add.w	r3, r3, #4
  404474:	4618      	mov	r0, r3
  404476:	f641 333d 	movw	r3, #6973	; 0x1b3d
  40447a:	f2c0 0340 	movt	r3, #64	; 0x40
  40447e:	4798      	blx	r3

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  404480:	69bb      	ldr	r3, [r7, #24]
  404482:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  404484:	69b8      	ldr	r0, [r7, #24]
  404486:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  404488:	69bb      	ldr	r3, [r7, #24]
  40448a:	69db      	ldr	r3, [r3, #28]
  40448c:	2b01      	cmp	r3, #1
  40448e:	d136      	bne.n	4044fe <prvSwitchTimerLists+0xba>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  404490:	69bb      	ldr	r3, [r7, #24]
  404492:	699a      	ldr	r2, [r3, #24]
  404494:	69fb      	ldr	r3, [r7, #28]
  404496:	18d3      	adds	r3, r2, r3
  404498:	617b      	str	r3, [r7, #20]
			if( xReloadTime > xNextExpireTime )
  40449a:	697a      	ldr	r2, [r7, #20]
  40449c:	69fb      	ldr	r3, [r7, #28]
  40449e:	429a      	cmp	r2, r3
  4044a0:	d915      	bls.n	4044ce <prvSwitchTimerLists+0x8a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  4044a2:	69bb      	ldr	r3, [r7, #24]
  4044a4:	697a      	ldr	r2, [r7, #20]
  4044a6:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  4044a8:	69bb      	ldr	r3, [r7, #24]
  4044aa:	69ba      	ldr	r2, [r7, #24]
  4044ac:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  4044ae:	f24a 6310 	movw	r3, #42512	; 0xa610
  4044b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4044b6:	681a      	ldr	r2, [r3, #0]
  4044b8:	69bb      	ldr	r3, [r7, #24]
  4044ba:	f103 0304 	add.w	r3, r3, #4
  4044be:	4610      	mov	r0, r2
  4044c0:	4619      	mov	r1, r3
  4044c2:	f641 23c9 	movw	r3, #6857	; 0x1ac9
  4044c6:	f2c0 0340 	movt	r3, #64	; 0x40
  4044ca:	4798      	blx	r3
  4044cc:	e017      	b.n	4044fe <prvSwitchTimerLists+0xba>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  4044ce:	f04f 0300 	mov.w	r3, #0
  4044d2:	9300      	str	r3, [sp, #0]
  4044d4:	69b8      	ldr	r0, [r7, #24]
  4044d6:	f04f 0100 	mov.w	r1, #0
  4044da:	69fa      	ldr	r2, [r7, #28]
  4044dc:	f04f 0300 	mov.w	r3, #0
  4044e0:	f643 747d 	movw	r4, #16253	; 0x3f7d
  4044e4:	f2c0 0440 	movt	r4, #64	; 0x40
  4044e8:	47a0      	blx	r4
  4044ea:	6138      	str	r0, [r7, #16]
				configASSERT( xResult );
  4044ec:	693b      	ldr	r3, [r7, #16]
  4044ee:	2b00      	cmp	r3, #0
  4044f0:	d105      	bne.n	4044fe <prvSwitchTimerLists+0xba>
  4044f2:	f641 6305 	movw	r3, #7685	; 0x1e05
  4044f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4044fa:	4798      	blx	r3
  4044fc:	e7fe      	b.n	4044fc <prvSwitchTimerLists+0xb8>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  4044fe:	f24a 6310 	movw	r3, #42512	; 0xa610
  404502:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404506:	681b      	ldr	r3, [r3, #0]
  404508:	681b      	ldr	r3, [r3, #0]
  40450a:	2b00      	cmp	r3, #0
  40450c:	d19f      	bne.n	40444e <prvSwitchTimerLists+0xa>
				( void ) xResult;
			}
		}
	}

	pxTemp = pxCurrentTimerList;
  40450e:	f24a 6310 	movw	r3, #42512	; 0xa610
  404512:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404516:	681b      	ldr	r3, [r3, #0]
  404518:	60fb      	str	r3, [r7, #12]
	pxCurrentTimerList = pxOverflowTimerList;
  40451a:	f24a 6314 	movw	r3, #42516	; 0xa614
  40451e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404522:	681a      	ldr	r2, [r3, #0]
  404524:	f24a 6310 	movw	r3, #42512	; 0xa610
  404528:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40452c:	601a      	str	r2, [r3, #0]
	pxOverflowTimerList = pxTemp;
  40452e:	f24a 6314 	movw	r3, #42516	; 0xa614
  404532:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404536:	68fa      	ldr	r2, [r7, #12]
  404538:	601a      	str	r2, [r3, #0]
}
  40453a:	f107 0724 	add.w	r7, r7, #36	; 0x24
  40453e:	46bd      	mov	sp, r7
  404540:	bd90      	pop	{r4, r7, pc}
  404542:	bf00      	nop

00404544 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  404544:	b580      	push	{r7, lr}
  404546:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  404548:	f641 5399 	movw	r3, #7577	; 0x1d99
  40454c:	f2c0 0340 	movt	r3, #64	; 0x40
  404550:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
  404552:	f24a 6318 	movw	r3, #42520	; 0xa618
  404556:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40455a:	681b      	ldr	r3, [r3, #0]
  40455c:	2b00      	cmp	r3, #0
  40455e:	d134      	bne.n	4045ca <prvCheckForValidListAndQueue+0x86>
		{
			vListInitialise( &xActiveTimerList1 );
  404560:	f24a 50e8 	movw	r0, #42472	; 0xa5e8
  404564:	f2c2 0000 	movt	r0, #8192	; 0x2000
  404568:	f641 2325 	movw	r3, #6693	; 0x1a25
  40456c:	f2c0 0340 	movt	r3, #64	; 0x40
  404570:	4798      	blx	r3
			vListInitialise( &xActiveTimerList2 );
  404572:	f24a 50fc 	movw	r0, #42492	; 0xa5fc
  404576:	f2c2 0000 	movt	r0, #8192	; 0x2000
  40457a:	f641 2325 	movw	r3, #6693	; 0x1a25
  40457e:	f2c0 0340 	movt	r3, #64	; 0x40
  404582:	4798      	blx	r3
			pxCurrentTimerList = &xActiveTimerList1;
  404584:	f24a 6310 	movw	r3, #42512	; 0xa610
  404588:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40458c:	f24a 52e8 	movw	r2, #42472	; 0xa5e8
  404590:	f2c2 0200 	movt	r2, #8192	; 0x2000
  404594:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
  404596:	f24a 6314 	movw	r3, #42516	; 0xa614
  40459a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40459e:	f24a 52fc 	movw	r2, #42492	; 0xa5fc
  4045a2:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4045a6:	601a      	str	r2, [r3, #0]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
  4045a8:	f04f 0005 	mov.w	r0, #5
  4045ac:	f04f 010c 	mov.w	r1, #12
  4045b0:	f04f 0200 	mov.w	r2, #0
  4045b4:	f242 0331 	movw	r3, #8241	; 0x2031
  4045b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4045bc:	4798      	blx	r3
  4045be:	4602      	mov	r2, r0
  4045c0:	f24a 6318 	movw	r3, #42520	; 0xa618
  4045c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4045c8:	601a      	str	r2, [r3, #0]
		}
	}
	taskEXIT_CRITICAL();
  4045ca:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  4045ce:	f2c0 0340 	movt	r3, #64	; 0x40
  4045d2:	4798      	blx	r3
}
  4045d4:	bd80      	pop	{r7, pc}
  4045d6:	bf00      	nop

004045d8 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field
 */
static __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  4045d8:	b480      	push	{r7}
  4045da:	b085      	sub	sp, #20
  4045dc:	af00      	add	r7, sp, #0
  4045de:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
  4045e0:	687b      	ldr	r3, [r7, #4]
  4045e2:	f003 0307 	and.w	r3, r3, #7
  4045e6:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  4045e8:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  4045ec:	f2ce 0300 	movt	r3, #57344	; 0xe000
  4045f0:	68db      	ldr	r3, [r3, #12]
  4045f2:	60bb      	str	r3, [r7, #8]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  4045f4:	68ba      	ldr	r2, [r7, #8]
  4045f6:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
  4045fa:	4013      	ands	r3, r2
  4045fc:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  4045fe:	68fb      	ldr	r3, [r7, #12]
  404600:	ea4f 2203 	mov.w	r2, r3, lsl #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
  404604:	68bb      	ldr	r3, [r7, #8]
  404606:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
  404608:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  40460c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  404610:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
  404612:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  404616:	f2ce 0300 	movt	r3, #57344	; 0xe000
  40461a:	68ba      	ldr	r2, [r7, #8]
  40461c:	60da      	str	r2, [r3, #12]
}
  40461e:	f107 0714 	add.w	r7, r7, #20
  404622:	46bd      	mov	sp, r7
  404624:	bc80      	pop	{r7}
  404626:	4770      	bx	lr

00404628 <main>:

/* See the documentation page for this demo on the FreeRTOS.org web site for
full information - including hardware setup requirements. */

int main( void )
{
  404628:	b580      	push	{r7, lr}
  40462a:	af00      	add	r7, sp, #0
	/* Prepare the hardware to run this demo. */
	prvSetupHardware();
  40462c:	f244 6349 	movw	r3, #17993	; 0x4649
  404630:	f2c0 0340 	movt	r3, #64	; 0x40
  404634:	4798      	blx	r3

	/* The mainCREATE_SIMPLE_BLINKY_DEMO_ONLY setting is described at the top
	of this file. */
	#if mainCREATE_SIMPLE_BLINKY_DEMO_ONLY == 1
	{
		main_blinky();
  404636:	f244 63b1 	movw	r3, #18097	; 0x46b1
  40463a:	f2c0 0340 	movt	r3, #64	; 0x40
  40463e:	4798      	blx	r3
	{
		main_full();
	}
	#endif

	return 0;
  404640:	f04f 0300 	mov.w	r3, #0
}
  404644:	4618      	mov	r0, r3
  404646:	bd80      	pop	{r7, pc}

00404648 <prvSetupHardware>:
/*-----------------------------------------------------------*/

static void prvSetupHardware( void )
{
  404648:	b580      	push	{r7, lr}
  40464a:	af00      	add	r7, sp, #0
extern void SystemCoreClockUpdate( void );

	/* ASF function to setup clocking. */
	sysclk_init();
  40464c:	f640 23f9 	movw	r3, #2809	; 0xaf9
  404650:	f2c0 0340 	movt	r3, #64	; 0x40
  404654:	4798      	blx	r3

	/* Ensure all priority bits are assigned as preemption priority bits. */
	NVIC_SetPriorityGrouping( 0 );
  404656:	f04f 0000 	mov.w	r0, #0
  40465a:	f244 53d9 	movw	r3, #17881	; 0x45d9
  40465e:	f2c0 0340 	movt	r3, #64	; 0x40
  404662:	4798      	blx	r3

	/* Atmel library function to setup for the evaluation kit being used. */
	board_init();
  404664:	f640 3385 	movw	r3, #2949	; 0xb85
  404668:	f2c0 0340 	movt	r3, #64	; 0x40
  40466c:	4798      	blx	r3

	/* Perform any configuration necessary to use the ParTest LED output
	functions. */
	vParTestInitialise();
  40466e:	f644 0331 	movw	r3, #18481	; 0x4831
  404672:	f2c0 0340 	movt	r3, #64	; 0x40
  404676:	4798      	blx	r3
}
  404678:	bd80      	pop	{r7, pc}
  40467a:	bf00      	nop

0040467c <vApplicationMallocFailedHook>:
/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
  40467c:	b580      	push	{r7, lr}
  40467e:	af00      	add	r7, sp, #0
	demo application.  If heap_1.c or heap_2.c are used, then the size of the
	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
  404680:	f641 6305 	movw	r3, #7685	; 0x1e05
  404684:	f2c0 0340 	movt	r3, #64	; 0x40
  404688:	4798      	blx	r3
	for( ;; );
  40468a:	e7fe      	b.n	40468a <vApplicationMallocFailedHook+0xe>

0040468c <vApplicationStackOverflowHook>:
	memory allocated by the kernel to any task that has since been deleted. */
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName )
{
  40468c:	b580      	push	{r7, lr}
  40468e:	b082      	sub	sp, #8
  404690:	af00      	add	r7, sp, #0
  404692:	6078      	str	r0, [r7, #4]
  404694:	6039      	str	r1, [r7, #0]
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
  404696:	f641 6305 	movw	r3, #7685	; 0x1e05
  40469a:	f2c0 0340 	movt	r3, #64	; 0x40
  40469e:	4798      	blx	r3
	for( ;; );
  4046a0:	e7fe      	b.n	4046a0 <vApplicationStackOverflowHook+0x14>
  4046a2:	bf00      	nop

004046a4 <vApplicationTickHook>:
}
/*-----------------------------------------------------------*/

void vApplicationTickHook( void )
{
  4046a4:	b480      	push	{r7}
  4046a6:	af00      	add	r7, sp, #0
	{
		/* In this case the tick hook is used as part of the queue set test. */
		vQueueSetAccessQueueSetFromISR();
	}
	#endif /* mainCREATE_SIMPLE_BLINKY_DEMO_ONLY */
}
  4046a8:	46bd      	mov	sp, r7
  4046aa:	bc80      	pop	{r7}
  4046ac:	4770      	bx	lr
  4046ae:	bf00      	nop

004046b0 <main_blinky>:
static xQueueHandle xQueue = NULL;

/*-----------------------------------------------------------*/

void main_blinky( void )
{
  4046b0:	b590      	push	{r4, r7, lr}
  4046b2:	b085      	sub	sp, #20
  4046b4:	af04      	add	r7, sp, #16
	/* Create the queue. */
	xQueue = xQueueCreate( mainQUEUE_LENGTH, sizeof( unsigned long ) );
  4046b6:	f04f 0001 	mov.w	r0, #1
  4046ba:	f04f 0104 	mov.w	r1, #4
  4046be:	f04f 0200 	mov.w	r2, #0
  4046c2:	f242 0331 	movw	r3, #8241	; 0x2031
  4046c6:	f2c0 0340 	movt	r3, #64	; 0x40
  4046ca:	4798      	blx	r3
  4046cc:	4602      	mov	r2, r0
  4046ce:	f24a 6320 	movw	r3, #42528	; 0xa620
  4046d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4046d6:	601a      	str	r2, [r3, #0]

	if( xQueue != NULL )
  4046d8:	f24a 6320 	movw	r3, #42528	; 0xa620
  4046dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4046e0:	681b      	ldr	r3, [r3, #0]
  4046e2:	2b00      	cmp	r3, #0
  4046e4:	d03e      	beq.n	404764 <main_blinky+0xb4>
	{
		/* Start the two tasks as described in the comments at the top of this
		file. */
		xTaskCreate( prvQueueReceiveTask,					/* The function that implements the task. */
  4046e6:	f04f 0302 	mov.w	r3, #2
  4046ea:	9300      	str	r3, [sp, #0]
  4046ec:	f04f 0300 	mov.w	r3, #0
  4046f0:	9301      	str	r3, [sp, #4]
  4046f2:	f04f 0300 	mov.w	r3, #0
  4046f6:	9302      	str	r3, [sp, #8]
  4046f8:	f04f 0300 	mov.w	r3, #0
  4046fc:	9303      	str	r3, [sp, #12]
  4046fe:	f244 70d5 	movw	r0, #18389	; 0x47d5
  404702:	f2c0 0040 	movt	r0, #64	; 0x40
  404706:	f644 21fc 	movw	r1, #19196	; 0x4afc
  40470a:	f2c0 0140 	movt	r1, #64	; 0x40
  40470e:	f04f 0282 	mov.w	r2, #130	; 0x82
  404712:	f04f 0322 	mov.w	r3, #34	; 0x22
  404716:	f642 3479 	movw	r4, #11129	; 0x2b79
  40471a:	f2c0 0440 	movt	r4, #64	; 0x40
  40471e:	47a0      	blx	r4
					configMINIMAL_STACK_SIZE, 				/* The size of the stack to allocate to the task. */
					( void * ) mainQUEUE_RECEIVE_PARAMETER, /* The parameter passed to the task - just to check the functionality. */
					mainQUEUE_RECEIVE_TASK_PRIORITY, 		/* The priority assigned to the task. */
					NULL );									/* The task handle is not required, so NULL is passed. */

		xTaskCreate( prvQueueSendTask, ( signed char * ) "TX", configMINIMAL_STACK_SIZE, ( void * ) mainQUEUE_SEND_PARAMETER, mainQUEUE_SEND_TASK_PRIORITY, NULL );
  404720:	f04f 0301 	mov.w	r3, #1
  404724:	9300      	str	r3, [sp, #0]
  404726:	f04f 0300 	mov.w	r3, #0
  40472a:	9301      	str	r3, [sp, #4]
  40472c:	f04f 0300 	mov.w	r3, #0
  404730:	9302      	str	r3, [sp, #8]
  404732:	f04f 0300 	mov.w	r3, #0
  404736:	9303      	str	r3, [sp, #12]
  404738:	f244 7069 	movw	r0, #18281	; 0x4769
  40473c:	f2c0 0040 	movt	r0, #64	; 0x40
  404740:	f644 3100 	movw	r1, #19200	; 0x4b00
  404744:	f2c0 0140 	movt	r1, #64	; 0x40
  404748:	f04f 0282 	mov.w	r2, #130	; 0x82
  40474c:	f241 1311 	movw	r3, #4369	; 0x1111
  404750:	f642 3479 	movw	r4, #11129	; 0x2b79
  404754:	f2c0 0440 	movt	r4, #64	; 0x40
  404758:	47a0      	blx	r4

		/* Start the tasks and timer running. */
		vTaskStartScheduler();
  40475a:	f642 6389 	movw	r3, #11913	; 0x2e89
  40475e:	f2c0 0340 	movt	r3, #64	; 0x40
  404762:	4798      	blx	r3
	/* If all is well, the scheduler will now be running, and the following
	line will never be reached.  If the following line does execute, then
	there was insufficient FreeRTOS heap memory available for the idle and/or
	timer tasks	to be created.  See the memory management section on the
	FreeRTOS web site for more details. */
	for( ;; );
  404764:	e7fe      	b.n	404764 <main_blinky+0xb4>
  404766:	bf00      	nop

00404768 <prvQueueSendTask>:
}
/*-----------------------------------------------------------*/

static void prvQueueSendTask( void *pvParameters )
{
  404768:	b590      	push	{r4, r7, lr}
  40476a:	b085      	sub	sp, #20
  40476c:	af00      	add	r7, sp, #0
  40476e:	6078      	str	r0, [r7, #4]
portTickType xNextWakeTime;
const unsigned long ulValueToSend = 100UL;
  404770:	f04f 0364 	mov.w	r3, #100	; 0x64
  404774:	60bb      	str	r3, [r7, #8]

	/* Check the task parameter is as expected. */
	configASSERT( ( ( unsigned long ) pvParameters ) == mainQUEUE_SEND_PARAMETER );
  404776:	687a      	ldr	r2, [r7, #4]
  404778:	f241 1311 	movw	r3, #4369	; 0x1111
  40477c:	429a      	cmp	r2, r3
  40477e:	d005      	beq.n	40478c <prvQueueSendTask+0x24>
  404780:	f641 6305 	movw	r3, #7685	; 0x1e05
  404784:	f2c0 0340 	movt	r3, #64	; 0x40
  404788:	4798      	blx	r3
  40478a:	e7fe      	b.n	40478a <prvQueueSendTask+0x22>

	/* Initialise xNextWakeTime - this only needs to be done once. */
	xNextWakeTime = xTaskGetTickCount();
  40478c:	f243 03f9 	movw	r3, #12537	; 0x30f9
  404790:	f2c0 0340 	movt	r3, #64	; 0x40
  404794:	4798      	blx	r3
  404796:	4603      	mov	r3, r0
  404798:	60fb      	str	r3, [r7, #12]
	{
		/* Place this task in the blocked state until it is time to run again.
		The block time is specified in ticks, the constant used converts ticks
		to ms.  While in the Blocked state this task will not consume any CPU
		time. */
		vTaskDelayUntil( &xNextWakeTime, mainQUEUE_SEND_FREQUENCY_MS );
  40479a:	f107 030c 	add.w	r3, r7, #12
  40479e:	4618      	mov	r0, r3
  4047a0:	f04f 01c8 	mov.w	r1, #200	; 0xc8
  4047a4:	f642 536d 	movw	r3, #11629	; 0x2d6d
  4047a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4047ac:	4798      	blx	r3

		/* Send to the queue - causing the queue receive task to unblock and
		toggle the LED.  0 is used as the block time so the sending operation
		will not block - it shouldn't need to block as the queue should always
		be empty at this point in the code. */
		xQueueSend( xQueue, &ulValueToSend, 0U );
  4047ae:	f24a 6320 	movw	r3, #42528	; 0xa620
  4047b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4047b6:	681a      	ldr	r2, [r3, #0]
  4047b8:	f107 0308 	add.w	r3, r7, #8
  4047bc:	4610      	mov	r0, r2
  4047be:	4619      	mov	r1, r3
  4047c0:	f04f 0200 	mov.w	r2, #0
  4047c4:	f04f 0300 	mov.w	r3, #0
  4047c8:	f242 04dd 	movw	r4, #8413	; 0x20dd
  4047cc:	f2c0 0440 	movt	r4, #64	; 0x40
  4047d0:	47a0      	blx	r4
	}
  4047d2:	e7e2      	b.n	40479a <prvQueueSendTask+0x32>

004047d4 <prvQueueReceiveTask>:
}
/*-----------------------------------------------------------*/

static void prvQueueReceiveTask( void *pvParameters )
{
  4047d4:	b590      	push	{r4, r7, lr}
  4047d6:	b085      	sub	sp, #20
  4047d8:	af00      	add	r7, sp, #0
  4047da:	6078      	str	r0, [r7, #4]
unsigned long ulReceivedValue;

	/* Check the task parameter is as expected. */
	configASSERT( ( ( unsigned long ) pvParameters ) == mainQUEUE_RECEIVE_PARAMETER );
  4047dc:	687b      	ldr	r3, [r7, #4]
  4047de:	2b22      	cmp	r3, #34	; 0x22
  4047e0:	d006      	beq.n	4047f0 <prvQueueReceiveTask+0x1c>
  4047e2:	f641 6305 	movw	r3, #7685	; 0x1e05
  4047e6:	f2c0 0340 	movt	r3, #64	; 0x40
  4047ea:	4798      	blx	r3
  4047ec:	e7fe      	b.n	4047ec <prvQueueReceiveTask+0x18>
		if( ulReceivedValue == 100UL )
		{
			vParTestToggleLED( 0 );
			ulReceivedValue = 0U;
		}
	}
  4047ee:	bf00      	nop
	for( ;; )
	{
		/* Wait until something arrives in the queue - this task will block
		indefinitely provided INCLUDE_vTaskSuspend is set to 1 in
		FreeRTOSConfig.h. */
		xQueueReceive( xQueue, &ulReceivedValue, portMAX_DELAY );
  4047f0:	f24a 6320 	movw	r3, #42528	; 0xa620
  4047f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4047f8:	681a      	ldr	r2, [r3, #0]
  4047fa:	f107 030c 	add.w	r3, r7, #12
  4047fe:	4610      	mov	r0, r2
  404800:	4619      	mov	r1, r3
  404802:	f04f 32ff 	mov.w	r2, #4294967295
  404806:	f04f 0300 	mov.w	r3, #0
  40480a:	f242 4455 	movw	r4, #9301	; 0x2455
  40480e:	f2c0 0440 	movt	r4, #64	; 0x40
  404812:	47a0      	blx	r4

		/*  To get here something must have been received from the queue, but
		is it the expected value?  If it is, toggle the LED. */
		if( ulReceivedValue == 100UL )
  404814:	68fb      	ldr	r3, [r7, #12]
  404816:	2b64      	cmp	r3, #100	; 0x64
  404818:	d1e9      	bne.n	4047ee <prvQueueReceiveTask+0x1a>
		{
			vParTestToggleLED( 0 );
  40481a:	f04f 0000 	mov.w	r0, #0
  40481e:	f644 1315 	movw	r3, #18709	; 0x4915
  404822:	f2c0 0340 	movt	r3, #64	; 0x40
  404826:	4798      	blx	r3
			ulReceivedValue = 0U;
  404828:	f04f 0300 	mov.w	r3, #0
  40482c:	60fb      	str	r3, [r7, #12]
		}
	}
  40482e:	e7de      	b.n	4047ee <prvQueueReceiveTask+0x1a>

00404830 <vParTestInitialise>:
static const uint32_t ulLED[] = { LED2_GPIO, LED0_GPIO, LED1_GPIO };

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
  404830:	b580      	push	{r7, lr}
  404832:	b082      	sub	sp, #8
  404834:	af00      	add	r7, sp, #0
unsigned long ul;

	for( ul = 0; ul < partestNUM_LEDS; ul++ )
  404836:	f04f 0300 	mov.w	r3, #0
  40483a:	607b      	str	r3, [r7, #4]
  40483c:	e01a      	b.n	404874 <vParTestInitialise+0x44>
	{
		/* Configure the LED, before ensuring it starts in the off state. */
		gpio_configure_pin( ulLED[ ul ],  ( PIO_OUTPUT_1 | PIO_DEFAULT ) );
  40483e:	f644 3304 	movw	r3, #19204	; 0x4b04
  404842:	f2c0 0340 	movt	r3, #64	; 0x40
  404846:	687a      	ldr	r2, [r7, #4]
  404848:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40484c:	4618      	mov	r0, r3
  40484e:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  404852:	f640 7389 	movw	r3, #3977	; 0xf89
  404856:	f2c0 0340 	movt	r3, #64	; 0x40
  40485a:	4798      	blx	r3
		vParTestSetLED( ul, pdFALSE );
  40485c:	6878      	ldr	r0, [r7, #4]
  40485e:	f04f 0100 	mov.w	r1, #0
  404862:	f644 0385 	movw	r3, #18565	; 0x4885
  404866:	f2c0 0340 	movt	r3, #64	; 0x40
  40486a:	4798      	blx	r3

void vParTestInitialise( void )
{
unsigned long ul;

	for( ul = 0; ul < partestNUM_LEDS; ul++ )
  40486c:	687b      	ldr	r3, [r7, #4]
  40486e:	f103 0301 	add.w	r3, r3, #1
  404872:	607b      	str	r3, [r7, #4]
  404874:	687b      	ldr	r3, [r7, #4]
  404876:	2b02      	cmp	r3, #2
  404878:	d9e1      	bls.n	40483e <vParTestInitialise+0xe>
	{
		/* Configure the LED, before ensuring it starts in the off state. */
		gpio_configure_pin( ulLED[ ul ],  ( PIO_OUTPUT_1 | PIO_DEFAULT ) );
		vParTestSetLED( ul, pdFALSE );
	}
}
  40487a:	f107 0708 	add.w	r7, r7, #8
  40487e:	46bd      	mov	sp, r7
  404880:	bd80      	pop	{r7, pc}
  404882:	bf00      	nop

00404884 <vParTestSetLED>:
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{	
  404884:	b580      	push	{r7, lr}
  404886:	b082      	sub	sp, #8
  404888:	af00      	add	r7, sp, #0
  40488a:	6078      	str	r0, [r7, #4]
  40488c:	6039      	str	r1, [r7, #0]
	if( uxLED < partestNUM_LEDS )
  40488e:	687b      	ldr	r3, [r7, #4]
  404890:	2b02      	cmp	r3, #2
  404892:	d83b      	bhi.n	40490c <vParTestSetLED+0x88>
	{
		if( uxLED == partstsINVERTED_LED )
  404894:	687b      	ldr	r3, [r7, #4]
  404896:	2b00      	cmp	r3, #0
  404898:	d106      	bne.n	4048a8 <vParTestSetLED+0x24>
		{
			xValue = !xValue;					
  40489a:	683b      	ldr	r3, [r7, #0]
  40489c:	2b00      	cmp	r3, #0
  40489e:	bf14      	ite	ne
  4048a0:	2300      	movne	r3, #0
  4048a2:	2301      	moveq	r3, #1
  4048a4:	b2db      	uxtb	r3, r3
  4048a6:	603b      	str	r3, [r7, #0]
		}
		
		if( xValue != pdFALSE )
  4048a8:	683b      	ldr	r3, [r7, #0]
  4048aa:	2b00      	cmp	r3, #0
  4048ac:	d017      	beq.n	4048de <vParTestSetLED+0x5a>
		{
			/* Turn the LED on. */
			taskENTER_CRITICAL();
  4048ae:	f641 5399 	movw	r3, #7577	; 0x1d99
  4048b2:	f2c0 0340 	movt	r3, #64	; 0x40
  4048b6:	4798      	blx	r3
			{
				gpio_set_pin_low( ulLED[ uxLED ]);
  4048b8:	f644 3304 	movw	r3, #19204	; 0x4b04
  4048bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4048c0:	687a      	ldr	r2, [r7, #4]
  4048c2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4048c6:	4618      	mov	r0, r3
  4048c8:	f640 63e5 	movw	r3, #3813	; 0xee5
  4048cc:	f2c0 0340 	movt	r3, #64	; 0x40
  4048d0:	4798      	blx	r3
			}
			taskEXIT_CRITICAL();
  4048d2:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  4048d6:	f2c0 0340 	movt	r3, #64	; 0x40
  4048da:	4798      	blx	r3
  4048dc:	e016      	b.n	40490c <vParTestSetLED+0x88>
		}
		else
		{
			/* Turn the LED off. */
			taskENTER_CRITICAL();
  4048de:	f641 5399 	movw	r3, #7577	; 0x1d99
  4048e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4048e6:	4798      	blx	r3
			{
				gpio_set_pin_high( ulLED[ uxLED ]);
  4048e8:	f644 3304 	movw	r3, #19204	; 0x4b04
  4048ec:	f2c0 0340 	movt	r3, #64	; 0x40
  4048f0:	687a      	ldr	r2, [r7, #4]
  4048f2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4048f6:	4618      	mov	r0, r3
  4048f8:	f640 63a9 	movw	r3, #3753	; 0xea9
  4048fc:	f2c0 0340 	movt	r3, #64	; 0x40
  404900:	4798      	blx	r3
			}
			taskEXIT_CRITICAL();
  404902:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  404906:	f2c0 0340 	movt	r3, #64	; 0x40
  40490a:	4798      	blx	r3
		}
	}
}
  40490c:	f107 0708 	add.w	r7, r7, #8
  404910:	46bd      	mov	sp, r7
  404912:	bd80      	pop	{r7, pc}

00404914 <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
  404914:	b580      	push	{r7, lr}
  404916:	b082      	sub	sp, #8
  404918:	af00      	add	r7, sp, #0
  40491a:	6078      	str	r0, [r7, #4]
	if( uxLED < partestNUM_LEDS )
  40491c:	687b      	ldr	r3, [r7, #4]
  40491e:	2b02      	cmp	r3, #2
  404920:	d816      	bhi.n	404950 <vParTestToggleLED+0x3c>
	{
		taskENTER_CRITICAL();
  404922:	f641 5399 	movw	r3, #7577	; 0x1d99
  404926:	f2c0 0340 	movt	r3, #64	; 0x40
  40492a:	4798      	blx	r3
		{			
			gpio_toggle_pin( ulLED[ uxLED ] );
  40492c:	f644 3304 	movw	r3, #19204	; 0x4b04
  404930:	f2c0 0340 	movt	r3, #64	; 0x40
  404934:	687a      	ldr	r2, [r7, #4]
  404936:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40493a:	4618      	mov	r0, r3
  40493c:	f640 7321 	movw	r3, #3873	; 0xf21
  404940:	f2c0 0340 	movt	r3, #64	; 0x40
  404944:	4798      	blx	r3
		}
		taskEXIT_CRITICAL();		
  404946:	f641 53c9 	movw	r3, #7625	; 0x1dc9
  40494a:	f2c0 0340 	movt	r3, #64	; 0x40
  40494e:	4798      	blx	r3
	}
}
  404950:	f107 0708 	add.w	r7, r7, #8
  404954:	46bd      	mov	sp, r7
  404956:	bd80      	pop	{r7, pc}

00404958 <__register_exitproc>:
  404958:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40495c:	4698      	mov	r8, r3
  40495e:	4b23      	ldr	r3, [pc, #140]	; (4049ec <__register_exitproc+0x94>)
  404960:	681c      	ldr	r4, [r3, #0]
  404962:	4606      	mov	r6, r0
  404964:	f8d4 0148 	ldr.w	r0, [r4, #328]	; 0x148
  404968:	460f      	mov	r7, r1
  40496a:	4691      	mov	r9, r2
  40496c:	b918      	cbnz	r0, 404976 <__register_exitproc+0x1e>
  40496e:	f504 70a6 	add.w	r0, r4, #332	; 0x14c
  404972:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  404976:	6841      	ldr	r1, [r0, #4]
  404978:	291f      	cmp	r1, #31
  40497a:	dd16      	ble.n	4049aa <__register_exitproc+0x52>
  40497c:	481c      	ldr	r0, [pc, #112]	; (4049f0 <__register_exitproc+0x98>)
  40497e:	b918      	cbnz	r0, 404988 <__register_exitproc+0x30>
  404980:	f04f 30ff 	mov.w	r0, #4294967295
  404984:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  404988:	f44f 70c8 	mov.w	r0, #400	; 0x190
  40498c:	f3af 8000 	nop.w
  404990:	2800      	cmp	r0, #0
  404992:	d0f5      	beq.n	404980 <__register_exitproc+0x28>
  404994:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  404998:	2500      	movs	r5, #0
  40499a:	6045      	str	r5, [r0, #4]
  40499c:	6002      	str	r2, [r0, #0]
  40499e:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  4049a2:	f8c0 5188 	str.w	r5, [r0, #392]	; 0x188
  4049a6:	f8c0 518c 	str.w	r5, [r0, #396]	; 0x18c
  4049aa:	b1b6      	cbz	r6, 4049da <__register_exitproc+0x82>
  4049ac:	6844      	ldr	r4, [r0, #4]
  4049ae:	f8d0 1188 	ldr.w	r1, [r0, #392]	; 0x188
  4049b2:	2201      	movs	r2, #1
  4049b4:	eb00 0384 	add.w	r3, r0, r4, lsl #2
  4049b8:	fa02 f204 	lsl.w	r2, r2, r4
  4049bc:	4311      	orrs	r1, r2
  4049be:	2e02      	cmp	r6, #2
  4049c0:	f8c3 9088 	str.w	r9, [r3, #136]	; 0x88
  4049c4:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  4049c8:	461c      	mov	r4, r3
  4049ca:	f8c3 8108 	str.w	r8, [r3, #264]	; 0x108
  4049ce:	d104      	bne.n	4049da <__register_exitproc+0x82>
  4049d0:	f8d0 318c 	ldr.w	r3, [r0, #396]	; 0x18c
  4049d4:	431a      	orrs	r2, r3
  4049d6:	f8c0 218c 	str.w	r2, [r0, #396]	; 0x18c
  4049da:	6841      	ldr	r1, [r0, #4]
  4049dc:	1c8b      	adds	r3, r1, #2
  4049de:	1c4a      	adds	r2, r1, #1
  4049e0:	f840 7023 	str.w	r7, [r0, r3, lsl #2]
  4049e4:	6042      	str	r2, [r0, #4]
  4049e6:	2000      	movs	r0, #0
  4049e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4049ec:	00404b10 	.word	0x00404b10
  4049f0:	00000000 	.word	0x00000000

004049f4 <__libc_fini_array>:
  4049f4:	b570      	push	{r4, r5, r6, lr}
  4049f6:	4b08      	ldr	r3, [pc, #32]	; (404a18 <__libc_fini_array+0x24>)
  4049f8:	4c08      	ldr	r4, [pc, #32]	; (404a1c <__libc_fini_array+0x28>)
  4049fa:	1ae0      	subs	r0, r4, r3
  4049fc:	1084      	asrs	r4, r0, #2
  4049fe:	eb03 0684 	add.w	r6, r3, r4, lsl #2
  404a02:	2500      	movs	r5, #0
  404a04:	3d04      	subs	r5, #4
  404a06:	b11c      	cbz	r4, 404a10 <__libc_fini_array+0x1c>
  404a08:	5972      	ldr	r2, [r6, r5]
  404a0a:	4790      	blx	r2
  404a0c:	3c01      	subs	r4, #1
  404a0e:	e7f9      	b.n	404a04 <__libc_fini_array+0x10>
  404a10:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  404a14:	f000 b88a 	b.w	404b2c <_fini>
  404a18:	00404b38 	.word	0x00404b38
  404a1c:	00404b3c 	.word	0x00404b3c

00404a20 <__libc_init_array>:
  404a20:	b538      	push	{r3, r4, r5, lr}
  404a22:	4d0e      	ldr	r5, [pc, #56]	; (404a5c <__libc_init_array+0x3c>)
  404a24:	4b0e      	ldr	r3, [pc, #56]	; (404a60 <__libc_init_array+0x40>)
  404a26:	1ae8      	subs	r0, r5, r3
  404a28:	1085      	asrs	r5, r0, #2
  404a2a:	2400      	movs	r4, #0
  404a2c:	42ac      	cmp	r4, r5
  404a2e:	d005      	beq.n	404a3c <__libc_init_array+0x1c>
  404a30:	490b      	ldr	r1, [pc, #44]	; (404a60 <__libc_init_array+0x40>)
  404a32:	f851 2024 	ldr.w	r2, [r1, r4, lsl #2]
  404a36:	4790      	blx	r2
  404a38:	3401      	adds	r4, #1
  404a3a:	e7f7      	b.n	404a2c <__libc_init_array+0xc>
  404a3c:	f000 f86c 	bl	404b18 <_init>
  404a40:	4908      	ldr	r1, [pc, #32]	; (404a64 <__libc_init_array+0x44>)
  404a42:	4a09      	ldr	r2, [pc, #36]	; (404a68 <__libc_init_array+0x48>)
  404a44:	1a54      	subs	r4, r2, r1
  404a46:	10a5      	asrs	r5, r4, #2
  404a48:	2400      	movs	r4, #0
  404a4a:	42ac      	cmp	r4, r5
  404a4c:	d005      	beq.n	404a5a <__libc_init_array+0x3a>
  404a4e:	4b05      	ldr	r3, [pc, #20]	; (404a64 <__libc_init_array+0x44>)
  404a50:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  404a54:	4780      	blx	r0
  404a56:	3401      	adds	r4, #1
  404a58:	e7f7      	b.n	404a4a <__libc_init_array+0x2a>
  404a5a:	bd38      	pop	{r3, r4, r5, pc}
  404a5c:	00404b24 	.word	0x00404b24
  404a60:	00404b24 	.word	0x00404b24
  404a64:	00404b24 	.word	0x00404b24
  404a68:	00404b2c 	.word	0x00404b2c

00404a6c <memcmp>:
  404a6c:	b530      	push	{r4, r5, lr}
  404a6e:	2300      	movs	r3, #0
  404a70:	4293      	cmp	r3, r2
  404a72:	d008      	beq.n	404a86 <memcmp+0x1a>
  404a74:	5cc5      	ldrb	r5, [r0, r3]
  404a76:	3301      	adds	r3, #1
  404a78:	18cc      	adds	r4, r1, r3
  404a7a:	f814 4c01 	ldrb.w	r4, [r4, #-1]
  404a7e:	42a5      	cmp	r5, r4
  404a80:	d0f6      	beq.n	404a70 <memcmp+0x4>
  404a82:	1b28      	subs	r0, r5, r4
  404a84:	bd30      	pop	{r4, r5, pc}
  404a86:	2000      	movs	r0, #0
  404a88:	bd30      	pop	{r4, r5, pc}

00404a8a <memcpy>:
  404a8a:	b510      	push	{r4, lr}
  404a8c:	2300      	movs	r3, #0
  404a8e:	4293      	cmp	r3, r2
  404a90:	d003      	beq.n	404a9a <memcpy+0x10>
  404a92:	5ccc      	ldrb	r4, [r1, r3]
  404a94:	54c4      	strb	r4, [r0, r3]
  404a96:	3301      	adds	r3, #1
  404a98:	e7f9      	b.n	404a8e <memcpy+0x4>
  404a9a:	bd10      	pop	{r4, pc}

00404a9c <memset>:
  404a9c:	1882      	adds	r2, r0, r2
  404a9e:	4603      	mov	r3, r0
  404aa0:	4293      	cmp	r3, r2
  404aa2:	d002      	beq.n	404aaa <memset+0xe>
  404aa4:	f803 1b01 	strb.w	r1, [r3], #1
  404aa8:	e7fa      	b.n	404aa0 <memset+0x4>
  404aaa:	4770      	bx	lr

00404aac <register_fini>:
  404aac:	4b02      	ldr	r3, [pc, #8]	; (404ab8 <register_fini+0xc>)
  404aae:	b113      	cbz	r3, 404ab6 <register_fini+0xa>
  404ab0:	4802      	ldr	r0, [pc, #8]	; (404abc <register_fini+0x10>)
  404ab2:	f000 b805 	b.w	404ac0 <atexit>
  404ab6:	4770      	bx	lr
  404ab8:	00000000 	.word	0x00000000
  404abc:	004049f5 	.word	0x004049f5

00404ac0 <atexit>:
  404ac0:	4601      	mov	r1, r0
  404ac2:	2000      	movs	r0, #0
  404ac4:	4602      	mov	r2, r0
  404ac6:	4603      	mov	r3, r0
  404ac8:	f7ff bf46 	b.w	404958 <__register_exitproc>

00404acc <heapSTRUCT_SIZE>:
  404acc:	0008 0000                                   ....

00404ad0 <xTotalHeapSize>:
  404ad0:	9ff8 0000                                   ....

00404ad4 <pcInterruptPriorityRegisters>:
  404ad4:	e3f0 e000 4449 454c 0000 0000               ....IDLE....

00404ae0 <ucExpectedStackBytes.5224>:
  404ae0:	a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5     ................
  404af0:	a5a5 a5a5 6d54 2072 7653 0063 7852 0000     ....Tmr Svc.Rx..
  404b00:	5854 0000                                   TX..

00404b04 <ulLED>:
  404b04:	0054 0000 0013 0000 0014 0000               T...........

00404b10 <_global_impure_ptr>:
  404b10:	0018 2000 0043 0000                         ... C...

00404b18 <_init>:
  404b18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  404b1a:	bf00      	nop
  404b1c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  404b1e:	bc08      	pop	{r3}
  404b20:	469e      	mov	lr, r3
  404b22:	4770      	bx	lr

00404b24 <__init_array_start>:
  404b24:	00404aad 	.word	0x00404aad

00404b28 <__frame_dummy_init_array_entry>:
  404b28:	00400149                                I.@.

00404b2c <_fini>:
  404b2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  404b2e:	bf00      	nop
  404b30:	bcf8      	pop	{r3, r4, r5, r6, r7}
  404b32:	bc08      	pop	{r3}
  404b34:	469e      	mov	lr, r3
  404b36:	4770      	bx	lr

00404b38 <__fini_array_start>:
  404b38:	00400121 	.word	0x00400121


RTOSDemo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004cb4  00400000  00400000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000440  20000000  00404cb4  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000a1dc  20000440  004050f4  00010440  2**2
                  ALLOC
  3 .stack        00003004  2000a61c  0040f2d0  00010440  2**0
                  ALLOC
  4 .ARM.attributes 0000002a  00000000  00000000  00010440  2**0
                  CONTENTS, READONLY
  5 .comment      00000071  00000000  00000000  0001046a  2**0
                  CONTENTS, READONLY
  6 .debug_info   0000b0ad  00000000  00000000  000104db  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000256b  00000000  00000000  0001b588  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00003a33  00000000  00000000  0001daf3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000b00  00000000  00000000  00021526  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000009d0  00000000  00000000  00022026  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00005111  00000000  00000000  000229f6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000d145  00000000  00000000  00027b07  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0004b75d  00000000  00000000  00034c4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00002020  00000000  00000000  000803ac  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	2000d620 	.word	0x2000d620
  400004:	00401721 	.word	0x00401721
  400008:	00401719 	.word	0x00401719
  40000c:	00401719 	.word	0x00401719
  400010:	00401719 	.word	0x00401719
  400014:	00401719 	.word	0x00401719
  400018:	00401719 	.word	0x00401719
	...
  40002c:	00401d41 	.word	0x00401d41
  400030:	00401719 	.word	0x00401719
  400034:	00000000 	.word	0x00000000
  400038:	00401f3d 	.word	0x00401f3d
  40003c:	00401f79 	.word	0x00401f79
  400040:	00401719 	.word	0x00401719
  400044:	00401719 	.word	0x00401719
  400048:	00401719 	.word	0x00401719
  40004c:	00401719 	.word	0x00401719
  400050:	00401719 	.word	0x00401719
  400054:	00401719 	.word	0x00401719
  400058:	00401719 	.word	0x00401719
  40005c:	00401719 	.word	0x00401719
  400060:	00401719 	.word	0x00401719
  400064:	00401719 	.word	0x00401719
  400068:	00401719 	.word	0x00401719
  40006c:	004012e5 	.word	0x004012e5
  400070:	00401301 	.word	0x00401301
  400074:	0040131d 	.word	0x0040131d
  400078:	00401719 	.word	0x00401719
  40007c:	00401719 	.word	0x00401719
  400080:	00401719 	.word	0x00401719
  400084:	00401719 	.word	0x00401719
  400088:	00401719 	.word	0x00401719
  40008c:	00401719 	.word	0x00401719
  400090:	00401719 	.word	0x00401719
  400094:	00401719 	.word	0x00401719
  400098:	00401719 	.word	0x00401719
  40009c:	00401719 	.word	0x00401719
  4000a0:	00401719 	.word	0x00401719
  4000a4:	00401719 	.word	0x00401719
  4000a8:	00401719 	.word	0x00401719
  4000ac:	00401719 	.word	0x00401719
  4000b0:	00401719 	.word	0x00401719
  4000b4:	00401719 	.word	0x00401719
  4000b8:	00401719 	.word	0x00401719
  4000bc:	00401719 	.word	0x00401719
  4000c0:	00401719 	.word	0x00401719
  4000c4:	00401719 	.word	0x00401719
  4000c8:	00401719 	.word	0x00401719
  4000cc:	00401719 	.word	0x00401719

004000d0 <deregister_tm_clones>:
  4000d0:	b508      	push	{r3, lr}
  4000d2:	4805      	ldr	r0, [pc, #20]	; (4000e8 <deregister_tm_clones+0x18>)
  4000d4:	4b05      	ldr	r3, [pc, #20]	; (4000ec <deregister_tm_clones+0x1c>)
  4000d6:	1a19      	subs	r1, r3, r0
  4000d8:	2906      	cmp	r1, #6
  4000da:	d800      	bhi.n	4000de <deregister_tm_clones+0xe>
  4000dc:	bd08      	pop	{r3, pc}
  4000de:	4a04      	ldr	r2, [pc, #16]	; (4000f0 <deregister_tm_clones+0x20>)
  4000e0:	2a00      	cmp	r2, #0
  4000e2:	d0fb      	beq.n	4000dc <deregister_tm_clones+0xc>
  4000e4:	4790      	blx	r2
  4000e6:	e7f9      	b.n	4000dc <deregister_tm_clones+0xc>
  4000e8:	00404cb4 	.word	0x00404cb4
  4000ec:	00404cb7 	.word	0x00404cb7
  4000f0:	00000000 	.word	0x00000000

004000f4 <register_tm_clones>:
  4000f4:	b508      	push	{r3, lr}
  4000f6:	4807      	ldr	r0, [pc, #28]	; (400114 <register_tm_clones+0x20>)
  4000f8:	4b07      	ldr	r3, [pc, #28]	; (400118 <register_tm_clones+0x24>)
  4000fa:	1a19      	subs	r1, r3, r0
  4000fc:	108a      	asrs	r2, r1, #2
  4000fe:	eb02 73d2 	add.w	r3, r2, r2, lsr #31
  400102:	1059      	asrs	r1, r3, #1
  400104:	d100      	bne.n	400108 <register_tm_clones+0x14>
  400106:	bd08      	pop	{r3, pc}
  400108:	4a04      	ldr	r2, [pc, #16]	; (40011c <register_tm_clones+0x28>)
  40010a:	2a00      	cmp	r2, #0
  40010c:	d0fb      	beq.n	400106 <register_tm_clones+0x12>
  40010e:	4790      	blx	r2
  400110:	e7f9      	b.n	400106 <register_tm_clones+0x12>
  400112:	bf00      	nop
  400114:	00404cb4 	.word	0x00404cb4
  400118:	00404cb4 	.word	0x00404cb4
  40011c:	00000000 	.word	0x00000000

00400120 <__do_global_dtors_aux>:
  400120:	b510      	push	{r4, lr}
  400122:	4c06      	ldr	r4, [pc, #24]	; (40013c <__do_global_dtors_aux+0x1c>)
  400124:	7823      	ldrb	r3, [r4, #0]
  400126:	b943      	cbnz	r3, 40013a <__do_global_dtors_aux+0x1a>
  400128:	f7ff ffd2 	bl	4000d0 <deregister_tm_clones>
  40012c:	4804      	ldr	r0, [pc, #16]	; (400140 <__do_global_dtors_aux+0x20>)
  40012e:	b110      	cbz	r0, 400136 <__do_global_dtors_aux+0x16>
  400130:	4804      	ldr	r0, [pc, #16]	; (400144 <__do_global_dtors_aux+0x24>)
  400132:	f3af 8000 	nop.w
  400136:	2101      	movs	r1, #1
  400138:	7021      	strb	r1, [r4, #0]
  40013a:	bd10      	pop	{r4, pc}
  40013c:	20000440 	.word	0x20000440
  400140:	00000000 	.word	0x00000000
  400144:	00404cb4 	.word	0x00404cb4

00400148 <frame_dummy>:
  400148:	b508      	push	{r3, lr}
  40014a:	4b08      	ldr	r3, [pc, #32]	; (40016c <frame_dummy+0x24>)
  40014c:	b11b      	cbz	r3, 400156 <frame_dummy+0xe>
  40014e:	4808      	ldr	r0, [pc, #32]	; (400170 <frame_dummy+0x28>)
  400150:	4908      	ldr	r1, [pc, #32]	; (400174 <frame_dummy+0x2c>)
  400152:	f3af 8000 	nop.w
  400156:	4808      	ldr	r0, [pc, #32]	; (400178 <frame_dummy+0x30>)
  400158:	6801      	ldr	r1, [r0, #0]
  40015a:	b111      	cbz	r1, 400162 <frame_dummy+0x1a>
  40015c:	4a07      	ldr	r2, [pc, #28]	; (40017c <frame_dummy+0x34>)
  40015e:	b102      	cbz	r2, 400162 <frame_dummy+0x1a>
  400160:	4790      	blx	r2
  400162:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  400166:	f7ff bfc5 	b.w	4000f4 <register_tm_clones>
  40016a:	bf00      	nop
  40016c:	00000000 	.word	0x00000000
  400170:	00404cb4 	.word	0x00404cb4
  400174:	20000444 	.word	0x20000444
  400178:	00404cb4 	.word	0x00404cb4
  40017c:	00000000 	.word	0x00000000

00400180 <sysclk_enable_peripheral_clock>:
 * \brief Enable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
  400180:	b580      	push	{r7, lr}
  400182:	b082      	sub	sp, #8
  400184:	af00      	add	r7, sp, #0
  400186:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  400188:	6878      	ldr	r0, [r7, #4]
  40018a:	f241 6371 	movw	r3, #5745	; 0x1671
  40018e:	f2c0 0340 	movt	r3, #64	; 0x40
  400192:	4798      	blx	r3
}
  400194:	f107 0708 	add.w	r7, r7, #8
  400198:	46bd      	mov	sp, r7
  40019a:	bd80      	pop	{r7, pc}

0040019c <ioport_init>:
 *
 * This function must be called before using any other functions in the IOPORT
 * service.
 */
static inline void ioport_init(void)
{
  40019c:	b580      	push	{r7, lr}
  40019e:	af00      	add	r7, sp, #0
}

__always_inline static void arch_ioport_init(void)
{
#ifdef ID_PIOA
	sysclk_enable_peripheral_clock(ID_PIOA);
  4001a0:	f04f 000b 	mov.w	r0, #11
  4001a4:	f240 1381 	movw	r3, #385	; 0x181
  4001a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4001ac:	4798      	blx	r3
#endif
#ifdef ID_PIOB
	sysclk_enable_peripheral_clock(ID_PIOB);
  4001ae:	f04f 000c 	mov.w	r0, #12
  4001b2:	f240 1381 	movw	r3, #385	; 0x181
  4001b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4001ba:	4798      	blx	r3
#endif
#ifdef ID_PIOC
	sysclk_enable_peripheral_clock(ID_PIOC);
  4001bc:	f04f 000d 	mov.w	r0, #13
  4001c0:	f240 1381 	movw	r3, #385	; 0x181
  4001c4:	f2c0 0340 	movt	r3, #64	; 0x40
  4001c8:	4798      	blx	r3
	arch_ioport_init();
}
  4001ca:	bd80      	pop	{r7, pc}

004001cc <ioport_set_pin_mode>:
 *
 * \param pin IOPORT pin to configure
 * \param mode Mode masks to configure for the specified pin (\ref ioport_modes)
 */
static inline void ioport_set_pin_mode(ioport_pin_t pin, ioport_mode_t mode)
{
  4001cc:	b480      	push	{r7}
  4001ce:	b08d      	sub	sp, #52	; 0x34
  4001d0:	af00      	add	r7, sp, #0
  4001d2:	6078      	str	r0, [r7, #4]
  4001d4:	6039      	str	r1, [r7, #0]
  4001d6:	687b      	ldr	r3, [r7, #4]
  4001d8:	62fb      	str	r3, [r7, #44]	; 0x2c
  4001da:	683b      	ldr	r3, [r7, #0]
  4001dc:	62bb      	str	r3, [r7, #40]	; 0x28
  4001de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4001e0:	627b      	str	r3, [r7, #36]	; 0x24
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  4001e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4001e4:	ea4f 1353 	mov.w	r3, r3, lsr #5
}

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	arch_ioport_set_port_mode(arch_ioport_pin_to_port_id(pin),
  4001e8:	461a      	mov	r2, r3
  4001ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4001ec:	623b      	str	r3, [r7, #32]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  4001ee:	6a3b      	ldr	r3, [r7, #32]
  4001f0:	f003 031f 	and.w	r3, r3, #31
  4001f4:	f04f 0101 	mov.w	r1, #1
  4001f8:	fa01 f303 	lsl.w	r3, r1, r3
  4001fc:	61fa      	str	r2, [r7, #28]
  4001fe:	61bb      	str	r3, [r7, #24]
  400200:	6abb      	ldr	r3, [r7, #40]	; 0x28
  400202:	617b      	str	r3, [r7, #20]
  400204:	69fb      	ldr	r3, [r7, #28]
  400206:	613b      	str	r3, [r7, #16]
	return pin >> 5;
}

__always_inline static Pio *arch_ioport_port_to_base(ioport_port_t port)
{
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  400208:	693b      	ldr	r3, [r7, #16]
  40020a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40020e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400212:	ea4f 2343 	mov.w	r3, r3, lsl #9
}

__always_inline static void arch_ioport_set_port_mode(ioport_port_t port,
		ioport_port_mask_t mask, ioport_mode_t mode)
{
	Pio *base = arch_ioport_port_to_base(port);
  400216:	60fb      	str	r3, [r7, #12]

	if (mode & IOPORT_MODE_PULLUP) {
  400218:	697b      	ldr	r3, [r7, #20]
  40021a:	f003 0308 	and.w	r3, r3, #8
  40021e:	2b00      	cmp	r3, #0
  400220:	d003      	beq.n	40022a <ioport_set_pin_mode+0x5e>
		base->PIO_PUER = mask;
  400222:	68fb      	ldr	r3, [r7, #12]
  400224:	69ba      	ldr	r2, [r7, #24]
  400226:	665a      	str	r2, [r3, #100]	; 0x64
  400228:	e002      	b.n	400230 <ioport_set_pin_mode+0x64>
	} else {
		base->PIO_PUDR = mask;
  40022a:	68fb      	ldr	r3, [r7, #12]
  40022c:	69ba      	ldr	r2, [r7, #24]
  40022e:	661a      	str	r2, [r3, #96]	; 0x60
	}

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
  400230:	697b      	ldr	r3, [r7, #20]
  400232:	f003 0310 	and.w	r3, r3, #16
  400236:	2b00      	cmp	r3, #0
  400238:	d004      	beq.n	400244 <ioport_set_pin_mode+0x78>
		base->PIO_PPDER = mask;
  40023a:	68fb      	ldr	r3, [r7, #12]
  40023c:	69ba      	ldr	r2, [r7, #24]
  40023e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  400242:	e003      	b.n	40024c <ioport_set_pin_mode+0x80>
	} else {
		base->PIO_PPDDR = mask;
  400244:	68fb      	ldr	r3, [r7, #12]
  400246:	69ba      	ldr	r2, [r7, #24]
  400248:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	}
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  40024c:	697b      	ldr	r3, [r7, #20]
  40024e:	f003 0320 	and.w	r3, r3, #32
  400252:	2b00      	cmp	r3, #0
  400254:	d003      	beq.n	40025e <ioport_set_pin_mode+0x92>
		base->PIO_MDER = mask;
  400256:	68fb      	ldr	r3, [r7, #12]
  400258:	69ba      	ldr	r2, [r7, #24]
  40025a:	651a      	str	r2, [r3, #80]	; 0x50
  40025c:	e002      	b.n	400264 <ioport_set_pin_mode+0x98>
	} else {
		base->PIO_MDDR = mask;
  40025e:	68fb      	ldr	r3, [r7, #12]
  400260:	69ba      	ldr	r2, [r7, #24]
  400262:	655a      	str	r2, [r3, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  400264:	697b      	ldr	r3, [r7, #20]
  400266:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  40026a:	2b00      	cmp	r3, #0
  40026c:	d003      	beq.n	400276 <ioport_set_pin_mode+0xaa>
		base->PIO_IFER = mask;
  40026e:	68fb      	ldr	r3, [r7, #12]
  400270:	69ba      	ldr	r2, [r7, #24]
  400272:	621a      	str	r2, [r3, #32]
  400274:	e002      	b.n	40027c <ioport_set_pin_mode+0xb0>
	} else {
		base->PIO_IFDR = mask;
  400276:	68fb      	ldr	r3, [r7, #12]
  400278:	69ba      	ldr	r2, [r7, #24]
  40027a:	625a      	str	r2, [r3, #36]	; 0x24
	}

	if (mode & IOPORT_MODE_DEBOUNCE) {
  40027c:	697b      	ldr	r3, [r7, #20]
  40027e:	f003 0380 	and.w	r3, r3, #128	; 0x80
  400282:	2b00      	cmp	r3, #0
  400284:	d004      	beq.n	400290 <ioport_set_pin_mode+0xc4>
#if SAM3U || SAM3XA
		base->PIO_DIFSR = mask;
#else
		base->PIO_IFSCER = mask;
  400286:	68fb      	ldr	r3, [r7, #12]
  400288:	69ba      	ldr	r2, [r7, #24]
  40028a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  40028e:	e003      	b.n	400298 <ioport_set_pin_mode+0xcc>
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  400290:	68fb      	ldr	r3, [r7, #12]
  400292:	69ba      	ldr	r2, [r7, #24]
  400294:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		base->PIO_ABSR |= mask;
	} else {
		base->PIO_ABSR &= ~mask;
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
  400298:	697b      	ldr	r3, [r7, #20]
  40029a:	f003 0301 	and.w	r3, r3, #1
  40029e:	2b00      	cmp	r3, #0
  4002a0:	d006      	beq.n	4002b0 <ioport_set_pin_mode+0xe4>
		base->PIO_ABCDSR[0] |= mask;
  4002a2:	68fb      	ldr	r3, [r7, #12]
  4002a4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4002a6:	69bb      	ldr	r3, [r7, #24]
  4002a8:	431a      	orrs	r2, r3
  4002aa:	68fb      	ldr	r3, [r7, #12]
  4002ac:	671a      	str	r2, [r3, #112]	; 0x70
  4002ae:	e007      	b.n	4002c0 <ioport_set_pin_mode+0xf4>
	} else {
		base->PIO_ABCDSR[0] &= ~mask;
  4002b0:	68fb      	ldr	r3, [r7, #12]
  4002b2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4002b4:	69bb      	ldr	r3, [r7, #24]
  4002b6:	ea6f 0303 	mvn.w	r3, r3
  4002ba:	401a      	ands	r2, r3
  4002bc:	68fb      	ldr	r3, [r7, #12]
  4002be:	671a      	str	r2, [r3, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
  4002c0:	697b      	ldr	r3, [r7, #20]
  4002c2:	f003 0302 	and.w	r3, r3, #2
  4002c6:	2b00      	cmp	r3, #0
  4002c8:	d006      	beq.n	4002d8 <ioport_set_pin_mode+0x10c>
		base->PIO_ABCDSR[1] |= mask;
  4002ca:	68fb      	ldr	r3, [r7, #12]
  4002cc:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4002ce:	69bb      	ldr	r3, [r7, #24]
  4002d0:	431a      	orrs	r2, r3
  4002d2:	68fb      	ldr	r3, [r7, #12]
  4002d4:	675a      	str	r2, [r3, #116]	; 0x74
  4002d6:	e007      	b.n	4002e8 <ioport_set_pin_mode+0x11c>
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  4002d8:	68fb      	ldr	r3, [r7, #12]
  4002da:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4002dc:	69bb      	ldr	r3, [r7, #24]
  4002de:	ea6f 0303 	mvn.w	r3, r3
  4002e2:	401a      	ands	r2, r3
  4002e4:	68fb      	ldr	r3, [r7, #12]
  4002e6:	675a      	str	r2, [r3, #116]	; 0x74
	arch_ioport_set_pin_mode(pin, mode);
}
  4002e8:	f107 0734 	add.w	r7, r7, #52	; 0x34
  4002ec:	46bd      	mov	sp, r7
  4002ee:	bc80      	pop	{r7}
  4002f0:	4770      	bx	lr
  4002f2:	bf00      	nop

004002f4 <ioport_set_pin_dir>:
 * \param pin IOPORT pin to configure
 * \param dir Direction to set for the specified pin (\ref ioport_direction)
 */
static inline void ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
  4002f4:	b480      	push	{r7}
  4002f6:	b08d      	sub	sp, #52	; 0x34
  4002f8:	af00      	add	r7, sp, #0
  4002fa:	6078      	str	r0, [r7, #4]
  4002fc:	460b      	mov	r3, r1
  4002fe:	70fb      	strb	r3, [r7, #3]
  400300:	687b      	ldr	r3, [r7, #4]
  400302:	62fb      	str	r3, [r7, #44]	; 0x2c
  400304:	78fb      	ldrb	r3, [r7, #3]
  400306:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  40030a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40030c:	627b      	str	r3, [r7, #36]	; 0x24
  40030e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400310:	623b      	str	r3, [r7, #32]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  400312:	6a3b      	ldr	r3, [r7, #32]
  400314:	ea4f 1353 	mov.w	r3, r3, lsr #5
  400318:	61fb      	str	r3, [r7, #28]
}

__always_inline static Pio *arch_ioport_port_to_base(ioport_port_t port)
{
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40031a:	69fb      	ldr	r3, [r7, #28]
  40031c:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400320:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400324:	ea4f 2343 	mov.w	r3, r3, lsl #9
}

__always_inline static void arch_ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  400328:	61bb      	str	r3, [r7, #24]

	if (dir == IOPORT_DIR_OUTPUT) {
  40032a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  40032e:	2b01      	cmp	r3, #1
  400330:	d10c      	bne.n	40034c <ioport_set_pin_dir+0x58>
  400332:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  400334:	617b      	str	r3, [r7, #20]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400336:	697b      	ldr	r3, [r7, #20]
  400338:	f003 031f 	and.w	r3, r3, #31
  40033c:	f04f 0201 	mov.w	r2, #1
  400340:	fa02 f303 	lsl.w	r3, r2, r3
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  400344:	461a      	mov	r2, r3
  400346:	69bb      	ldr	r3, [r7, #24]
  400348:	611a      	str	r2, [r3, #16]
  40034a:	e00f      	b.n	40036c <ioport_set_pin_dir+0x78>
	} else if (dir == IOPORT_DIR_INPUT) {
  40034c:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  400350:	2b00      	cmp	r3, #0
  400352:	d10b      	bne.n	40036c <ioport_set_pin_dir+0x78>
  400354:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  400356:	613b      	str	r3, [r7, #16]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400358:	693b      	ldr	r3, [r7, #16]
  40035a:	f003 031f 	and.w	r3, r3, #31
  40035e:	f04f 0201 	mov.w	r2, #1
  400362:	fa02 f303 	lsl.w	r3, r2, r3
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  400366:	461a      	mov	r2, r3
  400368:	69bb      	ldr	r3, [r7, #24]
  40036a:	615a      	str	r2, [r3, #20]
  40036c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40036e:	60fb      	str	r3, [r7, #12]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400370:	68fb      	ldr	r3, [r7, #12]
  400372:	f003 031f 	and.w	r3, r3, #31
  400376:	f04f 0201 	mov.w	r2, #1
  40037a:	fa02 f303 	lsl.w	r3, r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40037e:	461a      	mov	r2, r3
  400380:	69bb      	ldr	r3, [r7, #24]
  400382:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	arch_ioport_set_pin_dir(pin, dir);
}
  400386:	f107 0734 	add.w	r7, r7, #52	; 0x34
  40038a:	46bd      	mov	sp, r7
  40038c:	bc80      	pop	{r7}
  40038e:	4770      	bx	lr

00400390 <ioport_set_pin_level>:
 *
 * \param pin IOPORT pin to configure
 * \param level Logical value of the pin
 */
static inline void ioport_set_pin_level(ioport_pin_t pin, bool level)
{
  400390:	b480      	push	{r7}
  400392:	b08b      	sub	sp, #44	; 0x2c
  400394:	af00      	add	r7, sp, #0
  400396:	6078      	str	r0, [r7, #4]
  400398:	460b      	mov	r3, r1
  40039a:	70fb      	strb	r3, [r7, #3]
  40039c:	687b      	ldr	r3, [r7, #4]
  40039e:	627b      	str	r3, [r7, #36]	; 0x24
  4003a0:	78fb      	ldrb	r3, [r7, #3]
  4003a2:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  4003a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4003a8:	61fb      	str	r3, [r7, #28]
  4003aa:	69fb      	ldr	r3, [r7, #28]
  4003ac:	61bb      	str	r3, [r7, #24]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  4003ae:	69bb      	ldr	r3, [r7, #24]
  4003b0:	ea4f 1353 	mov.w	r3, r3, lsr #5
  4003b4:	617b      	str	r3, [r7, #20]
}

__always_inline static Pio *arch_ioport_port_to_base(ioport_port_t port)
{
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4003b6:	697b      	ldr	r3, [r7, #20]
  4003b8:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4003bc:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4003c0:	ea4f 2343 	mov.w	r3, r3, lsl #9
}

__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  4003c4:	613b      	str	r3, [r7, #16]

	if (level) {
  4003c6:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  4003ca:	2b00      	cmp	r3, #0
  4003cc:	d00c      	beq.n	4003e8 <ioport_set_pin_level+0x58>
  4003ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4003d0:	60fb      	str	r3, [r7, #12]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  4003d2:	68fb      	ldr	r3, [r7, #12]
  4003d4:	f003 031f 	and.w	r3, r3, #31
  4003d8:	f04f 0201 	mov.w	r2, #1
  4003dc:	fa02 f303 	lsl.w	r3, r2, r3
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  4003e0:	461a      	mov	r2, r3
  4003e2:	693b      	ldr	r3, [r7, #16]
  4003e4:	631a      	str	r2, [r3, #48]	; 0x30
  4003e6:	e00b      	b.n	400400 <ioport_set_pin_level+0x70>
  4003e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4003ea:	60bb      	str	r3, [r7, #8]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  4003ec:	68bb      	ldr	r3, [r7, #8]
  4003ee:	f003 031f 	and.w	r3, r3, #31
  4003f2:	f04f 0201 	mov.w	r2, #1
  4003f6:	fa02 f303 	lsl.w	r3, r2, r3
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  4003fa:	461a      	mov	r2, r3
  4003fc:	693b      	ldr	r3, [r7, #16]
  4003fe:	635a      	str	r2, [r3, #52]	; 0x34
	arch_ioport_set_pin_level(pin, level);
}
  400400:	f107 072c 	add.w	r7, r7, #44	; 0x2c
  400404:	46bd      	mov	sp, r7
  400406:	bc80      	pop	{r7}
  400408:	4770      	bx	lr
  40040a:	bf00      	nop

0040040c <board_init>:
 * \addtogroup sam4s_xplained_pro_group
 * @{
 */

void board_init(void)
{
  40040c:	b580      	push	{r7, lr}
  40040e:	af00      	add	r7, sp, #0
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	wdt_disable(WDT);
  400410:	f241 4050 	movw	r0, #5200	; 0x1450
  400414:	f2c4 000e 	movt	r0, #16398	; 0x400e
  400418:	f240 43f5 	movw	r3, #1269	; 0x4f5
  40041c:	f2c0 0340 	movt	r3, #64	; 0x40
  400420:	4798      	blx	r3

	/* GPIO has been deprecated, the old code just keeps it for compatibility.
	 * In new designs IOPORT is used instead.
	 * Here IOPORT must be initialized for others to use before setting up IO.
	 */
	ioport_init();
  400422:	f240 139d 	movw	r3, #413	; 0x19d
  400426:	f2c0 0340 	movt	r3, #64	; 0x40
  40042a:	4798      	blx	r3

	/* Initialize LED0, turned off */
	ioport_set_pin_level(LED_0_PIN, !LED_0_ACTIVE);
  40042c:	f04f 0057 	mov.w	r0, #87	; 0x57
  400430:	f04f 0101 	mov.w	r1, #1
  400434:	f240 3391 	movw	r3, #913	; 0x391
  400438:	f2c0 0340 	movt	r3, #64	; 0x40
  40043c:	4798      	blx	r3
	ioport_set_pin_dir(LED_0_PIN, IOPORT_DIR_OUTPUT);
  40043e:	f04f 0057 	mov.w	r0, #87	; 0x57
  400442:	f04f 0101 	mov.w	r1, #1
  400446:	f240 23f5 	movw	r3, #757	; 0x2f5
  40044a:	f2c0 0340 	movt	r3, #64	; 0x40
  40044e:	4798      	blx	r3

	/* Initialize SW0 */
	ioport_set_pin_dir(BUTTON_0_PIN, IOPORT_DIR_INPUT);
  400450:	f04f 0002 	mov.w	r0, #2
  400454:	f04f 0100 	mov.w	r1, #0
  400458:	f240 23f5 	movw	r3, #757	; 0x2f5
  40045c:	f2c0 0340 	movt	r3, #64	; 0x40
  400460:	4798      	blx	r3
	ioport_set_pin_mode(BUTTON_0_PIN, (BUTTON_0_ACTIVE ?
  400462:	f04f 0002 	mov.w	r0, #2
  400466:	f04f 0108 	mov.w	r1, #8
  40046a:	f240 13cd 	movw	r3, #461	; 0x1cd
  40046e:	f2c0 0340 	movt	r3, #64	; 0x40
  400472:	4798      	blx	r3
				IOPORT_MODE_PULLDOWN : IOPORT_MODE_PULLUP));

	/* Initialize EXT3 LED0, LED1 & LED2, turned off */
	ioport_set_pin_level(IO1_LED1_PIN, !IO1_LED1_ACTIVE);
  400474:	f04f 0054 	mov.w	r0, #84	; 0x54
  400478:	f04f 0101 	mov.w	r1, #1
  40047c:	f240 3391 	movw	r3, #913	; 0x391
  400480:	f2c0 0340 	movt	r3, #64	; 0x40
  400484:	4798      	blx	r3
	ioport_set_pin_dir(IO1_LED1_PIN, IOPORT_DIR_OUTPUT);
  400486:	f04f 0054 	mov.w	r0, #84	; 0x54
  40048a:	f04f 0101 	mov.w	r1, #1
  40048e:	f240 23f5 	movw	r3, #757	; 0x2f5
  400492:	f2c0 0340 	movt	r3, #64	; 0x40
  400496:	4798      	blx	r3
	ioport_set_pin_level(IO1_LED2_PIN, !IO1_LED2_ACTIVE);
  400498:	f04f 0010 	mov.w	r0, #16
  40049c:	f04f 0101 	mov.w	r1, #1
  4004a0:	f240 3391 	movw	r3, #913	; 0x391
  4004a4:	f2c0 0340 	movt	r3, #64	; 0x40
  4004a8:	4798      	blx	r3
	ioport_set_pin_dir(IO1_LED2_PIN, IOPORT_DIR_OUTPUT);
  4004aa:	f04f 0010 	mov.w	r0, #16
  4004ae:	f04f 0101 	mov.w	r1, #1
  4004b2:	f240 23f5 	movw	r3, #757	; 0x2f5
  4004b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4004ba:	4798      	blx	r3
	ioport_set_pin_level(IO1_LED3_PIN, !IO1_LED3_ACTIVE);
  4004bc:	f04f 0056 	mov.w	r0, #86	; 0x56
  4004c0:	f04f 0101 	mov.w	r1, #1
  4004c4:	f240 3391 	movw	r3, #913	; 0x391
  4004c8:	f2c0 0340 	movt	r3, #64	; 0x40
  4004cc:	4798      	blx	r3
	ioport_set_pin_dir(IO1_LED3_PIN, IOPORT_DIR_OUTPUT);
  4004ce:	f04f 0056 	mov.w	r0, #86	; 0x56
  4004d2:	f04f 0101 	mov.w	r1, #1
  4004d6:	f240 23f5 	movw	r3, #757	; 0x2f5
  4004da:	f2c0 0340 	movt	r3, #64	; 0x40
  4004de:	4798      	blx	r3

  if ( BUTTON_0_ACTIVE ) {
		ioport_set_pin_mode(BUTTON_0_PIN, IOPORT_MODE_PULLDOWN);
	}
  else {
		ioport_set_pin_mode(BUTTON_0_PIN, IOPORT_MODE_PULLUP);
  4004e0:	f04f 0002 	mov.w	r0, #2
  4004e4:	f04f 0108 	mov.w	r1, #8
  4004e8:	f240 13cd 	movw	r3, #461	; 0x1cd
  4004ec:	f2c0 0340 	movt	r3, #64	; 0x40
  4004f0:	4798      	blx	r3
  }
}
  4004f2:	bd80      	pop	{r7, pc}

004004f4 <wdt_disable>:

/**
 * \brief Disable the watchdog timer.
 */
void wdt_disable(Wdt *p_wdt)
{
  4004f4:	b480      	push	{r7}
  4004f6:	b083      	sub	sp, #12
  4004f8:	af00      	add	r7, sp, #0
  4004fa:	6078      	str	r0, [r7, #4]
	p_wdt->WDT_MR = WDT_MR_WDDIS;
  4004fc:	687b      	ldr	r3, [r7, #4]
  4004fe:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  400502:	605a      	str	r2, [r3, #4]
}
  400504:	f107 070c 	add.w	r7, r7, #12
  400508:	46bd      	mov	sp, r7
  40050a:	bc80      	pop	{r7}
  40050c:	4770      	bx	lr
  40050e:	bf00      	nop

00400510 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  400510:	b580      	push	{r7, lr}
  400512:	b086      	sub	sp, #24
  400514:	af00      	add	r7, sp, #0
  400516:	6078      	str	r0, [r7, #4]
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
  400518:	f04f 0300 	mov.w	r3, #0
  40051c:	60fb      	str	r3, [r7, #12]

	vTaskSuspendAll();
  40051e:	f642 735d 	movw	r3, #12125	; 0x2f5d
  400522:	f2c0 0340 	movt	r3, #64	; 0x40
  400526:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
  400528:	f24a 4364 	movw	r3, #42084	; 0xa464
  40052c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400530:	681b      	ldr	r3, [r3, #0]
  400532:	2b00      	cmp	r3, #0
  400534:	d104      	bne.n	400540 <pvPortMalloc+0x30>
		{
			prvHeapInit();
  400536:	f240 7365 	movw	r3, #1893	; 0x765
  40053a:	f2c0 0340 	movt	r3, #64	; 0x40
  40053e:	4798      	blx	r3

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the xBlockLink structure 
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
  400540:	f24a 4368 	movw	r3, #42088	; 0xa468
  400544:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400548:	681a      	ldr	r2, [r3, #0]
  40054a:	687b      	ldr	r3, [r7, #4]
  40054c:	4013      	ands	r3, r2
  40054e:	2b00      	cmp	r3, #0
  400550:	f040 808b 	bne.w	40066a <pvPortMalloc+0x15a>
		{
			/* The wanted size is increased so it can contain a xBlockLink
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
  400554:	687b      	ldr	r3, [r7, #4]
  400556:	2b00      	cmp	r3, #0
  400558:	d012      	beq.n	400580 <pvPortMalloc+0x70>
			{
				xWantedSize += heapSTRUCT_SIZE;
  40055a:	f644 4344 	movw	r3, #19524	; 0x4c44
  40055e:	f2c0 0340 	movt	r3, #64	; 0x40
  400562:	881b      	ldrh	r3, [r3, #0]
  400564:	687a      	ldr	r2, [r7, #4]
  400566:	18d3      	adds	r3, r2, r3
  400568:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number 
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
  40056a:	687b      	ldr	r3, [r7, #4]
  40056c:	f003 0307 	and.w	r3, r3, #7
  400570:	2b00      	cmp	r3, #0
  400572:	d005      	beq.n	400580 <pvPortMalloc+0x70>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  400574:	687b      	ldr	r3, [r7, #4]
  400576:	f023 0307 	bic.w	r3, r3, #7
  40057a:	f103 0308 	add.w	r3, r3, #8
  40057e:	607b      	str	r3, [r7, #4]
				}
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
  400580:	687b      	ldr	r3, [r7, #4]
  400582:	2b00      	cmp	r3, #0
  400584:	d071      	beq.n	40066a <pvPortMalloc+0x15a>
  400586:	f240 0300 	movw	r3, #0
  40058a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40058e:	681b      	ldr	r3, [r3, #0]
  400590:	687a      	ldr	r2, [r7, #4]
  400592:	429a      	cmp	r2, r3
  400594:	d869      	bhi.n	40066a <pvPortMalloc+0x15a>
			{
				/* Traverse the list from the start	(lowest address) block until 
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
  400596:	f24a 435c 	movw	r3, #42076	; 0xa45c
  40059a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40059e:	613b      	str	r3, [r7, #16]
				pxBlock = xStart.pxNextFreeBlock;
  4005a0:	f24a 435c 	movw	r3, #42076	; 0xa45c
  4005a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4005a8:	681b      	ldr	r3, [r3, #0]
  4005aa:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  4005ac:	e004      	b.n	4005b8 <pvPortMalloc+0xa8>
				{
					pxPreviousBlock = pxBlock;
  4005ae:	697b      	ldr	r3, [r7, #20]
  4005b0:	613b      	str	r3, [r7, #16]
					pxBlock = pxBlock->pxNextFreeBlock;
  4005b2:	697b      	ldr	r3, [r7, #20]
  4005b4:	681b      	ldr	r3, [r3, #0]
  4005b6:	617b      	str	r3, [r7, #20]
			{
				/* Traverse the list from the start	(lowest address) block until 
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  4005b8:	697b      	ldr	r3, [r7, #20]
  4005ba:	685a      	ldr	r2, [r3, #4]
  4005bc:	687b      	ldr	r3, [r7, #4]
  4005be:	429a      	cmp	r2, r3
  4005c0:	d203      	bcs.n	4005ca <pvPortMalloc+0xba>
  4005c2:	697b      	ldr	r3, [r7, #20]
  4005c4:	681b      	ldr	r3, [r3, #0]
  4005c6:	2b00      	cmp	r3, #0
  4005c8:	d1f1      	bne.n	4005ae <pvPortMalloc+0x9e>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size 
				was	not found. */
				if( pxBlock != pxEnd )
  4005ca:	f24a 4364 	movw	r3, #42084	; 0xa464
  4005ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4005d2:	681b      	ldr	r3, [r3, #0]
  4005d4:	697a      	ldr	r2, [r7, #20]
  4005d6:	429a      	cmp	r2, r3
  4005d8:	d047      	beq.n	40066a <pvPortMalloc+0x15a>
				{
					/* Return the memory space pointed to - jumping over the 
					xBlockLink structure at its start. */
					pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
  4005da:	693b      	ldr	r3, [r7, #16]
  4005dc:	681a      	ldr	r2, [r3, #0]
  4005de:	f644 4344 	movw	r3, #19524	; 0x4c44
  4005e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4005e6:	881b      	ldrh	r3, [r3, #0]
  4005e8:	18d3      	adds	r3, r2, r3
  4005ea:	60fb      	str	r3, [r7, #12]

					/* This block is being returned for use so must be taken out 
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  4005ec:	697b      	ldr	r3, [r7, #20]
  4005ee:	681a      	ldr	r2, [r3, #0]
  4005f0:	693b      	ldr	r3, [r7, #16]
  4005f2:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into 
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  4005f4:	697b      	ldr	r3, [r7, #20]
  4005f6:	685a      	ldr	r2, [r3, #4]
  4005f8:	687b      	ldr	r3, [r7, #4]
  4005fa:	1ad2      	subs	r2, r2, r3
  4005fc:	f644 4344 	movw	r3, #19524	; 0x4c44
  400600:	f2c0 0340 	movt	r3, #64	; 0x40
  400604:	881b      	ldrh	r3, [r3, #0]
  400606:	ea4f 0343 	mov.w	r3, r3, lsl #1
  40060a:	429a      	cmp	r2, r3
  40060c:	d912      	bls.n	400634 <pvPortMalloc+0x124>
					{
						/* This block is to be split into two.  Create a new 
						block following the number of bytes requested. The void 
						cast is used to prevent byte alignment warnings from the 
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
  40060e:	697a      	ldr	r2, [r7, #20]
  400610:	687b      	ldr	r3, [r7, #4]
  400612:	18d3      	adds	r3, r2, r3
  400614:	60bb      	str	r3, [r7, #8]

						/* Calculate the sizes of two blocks split from the 
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  400616:	697b      	ldr	r3, [r7, #20]
  400618:	685a      	ldr	r2, [r3, #4]
  40061a:	687b      	ldr	r3, [r7, #4]
  40061c:	1ad2      	subs	r2, r2, r3
  40061e:	68bb      	ldr	r3, [r7, #8]
  400620:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
  400622:	697b      	ldr	r3, [r7, #20]
  400624:	687a      	ldr	r2, [r7, #4]
  400626:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
  400628:	68b8      	ldr	r0, [r7, #8]
  40062a:	f640 0361 	movw	r3, #2145	; 0x861
  40062e:	f2c0 0340 	movt	r3, #64	; 0x40
  400632:	4798      	blx	r3
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
  400634:	f240 0300 	movw	r3, #0
  400638:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40063c:	681a      	ldr	r2, [r3, #0]
  40063e:	697b      	ldr	r3, [r7, #20]
  400640:	685b      	ldr	r3, [r3, #4]
  400642:	1ad2      	subs	r2, r2, r3
  400644:	f240 0300 	movw	r3, #0
  400648:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40064c:	601a      	str	r2, [r3, #0]

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
  40064e:	697b      	ldr	r3, [r7, #20]
  400650:	685a      	ldr	r2, [r3, #4]
  400652:	f24a 4368 	movw	r3, #42088	; 0xa468
  400656:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40065a:	681b      	ldr	r3, [r3, #0]
  40065c:	431a      	orrs	r2, r3
  40065e:	697b      	ldr	r3, [r7, #20]
  400660:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
  400662:	697b      	ldr	r3, [r7, #20]
  400664:	f04f 0200 	mov.w	r2, #0
  400668:	601a      	str	r2, [r3, #0]
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	xTaskResumeAll();
  40066a:	f642 7381 	movw	r3, #12161	; 0x2f81
  40066e:	f2c0 0340 	movt	r3, #64	; 0x40
  400672:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
  400674:	68fb      	ldr	r3, [r7, #12]
  400676:	2b00      	cmp	r3, #0
  400678:	d104      	bne.n	400684 <pvPortMalloc+0x174>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
  40067a:	f244 738d 	movw	r3, #18317	; 0x478d
  40067e:	f2c0 0340 	movt	r3, #64	; 0x40
  400682:	4798      	blx	r3
		}
	}
	#endif

	return pvReturn;
  400684:	68fb      	ldr	r3, [r7, #12]
}
  400686:	4618      	mov	r0, r3
  400688:	f107 0718 	add.w	r7, r7, #24
  40068c:	46bd      	mov	sp, r7
  40068e:	bd80      	pop	{r7, pc}

00400690 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  400690:	b580      	push	{r7, lr}
  400692:	b084      	sub	sp, #16
  400694:	af00      	add	r7, sp, #0
  400696:	6078      	str	r0, [r7, #4]
unsigned char *puc = ( unsigned char * ) pv;
  400698:	687b      	ldr	r3, [r7, #4]
  40069a:	60fb      	str	r3, [r7, #12]
xBlockLink *pxLink;

	if( pv != NULL )
  40069c:	687b      	ldr	r3, [r7, #4]
  40069e:	2b00      	cmp	r3, #0
  4006a0:	d05c      	beq.n	40075c <vPortFree+0xcc>
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
  4006a2:	f644 4344 	movw	r3, #19524	; 0x4c44
  4006a6:	f2c0 0340 	movt	r3, #64	; 0x40
  4006aa:	881b      	ldrh	r3, [r3, #0]
  4006ac:	f1c3 0300 	rsb	r3, r3, #0
  4006b0:	68fa      	ldr	r2, [r7, #12]
  4006b2:	18d3      	adds	r3, r2, r3
  4006b4:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
  4006b6:	68fb      	ldr	r3, [r7, #12]
  4006b8:	60bb      	str	r3, [r7, #8]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
  4006ba:	68bb      	ldr	r3, [r7, #8]
  4006bc:	685a      	ldr	r2, [r3, #4]
  4006be:	f24a 4368 	movw	r3, #42088	; 0xa468
  4006c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4006c6:	681b      	ldr	r3, [r3, #0]
  4006c8:	4013      	ands	r3, r2
  4006ca:	2b00      	cmp	r3, #0
  4006cc:	d105      	bne.n	4006da <vPortFree+0x4a>
  4006ce:	f641 7321 	movw	r3, #7969	; 0x1f21
  4006d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4006d6:	4798      	blx	r3
  4006d8:	e7fe      	b.n	4006d8 <vPortFree+0x48>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
  4006da:	68bb      	ldr	r3, [r7, #8]
  4006dc:	681b      	ldr	r3, [r3, #0]
  4006de:	2b00      	cmp	r3, #0
  4006e0:	d005      	beq.n	4006ee <vPortFree+0x5e>
  4006e2:	f641 7321 	movw	r3, #7969	; 0x1f21
  4006e6:	f2c0 0340 	movt	r3, #64	; 0x40
  4006ea:	4798      	blx	r3
  4006ec:	e7fe      	b.n	4006ec <vPortFree+0x5c>
		
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
  4006ee:	68bb      	ldr	r3, [r7, #8]
  4006f0:	685a      	ldr	r2, [r3, #4]
  4006f2:	f24a 4368 	movw	r3, #42088	; 0xa468
  4006f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4006fa:	681b      	ldr	r3, [r3, #0]
  4006fc:	4013      	ands	r3, r2
  4006fe:	2b00      	cmp	r3, #0
  400700:	d02c      	beq.n	40075c <vPortFree+0xcc>
		{
			if( pxLink->pxNextFreeBlock == NULL )
  400702:	68bb      	ldr	r3, [r7, #8]
  400704:	681b      	ldr	r3, [r3, #0]
  400706:	2b00      	cmp	r3, #0
  400708:	d128      	bne.n	40075c <vPortFree+0xcc>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
  40070a:	68bb      	ldr	r3, [r7, #8]
  40070c:	685a      	ldr	r2, [r3, #4]
  40070e:	f24a 4368 	movw	r3, #42088	; 0xa468
  400712:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400716:	681b      	ldr	r3, [r3, #0]
  400718:	ea6f 0303 	mvn.w	r3, r3
  40071c:	401a      	ands	r2, r3
  40071e:	68bb      	ldr	r3, [r7, #8]
  400720:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
  400722:	f642 735d 	movw	r3, #12125	; 0x2f5d
  400726:	f2c0 0340 	movt	r3, #64	; 0x40
  40072a:	4798      	blx	r3
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
  40072c:	68bb      	ldr	r3, [r7, #8]
  40072e:	685a      	ldr	r2, [r3, #4]
  400730:	f240 0300 	movw	r3, #0
  400734:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400738:	681b      	ldr	r3, [r3, #0]
  40073a:	18d2      	adds	r2, r2, r3
  40073c:	f240 0300 	movw	r3, #0
  400740:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400744:	601a      	str	r2, [r3, #0]
					prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
  400746:	68b8      	ldr	r0, [r7, #8]
  400748:	f640 0361 	movw	r3, #2145	; 0x861
  40074c:	f2c0 0340 	movt	r3, #64	; 0x40
  400750:	4798      	blx	r3
					traceFREE( pv, pxLink->xBlockSize );
				}
				xTaskResumeAll();
  400752:	f642 7381 	movw	r3, #12161	; 0x2f81
  400756:	f2c0 0340 	movt	r3, #64	; 0x40
  40075a:	4798      	blx	r3
			}
		}
	}
}
  40075c:	f107 0710 	add.w	r7, r7, #16
  400760:	46bd      	mov	sp, r7
  400762:	bd80      	pop	{r7, pc}

00400764 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
  400764:	b580      	push	{r7, lr}
  400766:	b084      	sub	sp, #16
  400768:	af00      	add	r7, sp, #0
xBlockLink *pxFirstFreeBlock;
unsigned char *pucHeapEnd, *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
  40076a:	4b3c      	ldr	r3, [pc, #240]	; (40085c <prvHeapInit+0xf8>)
  40076c:	f023 0307 	bic.w	r3, r3, #7
  400770:	60fb      	str	r3, [r7, #12]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  400772:	f24a 435c 	movw	r3, #42076	; 0xa45c
  400776:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40077a:	68fa      	ldr	r2, [r7, #12]
  40077c:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
  40077e:	f24a 435c 	movw	r3, #42076	; 0xa45c
  400782:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400786:	f04f 0200 	mov.w	r2, #0
  40078a:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = pucAlignedHeap + xTotalHeapSize;
  40078c:	f644 4348 	movw	r3, #19528	; 0x4c48
  400790:	f2c0 0340 	movt	r3, #64	; 0x40
  400794:	681b      	ldr	r3, [r3, #0]
  400796:	68fa      	ldr	r2, [r7, #12]
  400798:	18d3      	adds	r3, r2, r3
  40079a:	60bb      	str	r3, [r7, #8]
	pucHeapEnd -= heapSTRUCT_SIZE;
  40079c:	f644 4344 	movw	r3, #19524	; 0x4c44
  4007a0:	f2c0 0340 	movt	r3, #64	; 0x40
  4007a4:	881b      	ldrh	r3, [r3, #0]
  4007a6:	f1c3 0300 	rsb	r3, r3, #0
  4007aa:	68ba      	ldr	r2, [r7, #8]
  4007ac:	18d3      	adds	r3, r2, r3
  4007ae:	60bb      	str	r3, [r7, #8]
	pxEnd = ( void * ) pucHeapEnd;
  4007b0:	f24a 4364 	movw	r3, #42084	; 0xa464
  4007b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4007b8:	68ba      	ldr	r2, [r7, #8]
  4007ba:	601a      	str	r2, [r3, #0]
	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
  4007bc:	f24a 4364 	movw	r3, #42084	; 0xa464
  4007c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4007c4:	681b      	ldr	r3, [r3, #0]
  4007c6:	f003 0307 	and.w	r3, r3, #7
  4007ca:	2b00      	cmp	r3, #0
  4007cc:	d005      	beq.n	4007da <prvHeapInit+0x76>
  4007ce:	f641 7321 	movw	r3, #7969	; 0x1f21
  4007d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4007d6:	4798      	blx	r3
  4007d8:	e7fe      	b.n	4007d8 <prvHeapInit+0x74>
	pxEnd->xBlockSize = 0;
  4007da:	f24a 4364 	movw	r3, #42084	; 0xa464
  4007de:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4007e2:	681b      	ldr	r3, [r3, #0]
  4007e4:	f04f 0200 	mov.w	r2, #0
  4007e8:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
  4007ea:	f24a 4364 	movw	r3, #42084	; 0xa464
  4007ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4007f2:	681b      	ldr	r3, [r3, #0]
  4007f4:	f04f 0200 	mov.w	r2, #0
  4007f8:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
  4007fa:	68fb      	ldr	r3, [r7, #12]
  4007fc:	607b      	str	r3, [r7, #4]
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
  4007fe:	f644 4348 	movw	r3, #19528	; 0x4c48
  400802:	f2c0 0340 	movt	r3, #64	; 0x40
  400806:	681a      	ldr	r2, [r3, #0]
  400808:	f644 4344 	movw	r3, #19524	; 0x4c44
  40080c:	f2c0 0340 	movt	r3, #64	; 0x40
  400810:	881b      	ldrh	r3, [r3, #0]
  400812:	1ad2      	subs	r2, r2, r3
  400814:	687b      	ldr	r3, [r7, #4]
  400816:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  400818:	f24a 4364 	movw	r3, #42084	; 0xa464
  40081c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400820:	681a      	ldr	r2, [r3, #0]
  400822:	687b      	ldr	r3, [r7, #4]
  400824:	601a      	str	r2, [r3, #0]

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
  400826:	f240 0300 	movw	r3, #0
  40082a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40082e:	681a      	ldr	r2, [r3, #0]
  400830:	f644 4344 	movw	r3, #19524	; 0x4c44
  400834:	f2c0 0340 	movt	r3, #64	; 0x40
  400838:	881b      	ldrh	r3, [r3, #0]
  40083a:	1ad2      	subs	r2, r2, r3
  40083c:	f240 0300 	movw	r3, #0
  400840:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400844:	601a      	str	r2, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  400846:	f24a 4368 	movw	r3, #42088	; 0xa468
  40084a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40084e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  400852:	601a      	str	r2, [r3, #0]
}
  400854:	f107 0710 	add.w	r7, r7, #16
  400858:	46bd      	mov	sp, r7
  40085a:	bd80      	pop	{r7, pc}
  40085c:	20000464 	.word	0x20000464

00400860 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
  400860:	b480      	push	{r7}
  400862:	b085      	sub	sp, #20
  400864:	af00      	add	r7, sp, #0
  400866:	6078      	str	r0, [r7, #4]
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  400868:	f24a 435c 	movw	r3, #42076	; 0xa45c
  40086c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400870:	60fb      	str	r3, [r7, #12]
  400872:	e002      	b.n	40087a <prvInsertBlockIntoFreeList+0x1a>
  400874:	68fb      	ldr	r3, [r7, #12]
  400876:	681b      	ldr	r3, [r3, #0]
  400878:	60fb      	str	r3, [r7, #12]
  40087a:	68fb      	ldr	r3, [r7, #12]
  40087c:	681a      	ldr	r2, [r3, #0]
  40087e:	687b      	ldr	r3, [r7, #4]
  400880:	429a      	cmp	r2, r3
  400882:	d3f7      	bcc.n	400874 <prvInsertBlockIntoFreeList+0x14>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
  400884:	68fb      	ldr	r3, [r7, #12]
  400886:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
  400888:	68fb      	ldr	r3, [r7, #12]
  40088a:	685b      	ldr	r3, [r3, #4]
  40088c:	68ba      	ldr	r2, [r7, #8]
  40088e:	18d2      	adds	r2, r2, r3
  400890:	687b      	ldr	r3, [r7, #4]
  400892:	429a      	cmp	r2, r3
  400894:	d108      	bne.n	4008a8 <prvInsertBlockIntoFreeList+0x48>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  400896:	68fb      	ldr	r3, [r7, #12]
  400898:	685a      	ldr	r2, [r3, #4]
  40089a:	687b      	ldr	r3, [r7, #4]
  40089c:	685b      	ldr	r3, [r3, #4]
  40089e:	18d2      	adds	r2, r2, r3
  4008a0:	68fb      	ldr	r3, [r7, #12]
  4008a2:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
  4008a4:	68fb      	ldr	r3, [r7, #12]
  4008a6:	607b      	str	r3, [r7, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
  4008a8:	687b      	ldr	r3, [r7, #4]
  4008aa:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
  4008ac:	687b      	ldr	r3, [r7, #4]
  4008ae:	685b      	ldr	r3, [r3, #4]
  4008b0:	68ba      	ldr	r2, [r7, #8]
  4008b2:	18d2      	adds	r2, r2, r3
  4008b4:	68fb      	ldr	r3, [r7, #12]
  4008b6:	681b      	ldr	r3, [r3, #0]
  4008b8:	429a      	cmp	r2, r3
  4008ba:	d11e      	bne.n	4008fa <prvInsertBlockIntoFreeList+0x9a>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  4008bc:	68fb      	ldr	r3, [r7, #12]
  4008be:	681a      	ldr	r2, [r3, #0]
  4008c0:	f24a 4364 	movw	r3, #42084	; 0xa464
  4008c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4008c8:	681b      	ldr	r3, [r3, #0]
  4008ca:	429a      	cmp	r2, r3
  4008cc:	d00d      	beq.n	4008ea <prvInsertBlockIntoFreeList+0x8a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  4008ce:	687b      	ldr	r3, [r7, #4]
  4008d0:	685a      	ldr	r2, [r3, #4]
  4008d2:	68fb      	ldr	r3, [r7, #12]
  4008d4:	681b      	ldr	r3, [r3, #0]
  4008d6:	685b      	ldr	r3, [r3, #4]
  4008d8:	18d2      	adds	r2, r2, r3
  4008da:	687b      	ldr	r3, [r7, #4]
  4008dc:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  4008de:	68fb      	ldr	r3, [r7, #12]
  4008e0:	681b      	ldr	r3, [r3, #0]
  4008e2:	681a      	ldr	r2, [r3, #0]
  4008e4:	687b      	ldr	r3, [r7, #4]
  4008e6:	601a      	str	r2, [r3, #0]
  4008e8:	e00b      	b.n	400902 <prvInsertBlockIntoFreeList+0xa2>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  4008ea:	f24a 4364 	movw	r3, #42084	; 0xa464
  4008ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4008f2:	681a      	ldr	r2, [r3, #0]
  4008f4:	687b      	ldr	r3, [r7, #4]
  4008f6:	601a      	str	r2, [r3, #0]
  4008f8:	e003      	b.n	400902 <prvInsertBlockIntoFreeList+0xa2>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
  4008fa:	68fb      	ldr	r3, [r7, #12]
  4008fc:	681a      	ldr	r2, [r3, #0]
  4008fe:	687b      	ldr	r3, [r7, #4]
  400900:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  400902:	68fa      	ldr	r2, [r7, #12]
  400904:	687b      	ldr	r3, [r7, #4]
  400906:	429a      	cmp	r2, r3
  400908:	d002      	beq.n	400910 <prvInsertBlockIntoFreeList+0xb0>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  40090a:	68fb      	ldr	r3, [r7, #12]
  40090c:	687a      	ldr	r2, [r7, #4]
  40090e:	601a      	str	r2, [r3, #0]
	}
}
  400910:	f107 0714 	add.w	r7, r7, #20
  400914:	46bd      	mov	sp, r7
  400916:	bc80      	pop	{r7}
  400918:	4770      	bx	lr
  40091a:	bf00      	nop

0040091c <osc_enable>:
#define OSC_MAINCK_XTAL_HZ			BOARD_FREQ_MAINCK_XTAL			//!< External crystal oscillator.
#define OSC_MAINCK_BYPASS_HZ		BOARD_FREQ_MAINCK_BYPASS		//!< External bypass oscillator.
//@}

static inline void osc_enable(uint32_t ul_id)
{
  40091c:	b580      	push	{r7, lr}
  40091e:	b082      	sub	sp, #8
  400920:	af00      	add	r7, sp, #0
  400922:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400924:	687b      	ldr	r3, [r7, #4]
  400926:	2b07      	cmp	r3, #7
  400928:	d84a      	bhi.n	4009c0 <osc_enable+0xa4>
  40092a:	a201      	add	r2, pc, #4	; (adr r2, 400930 <osc_enable+0x14>)
  40092c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400930:	004009c1 	.word	0x004009c1
  400934:	00400951 	.word	0x00400951
  400938:	00400961 	.word	0x00400961
  40093c:	00400971 	.word	0x00400971
  400940:	00400981 	.word	0x00400981
  400944:	00400991 	.word	0x00400991
  400948:	004009a1 	.word	0x004009a1
  40094c:	004009b1 	.word	0x004009b1
	case OSC_SLCK_32K_RC:
		break;

	case OSC_SLCK_32K_XTAL:
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  400950:	f04f 0000 	mov.w	r0, #0
  400954:	f241 33e5 	movw	r3, #5093	; 0x13e5
  400958:	f2c0 0340 	movt	r3, #64	; 0x40
  40095c:	4798      	blx	r3
		break;
  40095e:	e02f      	b.n	4009c0 <osc_enable+0xa4>

	case OSC_SLCK_32K_BYPASS:
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
  400960:	f04f 0001 	mov.w	r0, #1
  400964:	f241 33e5 	movw	r3, #5093	; 0x13e5
  400968:	f2c0 0340 	movt	r3, #64	; 0x40
  40096c:	4798      	blx	r3
		break;
  40096e:	e027      	b.n	4009c0 <osc_enable+0xa4>


	case OSC_MAINCK_4M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_4_MHz);
  400970:	f04f 0000 	mov.w	r0, #0
  400974:	f241 4371 	movw	r3, #5233	; 0x1471
  400978:	f2c0 0340 	movt	r3, #64	; 0x40
  40097c:	4798      	blx	r3
		break;
  40097e:	e01f      	b.n	4009c0 <osc_enable+0xa4>

	case OSC_MAINCK_8M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
  400980:	f04f 0010 	mov.w	r0, #16
  400984:	f241 4371 	movw	r3, #5233	; 0x1471
  400988:	f2c0 0340 	movt	r3, #64	; 0x40
  40098c:	4798      	blx	r3
		break;
  40098e:	e017      	b.n	4009c0 <osc_enable+0xa4>

	case OSC_MAINCK_12M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
  400990:	f04f 0020 	mov.w	r0, #32
  400994:	f241 4371 	movw	r3, #5233	; 0x1471
  400998:	f2c0 0340 	movt	r3, #64	; 0x40
  40099c:	4798      	blx	r3
		break;
  40099e:	e00f      	b.n	4009c0 <osc_enable+0xa4>


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL);
  4009a0:	f04f 0000 	mov.w	r0, #0
  4009a4:	f241 5351 	movw	r3, #5457	; 0x1551
  4009a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4009ac:	4798      	blx	r3
		break;
  4009ae:	e007      	b.n	4009c0 <osc_enable+0xa4>

	case OSC_MAINCK_BYPASS:
		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS);
  4009b0:	f04f 0001 	mov.w	r0, #1
  4009b4:	f241 5351 	movw	r3, #5457	; 0x1551
  4009b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4009bc:	4798      	blx	r3
		break;
  4009be:	bf00      	nop
	}
}
  4009c0:	f107 0708 	add.w	r7, r7, #8
  4009c4:	46bd      	mov	sp, r7
  4009c6:	bd80      	pop	{r7, pc}

004009c8 <osc_is_ready>:
		break;
	}
}

static inline bool osc_is_ready(uint32_t ul_id)
{
  4009c8:	b580      	push	{r7, lr}
  4009ca:	b082      	sub	sp, #8
  4009cc:	af00      	add	r7, sp, #0
  4009ce:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4009d0:	687b      	ldr	r3, [r7, #4]
  4009d2:	2b07      	cmp	r3, #7
  4009d4:	d82d      	bhi.n	400a32 <osc_is_ready+0x6a>
  4009d6:	a201      	add	r2, pc, #4	; (adr r2, 4009dc <osc_is_ready+0x14>)
  4009d8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4009dc:	004009fd 	.word	0x004009fd
  4009e0:	00400a03 	.word	0x00400a03
  4009e4:	00400a03 	.word	0x00400a03
  4009e8:	00400a1b 	.word	0x00400a1b
  4009ec:	00400a1b 	.word	0x00400a1b
  4009f0:	00400a1b 	.word	0x00400a1b
  4009f4:	00400a1b 	.word	0x00400a1b
  4009f8:	00400a1b 	.word	0x00400a1b
	case OSC_SLCK_32K_RC:
		return 1;
  4009fc:	f04f 0301 	mov.w	r3, #1
  400a00:	e019      	b.n	400a36 <osc_is_ready+0x6e>

	case OSC_SLCK_32K_XTAL:
	case OSC_SLCK_32K_BYPASS:
		return pmc_osc_is_ready_32kxtal();
  400a02:	f241 4335 	movw	r3, #5173	; 0x1435
  400a06:	f2c0 0340 	movt	r3, #64	; 0x40
  400a0a:	4798      	blx	r3
  400a0c:	4603      	mov	r3, r0
  400a0e:	2b00      	cmp	r3, #0
  400a10:	bf0c      	ite	eq
  400a12:	2300      	moveq	r3, #0
  400a14:	2301      	movne	r3, #1
  400a16:	b2db      	uxtb	r3, r3
  400a18:	e00d      	b.n	400a36 <osc_is_ready+0x6e>
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  400a1a:	f241 53ed 	movw	r3, #5613	; 0x15ed
  400a1e:	f2c0 0340 	movt	r3, #64	; 0x40
  400a22:	4798      	blx	r3
  400a24:	4603      	mov	r3, r0
  400a26:	2b00      	cmp	r3, #0
  400a28:	bf0c      	ite	eq
  400a2a:	2300      	moveq	r3, #0
  400a2c:	2301      	movne	r3, #1
  400a2e:	b2db      	uxtb	r3, r3
  400a30:	e001      	b.n	400a36 <osc_is_ready+0x6e>
	}

	return 0;
  400a32:	f04f 0300 	mov.w	r3, #0
}
  400a36:	4618      	mov	r0, r3
  400a38:	f107 0708 	add.w	r7, r7, #8
  400a3c:	46bd      	mov	sp, r7
  400a3e:	bd80      	pop	{r7, pc}

00400a40 <osc_get_rate>:

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  400a40:	b480      	push	{r7}
  400a42:	b083      	sub	sp, #12
  400a44:	af00      	add	r7, sp, #0
  400a46:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400a48:	687b      	ldr	r3, [r7, #4]
  400a4a:	2b07      	cmp	r3, #7
  400a4c:	d834      	bhi.n	400ab8 <osc_get_rate+0x78>
  400a4e:	a201      	add	r2, pc, #4	; (adr r2, 400a54 <osc_get_rate+0x14>)
  400a50:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400a54:	00400a75 	.word	0x00400a75
  400a58:	00400a7b 	.word	0x00400a7b
  400a5c:	00400a81 	.word	0x00400a81
  400a60:	00400a87 	.word	0x00400a87
  400a64:	00400a91 	.word	0x00400a91
  400a68:	00400a9b 	.word	0x00400a9b
  400a6c:	00400aa5 	.word	0x00400aa5
  400a70:	00400aaf 	.word	0x00400aaf
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  400a74:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  400a78:	e020      	b.n	400abc <osc_get_rate+0x7c>

#ifdef BOARD_FREQ_SLCK_XTAL
	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  400a7a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400a7e:	e01d      	b.n	400abc <osc_get_rate+0x7c>
#endif

#ifdef BOARD_FREQ_SLCK_BYPASS
	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  400a80:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400a84:	e01a      	b.n	400abc <osc_get_rate+0x7c>
#endif

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
  400a86:	f44f 6310 	mov.w	r3, #2304	; 0x900
  400a8a:	f2c0 033d 	movt	r3, #61	; 0x3d
  400a8e:	e015      	b.n	400abc <osc_get_rate+0x7c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  400a90:	f44f 5390 	mov.w	r3, #4608	; 0x1200
  400a94:	f2c0 037a 	movt	r3, #122	; 0x7a
  400a98:	e010      	b.n	400abc <osc_get_rate+0x7c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
  400a9a:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  400a9e:	f2c0 03b7 	movt	r3, #183	; 0xb7
  400aa2:	e00b      	b.n	400abc <osc_get_rate+0x7c>

#ifdef BOARD_FREQ_MAINCK_XTAL
	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  400aa4:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  400aa8:	f2c0 03b7 	movt	r3, #183	; 0xb7
  400aac:	e006      	b.n	400abc <osc_get_rate+0x7c>
#endif

#ifdef BOARD_FREQ_MAINCK_BYPASS
	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  400aae:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  400ab2:	f2c0 03b7 	movt	r3, #183	; 0xb7
  400ab6:	e001      	b.n	400abc <osc_get_rate+0x7c>
#endif
	}

	return 0;
  400ab8:	f04f 0300 	mov.w	r3, #0
}
  400abc:	4618      	mov	r0, r3
  400abe:	f107 070c 	add.w	r7, r7, #12
  400ac2:	46bd      	mov	sp, r7
  400ac4:	bc80      	pop	{r7}
  400ac6:	4770      	bx	lr

00400ac8 <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
  400ac8:	b580      	push	{r7, lr}
  400aca:	b082      	sub	sp, #8
  400acc:	af00      	add	r7, sp, #0
  400ace:	4603      	mov	r3, r0
  400ad0:	71fb      	strb	r3, [r7, #7]
	while (!osc_is_ready(id)) {
  400ad2:	bf00      	nop
  400ad4:	79fb      	ldrb	r3, [r7, #7]
  400ad6:	4618      	mov	r0, r3
  400ad8:	f640 13c9 	movw	r3, #2505	; 0x9c9
  400adc:	f2c0 0340 	movt	r3, #64	; 0x40
  400ae0:	4798      	blx	r3
  400ae2:	4603      	mov	r3, r0
  400ae4:	f083 0301 	eor.w	r3, r3, #1
  400ae8:	b2db      	uxtb	r3, r3
  400aea:	2b00      	cmp	r3, #0
  400aec:	d1f2      	bne.n	400ad4 <osc_wait_ready+0xc>
		/* Do nothing */
	}
}
  400aee:	f107 0708 	add.w	r7, r7, #8
  400af2:	46bd      	mov	sp, r7
  400af4:	bd80      	pop	{r7, pc}
  400af6:	bf00      	nop

00400af8 <pll_config_init>:
 * \note The SAM3S PLL hardware interprets mul as mul+1. For readability the hardware mul+1
 * is hidden in this implementation. Use mul as mul effective value.
 */
static inline void pll_config_init(struct pll_config *p_cfg,
		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
{
  400af8:	b580      	push	{r7, lr}
  400afa:	b086      	sub	sp, #24
  400afc:	af00      	add	r7, sp, #0
  400afe:	60f8      	str	r0, [r7, #12]
  400b00:	607a      	str	r2, [r7, #4]
  400b02:	603b      	str	r3, [r7, #0]
  400b04:	460b      	mov	r3, r1
  400b06:	72fb      	strb	r3, [r7, #11]
	uint32_t vco_hz;

	Assert(e_src < PLL_NR_SOURCES);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(e_src) / ul_div;
  400b08:	7afb      	ldrb	r3, [r7, #11]
  400b0a:	4618      	mov	r0, r3
  400b0c:	f640 2341 	movw	r3, #2625	; 0xa41
  400b10:	f2c0 0340 	movt	r3, #64	; 0x40
  400b14:	4798      	blx	r3
  400b16:	4602      	mov	r2, r0
  400b18:	687b      	ldr	r3, [r7, #4]
  400b1a:	fbb2 f3f3 	udiv	r3, r2, r3
  400b1e:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_INPUT_MIN_HZ);
	Assert(vco_hz <= PLL_INPUT_MAX_HZ);
	
	vco_hz *= ul_mul;
  400b20:	697b      	ldr	r3, [r7, #20]
  400b22:	683a      	ldr	r2, [r7, #0]
  400b24:	fb02 f303 	mul.w	r3, r2, r3
  400b28:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_OUTPUT_MIN_HZ);
	Assert(vco_hz <= PLL_OUTPUT_MAX_HZ);

	/* PMC hardware will automatically make it mul+1 */
	p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_DIVA(ul_div) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
  400b2a:	683b      	ldr	r3, [r7, #0]
  400b2c:	f103 33ff 	add.w	r3, r3, #4294967295
  400b30:	ea4f 4203 	mov.w	r2, r3, lsl #16
  400b34:	f04f 0300 	mov.w	r3, #0
  400b38:	f2c0 73ff 	movt	r3, #2047	; 0x7ff
  400b3c:	4013      	ands	r3, r2
  400b3e:	687a      	ldr	r2, [r7, #4]
  400b40:	b2d2      	uxtb	r2, r2
  400b42:	4313      	orrs	r3, r2
  400b44:	f443 527c 	orr.w	r2, r3, #16128	; 0x3f00
  400b48:	68fb      	ldr	r3, [r7, #12]
  400b4a:	601a      	str	r2, [r3, #0]
}
  400b4c:	f107 0718 	add.w	r7, r7, #24
  400b50:	46bd      	mov	sp, r7
  400b52:	bd80      	pop	{r7, pc}

00400b54 <pll_enable>:
		PMC->CKGR_PLLBR = p_cfg->ctrl;
	}
}

static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
  400b54:	b580      	push	{r7, lr}
  400b56:	b082      	sub	sp, #8
  400b58:	af00      	add	r7, sp, #0
  400b5a:	6078      	str	r0, [r7, #4]
  400b5c:	6039      	str	r1, [r7, #0]
	Assert(ul_pll_id < NR_PLLS);
	
	if (ul_pll_id == PLLA_ID) {
  400b5e:	683b      	ldr	r3, [r7, #0]
  400b60:	2b00      	cmp	r3, #0
  400b62:	d10e      	bne.n	400b82 <pll_enable+0x2e>
		pmc_disable_pllack(); // Always stop PLL first!
  400b64:	f241 6309 	movw	r3, #5641	; 0x1609
  400b68:	f2c0 0340 	movt	r3, #64	; 0x40
  400b6c:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  400b6e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  400b72:	f2c4 030e 	movt	r3, #16398	; 0x400e
  400b76:	687a      	ldr	r2, [r7, #4]
  400b78:	6812      	ldr	r2, [r2, #0]
  400b7a:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  400b7e:	629a      	str	r2, [r3, #40]	; 0x28
  400b80:	e00b      	b.n	400b9a <pll_enable+0x46>
	} else {
		pmc_disable_pllbck();
  400b82:	f241 633d 	movw	r3, #5693	; 0x163d
  400b86:	f2c0 0340 	movt	r3, #64	; 0x40
  400b8a:	4798      	blx	r3
		PMC->CKGR_PLLBR = p_cfg->ctrl;
  400b8c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  400b90:	f2c4 030e 	movt	r3, #16398	; 0x400e
  400b94:	687a      	ldr	r2, [r7, #4]
  400b96:	6812      	ldr	r2, [r2, #0]
  400b98:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
  400b9a:	f107 0708 	add.w	r7, r7, #8
  400b9e:	46bd      	mov	sp, r7
  400ba0:	bd80      	pop	{r7, pc}
  400ba2:	bf00      	nop

00400ba4 <pll_is_locked>:
	else
		pmc_disable_pllbck();
}

static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
  400ba4:	b580      	push	{r7, lr}
  400ba6:	b082      	sub	sp, #8
  400ba8:	af00      	add	r7, sp, #0
  400baa:	6078      	str	r0, [r7, #4]
	Assert(ul_pll_id < NR_PLLS);
	
	if (ul_pll_id == PLLA_ID)
  400bac:	687b      	ldr	r3, [r7, #4]
  400bae:	2b00      	cmp	r3, #0
  400bb0:	d106      	bne.n	400bc0 <pll_is_locked+0x1c>
		return pmc_is_locked_pllack();
  400bb2:	f241 6321 	movw	r3, #5665	; 0x1621
  400bb6:	f2c0 0340 	movt	r3, #64	; 0x40
  400bba:	4798      	blx	r3
  400bbc:	4603      	mov	r3, r0
  400bbe:	e005      	b.n	400bcc <pll_is_locked+0x28>
	else
		return pmc_is_locked_pllbck();
  400bc0:	f241 6355 	movw	r3, #5717	; 0x1655
  400bc4:	f2c0 0340 	movt	r3, #64	; 0x40
  400bc8:	4798      	blx	r3
  400bca:	4603      	mov	r3, r0
}
  400bcc:	4618      	mov	r0, r3
  400bce:	f107 0708 	add.w	r7, r7, #8
  400bd2:	46bd      	mov	sp, r7
  400bd4:	bd80      	pop	{r7, pc}
  400bd6:	bf00      	nop

00400bd8 <pll_enable_source>:

static inline void pll_enable_source(enum pll_source e_src)
{
  400bd8:	b580      	push	{r7, lr}
  400bda:	b082      	sub	sp, #8
  400bdc:	af00      	add	r7, sp, #0
  400bde:	4603      	mov	r3, r0
  400be0:	71fb      	strb	r3, [r7, #7]
	switch (e_src) {
  400be2:	79fb      	ldrb	r3, [r7, #7]
  400be4:	f1a3 0303 	sub.w	r3, r3, #3
  400be8:	2b04      	cmp	r3, #4
  400bea:	d80e      	bhi.n	400c0a <pll_enable_source+0x32>
	case PLL_SRC_MAINCK_4M_RC:
	case PLL_SRC_MAINCK_8M_RC:
	case PLL_SRC_MAINCK_12M_RC:
	case PLL_SRC_MAINCK_XTAL:
	case PLL_SRC_MAINCK_BYPASS:
		osc_enable(e_src);
  400bec:	79fb      	ldrb	r3, [r7, #7]
  400bee:	4618      	mov	r0, r3
  400bf0:	f640 131d 	movw	r3, #2333	; 0x91d
  400bf4:	f2c0 0340 	movt	r3, #64	; 0x40
  400bf8:	4798      	blx	r3
		osc_wait_ready(e_src);
  400bfa:	79fb      	ldrb	r3, [r7, #7]
  400bfc:	4618      	mov	r0, r3
  400bfe:	f640 23c9 	movw	r3, #2761	; 0xac9
  400c02:	f2c0 0340 	movt	r3, #64	; 0x40
  400c06:	4798      	blx	r3
		break;
  400c08:	e000      	b.n	400c0c <pll_enable_source+0x34>

	default:
		Assert(false);
		break;
  400c0a:	bf00      	nop
	}
}
  400c0c:	f107 0708 	add.w	r7, r7, #8
  400c10:	46bd      	mov	sp, r7
  400c12:	bd80      	pop	{r7, pc}

00400c14 <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
  400c14:	b580      	push	{r7, lr}
  400c16:	b082      	sub	sp, #8
  400c18:	af00      	add	r7, sp, #0
  400c1a:	6078      	str	r0, [r7, #4]
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  400c1c:	bf00      	nop
  400c1e:	6878      	ldr	r0, [r7, #4]
  400c20:	f640 33a5 	movw	r3, #2981	; 0xba5
  400c24:	f2c0 0340 	movt	r3, #64	; 0x40
  400c28:	4798      	blx	r3
  400c2a:	4603      	mov	r3, r0
  400c2c:	2b00      	cmp	r3, #0
  400c2e:	d0f6      	beq.n	400c1e <pll_wait_for_lock+0xa>
		/* Do nothing */
	}

	return 0;
  400c30:	f04f 0300 	mov.w	r3, #0
}
  400c34:	4618      	mov	r0, r3
  400c36:	f107 0708 	add.w	r7, r7, #8
  400c3a:	46bd      	mov	sp, r7
  400c3c:	bd80      	pop	{r7, pc}
  400c3e:	bf00      	nop

00400c40 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
  400c40:	b580      	push	{r7, lr}
  400c42:	af00      	add	r7, sp, #0
    case SYSCLK_SRC_MAINCK_BYPASS:
		return OSC_MAINCK_BYPASS_HZ;

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLLACK:
		return pll_get_default_rate(0);	
  400c44:	f04f 0006 	mov.w	r0, #6
  400c48:	f640 2341 	movw	r3, #2625	; 0xa41
  400c4c:	f2c0 0340 	movt	r3, #64	; 0x40
  400c50:	4798      	blx	r3
  400c52:	4602      	mov	r2, r0
  400c54:	4613      	mov	r3, r2
  400c56:	ea4f 0383 	mov.w	r3, r3, lsl #2
  400c5a:	189b      	adds	r3, r3, r2
  400c5c:	ea4f 0383 	mov.w	r3, r3, lsl #2
	
	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
  400c60:	4618      	mov	r0, r3
  400c62:	bd80      	pop	{r7, pc}

00400c64 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
  400c64:	b580      	push	{r7, lr}
  400c66:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediat value. */
	return sysclk_get_main_hz() / ((CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos) + 1);
  400c68:	f640 4341 	movw	r3, #3137	; 0xc41
  400c6c:	f2c0 0340 	movt	r3, #64	; 0x40
  400c70:	4798      	blx	r3
  400c72:	4603      	mov	r3, r0
  400c74:	ea4f 0353 	mov.w	r3, r3, lsr #1
}
  400c78:	4618      	mov	r0, r3
  400c7a:	bd80      	pop	{r7, pc}

00400c7c <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  400c7c:	b590      	push	{r4, r7, lr}
  400c7e:	b083      	sub	sp, #12
  400c80:	af00      	add	r7, sp, #0
	struct pll_config pllcfg;

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  400c82:	f640 4365 	movw	r3, #3173	; 0xc65
  400c86:	f2c0 0340 	movt	r3, #64	; 0x40
  400c8a:	4798      	blx	r3
  400c8c:	4603      	mov	r3, r0
  400c8e:	4618      	mov	r0, r3
  400c90:	f641 23a9 	movw	r3, #6825	; 0x1aa9
  400c94:	f2c0 0340 	movt	r3, #64	; 0x40
  400c98:	4798      	blx	r3
		pmc_switch_mck_to_mainck(CONFIG_SYSCLK_PRES);
		break;

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLLACK:
		pll_enable_source(CONFIG_PLL0_SOURCE);
  400c9a:	f04f 0006 	mov.w	r0, #6
  400c9e:	f640 33d9 	movw	r3, #3033	; 0xbd9
  400ca2:	f2c0 0340 	movt	r3, #64	; 0x40
  400ca6:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
  400ca8:	f107 0304 	add.w	r3, r7, #4
  400cac:	4618      	mov	r0, r3
  400cae:	f04f 0106 	mov.w	r1, #6
  400cb2:	f04f 0201 	mov.w	r2, #1
  400cb6:	f04f 0314 	mov.w	r3, #20
  400cba:	f640 24f9 	movw	r4, #2809	; 0xaf9
  400cbe:	f2c0 0440 	movt	r4, #64	; 0x40
  400cc2:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
  400cc4:	f107 0304 	add.w	r3, r7, #4
  400cc8:	4618      	mov	r0, r3
  400cca:	f04f 0100 	mov.w	r1, #0
  400cce:	f640 3355 	movw	r3, #2901	; 0xb55
  400cd2:	f2c0 0340 	movt	r3, #64	; 0x40
  400cd6:	4798      	blx	r3
		pll_wait_for_lock(0);
  400cd8:	f04f 0000 	mov.w	r0, #0
  400cdc:	f640 4315 	movw	r3, #3093	; 0xc15
  400ce0:	f2c0 0340 	movt	r3, #64	; 0x40
  400ce4:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  400ce6:	f04f 0010 	mov.w	r0, #16
  400cea:	f241 3339 	movw	r3, #4921	; 0x1339
  400cee:	f2c0 0340 	movt	r3, #64	; 0x40
  400cf2:	4798      	blx	r3
		break;	
  400cf4:	bf00      	nop
		break;
#endif	
	}

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  400cf6:	f241 73f5 	movw	r3, #6133	; 0x17f5
  400cfa:	f2c0 0340 	movt	r3, #64	; 0x40
  400cfe:	4798      	blx	r3
	
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
  400d00:	f107 070c 	add.w	r7, r7, #12
  400d04:	46bd      	mov	sp, r7
  400d06:	bd90      	pop	{r4, r7, pc}

00400d08 <pio_pull_up>:
 * \param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be
 * configured.
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
  400d08:	b480      	push	{r7}
  400d0a:	b085      	sub	sp, #20
  400d0c:	af00      	add	r7, sp, #0
  400d0e:	60f8      	str	r0, [r7, #12]
  400d10:	60b9      	str	r1, [r7, #8]
  400d12:	607a      	str	r2, [r7, #4]
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  400d14:	687b      	ldr	r3, [r7, #4]
  400d16:	2b00      	cmp	r3, #0
  400d18:	d003      	beq.n	400d22 <pio_pull_up+0x1a>
		p_pio->PIO_PUER = ul_mask;
  400d1a:	68fb      	ldr	r3, [r7, #12]
  400d1c:	68ba      	ldr	r2, [r7, #8]
  400d1e:	665a      	str	r2, [r3, #100]	; 0x64
  400d20:	e002      	b.n	400d28 <pio_pull_up+0x20>
	} else {
		p_pio->PIO_PUDR = ul_mask;
  400d22:	68fb      	ldr	r3, [r7, #12]
  400d24:	68ba      	ldr	r2, [r7, #8]
  400d26:	661a      	str	r2, [r3, #96]	; 0x60
	}
}
  400d28:	f107 0714 	add.w	r7, r7, #20
  400d2c:	46bd      	mov	sp, r7
  400d2e:	bc80      	pop	{r7}
  400d30:	4770      	bx	lr
  400d32:	bf00      	nop

00400d34 <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  400d34:	b480      	push	{r7}
  400d36:	b087      	sub	sp, #28
  400d38:	af00      	add	r7, sp, #0
  400d3a:	60f8      	str	r0, [r7, #12]
  400d3c:	60b9      	str	r1, [r7, #8]
  400d3e:	607a      	str	r2, [r7, #4]
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  400d40:	68fb      	ldr	r3, [r7, #12]
  400d42:	687a      	ldr	r2, [r7, #4]
  400d44:	645a      	str	r2, [r3, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S)
	switch (ul_type) {
  400d46:	68bb      	ldr	r3, [r7, #8]
  400d48:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  400d4c:	d04d      	beq.n	400dea <pio_set_peripheral+0xb6>
  400d4e:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  400d52:	d808      	bhi.n	400d66 <pio_set_peripheral+0x32>
  400d54:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  400d58:	d016      	beq.n	400d88 <pio_set_peripheral+0x54>
  400d5a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  400d5e:	d02e      	beq.n	400dbe <pio_set_peripheral+0x8a>
  400d60:	2b00      	cmp	r3, #0
  400d62:	d06d      	beq.n	400e40 <pio_set_peripheral+0x10c>
  400d64:	e068      	b.n	400e38 <pio_set_peripheral+0x104>
  400d66:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  400d6a:	d069      	beq.n	400e40 <pio_set_peripheral+0x10c>
  400d6c:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  400d70:	d803      	bhi.n	400d7a <pio_set_peripheral+0x46>
  400d72:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  400d76:	d04e      	beq.n	400e16 <pio_set_peripheral+0xe2>
  400d78:	e05e      	b.n	400e38 <pio_set_peripheral+0x104>
  400d7a:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  400d7e:	d05f      	beq.n	400e40 <pio_set_peripheral+0x10c>
  400d80:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  400d84:	d05c      	beq.n	400e40 <pio_set_peripheral+0x10c>
  400d86:	e057      	b.n	400e38 <pio_set_peripheral+0x104>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  400d88:	68fb      	ldr	r3, [r7, #12]
  400d8a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  400d8c:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  400d8e:	68fb      	ldr	r3, [r7, #12]
  400d90:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400d92:	687b      	ldr	r3, [r7, #4]
  400d94:	ea6f 0103 	mvn.w	r1, r3
  400d98:	697b      	ldr	r3, [r7, #20]
  400d9a:	400b      	ands	r3, r1
  400d9c:	401a      	ands	r2, r3
  400d9e:	68fb      	ldr	r3, [r7, #12]
  400da0:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400da2:	68fb      	ldr	r3, [r7, #12]
  400da4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  400da6:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  400da8:	68fb      	ldr	r3, [r7, #12]
  400daa:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400dac:	687b      	ldr	r3, [r7, #4]
  400dae:	ea6f 0103 	mvn.w	r1, r3
  400db2:	697b      	ldr	r3, [r7, #20]
  400db4:	400b      	ands	r3, r1
  400db6:	401a      	ands	r2, r3
  400db8:	68fb      	ldr	r3, [r7, #12]
  400dba:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  400dbc:	e03c      	b.n	400e38 <pio_set_peripheral+0x104>

	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  400dbe:	68fb      	ldr	r3, [r7, #12]
  400dc0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  400dc2:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  400dc4:	687a      	ldr	r2, [r7, #4]
  400dc6:	697b      	ldr	r3, [r7, #20]
  400dc8:	431a      	orrs	r2, r3
  400dca:	68fb      	ldr	r3, [r7, #12]
  400dcc:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400dce:	68fb      	ldr	r3, [r7, #12]
  400dd0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  400dd2:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  400dd4:	68fb      	ldr	r3, [r7, #12]
  400dd6:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400dd8:	687b      	ldr	r3, [r7, #4]
  400dda:	ea6f 0103 	mvn.w	r1, r3
  400dde:	697b      	ldr	r3, [r7, #20]
  400de0:	400b      	ands	r3, r1
  400de2:	401a      	ands	r2, r3
  400de4:	68fb      	ldr	r3, [r7, #12]
  400de6:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  400de8:	e026      	b.n	400e38 <pio_set_peripheral+0x104>

	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  400dea:	68fb      	ldr	r3, [r7, #12]
  400dec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  400dee:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  400df0:	68fb      	ldr	r3, [r7, #12]
  400df2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400df4:	687b      	ldr	r3, [r7, #4]
  400df6:	ea6f 0103 	mvn.w	r1, r3
  400dfa:	697b      	ldr	r3, [r7, #20]
  400dfc:	400b      	ands	r3, r1
  400dfe:	401a      	ands	r2, r3
  400e00:	68fb      	ldr	r3, [r7, #12]
  400e02:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400e04:	68fb      	ldr	r3, [r7, #12]
  400e06:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  400e08:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  400e0a:	687a      	ldr	r2, [r7, #4]
  400e0c:	697b      	ldr	r3, [r7, #20]
  400e0e:	431a      	orrs	r2, r3
  400e10:	68fb      	ldr	r3, [r7, #12]
  400e12:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  400e14:	e010      	b.n	400e38 <pio_set_peripheral+0x104>

	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  400e16:	68fb      	ldr	r3, [r7, #12]
  400e18:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  400e1a:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  400e1c:	687a      	ldr	r2, [r7, #4]
  400e1e:	697b      	ldr	r3, [r7, #20]
  400e20:	431a      	orrs	r2, r3
  400e22:	68fb      	ldr	r3, [r7, #12]
  400e24:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400e26:	68fb      	ldr	r3, [r7, #12]
  400e28:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  400e2a:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  400e2c:	687a      	ldr	r2, [r7, #4]
  400e2e:	697b      	ldr	r3, [r7, #20]
  400e30:	431a      	orrs	r2, r3
  400e32:	68fb      	ldr	r3, [r7, #12]
  400e34:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  400e36:	bf00      	nop
#else
#error "Unsupported device"
#endif

	// Remove the pins from under the control of PIO
	p_pio->PIO_PDR = ul_mask;
  400e38:	68fb      	ldr	r3, [r7, #12]
  400e3a:	687a      	ldr	r2, [r7, #4]
  400e3c:	605a      	str	r2, [r3, #4]
  400e3e:	e000      	b.n	400e42 <pio_set_peripheral+0x10e>
		// other types are invalid in this function
	case PIO_INPUT:
	case PIO_OUTPUT_0:
	case PIO_OUTPUT_1:
	case PIO_NOT_A_PIN:
		return;
  400e40:	bf00      	nop
#error "Unsupported device"
#endif

	// Remove the pins from under the control of PIO
	p_pio->PIO_PDR = ul_mask;
}
  400e42:	f107 071c 	add.w	r7, r7, #28
  400e46:	46bd      	mov	sp, r7
  400e48:	bc80      	pop	{r7}
  400e4a:	4770      	bx	lr

00400e4c <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
  400e4c:	b580      	push	{r7, lr}
  400e4e:	b084      	sub	sp, #16
  400e50:	af00      	add	r7, sp, #0
  400e52:	60f8      	str	r0, [r7, #12]
  400e54:	60b9      	str	r1, [r7, #8]
  400e56:	607a      	str	r2, [r7, #4]
	pio_disable_interrupt(p_pio, ul_mask);
  400e58:	68f8      	ldr	r0, [r7, #12]
  400e5a:	68b9      	ldr	r1, [r7, #8]
  400e5c:	f640 7339 	movw	r3, #3897	; 0xf39
  400e60:	f2c0 0340 	movt	r3, #64	; 0x40
  400e64:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);
  400e66:	687b      	ldr	r3, [r7, #4]
  400e68:	f003 0301 	and.w	r3, r3, #1
  400e6c:	68f8      	ldr	r0, [r7, #12]
  400e6e:	68b9      	ldr	r1, [r7, #8]
  400e70:	461a      	mov	r2, r3
  400e72:	f640 5309 	movw	r3, #3337	; 0xd09
  400e76:	f2c0 0340 	movt	r3, #64	; 0x40
  400e7a:	4798      	blx	r3

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  400e7c:	687b      	ldr	r3, [r7, #4]
  400e7e:	f003 030a 	and.w	r3, r3, #10
  400e82:	2b00      	cmp	r3, #0
  400e84:	d003      	beq.n	400e8e <pio_set_input+0x42>
		p_pio->PIO_IFER = ul_mask;
  400e86:	68fb      	ldr	r3, [r7, #12]
  400e88:	68ba      	ldr	r2, [r7, #8]
  400e8a:	621a      	str	r2, [r3, #32]
  400e8c:	e002      	b.n	400e94 <pio_set_input+0x48>
	} else {
		p_pio->PIO_IFDR = ul_mask;
  400e8e:	68fb      	ldr	r3, [r7, #12]
  400e90:	68ba      	ldr	r2, [r7, #8]
  400e92:	625a      	str	r2, [r3, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  400e94:	687b      	ldr	r3, [r7, #4]
  400e96:	f003 0302 	and.w	r3, r3, #2
  400e9a:	2b00      	cmp	r3, #0
  400e9c:	d004      	beq.n	400ea8 <pio_set_input+0x5c>
		p_pio->PIO_IFSCDR = ul_mask;
  400e9e:	68fb      	ldr	r3, [r7, #12]
  400ea0:	68ba      	ldr	r2, [r7, #8]
  400ea2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  400ea6:	e008      	b.n	400eba <pio_set_input+0x6e>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  400ea8:	687b      	ldr	r3, [r7, #4]
  400eaa:	f003 0308 	and.w	r3, r3, #8
  400eae:	2b00      	cmp	r3, #0
  400eb0:	d003      	beq.n	400eba <pio_set_input+0x6e>
			p_pio->PIO_IFSCER = ul_mask;
  400eb2:	68fb      	ldr	r3, [r7, #12]
  400eb4:	68ba      	ldr	r2, [r7, #8]
  400eb6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  400eba:	68fb      	ldr	r3, [r7, #12]
  400ebc:	68ba      	ldr	r2, [r7, #8]
  400ebe:	615a      	str	r2, [r3, #20]
	p_pio->PIO_PER = ul_mask;
  400ec0:	68fb      	ldr	r3, [r7, #12]
  400ec2:	68ba      	ldr	r2, [r7, #8]
  400ec4:	601a      	str	r2, [r3, #0]
}
  400ec6:	f107 0710 	add.w	r7, r7, #16
  400eca:	46bd      	mov	sp, r7
  400ecc:	bd80      	pop	{r7, pc}
  400ece:	bf00      	nop

00400ed0 <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
  400ed0:	b580      	push	{r7, lr}
  400ed2:	b084      	sub	sp, #16
  400ed4:	af00      	add	r7, sp, #0
  400ed6:	60f8      	str	r0, [r7, #12]
  400ed8:	60b9      	str	r1, [r7, #8]
  400eda:	607a      	str	r2, [r7, #4]
  400edc:	603b      	str	r3, [r7, #0]
	pio_disable_interrupt(p_pio, ul_mask);
  400ede:	68f8      	ldr	r0, [r7, #12]
  400ee0:	68b9      	ldr	r1, [r7, #8]
  400ee2:	f640 7339 	movw	r3, #3897	; 0xf39
  400ee6:	f2c0 0340 	movt	r3, #64	; 0x40
  400eea:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);
  400eec:	68f8      	ldr	r0, [r7, #12]
  400eee:	68b9      	ldr	r1, [r7, #8]
  400ef0:	69ba      	ldr	r2, [r7, #24]
  400ef2:	f640 5309 	movw	r3, #3337	; 0xd09
  400ef6:	f2c0 0340 	movt	r3, #64	; 0x40
  400efa:	4798      	blx	r3

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  400efc:	683b      	ldr	r3, [r7, #0]
  400efe:	2b00      	cmp	r3, #0
  400f00:	d003      	beq.n	400f0a <pio_set_output+0x3a>
		p_pio->PIO_MDER = ul_mask;
  400f02:	68fb      	ldr	r3, [r7, #12]
  400f04:	68ba      	ldr	r2, [r7, #8]
  400f06:	651a      	str	r2, [r3, #80]	; 0x50
  400f08:	e002      	b.n	400f10 <pio_set_output+0x40>
	} else {
		p_pio->PIO_MDDR = ul_mask;
  400f0a:	68fb      	ldr	r3, [r7, #12]
  400f0c:	68ba      	ldr	r2, [r7, #8]
  400f0e:	655a      	str	r2, [r3, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
  400f10:	687b      	ldr	r3, [r7, #4]
  400f12:	2b00      	cmp	r3, #0
  400f14:	d003      	beq.n	400f1e <pio_set_output+0x4e>
		p_pio->PIO_SODR = ul_mask;
  400f16:	68fb      	ldr	r3, [r7, #12]
  400f18:	68ba      	ldr	r2, [r7, #8]
  400f1a:	631a      	str	r2, [r3, #48]	; 0x30
  400f1c:	e002      	b.n	400f24 <pio_set_output+0x54>
	} else {
		p_pio->PIO_CODR = ul_mask;
  400f1e:	68fb      	ldr	r3, [r7, #12]
  400f20:	68ba      	ldr	r2, [r7, #8]
  400f22:	635a      	str	r2, [r3, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  400f24:	68fb      	ldr	r3, [r7, #12]
  400f26:	68ba      	ldr	r2, [r7, #8]
  400f28:	611a      	str	r2, [r3, #16]
	p_pio->PIO_PER = ul_mask;
  400f2a:	68fb      	ldr	r3, [r7, #12]
  400f2c:	68ba      	ldr	r2, [r7, #8]
  400f2e:	601a      	str	r2, [r3, #0]
}
  400f30:	f107 0710 	add.w	r7, r7, #16
  400f34:	46bd      	mov	sp, r7
  400f36:	bd80      	pop	{r7, pc}

00400f38 <pio_disable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  400f38:	b480      	push	{r7}
  400f3a:	b083      	sub	sp, #12
  400f3c:	af00      	add	r7, sp, #0
  400f3e:	6078      	str	r0, [r7, #4]
  400f40:	6039      	str	r1, [r7, #0]
	p_pio->PIO_IDR = ul_mask;
  400f42:	687b      	ldr	r3, [r7, #4]
  400f44:	683a      	ldr	r2, [r7, #0]
  400f46:	645a      	str	r2, [r3, #68]	; 0x44
}
  400f48:	f107 070c 	add.w	r7, r7, #12
  400f4c:	46bd      	mov	sp, r7
  400f4e:	bc80      	pop	{r7}
  400f50:	4770      	bx	lr
  400f52:	bf00      	nop

00400f54 <pio_get_interrupt_status>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
  400f54:	b480      	push	{r7}
  400f56:	b083      	sub	sp, #12
  400f58:	af00      	add	r7, sp, #0
  400f5a:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_ISR;
  400f5c:	687b      	ldr	r3, [r7, #4]
  400f5e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
  400f60:	4618      	mov	r0, r3
  400f62:	f107 070c 	add.w	r7, r7, #12
  400f66:	46bd      	mov	sp, r7
  400f68:	bc80      	pop	{r7}
  400f6a:	4770      	bx	lr

00400f6c <pio_get_interrupt_mask>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
  400f6c:	b480      	push	{r7}
  400f6e:	b083      	sub	sp, #12
  400f70:	af00      	add	r7, sp, #0
  400f72:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_IMR;
  400f74:	687b      	ldr	r3, [r7, #4]
  400f76:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
  400f78:	4618      	mov	r0, r3
  400f7a:	f107 070c 	add.w	r7, r7, #12
  400f7e:	46bd      	mov	sp, r7
  400f80:	bc80      	pop	{r7}
  400f82:	4770      	bx	lr

00400f84 <pio_set_pin_high>:
 * \param ul_pin The pin index.
 *
 * \note The function \ref pio_configure_pin must be called beforehand.
 */
void pio_set_pin_high(uint32_t ul_pin)
{
  400f84:	b480      	push	{r7}
  400f86:	b085      	sub	sp, #20
  400f88:	af00      	add	r7, sp, #0
  400f8a:	6078      	str	r0, [r7, #4]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  400f8c:	687b      	ldr	r3, [r7, #4]
  400f8e:	ea4f 1353 	mov.w	r3, r3, lsr #5
  400f92:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400f96:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400f9a:	ea4f 2343 	mov.w	r3, r3, lsl #9
  400f9e:	60fb      	str	r3, [r7, #12]
	// Value to be driven on the I/O line: 1.
	p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  400fa0:	687b      	ldr	r3, [r7, #4]
  400fa2:	f003 031f 	and.w	r3, r3, #31
  400fa6:	f04f 0201 	mov.w	r2, #1
  400faa:	fa02 f303 	lsl.w	r3, r2, r3
  400fae:	461a      	mov	r2, r3
  400fb0:	68fb      	ldr	r3, [r7, #12]
  400fb2:	631a      	str	r2, [r3, #48]	; 0x30
}
  400fb4:	f107 0714 	add.w	r7, r7, #20
  400fb8:	46bd      	mov	sp, r7
  400fba:	bc80      	pop	{r7}
  400fbc:	4770      	bx	lr
  400fbe:	bf00      	nop

00400fc0 <pio_set_pin_low>:
 * \param ul_pin The pin index.
 *
 * \note The function \ref pio_configure_pin must be called before.
 */
void pio_set_pin_low(uint32_t ul_pin)
{
  400fc0:	b480      	push	{r7}
  400fc2:	b085      	sub	sp, #20
  400fc4:	af00      	add	r7, sp, #0
  400fc6:	6078      	str	r0, [r7, #4]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  400fc8:	687b      	ldr	r3, [r7, #4]
  400fca:	ea4f 1353 	mov.w	r3, r3, lsr #5
  400fce:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400fd2:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400fd6:	ea4f 2343 	mov.w	r3, r3, lsl #9
  400fda:	60fb      	str	r3, [r7, #12]
	// Value to be driven on the I/O line: 0.
	p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  400fdc:	687b      	ldr	r3, [r7, #4]
  400fde:	f003 031f 	and.w	r3, r3, #31
  400fe2:	f04f 0201 	mov.w	r2, #1
  400fe6:	fa02 f303 	lsl.w	r3, r2, r3
  400fea:	461a      	mov	r2, r3
  400fec:	68fb      	ldr	r3, [r7, #12]
  400fee:	635a      	str	r2, [r3, #52]	; 0x34
}
  400ff0:	f107 0714 	add.w	r7, r7, #20
  400ff4:	46bd      	mov	sp, r7
  400ff6:	bc80      	pop	{r7}
  400ff8:	4770      	bx	lr
  400ffa:	bf00      	nop

00400ffc <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  400ffc:	b590      	push	{r4, r7, lr}
  400ffe:	b087      	sub	sp, #28
  401000:	af02      	add	r7, sp, #8
  401002:	6078      	str	r0, [r7, #4]
  401004:	6039      	str	r1, [r7, #0]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  401006:	687b      	ldr	r3, [r7, #4]
  401008:	ea4f 1353 	mov.w	r3, r3, lsr #5
  40100c:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401010:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401014:	ea4f 2343 	mov.w	r3, r3, lsl #9
  401018:	60fb      	str	r3, [r7, #12]

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40101a:	683b      	ldr	r3, [r7, #0]
  40101c:	f003 43f0 	and.w	r3, r3, #2013265920	; 0x78000000
  401020:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  401024:	f000 8086 	beq.w	401134 <pio_configure_pin+0x138>
  401028:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  40102c:	d809      	bhi.n	401042 <pio_configure_pin+0x46>
  40102e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  401032:	d037      	beq.n	4010a4 <pio_configure_pin+0xa8>
  401034:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  401038:	d058      	beq.n	4010ec <pio_configure_pin+0xf0>
  40103a:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  40103e:	d00d      	beq.n	40105c <pio_configure_pin+0x60>
  401040:	e0cf      	b.n	4011e2 <pio_configure_pin+0x1e6>
  401042:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  401046:	f000 80a9 	beq.w	40119c <pio_configure_pin+0x1a0>
  40104a:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  40104e:	f000 80a5 	beq.w	40119c <pio_configure_pin+0x1a0>
  401052:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  401056:	f000 8091 	beq.w	40117c <pio_configure_pin+0x180>
  40105a:	e0c2      	b.n	4011e2 <pio_configure_pin+0x1e6>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
  40105c:	687b      	ldr	r3, [r7, #4]
  40105e:	f003 031f 	and.w	r3, r3, #31
  401062:	f04f 0201 	mov.w	r2, #1
  401066:	fa02 f303 	lsl.w	r3, r2, r3
  40106a:	68f8      	ldr	r0, [r7, #12]
  40106c:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  401070:	461a      	mov	r2, r3
  401072:	f640 5335 	movw	r3, #3381	; 0xd35
  401076:	f2c0 0340 	movt	r3, #64	; 0x40
  40107a:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  40107c:	687b      	ldr	r3, [r7, #4]
  40107e:	f003 031f 	and.w	r3, r3, #31
  401082:	f04f 0201 	mov.w	r2, #1
  401086:	fa02 f303 	lsl.w	r3, r2, r3
  40108a:	461a      	mov	r2, r3
  40108c:	683b      	ldr	r3, [r7, #0]
  40108e:	f003 0301 	and.w	r3, r3, #1
  401092:	68f8      	ldr	r0, [r7, #12]
  401094:	4611      	mov	r1, r2
  401096:	461a      	mov	r2, r3
  401098:	f640 5309 	movw	r3, #3337	; 0xd09
  40109c:	f2c0 0340 	movt	r3, #64	; 0x40
  4010a0:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
  4010a2:	e0a1      	b.n	4011e8 <pio_configure_pin+0x1ec>
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
  4010a4:	687b      	ldr	r3, [r7, #4]
  4010a6:	f003 031f 	and.w	r3, r3, #31
  4010aa:	f04f 0201 	mov.w	r2, #1
  4010ae:	fa02 f303 	lsl.w	r3, r2, r3
  4010b2:	68f8      	ldr	r0, [r7, #12]
  4010b4:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  4010b8:	461a      	mov	r2, r3
  4010ba:	f640 5335 	movw	r3, #3381	; 0xd35
  4010be:	f2c0 0340 	movt	r3, #64	; 0x40
  4010c2:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  4010c4:	687b      	ldr	r3, [r7, #4]
  4010c6:	f003 031f 	and.w	r3, r3, #31
  4010ca:	f04f 0201 	mov.w	r2, #1
  4010ce:	fa02 f303 	lsl.w	r3, r2, r3
  4010d2:	461a      	mov	r2, r3
  4010d4:	683b      	ldr	r3, [r7, #0]
  4010d6:	f003 0301 	and.w	r3, r3, #1
  4010da:	68f8      	ldr	r0, [r7, #12]
  4010dc:	4611      	mov	r1, r2
  4010de:	461a      	mov	r2, r3
  4010e0:	f640 5309 	movw	r3, #3337	; 0xd09
  4010e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4010e8:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
  4010ea:	e07d      	b.n	4011e8 <pio_configure_pin+0x1ec>
#     if (SAM3S || SAM3N || SAM4S)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
  4010ec:	687b      	ldr	r3, [r7, #4]
  4010ee:	f003 031f 	and.w	r3, r3, #31
  4010f2:	f04f 0201 	mov.w	r2, #1
  4010f6:	fa02 f303 	lsl.w	r3, r2, r3
  4010fa:	68f8      	ldr	r0, [r7, #12]
  4010fc:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  401100:	461a      	mov	r2, r3
  401102:	f640 5335 	movw	r3, #3381	; 0xd35
  401106:	f2c0 0340 	movt	r3, #64	; 0x40
  40110a:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  40110c:	687b      	ldr	r3, [r7, #4]
  40110e:	f003 031f 	and.w	r3, r3, #31
  401112:	f04f 0201 	mov.w	r2, #1
  401116:	fa02 f303 	lsl.w	r3, r2, r3
  40111a:	461a      	mov	r2, r3
  40111c:	683b      	ldr	r3, [r7, #0]
  40111e:	f003 0301 	and.w	r3, r3, #1
  401122:	68f8      	ldr	r0, [r7, #12]
  401124:	4611      	mov	r1, r2
  401126:	461a      	mov	r2, r3
  401128:	f640 5309 	movw	r3, #3337	; 0xd09
  40112c:	f2c0 0340 	movt	r3, #64	; 0x40
  401130:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
  401132:	e059      	b.n	4011e8 <pio_configure_pin+0x1ec>
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  401134:	687b      	ldr	r3, [r7, #4]
  401136:	f003 031f 	and.w	r3, r3, #31
  40113a:	f04f 0201 	mov.w	r2, #1
  40113e:	fa02 f303 	lsl.w	r3, r2, r3
  401142:	68f8      	ldr	r0, [r7, #12]
  401144:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  401148:	461a      	mov	r2, r3
  40114a:	f640 5335 	movw	r3, #3381	; 0xd35
  40114e:	f2c0 0340 	movt	r3, #64	; 0x40
  401152:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401154:	687b      	ldr	r3, [r7, #4]
  401156:	f003 031f 	and.w	r3, r3, #31
  40115a:	f04f 0201 	mov.w	r2, #1
  40115e:	fa02 f303 	lsl.w	r3, r2, r3
  401162:	461a      	mov	r2, r3
  401164:	683b      	ldr	r3, [r7, #0]
  401166:	f003 0301 	and.w	r3, r3, #1
  40116a:	68f8      	ldr	r0, [r7, #12]
  40116c:	4611      	mov	r1, r2
  40116e:	461a      	mov	r2, r3
  401170:	f640 5309 	movw	r3, #3337	; 0xd09
  401174:	f2c0 0340 	movt	r3, #64	; 0x40
  401178:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
  40117a:	e035      	b.n	4011e8 <pio_configure_pin+0x1ec>
#     endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  40117c:	687b      	ldr	r3, [r7, #4]
  40117e:	f003 031f 	and.w	r3, r3, #31
  401182:	f04f 0201 	mov.w	r2, #1
  401186:	fa02 f303 	lsl.w	r3, r2, r3
  40118a:	68f8      	ldr	r0, [r7, #12]
  40118c:	4619      	mov	r1, r3
  40118e:	683a      	ldr	r2, [r7, #0]
  401190:	f640 634d 	movw	r3, #3661	; 0xe4d
  401194:	f2c0 0340 	movt	r3, #64	; 0x40
  401198:	4798      	blx	r3
		break;
  40119a:	e025      	b.n	4011e8 <pio_configure_pin+0x1ec>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  40119c:	687b      	ldr	r3, [r7, #4]
  40119e:	f003 031f 	and.w	r3, r3, #31
  4011a2:	f04f 0201 	mov.w	r2, #1
  4011a6:	fa02 f303 	lsl.w	r3, r2, r3
  4011aa:	4619      	mov	r1, r3
  4011ac:	683b      	ldr	r3, [r7, #0]
  4011ae:	f003 5260 	and.w	r2, r3, #939524096	; 0x38000000
				(ul_flags & PIO_TYPE_PIO_OUTPUT_1),
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  4011b2:	683b      	ldr	r3, [r7, #0]
  4011b4:	f003 0304 	and.w	r3, r3, #4
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  4011b8:	2b00      	cmp	r3, #0
  4011ba:	bf0c      	ite	eq
  4011bc:	2300      	moveq	r3, #0
  4011be:	2301      	movne	r3, #1
  4011c0:	b2db      	uxtb	r3, r3
				(ul_flags & PIO_TYPE_PIO_OUTPUT_1),
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
  4011c2:	6838      	ldr	r0, [r7, #0]
  4011c4:	f000 0001 	and.w	r0, r0, #1
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  4011c8:	2800      	cmp	r0, #0
  4011ca:	bf0c      	ite	eq
  4011cc:	2000      	moveq	r0, #0
  4011ce:	2001      	movne	r0, #1
  4011d0:	b2c0      	uxtb	r0, r0
  4011d2:	9000      	str	r0, [sp, #0]
  4011d4:	68f8      	ldr	r0, [r7, #12]
  4011d6:	f640 64d1 	movw	r4, #3793	; 0xed1
  4011da:	f2c0 0440 	movt	r4, #64	; 0x40
  4011de:	47a0      	blx	r4
				(ul_flags & PIO_TYPE_PIO_OUTPUT_1),
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
  4011e0:	e002      	b.n	4011e8 <pio_configure_pin+0x1ec>

	default:
		return 0;
  4011e2:	f04f 0300 	mov.w	r3, #0
  4011e6:	e001      	b.n	4011ec <pio_configure_pin+0x1f0>
	}

	return 1;
  4011e8:	f04f 0301 	mov.w	r3, #1
}
  4011ec:	4618      	mov	r0, r3
  4011ee:	f107 0714 	add.w	r7, r7, #20
  4011f2:	46bd      	mov	sp, r7
  4011f4:	bd90      	pop	{r4, r7, pc}
  4011f6:	bf00      	nop

004011f8 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  4011f8:	b580      	push	{r7, lr}
  4011fa:	b084      	sub	sp, #16
  4011fc:	af00      	add	r7, sp, #0
  4011fe:	6078      	str	r0, [r7, #4]
  401200:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  401202:	6878      	ldr	r0, [r7, #4]
  401204:	f640 7355 	movw	r3, #3925	; 0xf55
  401208:	f2c0 0340 	movt	r3, #64	; 0x40
  40120c:	4798      	blx	r3
  40120e:	60f8      	str	r0, [r7, #12]
	status &= pio_get_interrupt_mask(p_pio);
  401210:	6878      	ldr	r0, [r7, #4]
  401212:	f640 736d 	movw	r3, #3949	; 0xf6d
  401216:	f2c0 0340 	movt	r3, #64	; 0x40
  40121a:	4798      	blx	r3
  40121c:	4603      	mov	r3, r0
  40121e:	68fa      	ldr	r2, [r7, #12]
  401220:	4013      	ands	r3, r2
  401222:	60fb      	str	r3, [r7, #12]

	/* Check pending events */
	if (status != 0) {
  401224:	68fb      	ldr	r3, [r7, #12]
  401226:	2b00      	cmp	r3, #0
  401228:	d057      	beq.n	4012da <pio_handler_process+0xe2>
		/* Find triggering source */
		i = 0;
  40122a:	f04f 0300 	mov.w	r3, #0
  40122e:	60bb      	str	r3, [r7, #8]
		while (status != 0) {
  401230:	e050      	b.n	4012d4 <pio_handler_process+0xdc>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  401232:	f24a 436c 	movw	r3, #42092	; 0xa46c
  401236:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40123a:	68ba      	ldr	r2, [r7, #8]
  40123c:	ea4f 1202 	mov.w	r2, r2, lsl #4
  401240:	189b      	adds	r3, r3, r2
  401242:	681a      	ldr	r2, [r3, #0]
  401244:	683b      	ldr	r3, [r7, #0]
  401246:	429a      	cmp	r2, r3
  401248:	d140      	bne.n	4012cc <pio_handler_process+0xd4>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  40124a:	f24a 436c 	movw	r3, #42092	; 0xa46c
  40124e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401252:	68ba      	ldr	r2, [r7, #8]
  401254:	ea4f 1202 	mov.w	r2, r2, lsl #4
  401258:	189b      	adds	r3, r3, r2
  40125a:	f103 0304 	add.w	r3, r3, #4
  40125e:	681a      	ldr	r2, [r3, #0]
  401260:	68fb      	ldr	r3, [r7, #12]
  401262:	4013      	ands	r3, r2
  401264:	2b00      	cmp	r3, #0
  401266:	d031      	beq.n	4012cc <pio_handler_process+0xd4>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  401268:	f24a 436c 	movw	r3, #42092	; 0xa46c
  40126c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401270:	68ba      	ldr	r2, [r7, #8]
  401272:	ea4f 1202 	mov.w	r2, r2, lsl #4
  401276:	189b      	adds	r3, r3, r2
  401278:	f103 030c 	add.w	r3, r3, #12
  40127c:	681a      	ldr	r2, [r3, #0]
  40127e:	f24a 436c 	movw	r3, #42092	; 0xa46c
  401282:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401286:	68b9      	ldr	r1, [r7, #8]
  401288:	ea4f 1101 	mov.w	r1, r1, lsl #4
  40128c:	185b      	adds	r3, r3, r1
  40128e:	6819      	ldr	r1, [r3, #0]
  401290:	f24a 436c 	movw	r3, #42092	; 0xa46c
  401294:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401298:	68b8      	ldr	r0, [r7, #8]
  40129a:	ea4f 1000 	mov.w	r0, r0, lsl #4
  40129e:	181b      	adds	r3, r3, r0
  4012a0:	f103 0304 	add.w	r3, r3, #4
  4012a4:	681b      	ldr	r3, [r3, #0]
  4012a6:	4608      	mov	r0, r1
  4012a8:	4619      	mov	r1, r3
  4012aa:	4790      	blx	r2
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  4012ac:	f24a 436c 	movw	r3, #42092	; 0xa46c
  4012b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4012b4:	68ba      	ldr	r2, [r7, #8]
  4012b6:	ea4f 1202 	mov.w	r2, r2, lsl #4
  4012ba:	189b      	adds	r3, r3, r2
  4012bc:	f103 0304 	add.w	r3, r3, #4
  4012c0:	681b      	ldr	r3, [r3, #0]
  4012c2:	ea6f 0303 	mvn.w	r3, r3
  4012c6:	68fa      	ldr	r2, [r7, #12]
  4012c8:	4013      	ands	r3, r2
  4012ca:	60fb      	str	r3, [r7, #12]
				}
			}
			i++;
  4012cc:	68bb      	ldr	r3, [r7, #8]
  4012ce:	f103 0301 	add.w	r3, r3, #1
  4012d2:	60bb      	str	r3, [r7, #8]

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  4012d4:	68fb      	ldr	r3, [r7, #12]
  4012d6:	2b00      	cmp	r3, #0
  4012d8:	d1ab      	bne.n	401232 <pio_handler_process+0x3a>
				}
			}
			i++;
		}
	}
}
  4012da:	f107 0710 	add.w	r7, r7, #16
  4012de:	46bd      	mov	sp, r7
  4012e0:	bd80      	pop	{r7, pc}
  4012e2:	bf00      	nop

004012e4 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  4012e4:	b580      	push	{r7, lr}
  4012e6:	af00      	add	r7, sp, #0
	pio_handler_process(PIOA, ID_PIOA);
  4012e8:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  4012ec:	f2c4 000e 	movt	r0, #16398	; 0x400e
  4012f0:	f04f 010b 	mov.w	r1, #11
  4012f4:	f241 13f9 	movw	r3, #4601	; 0x11f9
  4012f8:	f2c0 0340 	movt	r3, #64	; 0x40
  4012fc:	4798      	blx	r3
}
  4012fe:	bd80      	pop	{r7, pc}

00401300 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  401300:	b580      	push	{r7, lr}
  401302:	af00      	add	r7, sp, #0
    pio_handler_process(PIOB, ID_PIOB);
  401304:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  401308:	f2c4 000e 	movt	r0, #16398	; 0x400e
  40130c:	f04f 010c 	mov.w	r1, #12
  401310:	f241 13f9 	movw	r3, #4601	; 0x11f9
  401314:	f2c0 0340 	movt	r3, #64	; 0x40
  401318:	4798      	blx	r3
}
  40131a:	bd80      	pop	{r7, pc}

0040131c <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  40131c:	b580      	push	{r7, lr}
  40131e:	af00      	add	r7, sp, #0
	pio_handler_process(PIOC, ID_PIOC);
  401320:	f44f 5090 	mov.w	r0, #4608	; 0x1200
  401324:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401328:	f04f 010d 	mov.w	r1, #13
  40132c:	f241 13f9 	movw	r3, #4601	; 0x11f9
  401330:	f2c0 0340 	movt	r3, #64	; 0x40
  401334:	4798      	blx	r3
}
  401336:	bd80      	pop	{r7, pc}

00401338 <pmc_switch_mck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
  401338:	b480      	push	{r7}
  40133a:	b085      	sub	sp, #20
  40133c:	af00      	add	r7, sp, #0
  40133e:	6078      	str	r0, [r7, #4]
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  401340:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401344:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401348:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40134c:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401350:	6b12      	ldr	r2, [r2, #48]	; 0x30
  401352:	f022 0170 	bic.w	r1, r2, #112	; 0x70
  401356:	687a      	ldr	r2, [r7, #4]
  401358:	430a      	orrs	r2, r1
  40135a:	631a      	str	r2, [r3, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40135c:	f44f 6300 	mov.w	r3, #2048	; 0x800
  401360:	60fb      	str	r3, [r7, #12]
  401362:	e009      	b.n	401378 <pmc_switch_mck_to_pllack+0x40>
			--ul_timeout) {
		if (ul_timeout == 0) {
  401364:	68fb      	ldr	r3, [r7, #12]
  401366:	2b00      	cmp	r3, #0
  401368:	d102      	bne.n	401370 <pmc_switch_mck_to_pllack+0x38>
			return 1;
  40136a:	f04f 0301 	mov.w	r3, #1
  40136e:	e033      	b.n	4013d8 <pmc_switch_mck_to_pllack+0xa0>
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
  401370:	68fb      	ldr	r3, [r7, #12]
  401372:	f103 33ff 	add.w	r3, r3, #4294967295
  401376:	60fb      	str	r3, [r7, #12]
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401378:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40137c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401380:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  401382:	f003 0308 	and.w	r3, r3, #8
  401386:	2b00      	cmp	r3, #0
  401388:	d0ec      	beq.n	401364 <pmc_switch_mck_to_pllack+0x2c>
		if (ul_timeout == 0) {
			return 1;
		}
	}
	
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  40138a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40138e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401392:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401396:	f2c4 020e 	movt	r2, #16398	; 0x400e
  40139a:	6b12      	ldr	r2, [r2, #48]	; 0x30
  40139c:	f022 0203 	bic.w	r2, r2, #3
  4013a0:	f042 0202 	orr.w	r2, r2, #2
  4013a4:	631a      	str	r2, [r3, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4013a6:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4013aa:	60fb      	str	r3, [r7, #12]
  4013ac:	e009      	b.n	4013c2 <pmc_switch_mck_to_pllack+0x8a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  4013ae:	68fb      	ldr	r3, [r7, #12]
  4013b0:	2b00      	cmp	r3, #0
  4013b2:	d102      	bne.n	4013ba <pmc_switch_mck_to_pllack+0x82>
			return 1;
  4013b4:	f04f 0301 	mov.w	r3, #1
  4013b8:	e00e      	b.n	4013d8 <pmc_switch_mck_to_pllack+0xa0>
	
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
  4013ba:	68fb      	ldr	r3, [r7, #12]
  4013bc:	f103 33ff 	add.w	r3, r3, #4294967295
  4013c0:	60fb      	str	r3, [r7, #12]
	}
	
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4013c2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4013c6:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4013ca:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4013cc:	f003 0308 	and.w	r3, r3, #8
  4013d0:	2b00      	cmp	r3, #0
  4013d2:	d0ec      	beq.n	4013ae <pmc_switch_mck_to_pllack+0x76>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  4013d4:	f04f 0300 	mov.w	r3, #0
}
  4013d8:	4618      	mov	r0, r3
  4013da:	f107 0714 	add.w	r7, r7, #20
  4013de:	46bd      	mov	sp, r7
  4013e0:	bc80      	pop	{r7}
  4013e2:	4770      	bx	lr

004013e4 <pmc_switch_sclk_to_32kxtal>:
 * power supply.
 *
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
  4013e4:	b480      	push	{r7}
  4013e6:	b083      	sub	sp, #12
  4013e8:	af00      	add	r7, sp, #0
  4013ea:	6078      	str	r0, [r7, #4]
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  4013ec:	687b      	ldr	r3, [r7, #4]
  4013ee:	2b01      	cmp	r3, #1
  4013f0:	d10d      	bne.n	40140e <pmc_switch_sclk_to_32kxtal+0x2a>
		SUPC->SUPC_MR |= SUPC_MR_KEY(SUPC_KEY_VALUE) |
  4013f2:	f241 4310 	movw	r3, #5136	; 0x1410
  4013f6:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4013fa:	f241 4210 	movw	r2, #5136	; 0x1410
  4013fe:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401402:	6892      	ldr	r2, [r2, #8]
  401404:	f042 4225 	orr.w	r2, r2, #2768240640	; 0xa5000000
  401408:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
  40140c:	609a      	str	r2, [r3, #8]
				SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR |= SUPC_CR_KEY(SUPC_KEY_VALUE) | SUPC_CR_XTALSEL;
  40140e:	f241 4310 	movw	r3, #5136	; 0x1410
  401412:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401416:	f241 4210 	movw	r2, #5136	; 0x1410
  40141a:	f2c4 020e 	movt	r2, #16398	; 0x400e
  40141e:	6812      	ldr	r2, [r2, #0]
  401420:	f042 4225 	orr.w	r2, r2, #2768240640	; 0xa5000000
  401424:	f042 0208 	orr.w	r2, r2, #8
  401428:	601a      	str	r2, [r3, #0]
}
  40142a:	f107 070c 	add.w	r7, r7, #12
  40142e:	46bd      	mov	sp, r7
  401430:	bc80      	pop	{r7}
  401432:	4770      	bx	lr

00401434 <pmc_osc_is_ready_32kxtal>:
 *
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
  401434:	b480      	push	{r7}
  401436:	af00      	add	r7, sp, #0
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  401438:	f241 4310 	movw	r3, #5136	; 0x1410
  40143c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401440:	695b      	ldr	r3, [r3, #20]
  401442:	f003 0380 	and.w	r3, r3, #128	; 0x80
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  401446:	2b00      	cmp	r3, #0
  401448:	d00b      	beq.n	401462 <pmc_osc_is_ready_32kxtal+0x2e>
  40144a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40144e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401452:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  401454:	f003 0380 	and.w	r3, r3, #128	; 0x80
  401458:	2b00      	cmp	r3, #0
  40145a:	d002      	beq.n	401462 <pmc_osc_is_ready_32kxtal+0x2e>
  40145c:	f04f 0301 	mov.w	r3, #1
  401460:	e001      	b.n	401466 <pmc_osc_is_ready_32kxtal+0x32>
  401462:	f04f 0300 	mov.w	r3, #0
}
  401466:	4618      	mov	r0, r3
  401468:	46bd      	mov	sp, r7
  40146a:	bc80      	pop	{r7}
  40146c:	4770      	bx	lr
  40146e:	bf00      	nop

00401470 <pmc_switch_mainck_to_fastrc>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
  401470:	b480      	push	{r7}
  401472:	b085      	sub	sp, #20
  401474:	af00      	add	r7, sp, #0
  401476:	6078      	str	r0, [r7, #4]
	uint32_t ul_needXTEN = 0;
  401478:	f04f 0300 	mov.w	r3, #0
  40147c:	60fb      	str	r3, [r7, #12]

	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	if (PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN) {
  40147e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401482:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401486:	6a1b      	ldr	r3, [r3, #32]
  401488:	f003 0301 	and.w	r3, r3, #1
  40148c:	2b00      	cmp	r3, #0
  40148e:	d014      	beq.n	4014ba <pmc_switch_mainck_to_fastrc+0x4a>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  401490:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401494:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401498:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40149c:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4014a0:	6a12      	ldr	r2, [r2, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
  4014a2:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  4014a6:	f022 0278 	bic.w	r2, r2, #120	; 0x78
  4014aa:	6879      	ldr	r1, [r7, #4]
  4014ac:	430a      	orrs	r2, r1
  4014ae:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  4014b2:	f042 0208 	orr.w	r2, r2, #8
{
	uint32_t ul_needXTEN = 0;

	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	if (PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4014b6:	621a      	str	r2, [r3, #32]
				CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME) |
				ul_moscrcf;
	}

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4014b8:	e018      	b.n	4014ec <pmc_switch_mainck_to_fastrc+0x7c>
	if (PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
				ul_moscrcf;
	} else {
		ul_needXTEN = 1;
  4014ba:	f04f 0301 	mov.w	r3, #1
  4014be:	60fb      	str	r3, [r7, #12]
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4014c0:	f44f 6280 	mov.w	r2, #1024	; 0x400
  4014c4:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4014c8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4014cc:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4014d0:	6a19      	ldr	r1, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
				CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME) |
  4014d2:	f24c 0386 	movw	r3, #49286	; 0xc086
  4014d6:	f6cf 73c8 	movt	r3, #65480	; 0xffc8
  4014da:	400b      	ands	r3, r1
  4014dc:	6879      	ldr	r1, [r7, #4]
  4014de:	4319      	orrs	r1, r3
  4014e0:	f643 7309 	movw	r3, #16137	; 0x3f09
  4014e4:	f2c0 0337 	movt	r3, #55	; 0x37
  4014e8:	430b      	orrs	r3, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
				ul_moscrcf;
	} else {
		ul_needXTEN = 1;
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4014ea:	6213      	str	r3, [r2, #32]
				CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME) |
				ul_moscrcf;
	}

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4014ec:	bf00      	nop
  4014ee:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4014f2:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4014f6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4014f8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  4014fc:	2b00      	cmp	r3, #0
  4014fe:	d0f6      	beq.n	4014ee <pmc_switch_mainck_to_fastrc+0x7e>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) | PMC_CKGR_MOR_KEY_VALUE;
  401500:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401504:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401508:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40150c:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401510:	6a12      	ldr	r2, [r2, #32]
  401512:	f022 729b 	bic.w	r2, r2, #20316160	; 0x1360000
  401516:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  40151a:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  40151e:	621a      	str	r2, [r3, #32]

	// BUG FIX : clock_example3_sam3s does not switch sclk->mainck with XT disabled.
	if (ul_needXTEN) {
  401520:	68fb      	ldr	r3, [r7, #12]
  401522:	2b00      	cmp	r3, #0
  401524:	d00f      	beq.n	401546 <pmc_switch_mainck_to_fastrc+0xd6>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  401526:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40152a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40152e:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401532:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401536:	6a12      	ldr	r2, [r2, #32]
  401538:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  40153c:	f022 0201 	bic.w	r2, r2, #1
  401540:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  401544:	621a      	str	r2, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE;
	}
}
  401546:	f107 0714 	add.w	r7, r7, #20
  40154a:	46bd      	mov	sp, r7
  40154c:	bc80      	pop	{r7}
  40154e:	4770      	bx	lr

00401550 <pmc_switch_mainck_to_xtal>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass)
{
  401550:	b480      	push	{r7}
  401552:	b083      	sub	sp, #12
  401554:	af00      	add	r7, sp, #0
  401556:	6078      	str	r0, [r7, #4]
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  401558:	687b      	ldr	r3, [r7, #4]
  40155a:	2b00      	cmp	r3, #0
  40155c:	d014      	beq.n	401588 <pmc_switch_mainck_to_xtal+0x38>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40155e:	f44f 6180 	mov.w	r1, #1024	; 0x400
  401562:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401566:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40156a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40156e:	6a1b      	ldr	r3, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
  401570:	f64f 72fc 	movw	r2, #65532	; 0xfffc
  401574:	f6cf 62c8 	movt	r2, #65224	; 0xfec8
  401578:	401a      	ands	r2, r3
  40157a:	f04f 0302 	mov.w	r3, #2
  40157e:	f2c0 1337 	movt	r3, #311	; 0x137
  401582:	4313      	orrs	r3, r2
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  401584:	620b      	str	r3, [r1, #32]
  401586:	e02b      	b.n	4015e0 <pmc_switch_mainck_to_xtal+0x90>
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  401588:	f44f 6180 	mov.w	r1, #1024	; 0x400
  40158c:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401590:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401594:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401598:	6a1b      	ldr	r3, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
  40159a:	f24c 02fc 	movw	r2, #49404	; 0xc0fc
  40159e:	f6cf 72c8 	movt	r2, #65480	; 0xffc8
  4015a2:	401a      	ands	r2, r3
  4015a4:	f643 7301 	movw	r3, #16129	; 0x3f01
  4015a8:	f2c0 0337 	movt	r3, #55	; 0x37
  4015ac:	4313      	orrs	r3, r2
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4015ae:	620b      	str	r3, [r1, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  4015b0:	bf00      	nop
  4015b2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4015b6:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4015ba:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4015bc:	f003 0301 	and.w	r3, r3, #1
  4015c0:	2b00      	cmp	r3, #0
  4015c2:	d0f6      	beq.n	4015b2 <pmc_switch_mainck_to_xtal+0x62>

		PMC->CKGR_MOR |= PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCSEL;
  4015c4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4015c8:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4015cc:	f44f 6280 	mov.w	r2, #1024	; 0x400
  4015d0:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4015d4:	6a12      	ldr	r2, [r2, #32]
  4015d6:	f042 729b 	orr.w	r2, r2, #20316160	; 0x1360000
  4015da:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  4015de:	621a      	str	r2, [r3, #32]
	}
}
  4015e0:	f107 070c 	add.w	r7, r7, #12
  4015e4:	46bd      	mov	sp, r7
  4015e6:	bc80      	pop	{r7}
  4015e8:	4770      	bx	lr
  4015ea:	bf00      	nop

004015ec <pmc_osc_is_ready_mainck>:
 *
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
  4015ec:	b480      	push	{r7}
  4015ee:	af00      	add	r7, sp, #0
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4015f0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4015f4:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4015f8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4015fa:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
  4015fe:	4618      	mov	r0, r3
  401600:	46bd      	mov	sp, r7
  401602:	bc80      	pop	{r7}
  401604:	4770      	bx	lr
  401606:	bf00      	nop

00401608 <pmc_disable_pllack>:

/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
  401608:	b480      	push	{r7}
  40160a:	af00      	add	r7, sp, #0
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  40160c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401610:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401614:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  401618:	629a      	str	r2, [r3, #40]	; 0x28
}
  40161a:	46bd      	mov	sp, r7
  40161c:	bc80      	pop	{r7}
  40161e:	4770      	bx	lr

00401620 <pmc_is_locked_pllack>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
  401620:	b480      	push	{r7}
  401622:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  401624:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401628:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40162c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40162e:	f003 0302 	and.w	r3, r3, #2
}
  401632:	4618      	mov	r0, r3
  401634:	46bd      	mov	sp, r7
  401636:	bc80      	pop	{r7}
  401638:	4770      	bx	lr
  40163a:	bf00      	nop

0040163c <pmc_disable_pllbck>:

/**
 * \brief Disable PLLB clock.
 */
void pmc_disable_pllbck(void)
{
  40163c:	b480      	push	{r7}
  40163e:	af00      	add	r7, sp, #0
	PMC->CKGR_PLLBR = CKGR_PLLBR_MULB(0);
  401640:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401644:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401648:	f04f 0200 	mov.w	r2, #0
  40164c:	62da      	str	r2, [r3, #44]	; 0x2c
}
  40164e:	46bd      	mov	sp, r7
  401650:	bc80      	pop	{r7}
  401652:	4770      	bx	lr

00401654 <pmc_is_locked_pllbck>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllbck(void)
{
  401654:	b480      	push	{r7}
  401656:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKB);
  401658:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40165c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401660:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  401662:	f003 0304 	and.w	r3, r3, #4
}
  401666:	4618      	mov	r0, r3
  401668:	46bd      	mov	sp, r7
  40166a:	bc80      	pop	{r7}
  40166c:	4770      	bx	lr
  40166e:	bf00      	nop

00401670 <pmc_enable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
  401670:	b480      	push	{r7}
  401672:	b083      	sub	sp, #12
  401674:	af00      	add	r7, sp, #0
  401676:	6078      	str	r0, [r7, #4]
	if (ul_id > MAX_PERIPH_ID) {
  401678:	687b      	ldr	r3, [r7, #4]
  40167a:	2b22      	cmp	r3, #34	; 0x22
  40167c:	d902      	bls.n	401684 <pmc_enable_periph_clk+0x14>
		return 1;
  40167e:	f04f 0301 	mov.w	r3, #1
  401682:	e043      	b.n	40170c <pmc_enable_periph_clk+0x9c>
	}

	if (ul_id < 32) {
  401684:	687b      	ldr	r3, [r7, #4]
  401686:	2b1f      	cmp	r3, #31
  401688:	d81c      	bhi.n	4016c4 <pmc_enable_periph_clk+0x54>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  40168a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40168e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401692:	699a      	ldr	r2, [r3, #24]
  401694:	687b      	ldr	r3, [r7, #4]
  401696:	f04f 0101 	mov.w	r1, #1
  40169a:	fa01 f303 	lsl.w	r3, r1, r3
  40169e:	401a      	ands	r2, r3
  4016a0:	687b      	ldr	r3, [r7, #4]
  4016a2:	f04f 0101 	mov.w	r1, #1
  4016a6:	fa01 f303 	lsl.w	r3, r1, r3
  4016aa:	429a      	cmp	r2, r3
  4016ac:	d02c      	beq.n	401708 <pmc_enable_periph_clk+0x98>
			PMC->PMC_PCER0 = 1 << ul_id;
  4016ae:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4016b2:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4016b6:	687a      	ldr	r2, [r7, #4]
  4016b8:	f04f 0101 	mov.w	r1, #1
  4016bc:	fa01 f202 	lsl.w	r2, r1, r2
  4016c0:	611a      	str	r2, [r3, #16]
  4016c2:	e021      	b.n	401708 <pmc_enable_periph_clk+0x98>
		}
#if (SAM3S || SAM3XA || SAM4S)
	} else {
		ul_id -= 32;
  4016c4:	687b      	ldr	r3, [r7, #4]
  4016c6:	f1a3 0320 	sub.w	r3, r3, #32
  4016ca:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  4016cc:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4016d0:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4016d4:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  4016d8:	687b      	ldr	r3, [r7, #4]
  4016da:	f04f 0101 	mov.w	r1, #1
  4016de:	fa01 f303 	lsl.w	r3, r1, r3
  4016e2:	401a      	ands	r2, r3
  4016e4:	687b      	ldr	r3, [r7, #4]
  4016e6:	f04f 0101 	mov.w	r1, #1
  4016ea:	fa01 f303 	lsl.w	r3, r1, r3
  4016ee:	429a      	cmp	r2, r3
  4016f0:	d00a      	beq.n	401708 <pmc_enable_periph_clk+0x98>
			PMC->PMC_PCER1 = 1 << ul_id;
  4016f2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4016f6:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4016fa:	687a      	ldr	r2, [r7, #4]
  4016fc:	f04f 0101 	mov.w	r1, #1
  401700:	fa01 f202 	lsl.w	r2, r1, r2
  401704:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
		}
#endif
	}
	
	return 0;
  401708:	f04f 0300 	mov.w	r3, #0
}
  40170c:	4618      	mov	r0, r3
  40170e:	f107 070c 	add.w	r7, r7, #12
  401712:	46bd      	mov	sp, r7
  401714:	bc80      	pop	{r7}
  401716:	4770      	bx	lr

00401718 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  401718:	b480      	push	{r7}
  40171a:	af00      	add	r7, sp, #0
	while (1) {
	}
  40171c:	e7fe      	b.n	40171c <Dummy_Handler+0x4>
  40171e:	bf00      	nop

00401720 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  401720:	b580      	push	{r7, lr}
  401722:	b082      	sub	sp, #8
  401724:	af00      	add	r7, sp, #0
	uint32_t *pSrc, *pDest;

	/* Initialize the relocate segment */
	pSrc = &_etext;
  401726:	f644 43b4 	movw	r3, #19636	; 0x4cb4
  40172a:	f2c0 0340 	movt	r3, #64	; 0x40
  40172e:	607b      	str	r3, [r7, #4]
	pDest = &_srelocate;
  401730:	f240 0300 	movw	r3, #0
  401734:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401738:	603b      	str	r3, [r7, #0]

	if (pSrc != pDest) {
  40173a:	687a      	ldr	r2, [r7, #4]
  40173c:	683b      	ldr	r3, [r7, #0]
  40173e:	429a      	cmp	r2, r3
  401740:	d013      	beq.n	40176a <Reset_Handler+0x4a>
		for (; pDest < &_erelocate;) {
  401742:	e00b      	b.n	40175c <Reset_Handler+0x3c>
			*pDest++ = *pSrc++;
  401744:	687b      	ldr	r3, [r7, #4]
  401746:	681a      	ldr	r2, [r3, #0]
  401748:	683b      	ldr	r3, [r7, #0]
  40174a:	601a      	str	r2, [r3, #0]
  40174c:	683b      	ldr	r3, [r7, #0]
  40174e:	f103 0304 	add.w	r3, r3, #4
  401752:	603b      	str	r3, [r7, #0]
  401754:	687b      	ldr	r3, [r7, #4]
  401756:	f103 0304 	add.w	r3, r3, #4
  40175a:	607b      	str	r3, [r7, #4]
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
  40175c:	683a      	ldr	r2, [r7, #0]
  40175e:	f240 4340 	movw	r3, #1088	; 0x440
  401762:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401766:	429a      	cmp	r2, r3
  401768:	d3ec      	bcc.n	401744 <Reset_Handler+0x24>
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40176a:	f240 4340 	movw	r3, #1088	; 0x440
  40176e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401772:	603b      	str	r3, [r7, #0]
  401774:	e007      	b.n	401786 <Reset_Handler+0x66>
		*pDest++ = 0;
  401776:	683b      	ldr	r3, [r7, #0]
  401778:	f04f 0200 	mov.w	r2, #0
  40177c:	601a      	str	r2, [r3, #0]
  40177e:	683b      	ldr	r3, [r7, #0]
  401780:	f103 0304 	add.w	r3, r3, #4
  401784:	603b      	str	r3, [r7, #0]
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  401786:	683a      	ldr	r2, [r7, #0]
  401788:	f24a 631c 	movw	r3, #42524	; 0xa61c
  40178c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401790:	429a      	cmp	r2, r3
  401792:	d3f0      	bcc.n	401776 <Reset_Handler+0x56>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
  401794:	f240 0300 	movw	r3, #0
  401798:	f2c0 0340 	movt	r3, #64	; 0x40
  40179c:	607b      	str	r3, [r7, #4]
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  40179e:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  4017a2:	f2ce 0300 	movt	r3, #57344	; 0xe000
  4017a6:	687a      	ldr	r2, [r7, #4]
  4017a8:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
  4017ac:	609a      	str	r2, [r3, #8]

	if (((uint32_t) pSrc >= IRAM_ADDR) && ((uint32_t) pSrc < IRAM_ADDR + IRAM_SIZE)) {
  4017ae:	687a      	ldr	r2, [r7, #4]
  4017b0:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
  4017b4:	429a      	cmp	r2, r3
  4017b6:	d912      	bls.n	4017de <Reset_Handler+0xbe>
  4017b8:	687a      	ldr	r2, [r7, #4]
  4017ba:	f64f 73ff 	movw	r3, #65535	; 0xffff
  4017be:	f2c2 0301 	movt	r3, #8193	; 0x2001
  4017c2:	429a      	cmp	r2, r3
  4017c4:	d80b      	bhi.n	4017de <Reset_Handler+0xbe>
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
  4017c6:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  4017ca:	f2ce 0300 	movt	r3, #57344	; 0xe000
  4017ce:	f44f 426d 	mov.w	r2, #60672	; 0xed00
  4017d2:	f2ce 0200 	movt	r2, #57344	; 0xe000
  4017d6:	6892      	ldr	r2, [r2, #8]
  4017d8:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  4017dc:	609a      	str	r2, [r3, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
  4017de:	f644 3399 	movw	r3, #19353	; 0x4b99
  4017e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4017e6:	4798      	blx	r3

	/* Branch to main function */
	main();
  4017e8:	f244 63f1 	movw	r3, #18161	; 0x46f1
  4017ec:	f2c0 0340 	movt	r3, #64	; 0x40
  4017f0:	4798      	blx	r3

	/* Infinite loop */
	while (1);
  4017f2:	e7fe      	b.n	4017f2 <Reset_Handler+0xd2>

004017f4 <SystemCoreClockUpdate>:

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate(void)
{
  4017f4:	b480      	push	{r7}
  4017f6:	af00      	add	r7, sp, #0
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  4017f8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4017fc:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401800:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401802:	f003 0303 	and.w	r3, r3, #3
  401806:	2b03      	cmp	r3, #3
  401808:	f200 8119 	bhi.w	401a3e <SystemCoreClockUpdate+0x24a>
  40180c:	a101      	add	r1, pc, #4	; (adr r1, 401814 <SystemCoreClockUpdate+0x20>)
  40180e:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
  401812:	bf00      	nop
  401814:	00401825 	.word	0x00401825
  401818:	00401857 	.word	0x00401857
  40181c:	004018e9 	.word	0x004018e9
  401820:	004018e9 	.word	0x004018e9
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  401824:	f241 4310 	movw	r3, #5136	; 0x1410
  401828:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40182c:	695b      	ldr	r3, [r3, #20]
  40182e:	f003 0380 	and.w	r3, r3, #128	; 0x80
  401832:	2b00      	cmp	r3, #0
  401834:	d007      	beq.n	401846 <SystemCoreClockUpdate+0x52>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  401836:	f240 0304 	movw	r3, #4
  40183a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40183e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  401842:	601a      	str	r2, [r3, #0]
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
		}
		break;
  401844:	e0fc      	b.n	401a40 <SystemCoreClockUpdate+0x24c>
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  401846:	f240 0304 	movw	r3, #4
  40184a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40184e:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  401852:	601a      	str	r2, [r3, #0]
		}
		break;
  401854:	e0f4      	b.n	401a40 <SystemCoreClockUpdate+0x24c>
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  401856:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40185a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40185e:	6a1b      	ldr	r3, [r3, #32]
  401860:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  401864:	2b00      	cmp	r3, #0
  401866:	d009      	beq.n	40187c <SystemCoreClockUpdate+0x88>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  401868:	f240 0304 	movw	r3, #4
  40186c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401870:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  401874:	f2c0 02b7 	movt	r2, #183	; 0xb7
  401878:	601a      	str	r2, [r3, #0]
				break;
			default:
				break;
			}
		}
		break;
  40187a:	e0e1      	b.n	401a40 <SystemCoreClockUpdate+0x24c>
		break;
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  40187c:	f240 0304 	movw	r3, #4
  401880:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401884:	f44f 6210 	mov.w	r2, #2304	; 0x900
  401888:	f2c0 023d 	movt	r2, #61	; 0x3d
  40188c:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  40188e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401892:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401896:	6a1b      	ldr	r3, [r3, #32]
  401898:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40189c:	2b10      	cmp	r3, #16
  40189e:	d004      	beq.n	4018aa <SystemCoreClockUpdate+0xb6>
  4018a0:	2b20      	cmp	r3, #32
  4018a2:	d00f      	beq.n	4018c4 <SystemCoreClockUpdate+0xd0>
  4018a4:	2b00      	cmp	r3, #0
  4018a6:	d01d      	beq.n	4018e4 <SystemCoreClockUpdate+0xf0>
  4018a8:	e01b      	b.n	4018e2 <SystemCoreClockUpdate+0xee>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
  4018aa:	f240 0304 	movw	r3, #4
  4018ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4018b2:	681b      	ldr	r3, [r3, #0]
  4018b4:	ea4f 0243 	mov.w	r2, r3, lsl #1
  4018b8:	f240 0304 	movw	r3, #4
  4018bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4018c0:	601a      	str	r2, [r3, #0]
				break;
  4018c2:	e010      	b.n	4018e6 <SystemCoreClockUpdate+0xf2>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
  4018c4:	f240 0304 	movw	r3, #4
  4018c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4018cc:	681a      	ldr	r2, [r3, #0]
  4018ce:	4613      	mov	r3, r2
  4018d0:	ea4f 0343 	mov.w	r3, r3, lsl #1
  4018d4:	189a      	adds	r2, r3, r2
  4018d6:	f240 0304 	movw	r3, #4
  4018da:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4018de:	601a      	str	r2, [r3, #0]
				break;
  4018e0:	e001      	b.n	4018e6 <SystemCoreClockUpdate+0xf2>
			default:
				break;
  4018e2:	e000      	b.n	4018e6 <SystemCoreClockUpdate+0xf2>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
  4018e4:	bf00      	nop
				break;
			default:
				break;
			}
		}
		break;
  4018e6:	e0ab      	b.n	401a40 <SystemCoreClockUpdate+0x24c>
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  4018e8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4018ec:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4018f0:	6a1b      	ldr	r3, [r3, #32]
  4018f2:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  4018f6:	2b00      	cmp	r3, #0
  4018f8:	d009      	beq.n	40190e <SystemCoreClockUpdate+0x11a>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  4018fa:	f240 0304 	movw	r3, #4
  4018fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401902:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  401906:	f2c0 02b7 	movt	r2, #183	; 0xb7
  40190a:	601a      	str	r2, [r3, #0]
  40190c:	e034      	b.n	401978 <SystemCoreClockUpdate+0x184>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  40190e:	f240 0304 	movw	r3, #4
  401912:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401916:	f44f 6210 	mov.w	r2, #2304	; 0x900
  40191a:	f2c0 023d 	movt	r2, #61	; 0x3d
  40191e:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  401920:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401924:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401928:	6a1b      	ldr	r3, [r3, #32]
  40192a:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40192e:	2b10      	cmp	r3, #16
  401930:	d004      	beq.n	40193c <SystemCoreClockUpdate+0x148>
  401932:	2b20      	cmp	r3, #32
  401934:	d00f      	beq.n	401956 <SystemCoreClockUpdate+0x162>
  401936:	2b00      	cmp	r3, #0
  401938:	d01d      	beq.n	401976 <SystemCoreClockUpdate+0x182>
  40193a:	e01b      	b.n	401974 <SystemCoreClockUpdate+0x180>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
  40193c:	f240 0304 	movw	r3, #4
  401940:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401944:	681b      	ldr	r3, [r3, #0]
  401946:	ea4f 0243 	mov.w	r2, r3, lsl #1
  40194a:	f240 0304 	movw	r3, #4
  40194e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401952:	601a      	str	r2, [r3, #0]
				break;
  401954:	e010      	b.n	401978 <SystemCoreClockUpdate+0x184>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
  401956:	f240 0304 	movw	r3, #4
  40195a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40195e:	681a      	ldr	r2, [r3, #0]
  401960:	4613      	mov	r3, r2
  401962:	ea4f 0343 	mov.w	r3, r3, lsl #1
  401966:	189a      	adds	r2, r3, r2
  401968:	f240 0304 	movw	r3, #4
  40196c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401970:	601a      	str	r2, [r3, #0]
				break;
  401972:	e001      	b.n	401978 <SystemCoreClockUpdate+0x184>
			default:
				break;
  401974:	e000      	b.n	401978 <SystemCoreClockUpdate+0x184>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
  401976:	bf00      	nop
				break;
			default:
				break;
			}
		}
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
  401978:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40197c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401980:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401982:	f003 0303 	and.w	r3, r3, #3
  401986:	2b02      	cmp	r3, #2
  401988:	d12c      	bne.n	4019e4 <SystemCoreClockUpdate+0x1f0>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  40198a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40198e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401992:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  401994:	f04f 0300 	mov.w	r3, #0
  401998:	f2c0 73ff 	movt	r3, #2047	; 0x7ff
  40199c:	4013      	ands	r3, r2
  40199e:	ea4f 4313 	mov.w	r3, r3, lsr #16
				                          CKGR_PLLAR_MULA_Pos) + 1U);
  4019a2:	f103 0201 	add.w	r2, r3, #1
			default:
				break;
			}
		}
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  4019a6:	f240 0304 	movw	r3, #4
  4019aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4019ae:	681b      	ldr	r3, [r3, #0]
  4019b0:	fb03 f202 	mul.w	r2, r3, r2
  4019b4:	f240 0304 	movw	r3, #4
  4019b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4019bc:	601a      	str	r2, [r3, #0]
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
  4019be:	f240 0304 	movw	r3, #4
  4019c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4019c6:	681a      	ldr	r2, [r3, #0]
  4019c8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4019cc:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4019d0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  4019d2:	b2db      	uxtb	r3, r3
  4019d4:	fbb2 f2f3 	udiv	r2, r2, r3
  4019d8:	f240 0304 	movw	r3, #4
  4019dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4019e0:	601a      	str	r2, [r3, #0]
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
				                           CKGR_PLLBR_MULB_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk) >> 
				                               CKGR_PLLBR_DIVB_Pos));
		}
		break;
  4019e2:	e02d      	b.n	401a40 <SystemCoreClockUpdate+0x24c>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
				                          CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
  4019e4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4019e8:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4019ec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4019ee:	f04f 0300 	mov.w	r3, #0
  4019f2:	f2c0 73ff 	movt	r3, #2047	; 0x7ff
  4019f6:	4013      	ands	r3, r2
  4019f8:	ea4f 4313 	mov.w	r3, r3, lsr #16
				                           CKGR_PLLBR_MULB_Pos) + 1U);
  4019fc:	f103 0201 	add.w	r2, r3, #1
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
				                          CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
  401a00:	f240 0304 	movw	r3, #4
  401a04:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a08:	681b      	ldr	r3, [r3, #0]
  401a0a:	fb03 f202 	mul.w	r2, r3, r2
  401a0e:	f240 0304 	movw	r3, #4
  401a12:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a16:	601a      	str	r2, [r3, #0]
				                           CKGR_PLLBR_MULB_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk) >> 
  401a18:	f240 0304 	movw	r3, #4
  401a1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a20:	681a      	ldr	r2, [r3, #0]
  401a22:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401a26:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401a2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401a2c:	b2db      	uxtb	r3, r3
  401a2e:	fbb2 f2f3 	udiv	r2, r2, r3
  401a32:	f240 0304 	movw	r3, #4
  401a36:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a3a:	601a      	str	r2, [r3, #0]
				                               CKGR_PLLBR_DIVB_Pos));
		}
		break;
  401a3c:	e000      	b.n	401a40 <SystemCoreClockUpdate+0x24c>
	default:
		break;
  401a3e:	bf00      	nop
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  401a40:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401a44:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401a48:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401a4a:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401a4e:	2b70      	cmp	r3, #112	; 0x70
  401a50:	d112      	bne.n	401a78 <SystemCoreClockUpdate+0x284>
		SystemCoreClock /= 3U;
  401a52:	f240 0304 	movw	r3, #4
  401a56:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a5a:	681a      	ldr	r2, [r3, #0]
  401a5c:	f64a 23ab 	movw	r3, #43691	; 0xaaab
  401a60:	f6ca 23aa 	movt	r3, #43690	; 0xaaaa
  401a64:	fba3 1302 	umull	r1, r3, r3, r2
  401a68:	ea4f 0253 	mov.w	r2, r3, lsr #1
  401a6c:	f240 0304 	movw	r3, #4
  401a70:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a74:	601a      	str	r2, [r3, #0]
  401a76:	e014      	b.n	401aa2 <SystemCoreClockUpdate+0x2ae>
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  401a78:	f240 0304 	movw	r3, #4
  401a7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a80:	681a      	ldr	r2, [r3, #0]
  401a82:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401a86:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401a8a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401a8c:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401a90:	ea4f 1313 	mov.w	r3, r3, lsr #4
  401a94:	fa22 f203 	lsr.w	r2, r2, r3
  401a98:	f240 0304 	movw	r3, #4
  401a9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401aa0:	601a      	str	r2, [r3, #0]
	}
}
  401aa2:	46bd      	mov	sp, r7
  401aa4:	bc80      	pop	{r7}
  401aa6:	4770      	bx	lr

00401aa8 <system_init_flash>:

/** 
 * Initialize flash.
 */
void system_init_flash(uint32_t ul_clk)
{
  401aa8:	b480      	push	{r7}
  401aaa:	b083      	sub	sp, #12
  401aac:	af00      	add	r7, sp, #0
  401aae:	6078      	str	r0, [r7, #4]
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
  401ab0:	687a      	ldr	r2, [r7, #4]
  401ab2:	f642 43ff 	movw	r3, #11519	; 0x2cff
  401ab6:	f2c0 1331 	movt	r3, #305	; 0x131
  401aba:	429a      	cmp	r2, r3
  401abc:	d807      	bhi.n	401ace <system_init_flash+0x26>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0);
  401abe:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  401ac2:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401ac6:	f04f 0200 	mov.w	r2, #0
  401aca:	601a      	str	r2, [r3, #0]
  401acc:	e033      	b.n	401b36 <system_init_flash+0x8e>
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
  401ace:	687a      	ldr	r2, [r7, #4]
  401ad0:	f645 13ff 	movw	r3, #23039	; 0x59ff
  401ad4:	f2c0 2362 	movt	r3, #610	; 0x262
  401ad8:	429a      	cmp	r2, r3
  401ada:	d807      	bhi.n	401aec <system_init_flash+0x44>
		EFC->EEFC_FMR = EEFC_FMR_FWS(1);
  401adc:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  401ae0:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401ae4:	f44f 7280 	mov.w	r2, #256	; 0x100
  401ae8:	601a      	str	r2, [r3, #0]
  401aea:	e024      	b.n	401b36 <system_init_flash+0x8e>
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
  401aec:	687a      	ldr	r2, [r7, #4]
  401aee:	f248 63ff 	movw	r3, #34559	; 0x86ff
  401af2:	f2c0 3393 	movt	r3, #915	; 0x393
  401af6:	429a      	cmp	r2, r3
  401af8:	d807      	bhi.n	401b0a <system_init_flash+0x62>
		EFC->EEFC_FMR = EEFC_FMR_FWS(2);
  401afa:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  401afe:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401b02:	f44f 7200 	mov.w	r2, #512	; 0x200
  401b06:	601a      	str	r2, [r3, #0]
  401b08:	e015      	b.n	401b36 <system_init_flash+0x8e>
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
  401b0a:	687a      	ldr	r2, [r7, #4]
  401b0c:	f24b 33ff 	movw	r3, #46079	; 0xb3ff
  401b10:	f2c0 43c4 	movt	r3, #1220	; 0x4c4
  401b14:	429a      	cmp	r2, r3
  401b16:	d807      	bhi.n	401b28 <system_init_flash+0x80>
		EFC->EEFC_FMR = EEFC_FMR_FWS(3);
  401b18:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  401b1c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401b20:	f44f 7240 	mov.w	r2, #768	; 0x300
  401b24:	601a      	str	r2, [r3, #0]
  401b26:	e006      	b.n	401b36 <system_init_flash+0x8e>
	} else {
		EFC->EEFC_FMR = EEFC_FMR_FWS(4);
  401b28:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  401b2c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401b30:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401b34:	601a      	str	r2, [r3, #0]
	}
}
  401b36:	f107 070c 	add.w	r7, r7, #12
  401b3a:	46bd      	mov	sp, r7
  401b3c:	bc80      	pop	{r7}
  401b3e:	4770      	bx	lr

00401b40 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList * const pxList )
{
  401b40:	b480      	push	{r7}
  401b42:	b083      	sub	sp, #12
  401b44:	af00      	add	r7, sp, #0
  401b46:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  401b48:	687b      	ldr	r3, [r7, #4]
  401b4a:	f103 0208 	add.w	r2, r3, #8
  401b4e:	687b      	ldr	r3, [r7, #4]
  401b50:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  401b52:	687b      	ldr	r3, [r7, #4]
  401b54:	f04f 32ff 	mov.w	r2, #4294967295
  401b58:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  401b5a:	687b      	ldr	r3, [r7, #4]
  401b5c:	f103 0208 	add.w	r2, r3, #8
  401b60:	687b      	ldr	r3, [r7, #4]
  401b62:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  401b64:	687b      	ldr	r3, [r7, #4]
  401b66:	f103 0208 	add.w	r2, r3, #8
  401b6a:	687b      	ldr	r3, [r7, #4]
  401b6c:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  401b6e:	687b      	ldr	r3, [r7, #4]
  401b70:	f04f 0200 	mov.w	r2, #0
  401b74:	601a      	str	r2, [r3, #0]
}
  401b76:	f107 070c 	add.w	r7, r7, #12
  401b7a:	46bd      	mov	sp, r7
  401b7c:	bc80      	pop	{r7}
  401b7e:	4770      	bx	lr

00401b80 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem * const pxItem )
{
  401b80:	b480      	push	{r7}
  401b82:	b083      	sub	sp, #12
  401b84:	af00      	add	r7, sp, #0
  401b86:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  401b88:	687b      	ldr	r3, [r7, #4]
  401b8a:	f04f 0200 	mov.w	r2, #0
  401b8e:	611a      	str	r2, [r3, #16]
}
  401b90:	f107 070c 	add.w	r7, r7, #12
  401b94:	46bd      	mov	sp, r7
  401b96:	bc80      	pop	{r7}
  401b98:	4770      	bx	lr
  401b9a:	bf00      	nop

00401b9c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList * const pxList, xListItem * const pxNewListItem )
{
  401b9c:	b480      	push	{r7}
  401b9e:	b085      	sub	sp, #20
  401ba0:	af00      	add	r7, sp, #0
  401ba2:	6078      	str	r0, [r7, #4]
  401ba4:	6039      	str	r1, [r7, #0]
xListItem * pxIndex;

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry. */
	pxIndex = pxList->pxIndex;
  401ba6:	687b      	ldr	r3, [r7, #4]
  401ba8:	685b      	ldr	r3, [r3, #4]
  401baa:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex;
  401bac:	683b      	ldr	r3, [r7, #0]
  401bae:	68fa      	ldr	r2, [r7, #12]
  401bb0:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  401bb2:	68fb      	ldr	r3, [r7, #12]
  401bb4:	689a      	ldr	r2, [r3, #8]
  401bb6:	683b      	ldr	r3, [r7, #0]
  401bb8:	609a      	str	r2, [r3, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
  401bba:	68fb      	ldr	r3, [r7, #12]
  401bbc:	689b      	ldr	r3, [r3, #8]
  401bbe:	683a      	ldr	r2, [r7, #0]
  401bc0:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
  401bc2:	68fb      	ldr	r3, [r7, #12]
  401bc4:	683a      	ldr	r2, [r7, #0]
  401bc6:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  401bc8:	683b      	ldr	r3, [r7, #0]
  401bca:	687a      	ldr	r2, [r7, #4]
  401bcc:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  401bce:	687b      	ldr	r3, [r7, #4]
  401bd0:	681b      	ldr	r3, [r3, #0]
  401bd2:	f103 0201 	add.w	r2, r3, #1
  401bd6:	687b      	ldr	r3, [r7, #4]
  401bd8:	601a      	str	r2, [r3, #0]
}
  401bda:	f107 0714 	add.w	r7, r7, #20
  401bde:	46bd      	mov	sp, r7
  401be0:	bc80      	pop	{r7}
  401be2:	4770      	bx	lr

00401be4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList * const pxList, xListItem * const pxNewListItem )
{
  401be4:	b480      	push	{r7}
  401be6:	b085      	sub	sp, #20
  401be8:	af00      	add	r7, sp, #0
  401bea:	6078      	str	r0, [r7, #4]
  401bec:	6039      	str	r1, [r7, #0]
xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
  401bee:	683b      	ldr	r3, [r7, #0]
  401bf0:	681b      	ldr	r3, [r3, #0]
  401bf2:	60bb      	str	r3, [r7, #8]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  401bf4:	68bb      	ldr	r3, [r7, #8]
  401bf6:	f1b3 3fff 	cmp.w	r3, #4294967295
  401bfa:	d103      	bne.n	401c04 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  401bfc:	687b      	ldr	r3, [r7, #4]
  401bfe:	691b      	ldr	r3, [r3, #16]
  401c00:	60fb      	str	r3, [r7, #12]
  401c02:	e00d      	b.n	401c20 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  401c04:	687b      	ldr	r3, [r7, #4]
  401c06:	f103 0308 	add.w	r3, r3, #8
  401c0a:	60fb      	str	r3, [r7, #12]
  401c0c:	e002      	b.n	401c14 <vListInsert+0x30>
  401c0e:	68fb      	ldr	r3, [r7, #12]
  401c10:	685b      	ldr	r3, [r3, #4]
  401c12:	60fb      	str	r3, [r7, #12]
  401c14:	68fb      	ldr	r3, [r7, #12]
  401c16:	685b      	ldr	r3, [r3, #4]
  401c18:	681a      	ldr	r2, [r3, #0]
  401c1a:	68bb      	ldr	r3, [r7, #8]
  401c1c:	429a      	cmp	r2, r3
  401c1e:	d9f6      	bls.n	401c0e <vListInsert+0x2a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  401c20:	68fb      	ldr	r3, [r7, #12]
  401c22:	685a      	ldr	r2, [r3, #4]
  401c24:	683b      	ldr	r3, [r7, #0]
  401c26:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  401c28:	683b      	ldr	r3, [r7, #0]
  401c2a:	685b      	ldr	r3, [r3, #4]
  401c2c:	683a      	ldr	r2, [r7, #0]
  401c2e:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
  401c30:	683b      	ldr	r3, [r7, #0]
  401c32:	68fa      	ldr	r2, [r7, #12]
  401c34:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
  401c36:	68fb      	ldr	r3, [r7, #12]
  401c38:	683a      	ldr	r2, [r7, #0]
  401c3a:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  401c3c:	683b      	ldr	r3, [r7, #0]
  401c3e:	687a      	ldr	r2, [r7, #4]
  401c40:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  401c42:	687b      	ldr	r3, [r7, #4]
  401c44:	681b      	ldr	r3, [r3, #0]
  401c46:	f103 0201 	add.w	r2, r3, #1
  401c4a:	687b      	ldr	r3, [r7, #4]
  401c4c:	601a      	str	r2, [r3, #0]
}
  401c4e:	f107 0714 	add.w	r7, r7, #20
  401c52:	46bd      	mov	sp, r7
  401c54:	bc80      	pop	{r7}
  401c56:	4770      	bx	lr

00401c58 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove )
{
  401c58:	b480      	push	{r7}
  401c5a:	b085      	sub	sp, #20
  401c5c:	af00      	add	r7, sp, #0
  401c5e:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  401c60:	687b      	ldr	r3, [r7, #4]
  401c62:	685b      	ldr	r3, [r3, #4]
  401c64:	687a      	ldr	r2, [r7, #4]
  401c66:	6892      	ldr	r2, [r2, #8]
  401c68:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  401c6a:	687b      	ldr	r3, [r7, #4]
  401c6c:	689b      	ldr	r3, [r3, #8]
  401c6e:	687a      	ldr	r2, [r7, #4]
  401c70:	6852      	ldr	r2, [r2, #4]
  401c72:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  401c74:	687b      	ldr	r3, [r7, #4]
  401c76:	691b      	ldr	r3, [r3, #16]
  401c78:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  401c7a:	68fb      	ldr	r3, [r7, #12]
  401c7c:	685a      	ldr	r2, [r3, #4]
  401c7e:	687b      	ldr	r3, [r7, #4]
  401c80:	429a      	cmp	r2, r3
  401c82:	d103      	bne.n	401c8c <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  401c84:	687b      	ldr	r3, [r7, #4]
  401c86:	689a      	ldr	r2, [r3, #8]
  401c88:	68fb      	ldr	r3, [r7, #12]
  401c8a:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  401c8c:	687b      	ldr	r3, [r7, #4]
  401c8e:	f04f 0200 	mov.w	r2, #0
  401c92:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
  401c94:	68fb      	ldr	r3, [r7, #12]
  401c96:	681b      	ldr	r3, [r3, #0]
  401c98:	f103 32ff 	add.w	r2, r3, #4294967295
  401c9c:	68fb      	ldr	r3, [r7, #12]
  401c9e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  401ca0:	68fb      	ldr	r3, [r7, #12]
  401ca2:	681b      	ldr	r3, [r3, #0]
}
  401ca4:	4618      	mov	r0, r3
  401ca6:	f107 0714 	add.w	r7, r7, #20
  401caa:	46bd      	mov	sp, r7
  401cac:	bc80      	pop	{r7}
  401cae:	4770      	bx	lr

00401cb0 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
  401cb0:	b480      	push	{r7}
  401cb2:	b085      	sub	sp, #20
  401cb4:	af00      	add	r7, sp, #0
  401cb6:	60f8      	str	r0, [r7, #12]
  401cb8:	60b9      	str	r1, [r7, #8]
  401cba:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
  401cbc:	68fb      	ldr	r3, [r7, #12]
  401cbe:	f1a3 0304 	sub.w	r3, r3, #4
  401cc2:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
  401cc4:	68fb      	ldr	r3, [r7, #12]
  401cc6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  401cca:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  401ccc:	68fb      	ldr	r3, [r7, #12]
  401cce:	f1a3 0304 	sub.w	r3, r3, #4
  401cd2:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
  401cd4:	68ba      	ldr	r2, [r7, #8]
  401cd6:	68fb      	ldr	r3, [r7, #12]
  401cd8:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  401cda:	68fb      	ldr	r3, [r7, #12]
  401cdc:	f1a3 0304 	sub.w	r3, r3, #4
  401ce0:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) portTASK_RETURN_ADDRESS;	/* LR */
  401ce2:	f641 5315 	movw	r3, #7445	; 0x1d15
  401ce6:	f2c0 0340 	movt	r3, #64	; 0x40
  401cea:	68fa      	ldr	r2, [r7, #12]
  401cec:	6013      	str	r3, [r2, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
  401cee:	68fb      	ldr	r3, [r7, #12]
  401cf0:	f1a3 0314 	sub.w	r3, r3, #20
  401cf4:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
  401cf6:	687a      	ldr	r2, [r7, #4]
  401cf8:	68fb      	ldr	r3, [r7, #12]
  401cfa:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
  401cfc:	68fb      	ldr	r3, [r7, #12]
  401cfe:	f1a3 0320 	sub.w	r3, r3, #32
  401d02:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
  401d04:	68fb      	ldr	r3, [r7, #12]
}
  401d06:	4618      	mov	r0, r3
  401d08:	f107 0714 	add.w	r7, r7, #20
  401d0c:	46bd      	mov	sp, r7
  401d0e:	bc80      	pop	{r7}
  401d10:	4770      	bx	lr
  401d12:	bf00      	nop

00401d14 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
  401d14:	b580      	push	{r7, lr}
  401d16:	af00      	add	r7, sp, #0
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
  401d18:	f240 0308 	movw	r3, #8
  401d1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401d20:	681b      	ldr	r3, [r3, #0]
  401d22:	f1b3 3fff 	cmp.w	r3, #4294967295
  401d26:	d005      	beq.n	401d34 <prvTaskExitError+0x20>
  401d28:	f641 7321 	movw	r3, #7969	; 0x1f21
  401d2c:	f2c0 0340 	movt	r3, #64	; 0x40
  401d30:	4798      	blx	r3
  401d32:	e7fe      	b.n	401d32 <prvTaskExitError+0x1e>
	portDISABLE_INTERRUPTS();
  401d34:	f641 7321 	movw	r3, #7969	; 0x1f21
  401d38:	f2c0 0340 	movt	r3, #64	; 0x40
  401d3c:	4798      	blx	r3
	for( ;; );
  401d3e:	e7fe      	b.n	401d3e <prvTaskExitError+0x2a>

00401d40 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
  401d40:	4b06      	ldr	r3, [pc, #24]	; (401d5c <pxCurrentTCBConst2>)
  401d42:	6819      	ldr	r1, [r3, #0]
  401d44:	6808      	ldr	r0, [r1, #0]
  401d46:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  401d4a:	f380 8809 	msr	PSP, r0
  401d4e:	f04f 0000 	mov.w	r0, #0
  401d52:	f380 8811 	msr	BASEPRI, r0
  401d56:	f04e 0e0d 	orr.w	lr, lr, #13
  401d5a:	4770      	bx	lr

00401d5c <pxCurrentTCBConst2>:
  401d5c:	2000a4e4 	.word	0x2000a4e4

00401d60 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
  401d60:	4803      	ldr	r0, [pc, #12]	; (401d70 <prvPortStartFirstTask+0x10>)
  401d62:	6800      	ldr	r0, [r0, #0]
  401d64:	6800      	ldr	r0, [r0, #0]
  401d66:	f380 8808 	msr	MSP, r0
  401d6a:	b662      	cpsie	i
  401d6c:	df00      	svc	0
  401d6e:	bf00      	nop
  401d70:	e000ed08 	.word	0xe000ed08

00401d74 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
  401d74:	b580      	push	{r7, lr}
  401d76:	b084      	sub	sp, #16
  401d78:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile unsigned long ulOriginalPriority;
		volatile char * const pcFirstUserPriorityRegister = ( volatile char * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
  401d7a:	f44f 4364 	mov.w	r3, #58368	; 0xe400
  401d7e:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401d82:	60fb      	str	r3, [r7, #12]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pcFirstUserPriorityRegister;
  401d84:	68fb      	ldr	r3, [r7, #12]
  401d86:	781b      	ldrb	r3, [r3, #0]
  401d88:	b2db      	uxtb	r3, r3
  401d8a:	60bb      	str	r3, [r7, #8]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pcFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  401d8c:	68fb      	ldr	r3, [r7, #12]
  401d8e:	f04f 02ff 	mov.w	r2, #255	; 0xff
  401d92:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pcFirstUserPriorityRegister;
  401d94:	68fb      	ldr	r3, [r7, #12]
  401d96:	781b      	ldrb	r3, [r3, #0]
  401d98:	b2db      	uxtb	r3, r3
  401d9a:	71fb      	strb	r3, [r7, #7]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
  401d9c:	79fb      	ldrb	r3, [r7, #7]
  401d9e:	b2db      	uxtb	r3, r3
  401da0:	f023 035f 	bic.w	r3, r3, #95	; 0x5f
  401da4:	b2da      	uxtb	r2, r3
  401da6:	f24a 43dc 	movw	r3, #42204	; 0xa4dc
  401daa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401dae:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
  401db0:	f24a 43e0 	movw	r3, #42208	; 0xa4e0
  401db4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401db8:	f04f 0207 	mov.w	r2, #7
  401dbc:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  401dbe:	e011      	b.n	401de4 <xPortStartScheduler+0x70>
		{
			ulMaxPRIGROUPValue--;
  401dc0:	f24a 43e0 	movw	r3, #42208	; 0xa4e0
  401dc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401dc8:	681b      	ldr	r3, [r3, #0]
  401dca:	f103 32ff 	add.w	r2, r3, #4294967295
  401dce:	f24a 43e0 	movw	r3, #42208	; 0xa4e0
  401dd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401dd6:	601a      	str	r2, [r3, #0]
			ucMaxPriorityValue <<= ( unsigned char ) 0x01;
  401dd8:	79fb      	ldrb	r3, [r7, #7]
  401dda:	b2db      	uxtb	r3, r3
  401ddc:	ea4f 0343 	mov.w	r3, r3, lsl #1
  401de0:	b2db      	uxtb	r3, r3
  401de2:	71fb      	strb	r3, [r7, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  401de4:	79fb      	ldrb	r3, [r7, #7]
  401de6:	b2db      	uxtb	r3, r3
  401de8:	b2db      	uxtb	r3, r3
  401dea:	b25b      	sxtb	r3, r3
  401dec:	2b00      	cmp	r3, #0
  401dee:	dbe7      	blt.n	401dc0 <xPortStartScheduler+0x4c>
			ucMaxPriorityValue <<= ( unsigned char ) 0x01;
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
  401df0:	f24a 43e0 	movw	r3, #42208	; 0xa4e0
  401df4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401df8:	681b      	ldr	r3, [r3, #0]
  401dfa:	ea4f 2203 	mov.w	r2, r3, lsl #8
  401dfe:	f24a 43e0 	movw	r3, #42208	; 0xa4e0
  401e02:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401e06:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
  401e08:	f24a 43e0 	movw	r3, #42208	; 0xa4e0
  401e0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401e10:	681b      	ldr	r3, [r3, #0]
  401e12:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  401e16:	f24a 43e0 	movw	r3, #42208	; 0xa4e0
  401e1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401e1e:	601a      	str	r2, [r3, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pcFirstUserPriorityRegister = ulOriginalPriority;
  401e20:	68bb      	ldr	r3, [r7, #8]
  401e22:	b2da      	uxtb	r2, r3
  401e24:	68fb      	ldr	r3, [r7, #12]
  401e26:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  401e28:	f64e 5320 	movw	r3, #60704	; 0xed20
  401e2c:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401e30:	f64e 5220 	movw	r2, #60704	; 0xed20
  401e34:	f2ce 0200 	movt	r2, #57344	; 0xe000
  401e38:	6812      	ldr	r2, [r2, #0]
  401e3a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
  401e3e:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  401e40:	f64e 5320 	movw	r3, #60704	; 0xed20
  401e44:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401e48:	f64e 5220 	movw	r2, #60704	; 0xed20
  401e4c:	f2ce 0200 	movt	r2, #57344	; 0xe000
  401e50:	6812      	ldr	r2, [r2, #0]
  401e52:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
  401e56:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
  401e58:	f641 73b5 	movw	r3, #8117	; 0x1fb5
  401e5c:	f2c0 0340 	movt	r3, #64	; 0x40
  401e60:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  401e62:	f240 0308 	movw	r3, #8
  401e66:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401e6a:	f04f 0200 	mov.w	r2, #0
  401e6e:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
  401e70:	f641 5361 	movw	r3, #7521	; 0x1d61
  401e74:	f2c0 0340 	movt	r3, #64	; 0x40
  401e78:	4798      	blx	r3

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
  401e7a:	f641 5315 	movw	r3, #7445	; 0x1d15
  401e7e:	f2c0 0340 	movt	r3, #64	; 0x40
  401e82:	4798      	blx	r3

	/* Should not get here! */
	return 0;
  401e84:	f04f 0300 	mov.w	r3, #0
}
  401e88:	4618      	mov	r0, r3
  401e8a:	f107 0710 	add.w	r7, r7, #16
  401e8e:	46bd      	mov	sp, r7
  401e90:	bd80      	pop	{r7, pc}
  401e92:	bf00      	nop

00401e94 <vPortYield>:
	is nothing to return to.  */
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
  401e94:	b480      	push	{r7}
  401e96:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  401e98:	f64e 5304 	movw	r3, #60676	; 0xed04
  401e9c:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401ea0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401ea4:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
  401ea6:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
  401eaa:	f3bf 8f6f 	isb	sy
}
  401eae:	46bd      	mov	sp, r7
  401eb0:	bc80      	pop	{r7}
  401eb2:	4770      	bx	lr

00401eb4 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
  401eb4:	b580      	push	{r7, lr}
  401eb6:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
  401eb8:	f641 7321 	movw	r3, #7969	; 0x1f21
  401ebc:	f2c0 0340 	movt	r3, #64	; 0x40
  401ec0:	4798      	blx	r3
	uxCriticalNesting++;
  401ec2:	f240 0308 	movw	r3, #8
  401ec6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401eca:	681b      	ldr	r3, [r3, #0]
  401ecc:	f103 0201 	add.w	r2, r3, #1
  401ed0:	f240 0308 	movw	r3, #8
  401ed4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401ed8:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" );
  401eda:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
  401ede:	f3bf 8f6f 	isb	sy
}
  401ee2:	bd80      	pop	{r7, pc}

00401ee4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
  401ee4:	b580      	push	{r7, lr}
  401ee6:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
  401ee8:	f240 0308 	movw	r3, #8
  401eec:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401ef0:	681b      	ldr	r3, [r3, #0]
  401ef2:	f103 32ff 	add.w	r2, r3, #4294967295
  401ef6:	f240 0308 	movw	r3, #8
  401efa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401efe:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
  401f00:	f240 0308 	movw	r3, #8
  401f04:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401f08:	681b      	ldr	r3, [r3, #0]
  401f0a:	2b00      	cmp	r3, #0
  401f0c:	d106      	bne.n	401f1c <vPortExitCritical+0x38>
	{
		portENABLE_INTERRUPTS();
  401f0e:	f04f 0000 	mov.w	r0, #0
  401f12:	f641 7335 	movw	r3, #7989	; 0x1f35
  401f16:	f2c0 0340 	movt	r3, #64	; 0x40
  401f1a:	4798      	blx	r3
	}
}
  401f1c:	bd80      	pop	{r7, pc}
  401f1e:	bf00      	nop

00401f20 <ulPortSetInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
  401f20:	f3ef 8011 	mrs	r0, BASEPRI
  401f24:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  401f28:	f381 8811 	msr	BASEPRI, r1
  401f2c:	4770      	bx	lr
		:: "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "r0", "r1"	\
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
  401f2e:	f04f 0300 	mov.w	r3, #0
}
  401f32:	4618      	mov	r0, r3

00401f34 <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
  401f34:	f380 8811 	msr	BASEPRI, r0
  401f38:	4770      	bx	lr
  401f3a:	bf00      	nop

00401f3c <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
  401f3c:	f3ef 8009 	mrs	r0, PSP
  401f40:	4b0c      	ldr	r3, [pc, #48]	; (401f74 <pxCurrentTCBConst>)
  401f42:	681a      	ldr	r2, [r3, #0]
  401f44:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  401f48:	6010      	str	r0, [r2, #0]
  401f4a:	e92d 4008 	stmdb	sp!, {r3, lr}
  401f4e:	f04f 00a0 	mov.w	r0, #160	; 0xa0
  401f52:	f380 8811 	msr	BASEPRI, r0
  401f56:	f001 fa41 	bl	4033dc <vTaskSwitchContext>
  401f5a:	f04f 0000 	mov.w	r0, #0
  401f5e:	f380 8811 	msr	BASEPRI, r0
  401f62:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  401f66:	6819      	ldr	r1, [r3, #0]
  401f68:	6808      	ldr	r0, [r1, #0]
  401f6a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  401f6e:	f380 8809 	msr	PSP, r0
  401f72:	4770      	bx	lr

00401f74 <pxCurrentTCBConst>:
  401f74:	2000a4e4 	.word	0x2000a4e4

00401f78 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
  401f78:	b580      	push	{r7, lr}
  401f7a:	af00      	add	r7, sp, #0
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
  401f7c:	f641 7321 	movw	r3, #7969	; 0x1f21
  401f80:	f2c0 0340 	movt	r3, #64	; 0x40
  401f84:	4798      	blx	r3
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
  401f86:	f243 1359 	movw	r3, #12633	; 0x3159
  401f8a:	f2c0 0340 	movt	r3, #64	; 0x40
  401f8e:	4798      	blx	r3
  401f90:	4603      	mov	r3, r0
  401f92:	2b00      	cmp	r3, #0
  401f94:	d006      	beq.n	401fa4 <SysTick_Handler+0x2c>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  401f96:	f64e 5304 	movw	r3, #60676	; 0xed04
  401f9a:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401f9e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401fa2:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
  401fa4:	f04f 0000 	mov.w	r0, #0
  401fa8:	f641 7335 	movw	r3, #7989	; 0x1f35
  401fac:	f2c0 0340 	movt	r3, #64	; 0x40
  401fb0:	4798      	blx	r3
}
  401fb2:	bd80      	pop	{r7, pc}

00401fb4 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
  401fb4:	b480      	push	{r7}
  401fb6:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
  401fb8:	f24e 0314 	movw	r3, #57364	; 0xe014
  401fbc:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401fc0:	f240 0204 	movw	r2, #4
  401fc4:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401fc8:	6811      	ldr	r1, [r2, #0]
  401fca:	f644 52d3 	movw	r2, #19923	; 0x4dd3
  401fce:	f2c1 0262 	movt	r2, #4194	; 0x1062
  401fd2:	fba2 0201 	umull	r0, r2, r2, r1
  401fd6:	ea4f 1292 	mov.w	r2, r2, lsr #6
  401fda:	f102 32ff 	add.w	r2, r2, #4294967295
  401fde:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
  401fe0:	f24e 0310 	movw	r3, #57360	; 0xe010
  401fe4:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401fe8:	f04f 0207 	mov.w	r2, #7
  401fec:	601a      	str	r2, [r3, #0]
}
  401fee:	46bd      	mov	sp, r7
  401ff0:	bc80      	pop	{r7}
  401ff2:	4770      	bx	lr

00401ff4 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
  401ff4:	b590      	push	{r4, r7, lr}
  401ff6:	b083      	sub	sp, #12
  401ff8:	af00      	add	r7, sp, #0
	unsigned long ulCurrentInterrupt;
	unsigned char ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
  401ffa:	f3ef 8405 	mrs	r4, IPSR
  401ffe:	607c      	str	r4, [r7, #4]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
  402000:	687b      	ldr	r3, [r7, #4]
  402002:	2b0f      	cmp	r3, #15
  402004:	d916      	bls.n	402034 <vPortValidateInterruptPriority+0x40>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
  402006:	f644 434c 	movw	r3, #19532	; 0x4c4c
  40200a:	f2c0 0340 	movt	r3, #64	; 0x40
  40200e:	681a      	ldr	r2, [r3, #0]
  402010:	687b      	ldr	r3, [r7, #4]
  402012:	18d3      	adds	r3, r2, r3
  402014:	781b      	ldrb	r3, [r3, #0]
  402016:	70fb      	strb	r3, [r7, #3]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
  402018:	f24a 43dc 	movw	r3, #42204	; 0xa4dc
  40201c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402020:	781b      	ldrb	r3, [r3, #0]
  402022:	78fa      	ldrb	r2, [r7, #3]
  402024:	429a      	cmp	r2, r3
  402026:	d205      	bcs.n	402034 <vPortValidateInterruptPriority+0x40>
  402028:	f641 7321 	movw	r3, #7969	; 0x1f21
  40202c:	f2c0 0340 	movt	r3, #64	; 0x40
  402030:	4798      	blx	r3
  402032:	e7fe      	b.n	402032 <vPortValidateInterruptPriority+0x3e>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
  402034:	f64e 530c 	movw	r3, #60684	; 0xed0c
  402038:	f2ce 0300 	movt	r3, #57344	; 0xe000
  40203c:	681b      	ldr	r3, [r3, #0]
  40203e:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  402042:	f24a 43e0 	movw	r3, #42208	; 0xa4e0
  402046:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40204a:	681b      	ldr	r3, [r3, #0]
  40204c:	429a      	cmp	r2, r3
  40204e:	d905      	bls.n	40205c <vPortValidateInterruptPriority+0x68>
  402050:	f641 7321 	movw	r3, #7969	; 0x1f21
  402054:	f2c0 0340 	movt	r3, #64	; 0x40
  402058:	4798      	blx	r3
  40205a:	e7fe      	b.n	40205a <vPortValidateInterruptPriority+0x66>
	}
  40205c:	f107 070c 	add.w	r7, r7, #12
  402060:	46bd      	mov	sp, r7
  402062:	bd90      	pop	{r4, r7, pc}

00402064 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
  402064:	b580      	push	{r7, lr}
  402066:	b084      	sub	sp, #16
  402068:	af00      	add	r7, sp, #0
  40206a:	6078      	str	r0, [r7, #4]
  40206c:	6039      	str	r1, [r7, #0]
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  40206e:	687b      	ldr	r3, [r7, #4]
  402070:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
  402072:	68fb      	ldr	r3, [r7, #12]
  402074:	2b00      	cmp	r3, #0
  402076:	d105      	bne.n	402084 <xQueueGenericReset+0x20>
  402078:	f641 7321 	movw	r3, #7969	; 0x1f21
  40207c:	f2c0 0340 	movt	r3, #64	; 0x40
  402080:	4798      	blx	r3
  402082:	e7fe      	b.n	402082 <xQueueGenericReset+0x1e>

	taskENTER_CRITICAL();
  402084:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  402088:	f2c0 0340 	movt	r3, #64	; 0x40
  40208c:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  40208e:	68fb      	ldr	r3, [r7, #12]
  402090:	681a      	ldr	r2, [r3, #0]
  402092:	68fb      	ldr	r3, [r7, #12]
  402094:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  402096:	68f9      	ldr	r1, [r7, #12]
  402098:	6c09      	ldr	r1, [r1, #64]	; 0x40
  40209a:	fb01 f303 	mul.w	r3, r1, r3
  40209e:	18d2      	adds	r2, r2, r3
  4020a0:	68fb      	ldr	r3, [r7, #12]
  4020a2:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  4020a4:	68fb      	ldr	r3, [r7, #12]
  4020a6:	f04f 0200 	mov.w	r2, #0
  4020aa:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  4020ac:	68fb      	ldr	r3, [r7, #12]
  4020ae:	681a      	ldr	r2, [r3, #0]
  4020b0:	68fb      	ldr	r3, [r7, #12]
  4020b2:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
  4020b4:	68fb      	ldr	r3, [r7, #12]
  4020b6:	681a      	ldr	r2, [r3, #0]
  4020b8:	68fb      	ldr	r3, [r7, #12]
  4020ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  4020bc:	f103 33ff 	add.w	r3, r3, #4294967295
  4020c0:	68f9      	ldr	r1, [r7, #12]
  4020c2:	6c09      	ldr	r1, [r1, #64]	; 0x40
  4020c4:	fb01 f303 	mul.w	r3, r1, r3
  4020c8:	18d2      	adds	r2, r2, r3
  4020ca:	68fb      	ldr	r3, [r7, #12]
  4020cc:	60da      	str	r2, [r3, #12]
		pxQueue->xRxLock = queueUNLOCKED;
  4020ce:	68fb      	ldr	r3, [r7, #12]
  4020d0:	f04f 32ff 	mov.w	r2, #4294967295
  4020d4:	645a      	str	r2, [r3, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
  4020d6:	68fb      	ldr	r3, [r7, #12]
  4020d8:	f04f 32ff 	mov.w	r2, #4294967295
  4020dc:	649a      	str	r2, [r3, #72]	; 0x48

		if( xNewQueue == pdFALSE )
  4020de:	683b      	ldr	r3, [r7, #0]
  4020e0:	2b00      	cmp	r3, #0
  4020e2:	d115      	bne.n	402110 <xQueueGenericReset+0xac>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4020e4:	68fb      	ldr	r3, [r7, #12]
  4020e6:	691b      	ldr	r3, [r3, #16]
  4020e8:	2b00      	cmp	r3, #0
  4020ea:	d023      	beq.n	402134 <xQueueGenericReset+0xd0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  4020ec:	68fb      	ldr	r3, [r7, #12]
  4020ee:	f103 0310 	add.w	r3, r3, #16
  4020f2:	4618      	mov	r0, r3
  4020f4:	f243 63c1 	movw	r3, #14017	; 0x36c1
  4020f8:	f2c0 0340 	movt	r3, #64	; 0x40
  4020fc:	4798      	blx	r3
  4020fe:	4603      	mov	r3, r0
  402100:	2b01      	cmp	r3, #1
  402102:	d117      	bne.n	402134 <xQueueGenericReset+0xd0>
				{
					queueYIELD_IF_USING_PREEMPTION();
  402104:	f641 6395 	movw	r3, #7829	; 0x1e95
  402108:	f2c0 0340 	movt	r3, #64	; 0x40
  40210c:	4798      	blx	r3
  40210e:	e011      	b.n	402134 <xQueueGenericReset+0xd0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  402110:	68fb      	ldr	r3, [r7, #12]
  402112:	f103 0310 	add.w	r3, r3, #16
  402116:	4618      	mov	r0, r3
  402118:	f641 3341 	movw	r3, #6977	; 0x1b41
  40211c:	f2c0 0340 	movt	r3, #64	; 0x40
  402120:	4798      	blx	r3
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  402122:	68fb      	ldr	r3, [r7, #12]
  402124:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402128:	4618      	mov	r0, r3
  40212a:	f641 3341 	movw	r3, #6977	; 0x1b41
  40212e:	f2c0 0340 	movt	r3, #64	; 0x40
  402132:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
  402134:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  402138:	f2c0 0340 	movt	r3, #64	; 0x40
  40213c:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
  40213e:	f04f 0301 	mov.w	r3, #1
}
  402142:	4618      	mov	r0, r3
  402144:	f107 0710 	add.w	r7, r7, #16
  402148:	46bd      	mov	sp, r7
  40214a:	bd80      	pop	{r7, pc}

0040214c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
  40214c:	b580      	push	{r7, lr}
  40214e:	b088      	sub	sp, #32
  402150:	af00      	add	r7, sp, #0
  402152:	60f8      	str	r0, [r7, #12]
  402154:	60b9      	str	r1, [r7, #8]
  402156:	4613      	mov	r3, r2
  402158:	71fb      	strb	r3, [r7, #7]
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
  40215a:	f04f 0300 	mov.w	r3, #0
  40215e:	61fb      	str	r3, [r7, #28]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  402160:	68fb      	ldr	r3, [r7, #12]
  402162:	2b00      	cmp	r3, #0
  402164:	d039      	beq.n	4021da <xQueueGenericCreate+0x8e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  402166:	f04f 0050 	mov.w	r0, #80	; 0x50
  40216a:	f240 5311 	movw	r3, #1297	; 0x511
  40216e:	f2c0 0340 	movt	r3, #64	; 0x40
  402172:	4798      	blx	r3
  402174:	61b8      	str	r0, [r7, #24]
		if( pxNewQueue != NULL )
  402176:	69bb      	ldr	r3, [r7, #24]
  402178:	2b00      	cmp	r3, #0
  40217a:	d02e      	beq.n	4021da <xQueueGenericCreate+0x8e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  40217c:	68fb      	ldr	r3, [r7, #12]
  40217e:	68ba      	ldr	r2, [r7, #8]
  402180:	fb02 f303 	mul.w	r3, r2, r3
  402184:	f103 0301 	add.w	r3, r3, #1
  402188:	617b      	str	r3, [r7, #20]

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  40218a:	6978      	ldr	r0, [r7, #20]
  40218c:	f240 5311 	movw	r3, #1297	; 0x511
  402190:	f2c0 0340 	movt	r3, #64	; 0x40
  402194:	4798      	blx	r3
  402196:	4602      	mov	r2, r0
  402198:	69bb      	ldr	r3, [r7, #24]
  40219a:	601a      	str	r2, [r3, #0]
			if( pxNewQueue->pcHead != NULL )
  40219c:	69bb      	ldr	r3, [r7, #24]
  40219e:	681b      	ldr	r3, [r3, #0]
  4021a0:	2b00      	cmp	r3, #0
  4021a2:	d014      	beq.n	4021ce <xQueueGenericCreate+0x82>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
  4021a4:	69bb      	ldr	r3, [r7, #24]
  4021a6:	68fa      	ldr	r2, [r7, #12]
  4021a8:	63da      	str	r2, [r3, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
  4021aa:	69bb      	ldr	r3, [r7, #24]
  4021ac:	68ba      	ldr	r2, [r7, #8]
  4021ae:	641a      	str	r2, [r3, #64]	; 0x40
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  4021b0:	69b8      	ldr	r0, [r7, #24]
  4021b2:	f04f 0101 	mov.w	r1, #1
  4021b6:	f242 0365 	movw	r3, #8293	; 0x2065
  4021ba:	f2c0 0340 	movt	r3, #64	; 0x40
  4021be:	4798      	blx	r3
				}
				#endif /* configUSE_TRACE_FACILITY */

				#if( configUSE_QUEUE_SETS == 1 )
				{
					pxNewQueue->pxQueueSetContainer = NULL;
  4021c0:	69bb      	ldr	r3, [r7, #24]
  4021c2:	f04f 0200 	mov.w	r2, #0
  4021c6:	64da      	str	r2, [r3, #76]	; 0x4c
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
  4021c8:	69bb      	ldr	r3, [r7, #24]
  4021ca:	61fb      	str	r3, [r7, #28]
  4021cc:	e005      	b.n	4021da <xQueueGenericCreate+0x8e>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
  4021ce:	69b8      	ldr	r0, [r7, #24]
  4021d0:	f240 6391 	movw	r3, #1681	; 0x691
  4021d4:	f2c0 0340 	movt	r3, #64	; 0x40
  4021d8:	4798      	blx	r3
			}
		}
	}

	configASSERT( xReturn );
  4021da:	69fb      	ldr	r3, [r7, #28]
  4021dc:	2b00      	cmp	r3, #0
  4021de:	d105      	bne.n	4021ec <xQueueGenericCreate+0xa0>
  4021e0:	f641 7321 	movw	r3, #7969	; 0x1f21
  4021e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4021e8:	4798      	blx	r3
  4021ea:	e7fe      	b.n	4021ea <xQueueGenericCreate+0x9e>

	return xReturn;
  4021ec:	69fb      	ldr	r3, [r7, #28]
}
  4021ee:	4618      	mov	r0, r3
  4021f0:	f107 0720 	add.w	r7, r7, #32
  4021f4:	46bd      	mov	sp, r7
  4021f6:	bd80      	pop	{r7, pc}

004021f8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  4021f8:	b580      	push	{r7, lr}
  4021fa:	b088      	sub	sp, #32
  4021fc:	af00      	add	r7, sp, #0
  4021fe:	60f8      	str	r0, [r7, #12]
  402200:	60b9      	str	r1, [r7, #8]
  402202:	607a      	str	r2, [r7, #4]
  402204:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  402206:	f04f 0300 	mov.w	r3, #0
  40220a:	61fb      	str	r3, [r7, #28]
xTimeOutType xTimeOut;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  40220c:	68fb      	ldr	r3, [r7, #12]
  40220e:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
  402210:	69bb      	ldr	r3, [r7, #24]
  402212:	2b00      	cmp	r3, #0
  402214:	d105      	bne.n	402222 <xQueueGenericSend+0x2a>
  402216:	f641 7321 	movw	r3, #7969	; 0x1f21
  40221a:	f2c0 0340 	movt	r3, #64	; 0x40
  40221e:	4798      	blx	r3
  402220:	e7fe      	b.n	402220 <xQueueGenericSend+0x28>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  402222:	68bb      	ldr	r3, [r7, #8]
  402224:	2b00      	cmp	r3, #0
  402226:	d103      	bne.n	402230 <xQueueGenericSend+0x38>
  402228:	69bb      	ldr	r3, [r7, #24]
  40222a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40222c:	2b00      	cmp	r3, #0
  40222e:	d102      	bne.n	402236 <xQueueGenericSend+0x3e>
  402230:	f04f 0301 	mov.w	r3, #1
  402234:	e001      	b.n	40223a <xQueueGenericSend+0x42>
  402236:	f04f 0300 	mov.w	r3, #0
  40223a:	2b00      	cmp	r3, #0
  40223c:	d105      	bne.n	40224a <xQueueGenericSend+0x52>
  40223e:	f641 7321 	movw	r3, #7969	; 0x1f21
  402242:	f2c0 0340 	movt	r3, #64	; 0x40
  402246:	4798      	blx	r3
  402248:	e7fe      	b.n	402248 <xQueueGenericSend+0x50>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  40224a:	683b      	ldr	r3, [r7, #0]
  40224c:	2b02      	cmp	r3, #2
  40224e:	d103      	bne.n	402258 <xQueueGenericSend+0x60>
  402250:	69bb      	ldr	r3, [r7, #24]
  402252:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  402254:	2b01      	cmp	r3, #1
  402256:	d102      	bne.n	40225e <xQueueGenericSend+0x66>
  402258:	f04f 0301 	mov.w	r3, #1
  40225c:	e001      	b.n	402262 <xQueueGenericSend+0x6a>
  40225e:	f04f 0300 	mov.w	r3, #0
  402262:	2b00      	cmp	r3, #0
  402264:	d106      	bne.n	402274 <xQueueGenericSend+0x7c>
  402266:	f641 7321 	movw	r3, #7969	; 0x1f21
  40226a:	f2c0 0340 	movt	r3, #64	; 0x40
  40226e:	4798      	blx	r3
  402270:	e7fe      	b.n	402270 <xQueueGenericSend+0x78>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
  402272:	bf00      	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  402274:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  402278:	f2c0 0340 	movt	r3, #64	; 0x40
  40227c:	4798      	blx	r3
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  40227e:	69bb      	ldr	r3, [r7, #24]
  402280:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  402282:	69bb      	ldr	r3, [r7, #24]
  402284:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  402286:	429a      	cmp	r2, r3
  402288:	d302      	bcc.n	402290 <xQueueGenericSend+0x98>
  40228a:	683b      	ldr	r3, [r7, #0]
  40228c:	2b02      	cmp	r3, #2
  40228e:	d138      	bne.n	402302 <xQueueGenericSend+0x10a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  402290:	69b8      	ldr	r0, [r7, #24]
  402292:	68b9      	ldr	r1, [r7, #8]
  402294:	683a      	ldr	r2, [r7, #0]
  402296:	f242 73d5 	movw	r3, #10197	; 0x27d5
  40229a:	f2c0 0340 	movt	r3, #64	; 0x40
  40229e:	4798      	blx	r3

				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
  4022a0:	69bb      	ldr	r3, [r7, #24]
  4022a2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  4022a4:	2b00      	cmp	r3, #0
  4022a6:	d00f      	beq.n	4022c8 <xQueueGenericSend+0xd0>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
  4022a8:	69b8      	ldr	r0, [r7, #24]
  4022aa:	6839      	ldr	r1, [r7, #0]
  4022ac:	f642 3311 	movw	r3, #11025	; 0x2b11
  4022b0:	f2c0 0340 	movt	r3, #64	; 0x40
  4022b4:	4798      	blx	r3
  4022b6:	4603      	mov	r3, r0
  4022b8:	2b01      	cmp	r3, #1
  4022ba:	d11a      	bne.n	4022f2 <xQueueGenericSend+0xfa>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock. A context switch is required. */
							queueYIELD_IF_USING_PREEMPTION();
  4022bc:	f641 6395 	movw	r3, #7829	; 0x1e95
  4022c0:	f2c0 0340 	movt	r3, #64	; 0x40
  4022c4:	4798      	blx	r3
  4022c6:	e014      	b.n	4022f2 <xQueueGenericSend+0xfa>
					}
					else
					{
						/* If there was a task waiting for data to arrive on the
						queue then unblock it now. */
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4022c8:	69bb      	ldr	r3, [r7, #24]
  4022ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4022cc:	2b00      	cmp	r3, #0
  4022ce:	d010      	beq.n	4022f2 <xQueueGenericSend+0xfa>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
  4022d0:	69bb      	ldr	r3, [r7, #24]
  4022d2:	f103 0324 	add.w	r3, r3, #36	; 0x24
  4022d6:	4618      	mov	r0, r3
  4022d8:	f243 63c1 	movw	r3, #14017	; 0x36c1
  4022dc:	f2c0 0340 	movt	r3, #64	; 0x40
  4022e0:	4798      	blx	r3
  4022e2:	4603      	mov	r3, r0
  4022e4:	2b01      	cmp	r3, #1
  4022e6:	d104      	bne.n	4022f2 <xQueueGenericSend+0xfa>
							{
								/* The unblocked task has a priority higher than
								our own so yield immediately.  Yes it is ok to
								do this from within the critical section - the
								kernel takes care of that. */
								queueYIELD_IF_USING_PREEMPTION();
  4022e8:	f641 6395 	movw	r3, #7829	; 0x1e95
  4022ec:	f2c0 0340 	movt	r3, #64	; 0x40
  4022f0:	4798      	blx	r3
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
  4022f2:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  4022f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4022fa:	4798      	blx	r3

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
  4022fc:	f04f 0301 	mov.w	r3, #1
  402300:	e08e      	b.n	402420 <xQueueGenericSend+0x228>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  402302:	687b      	ldr	r3, [r7, #4]
  402304:	2b00      	cmp	r3, #0
  402306:	d107      	bne.n	402318 <xQueueGenericSend+0x120>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  402308:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  40230c:	f2c0 0340 	movt	r3, #64	; 0x40
  402310:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  402312:	f04f 0300 	mov.w	r3, #0
  402316:	e083      	b.n	402420 <xQueueGenericSend+0x228>
				}
				else if( xEntryTimeSet == pdFALSE )
  402318:	69fb      	ldr	r3, [r7, #28]
  40231a:	2b00      	cmp	r3, #0
  40231c:	d10a      	bne.n	402334 <xQueueGenericSend+0x13c>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  40231e:	f107 0310 	add.w	r3, r7, #16
  402322:	4618      	mov	r0, r3
  402324:	f243 73bd 	movw	r3, #14269	; 0x37bd
  402328:	f2c0 0340 	movt	r3, #64	; 0x40
  40232c:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  40232e:	f04f 0301 	mov.w	r3, #1
  402332:	61fb      	str	r3, [r7, #28]
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
  402334:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  402338:	f2c0 0340 	movt	r3, #64	; 0x40
  40233c:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  40233e:	f642 735d 	movw	r3, #12125	; 0x2f5d
  402342:	f2c0 0340 	movt	r3, #64	; 0x40
  402346:	4798      	blx	r3
		prvLockQueue( pxQueue );
  402348:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  40234c:	f2c0 0340 	movt	r3, #64	; 0x40
  402350:	4798      	blx	r3
  402352:	69bb      	ldr	r3, [r7, #24]
  402354:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  402356:	f1b3 3fff 	cmp.w	r3, #4294967295
  40235a:	d103      	bne.n	402364 <xQueueGenericSend+0x16c>
  40235c:	69bb      	ldr	r3, [r7, #24]
  40235e:	f04f 0200 	mov.w	r2, #0
  402362:	645a      	str	r2, [r3, #68]	; 0x44
  402364:	69bb      	ldr	r3, [r7, #24]
  402366:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  402368:	f1b3 3fff 	cmp.w	r3, #4294967295
  40236c:	d103      	bne.n	402376 <xQueueGenericSend+0x17e>
  40236e:	69bb      	ldr	r3, [r7, #24]
  402370:	f04f 0200 	mov.w	r2, #0
  402374:	649a      	str	r2, [r3, #72]	; 0x48
  402376:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  40237a:	f2c0 0340 	movt	r3, #64	; 0x40
  40237e:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  402380:	f107 0210 	add.w	r2, r7, #16
  402384:	f107 0304 	add.w	r3, r7, #4
  402388:	4610      	mov	r0, r2
  40238a:	4619      	mov	r1, r3
  40238c:	f243 73fd 	movw	r3, #14333	; 0x37fd
  402390:	f2c0 0340 	movt	r3, #64	; 0x40
  402394:	4798      	blx	r3
  402396:	4603      	mov	r3, r0
  402398:	2b00      	cmp	r3, #0
  40239a:	d134      	bne.n	402406 <xQueueGenericSend+0x20e>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  40239c:	69b8      	ldr	r0, [r7, #24]
  40239e:	f642 2355 	movw	r3, #10837	; 0x2a55
  4023a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4023a6:	4798      	blx	r3
  4023a8:	4603      	mov	r3, r0
  4023aa:	2b00      	cmp	r3, #0
  4023ac:	d01f      	beq.n	4023ee <xQueueGenericSend+0x1f6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  4023ae:	69bb      	ldr	r3, [r7, #24]
  4023b0:	f103 0210 	add.w	r2, r3, #16
  4023b4:	687b      	ldr	r3, [r7, #4]
  4023b6:	4610      	mov	r0, r2
  4023b8:	4619      	mov	r1, r3
  4023ba:	f243 533d 	movw	r3, #13629	; 0x353d
  4023be:	f2c0 0340 	movt	r3, #64	; 0x40
  4023c2:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  4023c4:	69b8      	ldr	r0, [r7, #24]
  4023c6:	f642 1319 	movw	r3, #10521	; 0x2919
  4023ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4023ce:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  4023d0:	f642 7381 	movw	r3, #12161	; 0x2f81
  4023d4:	f2c0 0340 	movt	r3, #64	; 0x40
  4023d8:	4798      	blx	r3
  4023da:	4603      	mov	r3, r0
  4023dc:	2b00      	cmp	r3, #0
  4023de:	f47f af48 	bne.w	402272 <xQueueGenericSend+0x7a>
				{
					portYIELD_WITHIN_API();
  4023e2:	f641 6395 	movw	r3, #7829	; 0x1e95
  4023e6:	f2c0 0340 	movt	r3, #64	; 0x40
  4023ea:	4798      	blx	r3
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
  4023ec:	e741      	b.n	402272 <xQueueGenericSend+0x7a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  4023ee:	69b8      	ldr	r0, [r7, #24]
  4023f0:	f642 1319 	movw	r3, #10521	; 0x2919
  4023f4:	f2c0 0340 	movt	r3, #64	; 0x40
  4023f8:	4798      	blx	r3
				( void ) xTaskResumeAll();
  4023fa:	f642 7381 	movw	r3, #12161	; 0x2f81
  4023fe:	f2c0 0340 	movt	r3, #64	; 0x40
  402402:	4798      	blx	r3
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
  402404:	e735      	b.n	402272 <xQueueGenericSend+0x7a>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  402406:	69b8      	ldr	r0, [r7, #24]
  402408:	f642 1319 	movw	r3, #10521	; 0x2919
  40240c:	f2c0 0340 	movt	r3, #64	; 0x40
  402410:	4798      	blx	r3
			( void ) xTaskResumeAll();
  402412:	f642 7381 	movw	r3, #12161	; 0x2f81
  402416:	f2c0 0340 	movt	r3, #64	; 0x40
  40241a:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  40241c:	f04f 0300 	mov.w	r3, #0
		}
	}
}
  402420:	4618      	mov	r0, r3
  402422:	f107 0720 	add.w	r7, r7, #32
  402426:	46bd      	mov	sp, r7
  402428:	bd80      	pop	{r7, pc}
  40242a:	bf00      	nop

0040242c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
  40242c:	b580      	push	{r7, lr}
  40242e:	b088      	sub	sp, #32
  402430:	af00      	add	r7, sp, #0
  402432:	60f8      	str	r0, [r7, #12]
  402434:	60b9      	str	r1, [r7, #8]
  402436:	607a      	str	r2, [r7, #4]
  402438:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  40243a:	68fb      	ldr	r3, [r7, #12]
  40243c:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
  40243e:	69bb      	ldr	r3, [r7, #24]
  402440:	2b00      	cmp	r3, #0
  402442:	d105      	bne.n	402450 <xQueueGenericSendFromISR+0x24>
  402444:	f641 7321 	movw	r3, #7969	; 0x1f21
  402448:	f2c0 0340 	movt	r3, #64	; 0x40
  40244c:	4798      	blx	r3
  40244e:	e7fe      	b.n	40244e <xQueueGenericSendFromISR+0x22>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  402450:	68bb      	ldr	r3, [r7, #8]
  402452:	2b00      	cmp	r3, #0
  402454:	d103      	bne.n	40245e <xQueueGenericSendFromISR+0x32>
  402456:	69bb      	ldr	r3, [r7, #24]
  402458:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40245a:	2b00      	cmp	r3, #0
  40245c:	d102      	bne.n	402464 <xQueueGenericSendFromISR+0x38>
  40245e:	f04f 0301 	mov.w	r3, #1
  402462:	e001      	b.n	402468 <xQueueGenericSendFromISR+0x3c>
  402464:	f04f 0300 	mov.w	r3, #0
  402468:	2b00      	cmp	r3, #0
  40246a:	d105      	bne.n	402478 <xQueueGenericSendFromISR+0x4c>
  40246c:	f641 7321 	movw	r3, #7969	; 0x1f21
  402470:	f2c0 0340 	movt	r3, #64	; 0x40
  402474:	4798      	blx	r3
  402476:	e7fe      	b.n	402476 <xQueueGenericSendFromISR+0x4a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  402478:	683b      	ldr	r3, [r7, #0]
  40247a:	2b02      	cmp	r3, #2
  40247c:	d103      	bne.n	402486 <xQueueGenericSendFromISR+0x5a>
  40247e:	69bb      	ldr	r3, [r7, #24]
  402480:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  402482:	2b01      	cmp	r3, #1
  402484:	d102      	bne.n	40248c <xQueueGenericSendFromISR+0x60>
  402486:	f04f 0301 	mov.w	r3, #1
  40248a:	e001      	b.n	402490 <xQueueGenericSendFromISR+0x64>
  40248c:	f04f 0300 	mov.w	r3, #0
  402490:	2b00      	cmp	r3, #0
  402492:	d105      	bne.n	4024a0 <xQueueGenericSendFromISR+0x74>
  402494:	f641 7321 	movw	r3, #7969	; 0x1f21
  402498:	f2c0 0340 	movt	r3, #64	; 0x40
  40249c:	4798      	blx	r3
  40249e:	e7fe      	b.n	40249e <xQueueGenericSendFromISR+0x72>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  4024a0:	f641 73f5 	movw	r3, #8181	; 0x1ff5
  4024a4:	f2c0 0340 	movt	r3, #64	; 0x40
  4024a8:	4798      	blx	r3
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  4024aa:	f641 7321 	movw	r3, #7969	; 0x1f21
  4024ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4024b2:	4798      	blx	r3
  4024b4:	6178      	str	r0, [r7, #20]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  4024b6:	69bb      	ldr	r3, [r7, #24]
  4024b8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  4024ba:	69bb      	ldr	r3, [r7, #24]
  4024bc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  4024be:	429a      	cmp	r2, r3
  4024c0:	d302      	bcc.n	4024c8 <xQueueGenericSendFromISR+0x9c>
  4024c2:	683b      	ldr	r3, [r7, #0]
  4024c4:	2b02      	cmp	r3, #2
  4024c6:	d144      	bne.n	402552 <xQueueGenericSendFromISR+0x126>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  4024c8:	69b8      	ldr	r0, [r7, #24]
  4024ca:	68b9      	ldr	r1, [r7, #8]
  4024cc:	683a      	ldr	r2, [r7, #0]
  4024ce:	f242 73d5 	movw	r3, #10197	; 0x27d5
  4024d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4024d6:	4798      	blx	r3

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
  4024d8:	69bb      	ldr	r3, [r7, #24]
  4024da:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  4024dc:	f1b3 3fff 	cmp.w	r3, #4294967295
  4024e0:	d12d      	bne.n	40253e <xQueueGenericSendFromISR+0x112>
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
  4024e2:	69bb      	ldr	r3, [r7, #24]
  4024e4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  4024e6:	2b00      	cmp	r3, #0
  4024e8:	d011      	beq.n	40250e <xQueueGenericSendFromISR+0xe2>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
  4024ea:	69b8      	ldr	r0, [r7, #24]
  4024ec:	6839      	ldr	r1, [r7, #0]
  4024ee:	f642 3311 	movw	r3, #11025	; 0x2b11
  4024f2:	f2c0 0340 	movt	r3, #64	; 0x40
  4024f6:	4798      	blx	r3
  4024f8:	4603      	mov	r3, r0
  4024fa:	2b01      	cmp	r3, #1
  4024fc:	d125      	bne.n	40254a <xQueueGenericSendFromISR+0x11e>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  4024fe:	687b      	ldr	r3, [r7, #4]
  402500:	2b00      	cmp	r3, #0
  402502:	d022      	beq.n	40254a <xQueueGenericSendFromISR+0x11e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  402504:	687b      	ldr	r3, [r7, #4]
  402506:	f04f 0201 	mov.w	r2, #1
  40250a:	601a      	str	r2, [r3, #0]
  40250c:	e01d      	b.n	40254a <xQueueGenericSendFromISR+0x11e>
							}
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  40250e:	69bb      	ldr	r3, [r7, #24]
  402510:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  402512:	2b00      	cmp	r3, #0
  402514:	d019      	beq.n	40254a <xQueueGenericSendFromISR+0x11e>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  402516:	69bb      	ldr	r3, [r7, #24]
  402518:	f103 0324 	add.w	r3, r3, #36	; 0x24
  40251c:	4618      	mov	r0, r3
  40251e:	f243 63c1 	movw	r3, #14017	; 0x36c1
  402522:	f2c0 0340 	movt	r3, #64	; 0x40
  402526:	4798      	blx	r3
  402528:	4603      	mov	r3, r0
  40252a:	2b00      	cmp	r3, #0
  40252c:	d00d      	beq.n	40254a <xQueueGenericSendFromISR+0x11e>
							{
								/* The task waiting has a higher priority so record that a
								context	switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
  40252e:	687b      	ldr	r3, [r7, #4]
  402530:	2b00      	cmp	r3, #0
  402532:	d00a      	beq.n	40254a <xQueueGenericSendFromISR+0x11e>
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
  402534:	687b      	ldr	r3, [r7, #4]
  402536:	f04f 0201 	mov.w	r2, #1
  40253a:	601a      	str	r2, [r3, #0]
  40253c:	e005      	b.n	40254a <xQueueGenericSendFromISR+0x11e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
  40253e:	69bb      	ldr	r3, [r7, #24]
  402540:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  402542:	f103 0201 	add.w	r2, r3, #1
  402546:	69bb      	ldr	r3, [r7, #24]
  402548:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
  40254a:	f04f 0301 	mov.w	r3, #1
  40254e:	61fb      	str	r3, [r7, #28]
  402550:	e002      	b.n	402558 <xQueueGenericSendFromISR+0x12c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  402552:	f04f 0300 	mov.w	r3, #0
  402556:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  402558:	6978      	ldr	r0, [r7, #20]
  40255a:	f641 7335 	movw	r3, #7989	; 0x1f35
  40255e:	f2c0 0340 	movt	r3, #64	; 0x40
  402562:	4798      	blx	r3

	return xReturn;
  402564:	69fb      	ldr	r3, [r7, #28]
}
  402566:	4618      	mov	r0, r3
  402568:	f107 0720 	add.w	r7, r7, #32
  40256c:	46bd      	mov	sp, r7
  40256e:	bd80      	pop	{r7, pc}

00402570 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  402570:	b580      	push	{r7, lr}
  402572:	b08a      	sub	sp, #40	; 0x28
  402574:	af00      	add	r7, sp, #0
  402576:	60f8      	str	r0, [r7, #12]
  402578:	60b9      	str	r1, [r7, #8]
  40257a:	607a      	str	r2, [r7, #4]
  40257c:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  40257e:	f04f 0300 	mov.w	r3, #0
  402582:	627b      	str	r3, [r7, #36]	; 0x24
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  402584:	68fb      	ldr	r3, [r7, #12]
  402586:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
  402588:	6a3b      	ldr	r3, [r7, #32]
  40258a:	2b00      	cmp	r3, #0
  40258c:	d105      	bne.n	40259a <xQueueGenericReceive+0x2a>
  40258e:	f641 7321 	movw	r3, #7969	; 0x1f21
  402592:	f2c0 0340 	movt	r3, #64	; 0x40
  402596:	4798      	blx	r3
  402598:	e7fe      	b.n	402598 <xQueueGenericReceive+0x28>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  40259a:	68bb      	ldr	r3, [r7, #8]
  40259c:	2b00      	cmp	r3, #0
  40259e:	d103      	bne.n	4025a8 <xQueueGenericReceive+0x38>
  4025a0:	6a3b      	ldr	r3, [r7, #32]
  4025a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4025a4:	2b00      	cmp	r3, #0
  4025a6:	d102      	bne.n	4025ae <xQueueGenericReceive+0x3e>
  4025a8:	f04f 0301 	mov.w	r3, #1
  4025ac:	e001      	b.n	4025b2 <xQueueGenericReceive+0x42>
  4025ae:	f04f 0300 	mov.w	r3, #0
  4025b2:	2b00      	cmp	r3, #0
  4025b4:	d106      	bne.n	4025c4 <xQueueGenericReceive+0x54>
  4025b6:	f641 7321 	movw	r3, #7969	; 0x1f21
  4025ba:	f2c0 0340 	movt	r3, #64	; 0x40
  4025be:	4798      	blx	r3
  4025c0:	e7fe      	b.n	4025c0 <xQueueGenericReceive+0x50>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
  4025c2:	bf00      	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  4025c4:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  4025c8:	f2c0 0340 	movt	r3, #64	; 0x40
  4025cc:	4798      	blx	r3
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  4025ce:	6a3b      	ldr	r3, [r7, #32]
  4025d0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  4025d2:	2b00      	cmp	r3, #0
  4025d4:	d054      	beq.n	402680 <xQueueGenericReceive+0x110>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
  4025d6:	6a3b      	ldr	r3, [r7, #32]
  4025d8:	68db      	ldr	r3, [r3, #12]
  4025da:	61fb      	str	r3, [r7, #28]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  4025dc:	6a38      	ldr	r0, [r7, #32]
  4025de:	68b9      	ldr	r1, [r7, #8]
  4025e0:	f642 03c5 	movw	r3, #10437	; 0x28c5
  4025e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4025e8:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
  4025ea:	683b      	ldr	r3, [r7, #0]
  4025ec:	2b00      	cmp	r3, #0
  4025ee:	d127      	bne.n	402640 <xQueueGenericReceive+0xd0>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
  4025f0:	6a3b      	ldr	r3, [r7, #32]
  4025f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  4025f4:	f103 32ff 	add.w	r2, r3, #4294967295
  4025f8:	6a3b      	ldr	r3, [r7, #32]
  4025fa:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4025fc:	6a3b      	ldr	r3, [r7, #32]
  4025fe:	681b      	ldr	r3, [r3, #0]
  402600:	2b00      	cmp	r3, #0
  402602:	d107      	bne.n	402614 <xQueueGenericReceive+0xa4>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
  402604:	f643 4391 	movw	r3, #15505	; 0x3c91
  402608:	f2c0 0340 	movt	r3, #64	; 0x40
  40260c:	4798      	blx	r3
  40260e:	4602      	mov	r2, r0
  402610:	6a3b      	ldr	r3, [r7, #32]
  402612:	605a      	str	r2, [r3, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  402614:	6a3b      	ldr	r3, [r7, #32]
  402616:	691b      	ldr	r3, [r3, #16]
  402618:	2b00      	cmp	r3, #0
  40261a:	d029      	beq.n	402670 <xQueueGenericReceive+0x100>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  40261c:	6a3b      	ldr	r3, [r7, #32]
  40261e:	f103 0310 	add.w	r3, r3, #16
  402622:	4618      	mov	r0, r3
  402624:	f243 63c1 	movw	r3, #14017	; 0x36c1
  402628:	f2c0 0340 	movt	r3, #64	; 0x40
  40262c:	4798      	blx	r3
  40262e:	4603      	mov	r3, r0
  402630:	2b01      	cmp	r3, #1
  402632:	d11d      	bne.n	402670 <xQueueGenericReceive+0x100>
						{
							queueYIELD_IF_USING_PREEMPTION();
  402634:	f641 6395 	movw	r3, #7829	; 0x1e95
  402638:	f2c0 0340 	movt	r3, #64	; 0x40
  40263c:	4798      	blx	r3
  40263e:	e017      	b.n	402670 <xQueueGenericReceive+0x100>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
  402640:	6a3b      	ldr	r3, [r7, #32]
  402642:	69fa      	ldr	r2, [r7, #28]
  402644:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  402646:	6a3b      	ldr	r3, [r7, #32]
  402648:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40264a:	2b00      	cmp	r3, #0
  40264c:	d010      	beq.n	402670 <xQueueGenericReceive+0x100>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  40264e:	6a3b      	ldr	r3, [r7, #32]
  402650:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402654:	4618      	mov	r0, r3
  402656:	f243 63c1 	movw	r3, #14017	; 0x36c1
  40265a:	f2c0 0340 	movt	r3, #64	; 0x40
  40265e:	4798      	blx	r3
  402660:	4603      	mov	r3, r0
  402662:	2b00      	cmp	r3, #0
  402664:	d004      	beq.n	402670 <xQueueGenericReceive+0x100>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
  402666:	f641 6395 	movw	r3, #7829	; 0x1e95
  40266a:	f2c0 0340 	movt	r3, #64	; 0x40
  40266e:	4798      	blx	r3
						}
					}
				}

				taskEXIT_CRITICAL();
  402670:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  402674:	f2c0 0340 	movt	r3, #64	; 0x40
  402678:	4798      	blx	r3
				return pdPASS;
  40267a:	f04f 0301 	mov.w	r3, #1
  40267e:	e0a4      	b.n	4027ca <xQueueGenericReceive+0x25a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  402680:	687b      	ldr	r3, [r7, #4]
  402682:	2b00      	cmp	r3, #0
  402684:	d107      	bne.n	402696 <xQueueGenericReceive+0x126>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  402686:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  40268a:	f2c0 0340 	movt	r3, #64	; 0x40
  40268e:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  402690:	f04f 0300 	mov.w	r3, #0
  402694:	e099      	b.n	4027ca <xQueueGenericReceive+0x25a>
				}
				else if( xEntryTimeSet == pdFALSE )
  402696:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402698:	2b00      	cmp	r3, #0
  40269a:	d10a      	bne.n	4026b2 <xQueueGenericReceive+0x142>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  40269c:	f107 0314 	add.w	r3, r7, #20
  4026a0:	4618      	mov	r0, r3
  4026a2:	f243 73bd 	movw	r3, #14269	; 0x37bd
  4026a6:	f2c0 0340 	movt	r3, #64	; 0x40
  4026aa:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  4026ac:	f04f 0301 	mov.w	r3, #1
  4026b0:	627b      	str	r3, [r7, #36]	; 0x24
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
  4026b2:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  4026b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4026ba:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  4026bc:	f642 735d 	movw	r3, #12125	; 0x2f5d
  4026c0:	f2c0 0340 	movt	r3, #64	; 0x40
  4026c4:	4798      	blx	r3
		prvLockQueue( pxQueue );
  4026c6:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  4026ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4026ce:	4798      	blx	r3
  4026d0:	6a3b      	ldr	r3, [r7, #32]
  4026d2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  4026d4:	f1b3 3fff 	cmp.w	r3, #4294967295
  4026d8:	d103      	bne.n	4026e2 <xQueueGenericReceive+0x172>
  4026da:	6a3b      	ldr	r3, [r7, #32]
  4026dc:	f04f 0200 	mov.w	r2, #0
  4026e0:	645a      	str	r2, [r3, #68]	; 0x44
  4026e2:	6a3b      	ldr	r3, [r7, #32]
  4026e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  4026e6:	f1b3 3fff 	cmp.w	r3, #4294967295
  4026ea:	d103      	bne.n	4026f4 <xQueueGenericReceive+0x184>
  4026ec:	6a3b      	ldr	r3, [r7, #32]
  4026ee:	f04f 0200 	mov.w	r2, #0
  4026f2:	649a      	str	r2, [r3, #72]	; 0x48
  4026f4:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  4026f8:	f2c0 0340 	movt	r3, #64	; 0x40
  4026fc:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  4026fe:	f107 0214 	add.w	r2, r7, #20
  402702:	f107 0304 	add.w	r3, r7, #4
  402706:	4610      	mov	r0, r2
  402708:	4619      	mov	r1, r3
  40270a:	f243 73fd 	movw	r3, #14333	; 0x37fd
  40270e:	f2c0 0340 	movt	r3, #64	; 0x40
  402712:	4798      	blx	r3
  402714:	4603      	mov	r3, r0
  402716:	2b00      	cmp	r3, #0
  402718:	d14a      	bne.n	4027b0 <xQueueGenericReceive+0x240>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  40271a:	6a38      	ldr	r0, [r7, #32]
  40271c:	f642 2315 	movw	r3, #10773	; 0x2a15
  402720:	f2c0 0340 	movt	r3, #64	; 0x40
  402724:	4798      	blx	r3
  402726:	4603      	mov	r3, r0
  402728:	2b00      	cmp	r3, #0
  40272a:	d035      	beq.n	402798 <xQueueGenericReceive+0x228>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40272c:	6a3b      	ldr	r3, [r7, #32]
  40272e:	681b      	ldr	r3, [r3, #0]
  402730:	2b00      	cmp	r3, #0
  402732:	d111      	bne.n	402758 <xQueueGenericReceive+0x1e8>
					{
						portENTER_CRITICAL();
  402734:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  402738:	f2c0 0340 	movt	r3, #64	; 0x40
  40273c:	4798      	blx	r3
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  40273e:	6a3b      	ldr	r3, [r7, #32]
  402740:	685b      	ldr	r3, [r3, #4]
  402742:	4618      	mov	r0, r3
  402744:	f643 43f9 	movw	r3, #15609	; 0x3cf9
  402748:	f2c0 0340 	movt	r3, #64	; 0x40
  40274c:	4798      	blx	r3
						}
						portEXIT_CRITICAL();
  40274e:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  402752:	f2c0 0340 	movt	r3, #64	; 0x40
  402756:	4798      	blx	r3
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  402758:	6a3b      	ldr	r3, [r7, #32]
  40275a:	f103 0224 	add.w	r2, r3, #36	; 0x24
  40275e:	687b      	ldr	r3, [r7, #4]
  402760:	4610      	mov	r0, r2
  402762:	4619      	mov	r1, r3
  402764:	f243 533d 	movw	r3, #13629	; 0x353d
  402768:	f2c0 0340 	movt	r3, #64	; 0x40
  40276c:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  40276e:	6a38      	ldr	r0, [r7, #32]
  402770:	f642 1319 	movw	r3, #10521	; 0x2919
  402774:	f2c0 0340 	movt	r3, #64	; 0x40
  402778:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  40277a:	f642 7381 	movw	r3, #12161	; 0x2f81
  40277e:	f2c0 0340 	movt	r3, #64	; 0x40
  402782:	4798      	blx	r3
  402784:	4603      	mov	r3, r0
  402786:	2b00      	cmp	r3, #0
  402788:	f47f af1b 	bne.w	4025c2 <xQueueGenericReceive+0x52>
				{
					portYIELD_WITHIN_API();
  40278c:	f641 6395 	movw	r3, #7829	; 0x1e95
  402790:	f2c0 0340 	movt	r3, #64	; 0x40
  402794:	4798      	blx	r3
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
  402796:	e714      	b.n	4025c2 <xQueueGenericReceive+0x52>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  402798:	6a38      	ldr	r0, [r7, #32]
  40279a:	f642 1319 	movw	r3, #10521	; 0x2919
  40279e:	f2c0 0340 	movt	r3, #64	; 0x40
  4027a2:	4798      	blx	r3
				( void ) xTaskResumeAll();
  4027a4:	f642 7381 	movw	r3, #12161	; 0x2f81
  4027a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4027ac:	4798      	blx	r3
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
  4027ae:	e708      	b.n	4025c2 <xQueueGenericReceive+0x52>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  4027b0:	6a38      	ldr	r0, [r7, #32]
  4027b2:	f642 1319 	movw	r3, #10521	; 0x2919
  4027b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4027ba:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4027bc:	f642 7381 	movw	r3, #12161	; 0x2f81
  4027c0:	f2c0 0340 	movt	r3, #64	; 0x40
  4027c4:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
  4027c6:	f04f 0300 	mov.w	r3, #0
		}
	}
}
  4027ca:	4618      	mov	r0, r3
  4027cc:	f107 0728 	add.w	r7, r7, #40	; 0x28
  4027d0:	46bd      	mov	sp, r7
  4027d2:	bd80      	pop	{r7, pc}

004027d4 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  4027d4:	b580      	push	{r7, lr}
  4027d6:	b084      	sub	sp, #16
  4027d8:	af00      	add	r7, sp, #0
  4027da:	60f8      	str	r0, [r7, #12]
  4027dc:	60b9      	str	r1, [r7, #8]
  4027de:	607a      	str	r2, [r7, #4]
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  4027e0:	68fb      	ldr	r3, [r7, #12]
  4027e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4027e4:	2b00      	cmp	r3, #0
  4027e6:	d110      	bne.n	40280a <prvCopyDataToQueue+0x36>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4027e8:	68fb      	ldr	r3, [r7, #12]
  4027ea:	681b      	ldr	r3, [r3, #0]
  4027ec:	2b00      	cmp	r3, #0
  4027ee:	d15e      	bne.n	4028ae <prvCopyDataToQueue+0xda>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  4027f0:	68fb      	ldr	r3, [r7, #12]
  4027f2:	685b      	ldr	r3, [r3, #4]
  4027f4:	4618      	mov	r0, r3
  4027f6:	f643 6341 	movw	r3, #15937	; 0x3e41
  4027fa:	f2c0 0340 	movt	r3, #64	; 0x40
  4027fe:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  402800:	68fb      	ldr	r3, [r7, #12]
  402802:	f04f 0200 	mov.w	r2, #0
  402806:	605a      	str	r2, [r3, #4]
  402808:	e051      	b.n	4028ae <prvCopyDataToQueue+0xda>
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
  40280a:	687b      	ldr	r3, [r7, #4]
  40280c:	2b00      	cmp	r3, #0
  40280e:	d11d      	bne.n	40284c <prvCopyDataToQueue+0x78>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
  402810:	68fb      	ldr	r3, [r7, #12]
  402812:	689a      	ldr	r2, [r3, #8]
  402814:	68fb      	ldr	r3, [r7, #12]
  402816:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402818:	4610      	mov	r0, r2
  40281a:	68b9      	ldr	r1, [r7, #8]
  40281c:	461a      	mov	r2, r3
  40281e:	f644 4303 	movw	r3, #19459	; 0x4c03
  402822:	f2c0 0340 	movt	r3, #64	; 0x40
  402826:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  402828:	68fb      	ldr	r3, [r7, #12]
  40282a:	689a      	ldr	r2, [r3, #8]
  40282c:	68fb      	ldr	r3, [r7, #12]
  40282e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402830:	18d2      	adds	r2, r2, r3
  402832:	68fb      	ldr	r3, [r7, #12]
  402834:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  402836:	68fb      	ldr	r3, [r7, #12]
  402838:	689a      	ldr	r2, [r3, #8]
  40283a:	68fb      	ldr	r3, [r7, #12]
  40283c:	685b      	ldr	r3, [r3, #4]
  40283e:	429a      	cmp	r2, r3
  402840:	d335      	bcc.n	4028ae <prvCopyDataToQueue+0xda>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  402842:	68fb      	ldr	r3, [r7, #12]
  402844:	681a      	ldr	r2, [r3, #0]
  402846:	68fb      	ldr	r3, [r7, #12]
  402848:	609a      	str	r2, [r3, #8]
  40284a:	e030      	b.n	4028ae <prvCopyDataToQueue+0xda>
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  40284c:	68fb      	ldr	r3, [r7, #12]
  40284e:	68da      	ldr	r2, [r3, #12]
  402850:	68fb      	ldr	r3, [r7, #12]
  402852:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402854:	4610      	mov	r0, r2
  402856:	68b9      	ldr	r1, [r7, #8]
  402858:	461a      	mov	r2, r3
  40285a:	f644 4303 	movw	r3, #19459	; 0x4c03
  40285e:	f2c0 0340 	movt	r3, #64	; 0x40
  402862:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
  402864:	68fb      	ldr	r3, [r7, #12]
  402866:	68da      	ldr	r2, [r3, #12]
  402868:	68fb      	ldr	r3, [r7, #12]
  40286a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40286c:	f1c3 0300 	rsb	r3, r3, #0
  402870:	18d2      	adds	r2, r2, r3
  402872:	68fb      	ldr	r3, [r7, #12]
  402874:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  402876:	68fb      	ldr	r3, [r7, #12]
  402878:	68da      	ldr	r2, [r3, #12]
  40287a:	68fb      	ldr	r3, [r7, #12]
  40287c:	681b      	ldr	r3, [r3, #0]
  40287e:	429a      	cmp	r2, r3
  402880:	d208      	bcs.n	402894 <prvCopyDataToQueue+0xc0>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  402882:	68fb      	ldr	r3, [r7, #12]
  402884:	685a      	ldr	r2, [r3, #4]
  402886:	68fb      	ldr	r3, [r7, #12]
  402888:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40288a:	f1c3 0300 	rsb	r3, r3, #0
  40288e:	18d2      	adds	r2, r2, r3
  402890:	68fb      	ldr	r3, [r7, #12]
  402892:	60da      	str	r2, [r3, #12]
		}

		if( xPosition == queueOVERWRITE )
  402894:	687b      	ldr	r3, [r7, #4]
  402896:	2b02      	cmp	r3, #2
  402898:	d109      	bne.n	4028ae <prvCopyDataToQueue+0xda>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  40289a:	68fb      	ldr	r3, [r7, #12]
  40289c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40289e:	2b00      	cmp	r3, #0
  4028a0:	d005      	beq.n	4028ae <prvCopyDataToQueue+0xda>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
  4028a2:	68fb      	ldr	r3, [r7, #12]
  4028a4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  4028a6:	f103 32ff 	add.w	r2, r3, #4294967295
  4028aa:	68fb      	ldr	r3, [r7, #12]
  4028ac:	639a      	str	r2, [r3, #56]	; 0x38
			}
		}
	}

	++( pxQueue->uxMessagesWaiting );
  4028ae:	68fb      	ldr	r3, [r7, #12]
  4028b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  4028b2:	f103 0201 	add.w	r2, r3, #1
  4028b6:	68fb      	ldr	r3, [r7, #12]
  4028b8:	639a      	str	r2, [r3, #56]	; 0x38
}
  4028ba:	f107 0710 	add.w	r7, r7, #16
  4028be:	46bd      	mov	sp, r7
  4028c0:	bd80      	pop	{r7, pc}
  4028c2:	bf00      	nop

004028c4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
{
  4028c4:	b580      	push	{r7, lr}
  4028c6:	b082      	sub	sp, #8
  4028c8:	af00      	add	r7, sp, #0
  4028ca:	6078      	str	r0, [r7, #4]
  4028cc:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  4028ce:	687b      	ldr	r3, [r7, #4]
  4028d0:	681b      	ldr	r3, [r3, #0]
  4028d2:	2b00      	cmp	r3, #0
  4028d4:	d01c      	beq.n	402910 <prvCopyDataFromQueue+0x4c>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
  4028d6:	687b      	ldr	r3, [r7, #4]
  4028d8:	68da      	ldr	r2, [r3, #12]
  4028da:	687b      	ldr	r3, [r7, #4]
  4028dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4028de:	18d2      	adds	r2, r2, r3
  4028e0:	687b      	ldr	r3, [r7, #4]
  4028e2:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  4028e4:	687b      	ldr	r3, [r7, #4]
  4028e6:	68da      	ldr	r2, [r3, #12]
  4028e8:	687b      	ldr	r3, [r7, #4]
  4028ea:	685b      	ldr	r3, [r3, #4]
  4028ec:	429a      	cmp	r2, r3
  4028ee:	d303      	bcc.n	4028f8 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
  4028f0:	687b      	ldr	r3, [r7, #4]
  4028f2:	681a      	ldr	r2, [r3, #0]
  4028f4:	687b      	ldr	r3, [r7, #4]
  4028f6:	60da      	str	r2, [r3, #12]
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
  4028f8:	687b      	ldr	r3, [r7, #4]
  4028fa:	68da      	ldr	r2, [r3, #12]
  4028fc:	687b      	ldr	r3, [r7, #4]
  4028fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402900:	6838      	ldr	r0, [r7, #0]
  402902:	4611      	mov	r1, r2
  402904:	461a      	mov	r2, r3
  402906:	f644 4303 	movw	r3, #19459	; 0x4c03
  40290a:	f2c0 0340 	movt	r3, #64	; 0x40
  40290e:	4798      	blx	r3
	}
}
  402910:	f107 0708 	add.w	r7, r7, #8
  402914:	46bd      	mov	sp, r7
  402916:	bd80      	pop	{r7, pc}

00402918 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
  402918:	b580      	push	{r7, lr}
  40291a:	b082      	sub	sp, #8
  40291c:	af00      	add	r7, sp, #0
  40291e:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  402920:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  402924:	f2c0 0340 	movt	r3, #64	; 0x40
  402928:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  40292a:	e02f      	b.n	40298c <prvUnlockQueue+0x74>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			#if ( configUSE_QUEUE_SETS == 1 )
			{
				if( pxQueue->pxQueueSetContainer != NULL )
  40292c:	687b      	ldr	r3, [r7, #4]
  40292e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  402930:	2b00      	cmp	r3, #0
  402932:	d010      	beq.n	402956 <prvUnlockQueue+0x3e>
				{
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
  402934:	6878      	ldr	r0, [r7, #4]
  402936:	f04f 0100 	mov.w	r1, #0
  40293a:	f642 3311 	movw	r3, #11025	; 0x2b11
  40293e:	f2c0 0340 	movt	r3, #64	; 0x40
  402942:	4798      	blx	r3
  402944:	4603      	mov	r3, r0
  402946:	2b01      	cmp	r3, #1
  402948:	d11a      	bne.n	402980 <prvUnlockQueue+0x68>
					{
						/* The queue is a member of a queue set, and posting to
						the queue set caused a higher priority task to unblock.
						A context switch is required. */
						vTaskMissedYield();
  40294a:	f643 03c9 	movw	r3, #14537	; 0x38c9
  40294e:	f2c0 0340 	movt	r3, #64	; 0x40
  402952:	4798      	blx	r3
  402954:	e014      	b.n	402980 <prvUnlockQueue+0x68>
				}
				else
				{
					/* Tasks that are removed from the event list will get added to
					the pending ready list as the scheduler is still suspended. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  402956:	687b      	ldr	r3, [r7, #4]
  402958:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40295a:	2b00      	cmp	r3, #0
  40295c:	d01b      	beq.n	402996 <prvUnlockQueue+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  40295e:	687b      	ldr	r3, [r7, #4]
  402960:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402964:	4618      	mov	r0, r3
  402966:	f243 63c1 	movw	r3, #14017	; 0x36c1
  40296a:	f2c0 0340 	movt	r3, #64	; 0x40
  40296e:	4798      	blx	r3
  402970:	4603      	mov	r3, r0
  402972:	2b00      	cmp	r3, #0
  402974:	d004      	beq.n	402980 <prvUnlockQueue+0x68>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							vTaskMissedYield();
  402976:	f643 03c9 	movw	r3, #14537	; 0x38c9
  40297a:	f2c0 0340 	movt	r3, #64	; 0x40
  40297e:	4798      	blx	r3
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
  402980:	687b      	ldr	r3, [r7, #4]
  402982:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  402984:	f103 32ff 	add.w	r2, r3, #4294967295
  402988:	687b      	ldr	r3, [r7, #4]
  40298a:	649a      	str	r2, [r3, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  40298c:	687b      	ldr	r3, [r7, #4]
  40298e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  402990:	2b00      	cmp	r3, #0
  402992:	dccb      	bgt.n	40292c <prvUnlockQueue+0x14>
  402994:	e000      	b.n	402998 <prvUnlockQueue+0x80>
							vTaskMissedYield();
						}
					}
					else
					{
						break;
  402996:	bf00      	nop
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
  402998:	687b      	ldr	r3, [r7, #4]
  40299a:	f04f 32ff 	mov.w	r2, #4294967295
  40299e:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
  4029a0:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  4029a4:	f2c0 0340 	movt	r3, #64	; 0x40
  4029a8:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  4029aa:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  4029ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4029b2:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4029b4:	e01a      	b.n	4029ec <prvUnlockQueue+0xd4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4029b6:	687b      	ldr	r3, [r7, #4]
  4029b8:	691b      	ldr	r3, [r3, #16]
  4029ba:	2b00      	cmp	r3, #0
  4029bc:	d01b      	beq.n	4029f6 <prvUnlockQueue+0xde>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  4029be:	687b      	ldr	r3, [r7, #4]
  4029c0:	f103 0310 	add.w	r3, r3, #16
  4029c4:	4618      	mov	r0, r3
  4029c6:	f243 63c1 	movw	r3, #14017	; 0x36c1
  4029ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4029ce:	4798      	blx	r3
  4029d0:	4603      	mov	r3, r0
  4029d2:	2b00      	cmp	r3, #0
  4029d4:	d004      	beq.n	4029e0 <prvUnlockQueue+0xc8>
				{
					vTaskMissedYield();
  4029d6:	f643 03c9 	movw	r3, #14537	; 0x38c9
  4029da:	f2c0 0340 	movt	r3, #64	; 0x40
  4029de:	4798      	blx	r3
				}

				--( pxQueue->xRxLock );
  4029e0:	687b      	ldr	r3, [r7, #4]
  4029e2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  4029e4:	f103 32ff 	add.w	r2, r3, #4294967295
  4029e8:	687b      	ldr	r3, [r7, #4]
  4029ea:	645a      	str	r2, [r3, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4029ec:	687b      	ldr	r3, [r7, #4]
  4029ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  4029f0:	2b00      	cmp	r3, #0
  4029f2:	dce0      	bgt.n	4029b6 <prvUnlockQueue+0x9e>
  4029f4:	e000      	b.n	4029f8 <prvUnlockQueue+0xe0>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
  4029f6:	bf00      	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
  4029f8:	687b      	ldr	r3, [r7, #4]
  4029fa:	f04f 32ff 	mov.w	r2, #4294967295
  4029fe:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  402a00:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  402a04:	f2c0 0340 	movt	r3, #64	; 0x40
  402a08:	4798      	blx	r3
}
  402a0a:	f107 0708 	add.w	r7, r7, #8
  402a0e:	46bd      	mov	sp, r7
  402a10:	bd80      	pop	{r7, pc}
  402a12:	bf00      	nop

00402a14 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
  402a14:	b580      	push	{r7, lr}
  402a16:	b084      	sub	sp, #16
  402a18:	af00      	add	r7, sp, #0
  402a1a:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  402a1c:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  402a20:	f2c0 0340 	movt	r3, #64	; 0x40
  402a24:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
  402a26:	687b      	ldr	r3, [r7, #4]
  402a28:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  402a2a:	2b00      	cmp	r3, #0
  402a2c:	d103      	bne.n	402a36 <prvIsQueueEmpty+0x22>
		{
			xReturn = pdTRUE;
  402a2e:	f04f 0301 	mov.w	r3, #1
  402a32:	60fb      	str	r3, [r7, #12]
  402a34:	e002      	b.n	402a3c <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
  402a36:	f04f 0300 	mov.w	r3, #0
  402a3a:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  402a3c:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  402a40:	f2c0 0340 	movt	r3, #64	; 0x40
  402a44:	4798      	blx	r3

	return xReturn;
  402a46:	68fb      	ldr	r3, [r7, #12]
}
  402a48:	4618      	mov	r0, r3
  402a4a:	f107 0710 	add.w	r7, r7, #16
  402a4e:	46bd      	mov	sp, r7
  402a50:	bd80      	pop	{r7, pc}
  402a52:	bf00      	nop

00402a54 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
  402a54:	b580      	push	{r7, lr}
  402a56:	b084      	sub	sp, #16
  402a58:	af00      	add	r7, sp, #0
  402a5a:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  402a5c:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  402a60:	f2c0 0340 	movt	r3, #64	; 0x40
  402a64:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  402a66:	687b      	ldr	r3, [r7, #4]
  402a68:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  402a6a:	687b      	ldr	r3, [r7, #4]
  402a6c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  402a6e:	429a      	cmp	r2, r3
  402a70:	d103      	bne.n	402a7a <prvIsQueueFull+0x26>
		{
			xReturn = pdTRUE;
  402a72:	f04f 0301 	mov.w	r3, #1
  402a76:	60fb      	str	r3, [r7, #12]
  402a78:	e002      	b.n	402a80 <prvIsQueueFull+0x2c>
		}
		else
		{
			xReturn = pdFALSE;
  402a7a:	f04f 0300 	mov.w	r3, #0
  402a7e:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  402a80:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  402a84:	f2c0 0340 	movt	r3, #64	; 0x40
  402a88:	4798      	blx	r3

	return xReturn;
  402a8a:	68fb      	ldr	r3, [r7, #12]
}
  402a8c:	4618      	mov	r0, r3
  402a8e:	f107 0710 	add.w	r7, r7, #16
  402a92:	46bd      	mov	sp, r7
  402a94:	bd80      	pop	{r7, pc}
  402a96:	bf00      	nop

00402a98 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
	{
  402a98:	b580      	push	{r7, lr}
  402a9a:	b084      	sub	sp, #16
  402a9c:	af00      	add	r7, sp, #0
  402a9e:	6078      	str	r0, [r7, #4]
  402aa0:	6039      	str	r1, [r7, #0]
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  402aa2:	687b      	ldr	r3, [r7, #4]
  402aa4:	60fb      	str	r3, [r7, #12]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
  402aa6:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  402aaa:	f2c0 0340 	movt	r3, #64	; 0x40
  402aae:	4798      	blx	r3
  402ab0:	68fb      	ldr	r3, [r7, #12]
  402ab2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  402ab4:	f1b3 3fff 	cmp.w	r3, #4294967295
  402ab8:	d103      	bne.n	402ac2 <vQueueWaitForMessageRestricted+0x2a>
  402aba:	68fb      	ldr	r3, [r7, #12]
  402abc:	f04f 0200 	mov.w	r2, #0
  402ac0:	645a      	str	r2, [r3, #68]	; 0x44
  402ac2:	68fb      	ldr	r3, [r7, #12]
  402ac4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  402ac6:	f1b3 3fff 	cmp.w	r3, #4294967295
  402aca:	d103      	bne.n	402ad4 <vQueueWaitForMessageRestricted+0x3c>
  402acc:	68fb      	ldr	r3, [r7, #12]
  402ace:	f04f 0200 	mov.w	r2, #0
  402ad2:	649a      	str	r2, [r3, #72]	; 0x48
  402ad4:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  402ad8:	f2c0 0340 	movt	r3, #64	; 0x40
  402adc:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
  402ade:	68fb      	ldr	r3, [r7, #12]
  402ae0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  402ae2:	2b00      	cmp	r3, #0
  402ae4:	d109      	bne.n	402afa <vQueueWaitForMessageRestricted+0x62>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  402ae6:	68fb      	ldr	r3, [r7, #12]
  402ae8:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402aec:	4618      	mov	r0, r3
  402aee:	6839      	ldr	r1, [r7, #0]
  402af0:	f243 6315 	movw	r3, #13845	; 0x3615
  402af4:	f2c0 0340 	movt	r3, #64	; 0x40
  402af8:	4798      	blx	r3
		}
		prvUnlockQueue( pxQueue );
  402afa:	68f8      	ldr	r0, [r7, #12]
  402afc:	f642 1319 	movw	r3, #10521	; 0x2919
  402b00:	f2c0 0340 	movt	r3, #64	; 0x40
  402b04:	4798      	blx	r3
	}
  402b06:	f107 0710 	add.w	r7, r7, #16
  402b0a:	46bd      	mov	sp, r7
  402b0c:	bd80      	pop	{r7, pc}
  402b0e:	bf00      	nop

00402b10 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static portBASE_TYPE prvNotifyQueueSetContainer( const xQUEUE * const pxQueue, portBASE_TYPE xCopyPosition )
	{
  402b10:	b580      	push	{r7, lr}
  402b12:	b084      	sub	sp, #16
  402b14:	af00      	add	r7, sp, #0
  402b16:	6078      	str	r0, [r7, #4]
  402b18:	6039      	str	r1, [r7, #0]
	xQUEUE *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
  402b1a:	687b      	ldr	r3, [r7, #4]
  402b1c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  402b1e:	60bb      	str	r3, [r7, #8]
	portBASE_TYPE xReturn = pdFALSE;
  402b20:	f04f 0300 	mov.w	r3, #0
  402b24:	60fb      	str	r3, [r7, #12]

		configASSERT( pxQueueSetContainer );
  402b26:	68bb      	ldr	r3, [r7, #8]
  402b28:	2b00      	cmp	r3, #0
  402b2a:	d105      	bne.n	402b38 <prvNotifyQueueSetContainer+0x28>
  402b2c:	f641 7321 	movw	r3, #7969	; 0x1f21
  402b30:	f2c0 0340 	movt	r3, #64	; 0x40
  402b34:	4798      	blx	r3
  402b36:	e7fe      	b.n	402b36 <prvNotifyQueueSetContainer+0x26>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
  402b38:	68bb      	ldr	r3, [r7, #8]
  402b3a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  402b3c:	68bb      	ldr	r3, [r7, #8]
  402b3e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  402b40:	429a      	cmp	r2, r3
  402b42:	d305      	bcc.n	402b50 <prvNotifyQueueSetContainer+0x40>
  402b44:	f641 7321 	movw	r3, #7969	; 0x1f21
  402b48:	f2c0 0340 	movt	r3, #64	; 0x40
  402b4c:	4798      	blx	r3
  402b4e:	e7fe      	b.n	402b4e <prvNotifyQueueSetContainer+0x3e>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
  402b50:	68bb      	ldr	r3, [r7, #8]
  402b52:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  402b54:	68bb      	ldr	r3, [r7, #8]
  402b56:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  402b58:	429a      	cmp	r2, r3
  402b5a:	d21c      	bcs.n	402b96 <prvNotifyQueueSetContainer+0x86>
		{
			traceQUEUE_SEND( pxQueueSetContainer );
			/* The data copies is the handle of the queue that contains data. */
			prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
  402b5c:	f107 0304 	add.w	r3, r7, #4
  402b60:	68b8      	ldr	r0, [r7, #8]
  402b62:	4619      	mov	r1, r3
  402b64:	683a      	ldr	r2, [r7, #0]
  402b66:	f242 73d5 	movw	r3, #10197	; 0x27d5
  402b6a:	f2c0 0340 	movt	r3, #64	; 0x40
  402b6e:	4798      	blx	r3
			if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
  402b70:	68bb      	ldr	r3, [r7, #8]
  402b72:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  402b74:	2b00      	cmp	r3, #0
  402b76:	d00e      	beq.n	402b96 <prvNotifyQueueSetContainer+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
  402b78:	68bb      	ldr	r3, [r7, #8]
  402b7a:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402b7e:	4618      	mov	r0, r3
  402b80:	f243 63c1 	movw	r3, #14017	; 0x36c1
  402b84:	f2c0 0340 	movt	r3, #64	; 0x40
  402b88:	4798      	blx	r3
  402b8a:	4603      	mov	r3, r0
  402b8c:	2b00      	cmp	r3, #0
  402b8e:	d002      	beq.n	402b96 <prvNotifyQueueSetContainer+0x86>
				{
					/* The task waiting has a higher priority */
					xReturn = pdTRUE;
  402b90:	f04f 0301 	mov.w	r3, #1
  402b94:	60fb      	str	r3, [r7, #12]
				}
			}
		}

		return xReturn;
  402b96:	68fb      	ldr	r3, [r7, #12]
	}
  402b98:	4618      	mov	r0, r3
  402b9a:	f107 0710 	add.w	r7, r7, #16
  402b9e:	46bd      	mov	sp, r7
  402ba0:	bd80      	pop	{r7, pc}
  402ba2:	bf00      	nop

00402ba4 <xTaskGenericCreate>:
	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
  402ba4:	b590      	push	{r4, r7, lr}
  402ba6:	b08b      	sub	sp, #44	; 0x2c
  402ba8:	af02      	add	r7, sp, #8
  402baa:	60f8      	str	r0, [r7, #12]
  402bac:	60b9      	str	r1, [r7, #8]
  402bae:	603b      	str	r3, [r7, #0]
  402bb0:	4613      	mov	r3, r2
  402bb2:	80fb      	strh	r3, [r7, #6]
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
  402bb4:	68fb      	ldr	r3, [r7, #12]
  402bb6:	2b00      	cmp	r3, #0
  402bb8:	d105      	bne.n	402bc6 <xTaskGenericCreate+0x22>
  402bba:	f641 7321 	movw	r3, #7969	; 0x1f21
  402bbe:	f2c0 0340 	movt	r3, #64	; 0x40
  402bc2:	4798      	blx	r3
  402bc4:	e7fe      	b.n	402bc4 <xTaskGenericCreate+0x20>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
  402bc6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  402bc8:	2b04      	cmp	r3, #4
  402bca:	d905      	bls.n	402bd8 <xTaskGenericCreate+0x34>
  402bcc:	f641 7321 	movw	r3, #7969	; 0x1f21
  402bd0:	f2c0 0340 	movt	r3, #64	; 0x40
  402bd4:	4798      	blx	r3
  402bd6:	e7fe      	b.n	402bd6 <xTaskGenericCreate+0x32>

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
  402bd8:	88fb      	ldrh	r3, [r7, #6]
  402bda:	4618      	mov	r0, r3
  402bdc:	6bb9      	ldr	r1, [r7, #56]	; 0x38
  402bde:	f643 33dd 	movw	r3, #15325	; 0x3bdd
  402be2:	f2c0 0340 	movt	r3, #64	; 0x40
  402be6:	4798      	blx	r3
  402be8:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
  402bea:	69bb      	ldr	r3, [r7, #24]
  402bec:	2b00      	cmp	r3, #0
  402bee:	f000 80b2 	beq.w	402d56 <xTaskGenericCreate+0x1b2>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
  402bf2:	69bb      	ldr	r3, [r7, #24]
  402bf4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  402bf6:	88fb      	ldrh	r3, [r7, #6]
  402bf8:	f103 33ff 	add.w	r3, r3, #4294967295
  402bfc:	ea4f 0383 	mov.w	r3, r3, lsl #2
  402c00:	18d3      	adds	r3, r2, r3
  402c02:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
  402c04:	697b      	ldr	r3, [r7, #20]
  402c06:	f023 0307 	bic.w	r3, r3, #7
  402c0a:	617b      	str	r3, [r7, #20]

			/* Check the alignment of the calculated top of stack is correct. */
			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
  402c0c:	697b      	ldr	r3, [r7, #20]
  402c0e:	f003 0307 	and.w	r3, r3, #7
  402c12:	2b00      	cmp	r3, #0
  402c14:	d005      	beq.n	402c22 <xTaskGenericCreate+0x7e>
  402c16:	f641 7321 	movw	r3, #7969	; 0x1f21
  402c1a:	f2c0 0340 	movt	r3, #64	; 0x40
  402c1e:	4798      	blx	r3
  402c20:	e7fe      	b.n	402c20 <xTaskGenericCreate+0x7c>
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
  402c22:	88fb      	ldrh	r3, [r7, #6]
  402c24:	9300      	str	r3, [sp, #0]
  402c26:	69b8      	ldr	r0, [r7, #24]
  402c28:	68b9      	ldr	r1, [r7, #8]
  402c2a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  402c2c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  402c2e:	f643 1411 	movw	r4, #14609	; 0x3911
  402c32:	f2c0 0440 	movt	r4, #64	; 0x40
  402c36:	47a0      	blx	r4
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  402c38:	6978      	ldr	r0, [r7, #20]
  402c3a:	68f9      	ldr	r1, [r7, #12]
  402c3c:	683a      	ldr	r2, [r7, #0]
  402c3e:	f641 43b1 	movw	r3, #7345	; 0x1cb1
  402c42:	f2c0 0340 	movt	r3, #64	; 0x40
  402c46:	4798      	blx	r3
  402c48:	4602      	mov	r2, r0
  402c4a:	69bb      	ldr	r3, [r7, #24]
  402c4c:	601a      	str	r2, [r3, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
  402c4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  402c50:	2b00      	cmp	r3, #0
  402c52:	d002      	beq.n	402c5a <xTaskGenericCreate+0xb6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
  402c54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  402c56:	69ba      	ldr	r2, [r7, #24]
  402c58:	601a      	str	r2, [r3, #0]
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
  402c5a:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  402c5e:	f2c0 0340 	movt	r3, #64	; 0x40
  402c62:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
  402c64:	f24a 53bc 	movw	r3, #42428	; 0xa5bc
  402c68:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402c6c:	681b      	ldr	r3, [r3, #0]
  402c6e:	f103 0201 	add.w	r2, r3, #1
  402c72:	f24a 53bc 	movw	r3, #42428	; 0xa5bc
  402c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402c7a:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
  402c7c:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  402c80:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402c84:	681b      	ldr	r3, [r3, #0]
  402c86:	2b00      	cmp	r3, #0
  402c88:	d112      	bne.n	402cb0 <xTaskGenericCreate+0x10c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
  402c8a:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  402c8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402c92:	69ba      	ldr	r2, [r7, #24]
  402c94:	601a      	str	r2, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
  402c96:	f24a 53bc 	movw	r3, #42428	; 0xa5bc
  402c9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402c9e:	681b      	ldr	r3, [r3, #0]
  402ca0:	2b01      	cmp	r3, #1
  402ca2:	d11b      	bne.n	402cdc <xTaskGenericCreate+0x138>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
  402ca4:	f643 13bd 	movw	r3, #14781	; 0x39bd
  402ca8:	f2c0 0340 	movt	r3, #64	; 0x40
  402cac:	4798      	blx	r3
  402cae:	e015      	b.n	402cdc <xTaskGenericCreate+0x138>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
  402cb0:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  402cb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402cb8:	681b      	ldr	r3, [r3, #0]
  402cba:	2b00      	cmp	r3, #0
  402cbc:	d10e      	bne.n	402cdc <xTaskGenericCreate+0x138>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
  402cbe:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  402cc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402cc6:	681b      	ldr	r3, [r3, #0]
  402cc8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402cca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  402ccc:	429a      	cmp	r2, r3
  402cce:	d805      	bhi.n	402cdc <xTaskGenericCreate+0x138>
					{
						pxCurrentTCB = pxNewTCB;
  402cd0:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  402cd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402cd8:	69ba      	ldr	r2, [r7, #24]
  402cda:	601a      	str	r2, [r3, #0]
					}
				}
			}

			uxTaskNumber++;
  402cdc:	f24a 53dc 	movw	r3, #42460	; 0xa5dc
  402ce0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402ce4:	681b      	ldr	r3, [r3, #0]
  402ce6:	f103 0201 	add.w	r2, r3, #1
  402cea:	f24a 53dc 	movw	r3, #42460	; 0xa5dc
  402cee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402cf2:	601a      	str	r2, [r3, #0]
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
  402cf4:	69bb      	ldr	r3, [r7, #24]
  402cf6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402cf8:	f04f 0201 	mov.w	r2, #1
  402cfc:	fa02 f203 	lsl.w	r2, r2, r3
  402d00:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  402d04:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402d08:	681b      	ldr	r3, [r3, #0]
  402d0a:	431a      	orrs	r2, r3
  402d0c:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  402d10:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402d14:	601a      	str	r2, [r3, #0]
  402d16:	69bb      	ldr	r3, [r7, #24]
  402d18:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402d1a:	4613      	mov	r3, r2
  402d1c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  402d20:	189b      	adds	r3, r3, r2
  402d22:	ea4f 0383 	mov.w	r3, r3, lsl #2
  402d26:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  402d2a:	f2c2 0200 	movt	r2, #8192	; 0x2000
  402d2e:	189a      	adds	r2, r3, r2
  402d30:	69bb      	ldr	r3, [r7, #24]
  402d32:	f103 0304 	add.w	r3, r3, #4
  402d36:	4610      	mov	r0, r2
  402d38:	4619      	mov	r1, r3
  402d3a:	f641 339d 	movw	r3, #7069	; 0x1b9d
  402d3e:	f2c0 0340 	movt	r3, #64	; 0x40
  402d42:	4798      	blx	r3

			xReturn = pdPASS;
  402d44:	f04f 0301 	mov.w	r3, #1
  402d48:	61fb      	str	r3, [r7, #28]
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
  402d4a:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  402d4e:	f2c0 0340 	movt	r3, #64	; 0x40
  402d52:	4798      	blx	r3
  402d54:	e002      	b.n	402d5c <xTaskGenericCreate+0x1b8>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  402d56:	f04f 33ff 	mov.w	r3, #4294967295
  402d5a:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
  402d5c:	69fb      	ldr	r3, [r7, #28]
  402d5e:	2b01      	cmp	r3, #1
  402d60:	d114      	bne.n	402d8c <xTaskGenericCreate+0x1e8>
	{
		if( xSchedulerRunning != pdFALSE )
  402d62:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  402d66:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402d6a:	681b      	ldr	r3, [r3, #0]
  402d6c:	2b00      	cmp	r3, #0
  402d6e:	d00d      	beq.n	402d8c <xTaskGenericCreate+0x1e8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
  402d70:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  402d74:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402d78:	681b      	ldr	r3, [r3, #0]
  402d7a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402d7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  402d7e:	429a      	cmp	r2, r3
  402d80:	d204      	bcs.n	402d8c <xTaskGenericCreate+0x1e8>
			{
				taskYIELD_IF_USING_PREEMPTION();
  402d82:	f641 6395 	movw	r3, #7829	; 0x1e95
  402d86:	f2c0 0340 	movt	r3, #64	; 0x40
  402d8a:	4798      	blx	r3
			}
		}
	}

	return xReturn;
  402d8c:	69fb      	ldr	r3, [r7, #28]
}
  402d8e:	4618      	mov	r0, r3
  402d90:	f107 0724 	add.w	r7, r7, #36	; 0x24
  402d94:	46bd      	mov	sp, r7
  402d96:	bd90      	pop	{r4, r7, pc}

00402d98 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
  402d98:	b580      	push	{r7, lr}
  402d9a:	b086      	sub	sp, #24
  402d9c:	af00      	add	r7, sp, #0
  402d9e:	6078      	str	r0, [r7, #4]
  402da0:	6039      	str	r1, [r7, #0]
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
  402da2:	f04f 0300 	mov.w	r3, #0
  402da6:	617b      	str	r3, [r7, #20]

		configASSERT( pxPreviousWakeTime );
  402da8:	687b      	ldr	r3, [r7, #4]
  402daa:	2b00      	cmp	r3, #0
  402dac:	d105      	bne.n	402dba <vTaskDelayUntil+0x22>
  402dae:	f641 7321 	movw	r3, #7969	; 0x1f21
  402db2:	f2c0 0340 	movt	r3, #64	; 0x40
  402db6:	4798      	blx	r3
  402db8:	e7fe      	b.n	402db8 <vTaskDelayUntil+0x20>
		configASSERT( ( xTimeIncrement > 0U ) );
  402dba:	683b      	ldr	r3, [r7, #0]
  402dbc:	2b00      	cmp	r3, #0
  402dbe:	d105      	bne.n	402dcc <vTaskDelayUntil+0x34>
  402dc0:	f641 7321 	movw	r3, #7969	; 0x1f21
  402dc4:	f2c0 0340 	movt	r3, #64	; 0x40
  402dc8:	4798      	blx	r3
  402dca:	e7fe      	b.n	402dca <vTaskDelayUntil+0x32>

		vTaskSuspendAll();
  402dcc:	f642 735d 	movw	r3, #12125	; 0x2f5d
  402dd0:	f2c0 0340 	movt	r3, #64	; 0x40
  402dd4:	4798      	blx	r3
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
  402dd6:	f24a 53c0 	movw	r3, #42432	; 0xa5c0
  402dda:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402dde:	681b      	ldr	r3, [r3, #0]
  402de0:	613b      	str	r3, [r7, #16]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
  402de2:	687b      	ldr	r3, [r7, #4]
  402de4:	681a      	ldr	r2, [r3, #0]
  402de6:	683b      	ldr	r3, [r7, #0]
  402de8:	18d3      	adds	r3, r2, r3
  402dea:	60fb      	str	r3, [r7, #12]

			if( xConstTickCount < *pxPreviousWakeTime )
  402dec:	687b      	ldr	r3, [r7, #4]
  402dee:	681a      	ldr	r2, [r3, #0]
  402df0:	693b      	ldr	r3, [r7, #16]
  402df2:	429a      	cmp	r2, r3
  402df4:	d90c      	bls.n	402e10 <vTaskDelayUntil+0x78>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
  402df6:	687b      	ldr	r3, [r7, #4]
  402df8:	681a      	ldr	r2, [r3, #0]
  402dfa:	68fb      	ldr	r3, [r7, #12]
  402dfc:	429a      	cmp	r2, r3
  402dfe:	d913      	bls.n	402e28 <vTaskDelayUntil+0x90>
  402e00:	68fa      	ldr	r2, [r7, #12]
  402e02:	693b      	ldr	r3, [r7, #16]
  402e04:	429a      	cmp	r2, r3
  402e06:	d90f      	bls.n	402e28 <vTaskDelayUntil+0x90>
				{
					xShouldDelay = pdTRUE;
  402e08:	f04f 0301 	mov.w	r3, #1
  402e0c:	617b      	str	r3, [r7, #20]
  402e0e:	e00b      	b.n	402e28 <vTaskDelayUntil+0x90>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
  402e10:	687b      	ldr	r3, [r7, #4]
  402e12:	681a      	ldr	r2, [r3, #0]
  402e14:	68fb      	ldr	r3, [r7, #12]
  402e16:	429a      	cmp	r2, r3
  402e18:	d803      	bhi.n	402e22 <vTaskDelayUntil+0x8a>
  402e1a:	68fa      	ldr	r2, [r7, #12]
  402e1c:	693b      	ldr	r3, [r7, #16]
  402e1e:	429a      	cmp	r2, r3
  402e20:	d902      	bls.n	402e28 <vTaskDelayUntil+0x90>
				{
					xShouldDelay = pdTRUE;
  402e22:	f04f 0301 	mov.w	r3, #1
  402e26:	617b      	str	r3, [r7, #20]
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
  402e28:	687b      	ldr	r3, [r7, #4]
  402e2a:	68fa      	ldr	r2, [r7, #12]
  402e2c:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
  402e2e:	697b      	ldr	r3, [r7, #20]
  402e30:	2b00      	cmp	r3, #0
  402e32:	d02c      	beq.n	402e8e <vTaskDelayUntil+0xf6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  402e34:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  402e38:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402e3c:	681b      	ldr	r3, [r3, #0]
  402e3e:	f103 0304 	add.w	r3, r3, #4
  402e42:	4618      	mov	r0, r3
  402e44:	f641 4359 	movw	r3, #7257	; 0x1c59
  402e48:	f2c0 0340 	movt	r3, #64	; 0x40
  402e4c:	4798      	blx	r3
  402e4e:	4603      	mov	r3, r0
  402e50:	2b00      	cmp	r3, #0
  402e52:	d116      	bne.n	402e82 <vTaskDelayUntil+0xea>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  402e54:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  402e58:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402e5c:	681b      	ldr	r3, [r3, #0]
  402e5e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402e60:	f04f 0201 	mov.w	r2, #1
  402e64:	fa02 f303 	lsl.w	r3, r2, r3
  402e68:	ea6f 0203 	mvn.w	r2, r3
  402e6c:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  402e70:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402e74:	681b      	ldr	r3, [r3, #0]
  402e76:	401a      	ands	r2, r3
  402e78:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  402e7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402e80:	601a      	str	r2, [r3, #0]
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
  402e82:	68f8      	ldr	r0, [r7, #12]
  402e84:	f643 3345 	movw	r3, #15173	; 0x3b45
  402e88:	f2c0 0340 	movt	r3, #64	; 0x40
  402e8c:	4798      	blx	r3
			}
		}
		xAlreadyYielded = xTaskResumeAll();
  402e8e:	f642 7381 	movw	r3, #12161	; 0x2f81
  402e92:	f2c0 0340 	movt	r3, #64	; 0x40
  402e96:	4798      	blx	r3
  402e98:	60b8      	str	r0, [r7, #8]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  402e9a:	68bb      	ldr	r3, [r7, #8]
  402e9c:	2b00      	cmp	r3, #0
  402e9e:	d104      	bne.n	402eaa <vTaskDelayUntil+0x112>
		{
			portYIELD_WITHIN_API();
  402ea0:	f641 6395 	movw	r3, #7829	; 0x1e95
  402ea4:	f2c0 0340 	movt	r3, #64	; 0x40
  402ea8:	4798      	blx	r3
		}
	}
  402eaa:	f107 0718 	add.w	r7, r7, #24
  402eae:	46bd      	mov	sp, r7
  402eb0:	bd80      	pop	{r7, pc}
  402eb2:	bf00      	nop

00402eb4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
  402eb4:	b590      	push	{r4, r7, lr}
  402eb6:	b087      	sub	sp, #28
  402eb8:	af04      	add	r7, sp, #16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
  402eba:	f04f 0300 	mov.w	r3, #0
  402ebe:	9300      	str	r3, [sp, #0]
  402ec0:	f04f 0300 	mov.w	r3, #0
  402ec4:	9301      	str	r3, [sp, #4]
  402ec6:	f04f 0300 	mov.w	r3, #0
  402eca:	9302      	str	r3, [sp, #8]
  402ecc:	f04f 0300 	mov.w	r3, #0
  402ed0:	9303      	str	r3, [sp, #12]
  402ed2:	f643 00e1 	movw	r0, #14561	; 0x38e1
  402ed6:	f2c0 0040 	movt	r0, #64	; 0x40
  402eda:	f644 4150 	movw	r1, #19536	; 0x4c50
  402ede:	f2c0 0140 	movt	r1, #64	; 0x40
  402ee2:	f04f 0282 	mov.w	r2, #130	; 0x82
  402ee6:	f04f 0300 	mov.w	r3, #0
  402eea:	f642 34a5 	movw	r4, #11173	; 0x2ba5
  402eee:	f2c0 0440 	movt	r4, #64	; 0x40
  402ef2:	47a0      	blx	r4
  402ef4:	6078      	str	r0, [r7, #4]
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
  402ef6:	687b      	ldr	r3, [r7, #4]
  402ef8:	2b01      	cmp	r3, #1
  402efa:	d105      	bne.n	402f08 <vTaskStartScheduler+0x54>
		{
			xReturn = xTimerCreateTimerTask();
  402efc:	f643 7329 	movw	r3, #16169	; 0x3f29
  402f00:	f2c0 0340 	movt	r3, #64	; 0x40
  402f04:	4798      	blx	r3
  402f06:	6078      	str	r0, [r7, #4]
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
  402f08:	687b      	ldr	r3, [r7, #4]
  402f0a:	2b01      	cmp	r3, #1
  402f0c:	d118      	bne.n	402f40 <vTaskStartScheduler+0x8c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
  402f0e:	f641 7321 	movw	r3, #7969	; 0x1f21
  402f12:	f2c0 0340 	movt	r3, #64	; 0x40
  402f16:	4798      	blx	r3
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
  402f18:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  402f1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402f20:	f04f 0201 	mov.w	r2, #1
  402f24:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
  402f26:	f24a 53c0 	movw	r3, #42432	; 0xa5c0
  402f2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402f2e:	f04f 0200 	mov.w	r2, #0
  402f32:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  402f34:	f641 5375 	movw	r3, #7541	; 0x1d75
  402f38:	f2c0 0340 	movt	r3, #64	; 0x40
  402f3c:	4798      	blx	r3
  402f3e:	e008      	b.n	402f52 <vTaskStartScheduler+0x9e>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
  402f40:	687b      	ldr	r3, [r7, #4]
  402f42:	2b00      	cmp	r3, #0
  402f44:	d105      	bne.n	402f52 <vTaskStartScheduler+0x9e>
  402f46:	f641 7321 	movw	r3, #7969	; 0x1f21
  402f4a:	f2c0 0340 	movt	r3, #64	; 0x40
  402f4e:	4798      	blx	r3
  402f50:	e7fe      	b.n	402f50 <vTaskStartScheduler+0x9c>
	}
}
  402f52:	f107 070c 	add.w	r7, r7, #12
  402f56:	46bd      	mov	sp, r7
  402f58:	bd90      	pop	{r4, r7, pc}
  402f5a:	bf00      	nop

00402f5c <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
  402f5c:	b480      	push	{r7}
  402f5e:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  402f60:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  402f64:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402f68:	681b      	ldr	r3, [r3, #0]
  402f6a:	f103 0201 	add.w	r2, r3, #1
  402f6e:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  402f72:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402f76:	601a      	str	r2, [r3, #0]
}
  402f78:	46bd      	mov	sp, r7
  402f7a:	bc80      	pop	{r7}
  402f7c:	4770      	bx	lr
  402f7e:	bf00      	nop

00402f80 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
  402f80:	b580      	push	{r7, lr}
  402f82:	b082      	sub	sp, #8
  402f84:	af00      	add	r7, sp, #0
tskTCB *pxTCB;
portBASE_TYPE xAlreadyYielded = pdFALSE;
  402f86:	f04f 0300 	mov.w	r3, #0
  402f8a:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
  402f8c:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  402f90:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402f94:	681b      	ldr	r3, [r3, #0]
  402f96:	2b00      	cmp	r3, #0
  402f98:	d105      	bne.n	402fa6 <xTaskResumeAll+0x26>
  402f9a:	f641 7321 	movw	r3, #7969	; 0x1f21
  402f9e:	f2c0 0340 	movt	r3, #64	; 0x40
  402fa2:	4798      	blx	r3
  402fa4:	e7fe      	b.n	402fa4 <xTaskResumeAll+0x24>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  402fa6:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  402faa:	f2c0 0340 	movt	r3, #64	; 0x40
  402fae:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  402fb0:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  402fb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402fb8:	681b      	ldr	r3, [r3, #0]
  402fba:	f103 32ff 	add.w	r2, r3, #4294967295
  402fbe:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  402fc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402fc6:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  402fc8:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  402fcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402fd0:	681b      	ldr	r3, [r3, #0]
  402fd2:	2b00      	cmp	r3, #0
  402fd4:	f040 809b 	bne.w	40310e <xTaskResumeAll+0x18e>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
  402fd8:	f24a 53bc 	movw	r3, #42428	; 0xa5bc
  402fdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402fe0:	681b      	ldr	r3, [r3, #0]
  402fe2:	2b00      	cmp	r3, #0
  402fe4:	f000 8093 	beq.w	40310e <xTaskResumeAll+0x18e>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  402fe8:	e051      	b.n	40308e <xTaskResumeAll+0x10e>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
  402fea:	f24a 537c 	movw	r3, #42364	; 0xa57c
  402fee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402ff2:	68db      	ldr	r3, [r3, #12]
  402ff4:	68db      	ldr	r3, [r3, #12]
  402ff6:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  402ff8:	683b      	ldr	r3, [r7, #0]
  402ffa:	f103 0318 	add.w	r3, r3, #24
  402ffe:	4618      	mov	r0, r3
  403000:	f641 4359 	movw	r3, #7257	; 0x1c59
  403004:	f2c0 0340 	movt	r3, #64	; 0x40
  403008:	4798      	blx	r3
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
  40300a:	683b      	ldr	r3, [r7, #0]
  40300c:	f103 0304 	add.w	r3, r3, #4
  403010:	4618      	mov	r0, r3
  403012:	f641 4359 	movw	r3, #7257	; 0x1c59
  403016:	f2c0 0340 	movt	r3, #64	; 0x40
  40301a:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
  40301c:	683b      	ldr	r3, [r7, #0]
  40301e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403020:	f04f 0201 	mov.w	r2, #1
  403024:	fa02 f203 	lsl.w	r2, r2, r3
  403028:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  40302c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403030:	681b      	ldr	r3, [r3, #0]
  403032:	431a      	orrs	r2, r3
  403034:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403038:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40303c:	601a      	str	r2, [r3, #0]
  40303e:	683b      	ldr	r3, [r7, #0]
  403040:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403042:	4613      	mov	r3, r2
  403044:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403048:	189b      	adds	r3, r3, r2
  40304a:	ea4f 0383 	mov.w	r3, r3, lsl #2
  40304e:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  403052:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403056:	189a      	adds	r2, r3, r2
  403058:	683b      	ldr	r3, [r7, #0]
  40305a:	f103 0304 	add.w	r3, r3, #4
  40305e:	4610      	mov	r0, r2
  403060:	4619      	mov	r1, r3
  403062:	f641 339d 	movw	r3, #7069	; 0x1b9d
  403066:	f2c0 0340 	movt	r3, #64	; 0x40
  40306a:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  40306c:	683b      	ldr	r3, [r7, #0]
  40306e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403070:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403074:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403078:	681b      	ldr	r3, [r3, #0]
  40307a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40307c:	429a      	cmp	r2, r3
  40307e:	d306      	bcc.n	40308e <xTaskResumeAll+0x10e>
					{
						xYieldPending = pdTRUE;
  403080:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  403084:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403088:	f04f 0201 	mov.w	r2, #1
  40308c:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  40308e:	f24a 537c 	movw	r3, #42364	; 0xa57c
  403092:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403096:	681b      	ldr	r3, [r3, #0]
  403098:	2b00      	cmp	r3, #0
  40309a:	d1a6      	bne.n	402fea <xTaskResumeAll+0x6a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
  40309c:	f24a 53d0 	movw	r3, #42448	; 0xa5d0
  4030a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4030a4:	681b      	ldr	r3, [r3, #0]
  4030a6:	2b00      	cmp	r3, #0
  4030a8:	d022      	beq.n	4030f0 <xTaskResumeAll+0x170>
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
  4030aa:	e01a      	b.n	4030e2 <xTaskResumeAll+0x162>
					{
						if( xTaskIncrementTick() != pdFALSE )
  4030ac:	f243 1359 	movw	r3, #12633	; 0x3159
  4030b0:	f2c0 0340 	movt	r3, #64	; 0x40
  4030b4:	4798      	blx	r3
  4030b6:	4603      	mov	r3, r0
  4030b8:	2b00      	cmp	r3, #0
  4030ba:	d006      	beq.n	4030ca <xTaskResumeAll+0x14a>
						{
							xYieldPending = pdTRUE;
  4030bc:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  4030c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4030c4:	f04f 0201 	mov.w	r2, #1
  4030c8:	601a      	str	r2, [r3, #0]
						}
						--uxPendedTicks;
  4030ca:	f24a 53d0 	movw	r3, #42448	; 0xa5d0
  4030ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4030d2:	681b      	ldr	r3, [r3, #0]
  4030d4:	f103 32ff 	add.w	r2, r3, #4294967295
  4030d8:	f24a 53d0 	movw	r3, #42448	; 0xa5d0
  4030dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4030e0:	601a      	str	r2, [r3, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
  4030e2:	f24a 53d0 	movw	r3, #42448	; 0xa5d0
  4030e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4030ea:	681b      	ldr	r3, [r3, #0]
  4030ec:	2b00      	cmp	r3, #0
  4030ee:	d1dd      	bne.n	4030ac <xTaskResumeAll+0x12c>
						}
						--uxPendedTicks;
					}
				}

				if( xYieldPending == pdTRUE )
  4030f0:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  4030f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4030f8:	681b      	ldr	r3, [r3, #0]
  4030fa:	2b01      	cmp	r3, #1
  4030fc:	d107      	bne.n	40310e <xTaskResumeAll+0x18e>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
  4030fe:	f04f 0301 	mov.w	r3, #1
  403102:	607b      	str	r3, [r7, #4]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
  403104:	f641 6395 	movw	r3, #7829	; 0x1e95
  403108:	f2c0 0340 	movt	r3, #64	; 0x40
  40310c:	4798      	blx	r3
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  40310e:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  403112:	f2c0 0340 	movt	r3, #64	; 0x40
  403116:	4798      	blx	r3

	return xAlreadyYielded;
  403118:	687b      	ldr	r3, [r7, #4]
}
  40311a:	4618      	mov	r0, r3
  40311c:	f107 0708 	add.w	r7, r7, #8
  403120:	46bd      	mov	sp, r7
  403122:	bd80      	pop	{r7, pc}

00403124 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCount( void )
{
  403124:	b580      	push	{r7, lr}
  403126:	b082      	sub	sp, #8
  403128:	af00      	add	r7, sp, #0
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
  40312a:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  40312e:	f2c0 0340 	movt	r3, #64	; 0x40
  403132:	4798      	blx	r3
	{
		xTicks = xTickCount;
  403134:	f24a 53c0 	movw	r3, #42432	; 0xa5c0
  403138:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40313c:	681b      	ldr	r3, [r3, #0]
  40313e:	607b      	str	r3, [r7, #4]
	}
	taskEXIT_CRITICAL();
  403140:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  403144:	f2c0 0340 	movt	r3, #64	; 0x40
  403148:	4798      	blx	r3

	return xTicks;
  40314a:	687b      	ldr	r3, [r7, #4]
}
  40314c:	4618      	mov	r0, r3
  40314e:	f107 0708 	add.w	r7, r7, #8
  403152:	46bd      	mov	sp, r7
  403154:	bd80      	pop	{r7, pc}
  403156:	bf00      	nop

00403158 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

portBASE_TYPE xTaskIncrementTick( void )
{
  403158:	b580      	push	{r7, lr}
  40315a:	b086      	sub	sp, #24
  40315c:	af00      	add	r7, sp, #0
tskTCB * pxTCB;
portTickType xItemValue;
portBASE_TYPE xSwitchRequired = pdFALSE;
  40315e:	f04f 0300 	mov.w	r3, #0
  403162:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  403164:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403168:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40316c:	681b      	ldr	r3, [r3, #0]
  40316e:	2b00      	cmp	r3, #0
  403170:	f040 8112 	bne.w	403398 <xTaskIncrementTick+0x240>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
  403174:	f24a 53c0 	movw	r3, #42432	; 0xa5c0
  403178:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40317c:	681b      	ldr	r3, [r3, #0]
  40317e:	f103 0201 	add.w	r2, r3, #1
  403182:	f24a 53c0 	movw	r3, #42432	; 0xa5c0
  403186:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40318a:	601a      	str	r2, [r3, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
  40318c:	f24a 53c0 	movw	r3, #42432	; 0xa5c0
  403190:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403194:	681b      	ldr	r3, [r3, #0]
  403196:	613b      	str	r3, [r7, #16]

			if( xConstTickCount == ( portTickType ) 0U )
  403198:	693b      	ldr	r3, [r7, #16]
  40319a:	2b00      	cmp	r3, #0
  40319c:	d155      	bne.n	40324a <xTaskIncrementTick+0xf2>
			{
				taskSWITCH_DELAYED_LISTS();
  40319e:	f24a 5374 	movw	r3, #42356	; 0xa574
  4031a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031a6:	681b      	ldr	r3, [r3, #0]
  4031a8:	681b      	ldr	r3, [r3, #0]
  4031aa:	2b00      	cmp	r3, #0
  4031ac:	d005      	beq.n	4031ba <xTaskIncrementTick+0x62>
  4031ae:	f641 7321 	movw	r3, #7969	; 0x1f21
  4031b2:	f2c0 0340 	movt	r3, #64	; 0x40
  4031b6:	4798      	blx	r3
  4031b8:	e7fe      	b.n	4031b8 <xTaskIncrementTick+0x60>
  4031ba:	f24a 5374 	movw	r3, #42356	; 0xa574
  4031be:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031c2:	681b      	ldr	r3, [r3, #0]
  4031c4:	60fb      	str	r3, [r7, #12]
  4031c6:	f24a 5378 	movw	r3, #42360	; 0xa578
  4031ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031ce:	681a      	ldr	r2, [r3, #0]
  4031d0:	f24a 5374 	movw	r3, #42356	; 0xa574
  4031d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031d8:	601a      	str	r2, [r3, #0]
  4031da:	f24a 5378 	movw	r3, #42360	; 0xa578
  4031de:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031e2:	68fa      	ldr	r2, [r7, #12]
  4031e4:	601a      	str	r2, [r3, #0]
  4031e6:	f24a 53d8 	movw	r3, #42456	; 0xa5d8
  4031ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031ee:	681b      	ldr	r3, [r3, #0]
  4031f0:	f103 0201 	add.w	r2, r3, #1
  4031f4:	f24a 53d8 	movw	r3, #42456	; 0xa5d8
  4031f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4031fc:	601a      	str	r2, [r3, #0]
  4031fe:	f24a 5374 	movw	r3, #42356	; 0xa574
  403202:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403206:	681b      	ldr	r3, [r3, #0]
  403208:	681b      	ldr	r3, [r3, #0]
  40320a:	2b00      	cmp	r3, #0
  40320c:	d102      	bne.n	403214 <xTaskIncrementTick+0xbc>
  40320e:	f04f 0301 	mov.w	r3, #1
  403212:	e001      	b.n	403218 <xTaskIncrementTick+0xc0>
  403214:	f04f 0300 	mov.w	r3, #0
  403218:	2b00      	cmp	r3, #0
  40321a:	d007      	beq.n	40322c <xTaskIncrementTick+0xd4>
  40321c:	f240 030c 	movw	r3, #12
  403220:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403224:	f04f 32ff 	mov.w	r2, #4294967295
  403228:	601a      	str	r2, [r3, #0]
  40322a:	e00e      	b.n	40324a <xTaskIncrementTick+0xf2>
  40322c:	f24a 5374 	movw	r3, #42356	; 0xa574
  403230:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403234:	681b      	ldr	r3, [r3, #0]
  403236:	68db      	ldr	r3, [r3, #12]
  403238:	68db      	ldr	r3, [r3, #12]
  40323a:	60bb      	str	r3, [r7, #8]
  40323c:	68bb      	ldr	r3, [r7, #8]
  40323e:	685a      	ldr	r2, [r3, #4]
  403240:	f240 030c 	movw	r3, #12
  403244:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403248:	601a      	str	r2, [r3, #0]

			/* See if this tick has made a timeout expire.  Tasks are stored in the
			queue in the order of their wake time - meaning once one tasks has been
			found whose block time has not expired there is no need not look any
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
  40324a:	f240 030c 	movw	r3, #12
  40324e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403252:	681b      	ldr	r3, [r3, #0]
  403254:	693a      	ldr	r2, [r7, #16]
  403256:	429a      	cmp	r2, r3
  403258:	d37a      	bcc.n	403350 <xTaskIncrementTick+0x1f8>
  40325a:	e000      	b.n	40325e <xTaskIncrementTick+0x106>
								xSwitchRequired = pdTRUE;
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
  40325c:	bf00      	nop
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  40325e:	f24a 5374 	movw	r3, #42356	; 0xa574
  403262:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403266:	681b      	ldr	r3, [r3, #0]
  403268:	681b      	ldr	r3, [r3, #0]
  40326a:	2b00      	cmp	r3, #0
  40326c:	d102      	bne.n	403274 <xTaskIncrementTick+0x11c>
  40326e:	f04f 0301 	mov.w	r3, #1
  403272:	e001      	b.n	403278 <xTaskIncrementTick+0x120>
  403274:	f04f 0300 	mov.w	r3, #0
  403278:	2b00      	cmp	r3, #0
  40327a:	d007      	beq.n	40328c <xTaskIncrementTick+0x134>
					{
						/* The delayed list is empty.  Set xNextTaskUnblockTime to
						the	maximum possible value so it is extremely unlikely that
						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
  40327c:	f240 030c 	movw	r3, #12
  403280:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403284:	f04f 32ff 	mov.w	r2, #4294967295
  403288:	601a      	str	r2, [r3, #0]
						break;
  40328a:	e061      	b.n	403350 <xTaskIncrementTick+0x1f8>
					{
						/* The delayed list is not empty, get the value of the item
						at the head of the delayed list.  This is the time at which
						the task at the head of the delayed list must be removed
						from the Blocked state. */
						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  40328c:	f24a 5374 	movw	r3, #42356	; 0xa574
  403290:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403294:	681b      	ldr	r3, [r3, #0]
  403296:	68db      	ldr	r3, [r3, #12]
  403298:	68db      	ldr	r3, [r3, #12]
  40329a:	60bb      	str	r3, [r7, #8]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  40329c:	68bb      	ldr	r3, [r7, #8]
  40329e:	685b      	ldr	r3, [r3, #4]
  4032a0:	607b      	str	r3, [r7, #4]

						if( xConstTickCount < xItemValue )
  4032a2:	693a      	ldr	r2, [r7, #16]
  4032a4:	687b      	ldr	r3, [r7, #4]
  4032a6:	429a      	cmp	r2, r3
  4032a8:	d206      	bcs.n	4032b8 <xTaskIncrementTick+0x160>
						{
							/* It is not time to unblock this item yet, but the item
							value is the time at which the task at the head of the
							blocked list must be removed from the Blocked state -
							so record the item value in xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
  4032aa:	f240 030c 	movw	r3, #12
  4032ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4032b2:	687a      	ldr	r2, [r7, #4]
  4032b4:	601a      	str	r2, [r3, #0]
							break;
  4032b6:	e04b      	b.n	403350 <xTaskIncrementTick+0x1f8>
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
  4032b8:	68bb      	ldr	r3, [r7, #8]
  4032ba:	f103 0304 	add.w	r3, r3, #4
  4032be:	4618      	mov	r0, r3
  4032c0:	f641 4359 	movw	r3, #7257	; 0x1c59
  4032c4:	f2c0 0340 	movt	r3, #64	; 0x40
  4032c8:	4798      	blx	r3

						/* Is the task waiting on an event also?  If so remove it
						from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  4032ca:	68bb      	ldr	r3, [r7, #8]
  4032cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  4032ce:	2b00      	cmp	r3, #0
  4032d0:	d008      	beq.n	4032e4 <xTaskIncrementTick+0x18c>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  4032d2:	68bb      	ldr	r3, [r7, #8]
  4032d4:	f103 0318 	add.w	r3, r3, #24
  4032d8:	4618      	mov	r0, r3
  4032da:	f641 4359 	movw	r3, #7257	; 0x1c59
  4032de:	f2c0 0340 	movt	r3, #64	; 0x40
  4032e2:	4798      	blx	r3
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
  4032e4:	68bb      	ldr	r3, [r7, #8]
  4032e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4032e8:	f04f 0201 	mov.w	r2, #1
  4032ec:	fa02 f203 	lsl.w	r2, r2, r3
  4032f0:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  4032f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4032f8:	681b      	ldr	r3, [r3, #0]
  4032fa:	431a      	orrs	r2, r3
  4032fc:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403300:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403304:	601a      	str	r2, [r3, #0]
  403306:	68bb      	ldr	r3, [r7, #8]
  403308:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40330a:	4613      	mov	r3, r2
  40330c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403310:	189b      	adds	r3, r3, r2
  403312:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403316:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  40331a:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40331e:	189a      	adds	r2, r3, r2
  403320:	68bb      	ldr	r3, [r7, #8]
  403322:	f103 0304 	add.w	r3, r3, #4
  403326:	4610      	mov	r0, r2
  403328:	4619      	mov	r1, r3
  40332a:	f641 339d 	movw	r3, #7069	; 0x1b9d
  40332e:	f2c0 0340 	movt	r3, #64	; 0x40
  403332:	4798      	blx	r3
						{
							/* Preemption is on, but a context switch should only
							be performed if the unblocked task has a priority that
							is equal to or higher than the currently executing
							task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  403334:	68bb      	ldr	r3, [r7, #8]
  403336:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403338:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  40333c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403340:	681b      	ldr	r3, [r3, #0]
  403342:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403344:	429a      	cmp	r2, r3
  403346:	d389      	bcc.n	40325c <xTaskIncrementTick+0x104>
							{
								xSwitchRequired = pdTRUE;
  403348:	f04f 0301 	mov.w	r3, #1
  40334c:	617b      	str	r3, [r7, #20]
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
  40334e:	e785      	b.n	40325c <xTaskIncrementTick+0x104>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  403350:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403354:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403358:	681b      	ldr	r3, [r3, #0]
  40335a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  40335c:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  403360:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403364:	460b      	mov	r3, r1
  403366:	ea4f 0383 	mov.w	r3, r3, lsl #2
  40336a:	185b      	adds	r3, r3, r1
  40336c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403370:	18d3      	adds	r3, r2, r3
  403372:	681b      	ldr	r3, [r3, #0]
  403374:	2b01      	cmp	r3, #1
  403376:	d902      	bls.n	40337e <xTaskIncrementTick+0x226>
			{
				xSwitchRequired = pdTRUE;
  403378:	f04f 0301 	mov.w	r3, #1
  40337c:	617b      	str	r3, [r7, #20]

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( unsigned portBASE_TYPE ) 0U )
  40337e:	f24a 53d0 	movw	r3, #42448	; 0xa5d0
  403382:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403386:	681b      	ldr	r3, [r3, #0]
  403388:	2b00      	cmp	r3, #0
  40338a:	d116      	bne.n	4033ba <xTaskIncrementTick+0x262>
			{
				vApplicationTickHook();
  40338c:	f244 73b5 	movw	r3, #18357	; 0x47b5
  403390:	f2c0 0340 	movt	r3, #64	; 0x40
  403394:	4798      	blx	r3
  403396:	e010      	b.n	4033ba <xTaskIncrementTick+0x262>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
  403398:	f24a 53d0 	movw	r3, #42448	; 0xa5d0
  40339c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4033a0:	681b      	ldr	r3, [r3, #0]
  4033a2:	f103 0201 	add.w	r2, r3, #1
  4033a6:	f24a 53d0 	movw	r3, #42448	; 0xa5d0
  4033aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4033ae:	601a      	str	r2, [r3, #0]

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
  4033b0:	f244 73b5 	movw	r3, #18357	; 0x47b5
  4033b4:	f2c0 0340 	movt	r3, #64	; 0x40
  4033b8:	4798      	blx	r3
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
  4033ba:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  4033be:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4033c2:	681b      	ldr	r3, [r3, #0]
  4033c4:	2b00      	cmp	r3, #0
  4033c6:	d002      	beq.n	4033ce <xTaskIncrementTick+0x276>
		{
			xSwitchRequired = pdTRUE;
  4033c8:	f04f 0301 	mov.w	r3, #1
  4033cc:	617b      	str	r3, [r7, #20]
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
  4033ce:	697b      	ldr	r3, [r7, #20]
}
  4033d0:	4618      	mov	r0, r3
  4033d2:	f107 0718 	add.w	r7, r7, #24
  4033d6:	46bd      	mov	sp, r7
  4033d8:	bd80      	pop	{r7, pc}
  4033da:	bf00      	nop

004033dc <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  4033dc:	b590      	push	{r4, r7, lr}
  4033de:	b085      	sub	sp, #20
  4033e0:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  4033e2:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  4033e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4033ea:	681b      	ldr	r3, [r3, #0]
  4033ec:	2b00      	cmp	r3, #0
  4033ee:	d007      	beq.n	403400 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
  4033f0:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  4033f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4033f8:	f04f 0201 	mov.w	r2, #1
  4033fc:	601a      	str	r2, [r3, #0]
  4033fe:	e098      	b.n	403532 <vTaskSwitchContext+0x156>
	}
	else
	{
		xYieldPending = pdFALSE;
  403400:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  403404:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403408:	f04f 0200 	mov.w	r2, #0
  40340c:	601a      	str	r2, [r3, #0]
				}
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
  40340e:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403412:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403416:	681b      	ldr	r3, [r3, #0]
  403418:	681a      	ldr	r2, [r3, #0]
  40341a:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  40341e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403422:	681b      	ldr	r3, [r3, #0]
  403424:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  403426:	429a      	cmp	r2, r3
  403428:	d812      	bhi.n	403450 <vTaskSwitchContext+0x74>
  40342a:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  40342e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403432:	681a      	ldr	r2, [r3, #0]
  403434:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403438:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40343c:	681b      	ldr	r3, [r3, #0]
  40343e:	f103 0334 	add.w	r3, r3, #52	; 0x34
  403442:	4610      	mov	r0, r2
  403444:	4619      	mov	r1, r3
  403446:	f244 739d 	movw	r3, #18333	; 0x479d
  40344a:	f2c0 0340 	movt	r3, #64	; 0x40
  40344e:	4798      	blx	r3
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
  403450:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403454:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403458:	681b      	ldr	r3, [r3, #0]
  40345a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40345c:	4618      	mov	r0, r3
  40345e:	f644 4158 	movw	r1, #19544	; 0x4c58
  403462:	f2c0 0140 	movt	r1, #64	; 0x40
  403466:	f04f 0214 	mov.w	r2, #20
  40346a:	f644 33e5 	movw	r3, #19429	; 0x4be5
  40346e:	f2c0 0340 	movt	r3, #64	; 0x40
  403472:	4798      	blx	r3
  403474:	4603      	mov	r3, r0
  403476:	2b00      	cmp	r3, #0
  403478:	d012      	beq.n	4034a0 <vTaskSwitchContext+0xc4>
  40347a:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  40347e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403482:	681a      	ldr	r2, [r3, #0]
  403484:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403488:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40348c:	681b      	ldr	r3, [r3, #0]
  40348e:	f103 0334 	add.w	r3, r3, #52	; 0x34
  403492:	4610      	mov	r0, r2
  403494:	4619      	mov	r1, r3
  403496:	f244 739d 	movw	r3, #18333	; 0x479d
  40349a:	f2c0 0340 	movt	r3, #64	; 0x40
  40349e:	4798      	blx	r3

		taskSELECT_HIGHEST_PRIORITY_TASK();
  4034a0:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  4034a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4034a8:	681b      	ldr	r3, [r3, #0]
  4034aa:	607b      	str	r3, [r7, #4]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline unsigned char ucPortCountLeadingZeros( unsigned long ulBitmap )
	{
	unsigned char ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
  4034ac:	687b      	ldr	r3, [r7, #4]
  4034ae:	fab3 f483 	clz	r4, r3
  4034b2:	70fc      	strb	r4, [r7, #3]
		return ucReturn;
  4034b4:	78fb      	ldrb	r3, [r7, #3]
  4034b6:	f1c3 031f 	rsb	r3, r3, #31
  4034ba:	60fb      	str	r3, [r7, #12]
  4034bc:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  4034c0:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4034c4:	68f9      	ldr	r1, [r7, #12]
  4034c6:	460b      	mov	r3, r1
  4034c8:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4034cc:	185b      	adds	r3, r3, r1
  4034ce:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4034d2:	18d3      	adds	r3, r2, r3
  4034d4:	681b      	ldr	r3, [r3, #0]
  4034d6:	2b00      	cmp	r3, #0
  4034d8:	d105      	bne.n	4034e6 <vTaskSwitchContext+0x10a>
  4034da:	f641 7321 	movw	r3, #7969	; 0x1f21
  4034de:	f2c0 0340 	movt	r3, #64	; 0x40
  4034e2:	4798      	blx	r3
  4034e4:	e7fe      	b.n	4034e4 <vTaskSwitchContext+0x108>
  4034e6:	68fa      	ldr	r2, [r7, #12]
  4034e8:	4613      	mov	r3, r2
  4034ea:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4034ee:	189b      	adds	r3, r3, r2
  4034f0:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4034f4:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  4034f8:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4034fc:	189b      	adds	r3, r3, r2
  4034fe:	60bb      	str	r3, [r7, #8]
  403500:	68bb      	ldr	r3, [r7, #8]
  403502:	685b      	ldr	r3, [r3, #4]
  403504:	685a      	ldr	r2, [r3, #4]
  403506:	68bb      	ldr	r3, [r7, #8]
  403508:	605a      	str	r2, [r3, #4]
  40350a:	68bb      	ldr	r3, [r7, #8]
  40350c:	685a      	ldr	r2, [r3, #4]
  40350e:	68bb      	ldr	r3, [r7, #8]
  403510:	f103 0308 	add.w	r3, r3, #8
  403514:	429a      	cmp	r2, r3
  403516:	d104      	bne.n	403522 <vTaskSwitchContext+0x146>
  403518:	68bb      	ldr	r3, [r7, #8]
  40351a:	685b      	ldr	r3, [r3, #4]
  40351c:	685a      	ldr	r2, [r3, #4]
  40351e:	68bb      	ldr	r3, [r7, #8]
  403520:	605a      	str	r2, [r3, #4]
  403522:	68bb      	ldr	r3, [r7, #8]
  403524:	685b      	ldr	r3, [r3, #4]
  403526:	68da      	ldr	r2, [r3, #12]
  403528:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  40352c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403530:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  403532:	f107 0714 	add.w	r7, r7, #20
  403536:	46bd      	mov	sp, r7
  403538:	bd90      	pop	{r4, r7, pc}
  40353a:	bf00      	nop

0040353c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
{
  40353c:	b580      	push	{r7, lr}
  40353e:	b084      	sub	sp, #16
  403540:	af00      	add	r7, sp, #0
  403542:	6078      	str	r0, [r7, #4]
  403544:	6039      	str	r1, [r7, #0]
portTickType xTimeToWake;

	configASSERT( pxEventList );
  403546:	687b      	ldr	r3, [r7, #4]
  403548:	2b00      	cmp	r3, #0
  40354a:	d105      	bne.n	403558 <vTaskPlaceOnEventList+0x1c>
  40354c:	f641 7321 	movw	r3, #7969	; 0x1f21
  403550:	f2c0 0340 	movt	r3, #64	; 0x40
  403554:	4798      	blx	r3
  403556:	e7fe      	b.n	403556 <vTaskPlaceOnEventList+0x1a>
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  403558:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  40355c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403560:	681b      	ldr	r3, [r3, #0]
  403562:	f103 0318 	add.w	r3, r3, #24
  403566:	6878      	ldr	r0, [r7, #4]
  403568:	4619      	mov	r1, r3
  40356a:	f641 33e5 	movw	r3, #7141	; 0x1be5
  40356e:	f2c0 0340 	movt	r3, #64	; 0x40
  403572:	4798      	blx	r3

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  403574:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403578:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40357c:	681b      	ldr	r3, [r3, #0]
  40357e:	f103 0304 	add.w	r3, r3, #4
  403582:	4618      	mov	r0, r3
  403584:	f641 4359 	movw	r3, #7257	; 0x1c59
  403588:	f2c0 0340 	movt	r3, #64	; 0x40
  40358c:	4798      	blx	r3
  40358e:	4603      	mov	r3, r0
  403590:	2b00      	cmp	r3, #0
  403592:	d116      	bne.n	4035c2 <vTaskPlaceOnEventList+0x86>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  403594:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403598:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40359c:	681b      	ldr	r3, [r3, #0]
  40359e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4035a0:	f04f 0201 	mov.w	r2, #1
  4035a4:	fa02 f303 	lsl.w	r3, r2, r3
  4035a8:	ea6f 0203 	mvn.w	r2, r3
  4035ac:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  4035b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4035b4:	681b      	ldr	r3, [r3, #0]
  4035b6:	401a      	ands	r2, r3
  4035b8:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  4035bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4035c0:	601a      	str	r2, [r3, #0]
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
  4035c2:	683b      	ldr	r3, [r7, #0]
  4035c4:	f1b3 3fff 	cmp.w	r3, #4294967295
  4035c8:	d111      	bne.n	4035ee <vTaskPlaceOnEventList+0xb2>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
  4035ca:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  4035ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4035d2:	681b      	ldr	r3, [r3, #0]
  4035d4:	f103 0304 	add.w	r3, r3, #4
  4035d8:	f24a 50a8 	movw	r0, #42408	; 0xa5a8
  4035dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4035e0:	4619      	mov	r1, r3
  4035e2:	f641 339d 	movw	r3, #7069	; 0x1b9d
  4035e6:	f2c0 0340 	movt	r3, #64	; 0x40
  4035ea:	4798      	blx	r3
  4035ec:	e00d      	b.n	40360a <vTaskPlaceOnEventList+0xce>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  4035ee:	f24a 53c0 	movw	r3, #42432	; 0xa5c0
  4035f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4035f6:	681a      	ldr	r2, [r3, #0]
  4035f8:	683b      	ldr	r3, [r7, #0]
  4035fa:	18d3      	adds	r3, r2, r3
  4035fc:	60fb      	str	r3, [r7, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  4035fe:	68f8      	ldr	r0, [r7, #12]
  403600:	f643 3345 	movw	r3, #15173	; 0x3b45
  403604:	f2c0 0340 	movt	r3, #64	; 0x40
  403608:	4798      	blx	r3
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  40360a:	f107 0710 	add.w	r7, r7, #16
  40360e:	46bd      	mov	sp, r7
  403610:	bd80      	pop	{r7, pc}
  403612:	bf00      	nop

00403614 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait )
	{
  403614:	b580      	push	{r7, lr}
  403616:	b084      	sub	sp, #16
  403618:	af00      	add	r7, sp, #0
  40361a:	6078      	str	r0, [r7, #4]
  40361c:	6039      	str	r1, [r7, #0]
	portTickType xTimeToWake;

		configASSERT( pxEventList );
  40361e:	687b      	ldr	r3, [r7, #4]
  403620:	2b00      	cmp	r3, #0
  403622:	d105      	bne.n	403630 <vTaskPlaceOnEventListRestricted+0x1c>
  403624:	f641 7321 	movw	r3, #7969	; 0x1f21
  403628:	f2c0 0340 	movt	r3, #64	; 0x40
  40362c:	4798      	blx	r3
  40362e:	e7fe      	b.n	40362e <vTaskPlaceOnEventListRestricted+0x1a>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  403630:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403634:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403638:	681b      	ldr	r3, [r3, #0]
  40363a:	f103 0318 	add.w	r3, r3, #24
  40363e:	6878      	ldr	r0, [r7, #4]
  403640:	4619      	mov	r1, r3
  403642:	f641 339d 	movw	r3, #7069	; 0x1b9d
  403646:	f2c0 0340 	movt	r3, #64	; 0x40
  40364a:	4798      	blx	r3

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  40364c:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403650:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403654:	681b      	ldr	r3, [r3, #0]
  403656:	f103 0304 	add.w	r3, r3, #4
  40365a:	4618      	mov	r0, r3
  40365c:	f641 4359 	movw	r3, #7257	; 0x1c59
  403660:	f2c0 0340 	movt	r3, #64	; 0x40
  403664:	4798      	blx	r3
  403666:	4603      	mov	r3, r0
  403668:	2b00      	cmp	r3, #0
  40366a:	d116      	bne.n	40369a <vTaskPlaceOnEventListRestricted+0x86>
		{
			/* The current task must be in a ready list, so there is no need to
			check, and the port reset macro can be called directly. */
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  40366c:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403670:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403674:	681b      	ldr	r3, [r3, #0]
  403676:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403678:	f04f 0201 	mov.w	r2, #1
  40367c:	fa02 f303 	lsl.w	r3, r2, r3
  403680:	ea6f 0203 	mvn.w	r2, r3
  403684:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403688:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40368c:	681b      	ldr	r3, [r3, #0]
  40368e:	401a      	ands	r2, r3
  403690:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403694:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403698:	601a      	str	r2, [r3, #0]
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
  40369a:	f24a 53c0 	movw	r3, #42432	; 0xa5c0
  40369e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4036a2:	681a      	ldr	r2, [r3, #0]
  4036a4:	683b      	ldr	r3, [r7, #0]
  4036a6:	18d3      	adds	r3, r2, r3
  4036a8:	60fb      	str	r3, [r7, #12]

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
  4036aa:	68f8      	ldr	r0, [r7, #12]
  4036ac:	f643 3345 	movw	r3, #15173	; 0x3b45
  4036b0:	f2c0 0340 	movt	r3, #64	; 0x40
  4036b4:	4798      	blx	r3
	}
  4036b6:	f107 0710 	add.w	r7, r7, #16
  4036ba:	46bd      	mov	sp, r7
  4036bc:	bd80      	pop	{r7, pc}
  4036be:	bf00      	nop

004036c0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
  4036c0:	b580      	push	{r7, lr}
  4036c2:	b084      	sub	sp, #16
  4036c4:	af00      	add	r7, sp, #0
  4036c6:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  4036c8:	687b      	ldr	r3, [r7, #4]
  4036ca:	68db      	ldr	r3, [r3, #12]
  4036cc:	68db      	ldr	r3, [r3, #12]
  4036ce:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
  4036d0:	68bb      	ldr	r3, [r7, #8]
  4036d2:	2b00      	cmp	r3, #0
  4036d4:	d105      	bne.n	4036e2 <xTaskRemoveFromEventList+0x22>
  4036d6:	f641 7321 	movw	r3, #7969	; 0x1f21
  4036da:	f2c0 0340 	movt	r3, #64	; 0x40
  4036de:	4798      	blx	r3
  4036e0:	e7fe      	b.n	4036e0 <xTaskRemoveFromEventList+0x20>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  4036e2:	68bb      	ldr	r3, [r7, #8]
  4036e4:	f103 0318 	add.w	r3, r3, #24
  4036e8:	4618      	mov	r0, r3
  4036ea:	f641 4359 	movw	r3, #7257	; 0x1c59
  4036ee:	f2c0 0340 	movt	r3, #64	; 0x40
  4036f2:	4798      	blx	r3

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4036f4:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  4036f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4036fc:	681b      	ldr	r3, [r3, #0]
  4036fe:	2b00      	cmp	r3, #0
  403700:	d131      	bne.n	403766 <xTaskRemoveFromEventList+0xa6>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  403702:	68bb      	ldr	r3, [r7, #8]
  403704:	f103 0304 	add.w	r3, r3, #4
  403708:	4618      	mov	r0, r3
  40370a:	f641 4359 	movw	r3, #7257	; 0x1c59
  40370e:	f2c0 0340 	movt	r3, #64	; 0x40
  403712:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
  403714:	68bb      	ldr	r3, [r7, #8]
  403716:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403718:	f04f 0201 	mov.w	r2, #1
  40371c:	fa02 f203 	lsl.w	r2, r2, r3
  403720:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403724:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403728:	681b      	ldr	r3, [r3, #0]
  40372a:	431a      	orrs	r2, r3
  40372c:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403730:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403734:	601a      	str	r2, [r3, #0]
  403736:	68bb      	ldr	r3, [r7, #8]
  403738:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40373a:	4613      	mov	r3, r2
  40373c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403740:	189b      	adds	r3, r3, r2
  403742:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403746:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  40374a:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40374e:	189a      	adds	r2, r3, r2
  403750:	68bb      	ldr	r3, [r7, #8]
  403752:	f103 0304 	add.w	r3, r3, #4
  403756:	4610      	mov	r0, r2
  403758:	4619      	mov	r1, r3
  40375a:	f641 339d 	movw	r3, #7069	; 0x1b9d
  40375e:	f2c0 0340 	movt	r3, #64	; 0x40
  403762:	4798      	blx	r3
  403764:	e00c      	b.n	403780 <xTaskRemoveFromEventList+0xc0>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  403766:	68bb      	ldr	r3, [r7, #8]
  403768:	f103 0318 	add.w	r3, r3, #24
  40376c:	f24a 507c 	movw	r0, #42364	; 0xa57c
  403770:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403774:	4619      	mov	r1, r3
  403776:	f641 339d 	movw	r3, #7069	; 0x1b9d
  40377a:	f2c0 0340 	movt	r3, #64	; 0x40
  40377e:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  403780:	68bb      	ldr	r3, [r7, #8]
  403782:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403784:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403788:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40378c:	681b      	ldr	r3, [r3, #0]
  40378e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403790:	429a      	cmp	r2, r3
  403792:	d30a      	bcc.n	4037aa <xTaskRemoveFromEventList+0xea>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
  403794:	f04f 0301 	mov.w	r3, #1
  403798:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
  40379a:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  40379e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4037a2:	f04f 0201 	mov.w	r2, #1
  4037a6:	601a      	str	r2, [r3, #0]
  4037a8:	e002      	b.n	4037b0 <xTaskRemoveFromEventList+0xf0>
	}
	else
	{
		xReturn = pdFALSE;
  4037aa:	f04f 0300 	mov.w	r3, #0
  4037ae:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
  4037b0:	68fb      	ldr	r3, [r7, #12]
}
  4037b2:	4618      	mov	r0, r3
  4037b4:	f107 0710 	add.w	r7, r7, #16
  4037b8:	46bd      	mov	sp, r7
  4037ba:	bd80      	pop	{r7, pc}

004037bc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
  4037bc:	b580      	push	{r7, lr}
  4037be:	b082      	sub	sp, #8
  4037c0:	af00      	add	r7, sp, #0
  4037c2:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
  4037c4:	687b      	ldr	r3, [r7, #4]
  4037c6:	2b00      	cmp	r3, #0
  4037c8:	d105      	bne.n	4037d6 <vTaskSetTimeOutState+0x1a>
  4037ca:	f641 7321 	movw	r3, #7969	; 0x1f21
  4037ce:	f2c0 0340 	movt	r3, #64	; 0x40
  4037d2:	4798      	blx	r3
  4037d4:	e7fe      	b.n	4037d4 <vTaskSetTimeOutState+0x18>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  4037d6:	f24a 53d8 	movw	r3, #42456	; 0xa5d8
  4037da:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4037de:	681a      	ldr	r2, [r3, #0]
  4037e0:	687b      	ldr	r3, [r7, #4]
  4037e2:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  4037e4:	f24a 53c0 	movw	r3, #42432	; 0xa5c0
  4037e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4037ec:	681a      	ldr	r2, [r3, #0]
  4037ee:	687b      	ldr	r3, [r7, #4]
  4037f0:	605a      	str	r2, [r3, #4]
}
  4037f2:	f107 0708 	add.w	r7, r7, #8
  4037f6:	46bd      	mov	sp, r7
  4037f8:	bd80      	pop	{r7, pc}
  4037fa:	bf00      	nop

004037fc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  4037fc:	b580      	push	{r7, lr}
  4037fe:	b084      	sub	sp, #16
  403800:	af00      	add	r7, sp, #0
  403802:	6078      	str	r0, [r7, #4]
  403804:	6039      	str	r1, [r7, #0]
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
  403806:	687b      	ldr	r3, [r7, #4]
  403808:	2b00      	cmp	r3, #0
  40380a:	d105      	bne.n	403818 <xTaskCheckForTimeOut+0x1c>
  40380c:	f641 7321 	movw	r3, #7969	; 0x1f21
  403810:	f2c0 0340 	movt	r3, #64	; 0x40
  403814:	4798      	blx	r3
  403816:	e7fe      	b.n	403816 <xTaskCheckForTimeOut+0x1a>
	configASSERT( pxTicksToWait );
  403818:	683b      	ldr	r3, [r7, #0]
  40381a:	2b00      	cmp	r3, #0
  40381c:	d105      	bne.n	40382a <xTaskCheckForTimeOut+0x2e>
  40381e:	f641 7321 	movw	r3, #7969	; 0x1f21
  403822:	f2c0 0340 	movt	r3, #64	; 0x40
  403826:	4798      	blx	r3
  403828:	e7fe      	b.n	403828 <xTaskCheckForTimeOut+0x2c>

	taskENTER_CRITICAL();
  40382a:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  40382e:	f2c0 0340 	movt	r3, #64	; 0x40
  403832:	4798      	blx	r3
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const portTickType xConstTickCount = xTickCount;
  403834:	f24a 53c0 	movw	r3, #42432	; 0xa5c0
  403838:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40383c:	681b      	ldr	r3, [r3, #0]
  40383e:	60bb      	str	r3, [r7, #8]

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
  403840:	683b      	ldr	r3, [r7, #0]
  403842:	681b      	ldr	r3, [r3, #0]
  403844:	f1b3 3fff 	cmp.w	r3, #4294967295
  403848:	d103      	bne.n	403852 <xTaskCheckForTimeOut+0x56>
			{
				xReturn = pdFALSE;
  40384a:	f04f 0300 	mov.w	r3, #0
  40384e:	60fb      	str	r3, [r7, #12]
  403850:	e02f      	b.n	4038b2 <xTaskCheckForTimeOut+0xb6>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  403852:	687b      	ldr	r3, [r7, #4]
  403854:	681a      	ldr	r2, [r3, #0]
  403856:	f24a 53d8 	movw	r3, #42456	; 0xa5d8
  40385a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40385e:	681b      	ldr	r3, [r3, #0]
  403860:	429a      	cmp	r2, r3
  403862:	d008      	beq.n	403876 <xTaskCheckForTimeOut+0x7a>
  403864:	687b      	ldr	r3, [r7, #4]
  403866:	685a      	ldr	r2, [r3, #4]
  403868:	68bb      	ldr	r3, [r7, #8]
  40386a:	429a      	cmp	r2, r3
  40386c:	d803      	bhi.n	403876 <xTaskCheckForTimeOut+0x7a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
  40386e:	f04f 0301 	mov.w	r3, #1
  403872:	60fb      	str	r3, [r7, #12]
  403874:	e01d      	b.n	4038b2 <xTaskCheckForTimeOut+0xb6>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
  403876:	687b      	ldr	r3, [r7, #4]
  403878:	685b      	ldr	r3, [r3, #4]
  40387a:	68ba      	ldr	r2, [r7, #8]
  40387c:	1ad2      	subs	r2, r2, r3
  40387e:	683b      	ldr	r3, [r7, #0]
  403880:	681b      	ldr	r3, [r3, #0]
  403882:	429a      	cmp	r2, r3
  403884:	d212      	bcs.n	4038ac <xTaskCheckForTimeOut+0xb0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
  403886:	683b      	ldr	r3, [r7, #0]
  403888:	681a      	ldr	r2, [r3, #0]
  40388a:	687b      	ldr	r3, [r7, #4]
  40388c:	6859      	ldr	r1, [r3, #4]
  40388e:	68bb      	ldr	r3, [r7, #8]
  403890:	1acb      	subs	r3, r1, r3
  403892:	18d2      	adds	r2, r2, r3
  403894:	683b      	ldr	r3, [r7, #0]
  403896:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
  403898:	6878      	ldr	r0, [r7, #4]
  40389a:	f243 73bd 	movw	r3, #14269	; 0x37bd
  40389e:	f2c0 0340 	movt	r3, #64	; 0x40
  4038a2:	4798      	blx	r3
			xReturn = pdFALSE;
  4038a4:	f04f 0300 	mov.w	r3, #0
  4038a8:	60fb      	str	r3, [r7, #12]
  4038aa:	e002      	b.n	4038b2 <xTaskCheckForTimeOut+0xb6>
		}
		else
		{
			xReturn = pdTRUE;
  4038ac:	f04f 0301 	mov.w	r3, #1
  4038b0:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  4038b2:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  4038b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4038ba:	4798      	blx	r3

	return xReturn;
  4038bc:	68fb      	ldr	r3, [r7, #12]
}
  4038be:	4618      	mov	r0, r3
  4038c0:	f107 0710 	add.w	r7, r7, #16
  4038c4:	46bd      	mov	sp, r7
  4038c6:	bd80      	pop	{r7, pc}

004038c8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
  4038c8:	b480      	push	{r7}
  4038ca:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
  4038cc:	f24a 53d4 	movw	r3, #42452	; 0xa5d4
  4038d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4038d4:	f04f 0201 	mov.w	r2, #1
  4038d8:	601a      	str	r2, [r3, #0]
}
  4038da:	46bd      	mov	sp, r7
  4038dc:	bc80      	pop	{r7}
  4038de:	4770      	bx	lr

004038e0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  4038e0:	b580      	push	{r7, lr}
  4038e2:	b082      	sub	sp, #8
  4038e4:	af00      	add	r7, sp, #0
  4038e6:	6078      	str	r0, [r7, #4]
  4038e8:	e000      	b.n	4038ec <prvIdleTask+0xc>
				}
				( void ) xTaskResumeAll();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
  4038ea:	bf00      	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
  4038ec:	f643 2385 	movw	r3, #14981	; 0x3a85
  4038f0:	f2c0 0340 	movt	r3, #64	; 0x40
  4038f4:	4798      	blx	r3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  4038f6:	f24a 43e8 	movw	r3, #42216	; 0xa4e8
  4038fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4038fe:	681b      	ldr	r3, [r3, #0]
  403900:	2b01      	cmp	r3, #1
  403902:	d9f2      	bls.n	4038ea <prvIdleTask+0xa>
			{
				taskYIELD();
  403904:	f641 6395 	movw	r3, #7829	; 0x1e95
  403908:	f2c0 0340 	movt	r3, #64	; 0x40
  40390c:	4798      	blx	r3
				}
				( void ) xTaskResumeAll();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
  40390e:	e7ec      	b.n	4038ea <prvIdleTask+0xa>

00403910 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
  403910:	b580      	push	{r7, lr}
  403912:	b086      	sub	sp, #24
  403914:	af00      	add	r7, sp, #0
  403916:	60f8      	str	r0, [r7, #12]
  403918:	60b9      	str	r1, [r7, #8]
  40391a:	607a      	str	r2, [r7, #4]
  40391c:	603b      	str	r3, [r7, #0]
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
  40391e:	f04f 0300 	mov.w	r3, #0
  403922:	617b      	str	r3, [r7, #20]
  403924:	e013      	b.n	40394e <prvInitialiseTCBVariables+0x3e>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
  403926:	68ba      	ldr	r2, [r7, #8]
  403928:	697b      	ldr	r3, [r7, #20]
  40392a:	18d3      	adds	r3, r2, r3
  40392c:	781a      	ldrb	r2, [r3, #0]
  40392e:	68f9      	ldr	r1, [r7, #12]
  403930:	697b      	ldr	r3, [r7, #20]
  403932:	18cb      	adds	r3, r1, r3
  403934:	f103 0330 	add.w	r3, r3, #48	; 0x30
  403938:	711a      	strb	r2, [r3, #4]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
  40393a:	68ba      	ldr	r2, [r7, #8]
  40393c:	697b      	ldr	r3, [r7, #20]
  40393e:	18d3      	adds	r3, r2, r3
  403940:	781b      	ldrb	r3, [r3, #0]
  403942:	2b00      	cmp	r3, #0
  403944:	d007      	beq.n	403956 <prvInitialiseTCBVariables+0x46>
static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
  403946:	697b      	ldr	r3, [r7, #20]
  403948:	f103 0301 	add.w	r3, r3, #1
  40394c:	617b      	str	r3, [r7, #20]
  40394e:	697b      	ldr	r3, [r7, #20]
  403950:	2b09      	cmp	r3, #9
  403952:	d9e8      	bls.n	403926 <prvInitialiseTCBVariables+0x16>
  403954:	e000      	b.n	403958 <prvInitialiseTCBVariables+0x48>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
  403956:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
  403958:	68fb      	ldr	r3, [r7, #12]
  40395a:	f04f 0200 	mov.w	r2, #0
  40395e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
  403962:	687b      	ldr	r3, [r7, #4]
  403964:	2b04      	cmp	r3, #4
  403966:	d902      	bls.n	40396e <prvInitialiseTCBVariables+0x5e>
	{
		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
  403968:	f04f 0304 	mov.w	r3, #4
  40396c:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
  40396e:	68fb      	ldr	r3, [r7, #12]
  403970:	687a      	ldr	r2, [r7, #4]
  403972:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
  403974:	68fb      	ldr	r3, [r7, #12]
  403976:	687a      	ldr	r2, [r7, #4]
  403978:	641a      	str	r2, [r3, #64]	; 0x40
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  40397a:	68fb      	ldr	r3, [r7, #12]
  40397c:	f103 0304 	add.w	r3, r3, #4
  403980:	4618      	mov	r0, r3
  403982:	f641 3381 	movw	r3, #7041	; 0x1b81
  403986:	f2c0 0340 	movt	r3, #64	; 0x40
  40398a:	4798      	blx	r3
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
  40398c:	68fb      	ldr	r3, [r7, #12]
  40398e:	f103 0318 	add.w	r3, r3, #24
  403992:	4618      	mov	r0, r3
  403994:	f641 3381 	movw	r3, #7041	; 0x1b81
  403998:	f2c0 0340 	movt	r3, #64	; 0x40
  40399c:	4798      	blx	r3

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
  40399e:	68fb      	ldr	r3, [r7, #12]
  4039a0:	68fa      	ldr	r2, [r7, #12]
  4039a2:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  4039a4:	687b      	ldr	r3, [r7, #4]
  4039a6:	f1c3 0205 	rsb	r2, r3, #5
  4039aa:	68fb      	ldr	r3, [r7, #12]
  4039ac:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
  4039ae:	68fb      	ldr	r3, [r7, #12]
  4039b0:	68fa      	ldr	r2, [r7, #12]
  4039b2:	625a      	str	r2, [r3, #36]	; 0x24
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
  4039b4:	f107 0718 	add.w	r7, r7, #24
  4039b8:	46bd      	mov	sp, r7
  4039ba:	bd80      	pop	{r7, pc}

004039bc <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
  4039bc:	b580      	push	{r7, lr}
  4039be:	b082      	sub	sp, #8
  4039c0:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
  4039c2:	f04f 0300 	mov.w	r3, #0
  4039c6:	607b      	str	r3, [r7, #4]
  4039c8:	e015      	b.n	4039f6 <prvInitialiseTaskLists+0x3a>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  4039ca:	687a      	ldr	r2, [r7, #4]
  4039cc:	4613      	mov	r3, r2
  4039ce:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4039d2:	189b      	adds	r3, r3, r2
  4039d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4039d8:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  4039dc:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4039e0:	189b      	adds	r3, r3, r2
  4039e2:	4618      	mov	r0, r3
  4039e4:	f641 3341 	movw	r3, #6977	; 0x1b41
  4039e8:	f2c0 0340 	movt	r3, #64	; 0x40
  4039ec:	4798      	blx	r3

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
  4039ee:	687b      	ldr	r3, [r7, #4]
  4039f0:	f103 0301 	add.w	r3, r3, #1
  4039f4:	607b      	str	r3, [r7, #4]
  4039f6:	687b      	ldr	r3, [r7, #4]
  4039f8:	2b04      	cmp	r3, #4
  4039fa:	d9e6      	bls.n	4039ca <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
  4039fc:	f24a 504c 	movw	r0, #42316	; 0xa54c
  403a00:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403a04:	f641 3341 	movw	r3, #6977	; 0x1b41
  403a08:	f2c0 0340 	movt	r3, #64	; 0x40
  403a0c:	4798      	blx	r3
	vListInitialise( &xDelayedTaskList2 );
  403a0e:	f24a 5060 	movw	r0, #42336	; 0xa560
  403a12:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403a16:	f641 3341 	movw	r3, #6977	; 0x1b41
  403a1a:	f2c0 0340 	movt	r3, #64	; 0x40
  403a1e:	4798      	blx	r3
	vListInitialise( &xPendingReadyList );
  403a20:	f24a 507c 	movw	r0, #42364	; 0xa57c
  403a24:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403a28:	f641 3341 	movw	r3, #6977	; 0x1b41
  403a2c:	f2c0 0340 	movt	r3, #64	; 0x40
  403a30:	4798      	blx	r3

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
  403a32:	f24a 5090 	movw	r0, #42384	; 0xa590
  403a36:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403a3a:	f641 3341 	movw	r3, #6977	; 0x1b41
  403a3e:	f2c0 0340 	movt	r3, #64	; 0x40
  403a42:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
  403a44:	f24a 50a8 	movw	r0, #42408	; 0xa5a8
  403a48:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403a4c:	f641 3341 	movw	r3, #6977	; 0x1b41
  403a50:	f2c0 0340 	movt	r3, #64	; 0x40
  403a54:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  403a56:	f24a 5374 	movw	r3, #42356	; 0xa574
  403a5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403a5e:	f24a 524c 	movw	r2, #42316	; 0xa54c
  403a62:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403a66:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  403a68:	f24a 5378 	movw	r3, #42360	; 0xa578
  403a6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403a70:	f24a 5260 	movw	r2, #42336	; 0xa560
  403a74:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403a78:	601a      	str	r2, [r3, #0]
}
  403a7a:	f107 0708 	add.w	r7, r7, #8
  403a7e:	46bd      	mov	sp, r7
  403a80:	bd80      	pop	{r7, pc}
  403a82:	bf00      	nop

00403a84 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
  403a84:	b580      	push	{r7, lr}
  403a86:	b082      	sub	sp, #8
  403a88:	af00      	add	r7, sp, #0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  403a8a:	e04f      	b.n	403b2c <prvCheckTasksWaitingTermination+0xa8>
		{
			vTaskSuspendAll();
  403a8c:	f642 735d 	movw	r3, #12125	; 0x2f5d
  403a90:	f2c0 0340 	movt	r3, #64	; 0x40
  403a94:	4798      	blx	r3
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  403a96:	f24a 5390 	movw	r3, #42384	; 0xa590
  403a9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403a9e:	681b      	ldr	r3, [r3, #0]
  403aa0:	2b00      	cmp	r3, #0
  403aa2:	bf14      	ite	ne
  403aa4:	2300      	movne	r3, #0
  403aa6:	2301      	moveq	r3, #1
  403aa8:	b2db      	uxtb	r3, r3
  403aaa:	607b      	str	r3, [r7, #4]
			( void ) xTaskResumeAll();
  403aac:	f642 7381 	movw	r3, #12161	; 0x2f81
  403ab0:	f2c0 0340 	movt	r3, #64	; 0x40
  403ab4:	4798      	blx	r3

			if( xListIsEmpty == pdFALSE )
  403ab6:	687b      	ldr	r3, [r7, #4]
  403ab8:	2b00      	cmp	r3, #0
  403aba:	d137      	bne.n	403b2c <prvCheckTasksWaitingTermination+0xa8>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
  403abc:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  403ac0:	f2c0 0340 	movt	r3, #64	; 0x40
  403ac4:	4798      	blx	r3
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
  403ac6:	f24a 5390 	movw	r3, #42384	; 0xa590
  403aca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ace:	68db      	ldr	r3, [r3, #12]
  403ad0:	68db      	ldr	r3, [r3, #12]
  403ad2:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
  403ad4:	683b      	ldr	r3, [r7, #0]
  403ad6:	f103 0304 	add.w	r3, r3, #4
  403ada:	4618      	mov	r0, r3
  403adc:	f641 4359 	movw	r3, #7257	; 0x1c59
  403ae0:	f2c0 0340 	movt	r3, #64	; 0x40
  403ae4:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
  403ae6:	f24a 53bc 	movw	r3, #42428	; 0xa5bc
  403aea:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403aee:	681b      	ldr	r3, [r3, #0]
  403af0:	f103 32ff 	add.w	r2, r3, #4294967295
  403af4:	f24a 53bc 	movw	r3, #42428	; 0xa5bc
  403af8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403afc:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
  403afe:	f24a 53a4 	movw	r3, #42404	; 0xa5a4
  403b02:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b06:	681b      	ldr	r3, [r3, #0]
  403b08:	f103 32ff 	add.w	r2, r3, #4294967295
  403b0c:	f24a 53a4 	movw	r3, #42404	; 0xa5a4
  403b10:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b14:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
  403b16:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  403b1a:	f2c0 0340 	movt	r3, #64	; 0x40
  403b1e:	4798      	blx	r3

				prvDeleteTCB( pxTCB );
  403b20:	6838      	ldr	r0, [r7, #0]
  403b22:	f643 4365 	movw	r3, #15461	; 0x3c65
  403b26:	f2c0 0340 	movt	r3, #64	; 0x40
  403b2a:	4798      	blx	r3
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  403b2c:	f24a 53a4 	movw	r3, #42404	; 0xa5a4
  403b30:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b34:	681b      	ldr	r3, [r3, #0]
  403b36:	2b00      	cmp	r3, #0
  403b38:	d1a8      	bne.n	403a8c <prvCheckTasksWaitingTermination+0x8>
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif /* vTaskDelete */
}
  403b3a:	f107 0708 	add.w	r7, r7, #8
  403b3e:	46bd      	mov	sp, r7
  403b40:	bd80      	pop	{r7, pc}
  403b42:	bf00      	nop

00403b44 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  403b44:	b580      	push	{r7, lr}
  403b46:	b082      	sub	sp, #8
  403b48:	af00      	add	r7, sp, #0
  403b4a:	6078      	str	r0, [r7, #4]
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  403b4c:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403b50:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b54:	681b      	ldr	r3, [r3, #0]
  403b56:	687a      	ldr	r2, [r7, #4]
  403b58:	605a      	str	r2, [r3, #4]

	if( xTimeToWake < xTickCount )
  403b5a:	f24a 53c0 	movw	r3, #42432	; 0xa5c0
  403b5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b62:	681b      	ldr	r3, [r3, #0]
  403b64:	687a      	ldr	r2, [r7, #4]
  403b66:	429a      	cmp	r2, r3
  403b68:	d213      	bcs.n	403b92 <prvAddCurrentTaskToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
  403b6a:	f24a 5378 	movw	r3, #42360	; 0xa578
  403b6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b72:	681a      	ldr	r2, [r3, #0]
  403b74:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403b78:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b7c:	681b      	ldr	r3, [r3, #0]
  403b7e:	f103 0304 	add.w	r3, r3, #4
  403b82:	4610      	mov	r0, r2
  403b84:	4619      	mov	r1, r3
  403b86:	f641 33e5 	movw	r3, #7141	; 0x1be5
  403b8a:	f2c0 0340 	movt	r3, #64	; 0x40
  403b8e:	4798      	blx	r3
  403b90:	e020      	b.n	403bd4 <prvAddCurrentTaskToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
  403b92:	f24a 5374 	movw	r3, #42356	; 0xa574
  403b96:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b9a:	681a      	ldr	r2, [r3, #0]
  403b9c:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403ba0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ba4:	681b      	ldr	r3, [r3, #0]
  403ba6:	f103 0304 	add.w	r3, r3, #4
  403baa:	4610      	mov	r0, r2
  403bac:	4619      	mov	r1, r3
  403bae:	f641 33e5 	movw	r3, #7141	; 0x1be5
  403bb2:	f2c0 0340 	movt	r3, #64	; 0x40
  403bb6:	4798      	blx	r3

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
  403bb8:	f240 030c 	movw	r3, #12
  403bbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403bc0:	681b      	ldr	r3, [r3, #0]
  403bc2:	687a      	ldr	r2, [r7, #4]
  403bc4:	429a      	cmp	r2, r3
  403bc6:	d205      	bcs.n	403bd4 <prvAddCurrentTaskToDelayedList+0x90>
		{
			xNextTaskUnblockTime = xTimeToWake;
  403bc8:	f240 030c 	movw	r3, #12
  403bcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403bd0:	687a      	ldr	r2, [r7, #4]
  403bd2:	601a      	str	r2, [r3, #0]
		}
	}
}
  403bd4:	f107 0708 	add.w	r7, r7, #8
  403bd8:	46bd      	mov	sp, r7
  403bda:	bd80      	pop	{r7, pc}

00403bdc <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
  403bdc:	b580      	push	{r7, lr}
  403bde:	b084      	sub	sp, #16
  403be0:	af00      	add	r7, sp, #0
  403be2:	4603      	mov	r3, r0
  403be4:	6039      	str	r1, [r7, #0]
  403be6:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
  403be8:	f04f 0044 	mov.w	r0, #68	; 0x44
  403bec:	f240 5311 	movw	r3, #1297	; 0x511
  403bf0:	f2c0 0340 	movt	r3, #64	; 0x40
  403bf4:	4798      	blx	r3
  403bf6:	60f8      	str	r0, [r7, #12]

	if( pxNewTCB != NULL )
  403bf8:	68fb      	ldr	r3, [r7, #12]
  403bfa:	2b00      	cmp	r3, #0
  403bfc:	d02c      	beq.n	403c58 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  403bfe:	683b      	ldr	r3, [r7, #0]
  403c00:	2b00      	cmp	r3, #0
  403c02:	d10a      	bne.n	403c1a <prvAllocateTCBAndStack+0x3e>
  403c04:	88fb      	ldrh	r3, [r7, #6]
  403c06:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403c0a:	4618      	mov	r0, r3
  403c0c:	f240 5311 	movw	r3, #1297	; 0x511
  403c10:	f2c0 0340 	movt	r3, #64	; 0x40
  403c14:	4798      	blx	r3
  403c16:	4603      	mov	r3, r0
  403c18:	e000      	b.n	403c1c <prvAllocateTCBAndStack+0x40>
  403c1a:	683b      	ldr	r3, [r7, #0]
  403c1c:	68fa      	ldr	r2, [r7, #12]
  403c1e:	6313      	str	r3, [r2, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
  403c20:	68fb      	ldr	r3, [r7, #12]
  403c22:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  403c24:	2b00      	cmp	r3, #0
  403c26:	d109      	bne.n	403c3c <prvAllocateTCBAndStack+0x60>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
  403c28:	68f8      	ldr	r0, [r7, #12]
  403c2a:	f240 6391 	movw	r3, #1681	; 0x691
  403c2e:	f2c0 0340 	movt	r3, #64	; 0x40
  403c32:	4798      	blx	r3
			pxNewTCB = NULL;
  403c34:	f04f 0300 	mov.w	r3, #0
  403c38:	60fb      	str	r3, [r7, #12]
  403c3a:	e00d      	b.n	403c58 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
  403c3c:	68fb      	ldr	r3, [r7, #12]
  403c3e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  403c40:	88fb      	ldrh	r3, [r7, #6]
  403c42:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403c46:	4610      	mov	r0, r2
  403c48:	f04f 01a5 	mov.w	r1, #165	; 0xa5
  403c4c:	461a      	mov	r2, r3
  403c4e:	f644 4315 	movw	r3, #19477	; 0x4c15
  403c52:	f2c0 0340 	movt	r3, #64	; 0x40
  403c56:	4798      	blx	r3
		}
	}

	return pxNewTCB;
  403c58:	68fb      	ldr	r3, [r7, #12]
}
  403c5a:	4618      	mov	r0, r3
  403c5c:	f107 0710 	add.w	r7, r7, #16
  403c60:	46bd      	mov	sp, r7
  403c62:	bd80      	pop	{r7, pc}

00403c64 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
  403c64:	b580      	push	{r7, lr}
  403c66:	b082      	sub	sp, #8
  403c68:	af00      	add	r7, sp, #0
  403c6a:	6078      	str	r0, [r7, #4]
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
  403c6c:	687b      	ldr	r3, [r7, #4]
  403c6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  403c70:	4618      	mov	r0, r3
  403c72:	f240 6391 	movw	r3, #1681	; 0x691
  403c76:	f2c0 0340 	movt	r3, #64	; 0x40
  403c7a:	4798      	blx	r3
		vPortFree( pxTCB );
  403c7c:	6878      	ldr	r0, [r7, #4]
  403c7e:	f240 6391 	movw	r3, #1681	; 0x691
  403c82:	f2c0 0340 	movt	r3, #64	; 0x40
  403c86:	4798      	blx	r3
	}
  403c88:	f107 0708 	add.w	r7, r7, #8
  403c8c:	46bd      	mov	sp, r7
  403c8e:	bd80      	pop	{r7, pc}

00403c90 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
  403c90:	b480      	push	{r7}
  403c92:	b083      	sub	sp, #12
  403c94:	af00      	add	r7, sp, #0
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  403c96:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403c9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403c9e:	681b      	ldr	r3, [r3, #0]
  403ca0:	607b      	str	r3, [r7, #4]

		return xReturn;
  403ca2:	687b      	ldr	r3, [r7, #4]
	}
  403ca4:	4618      	mov	r0, r3
  403ca6:	f107 070c 	add.w	r7, r7, #12
  403caa:	46bd      	mov	sp, r7
  403cac:	bc80      	pop	{r7}
  403cae:	4770      	bx	lr

00403cb0 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
  403cb0:	b480      	push	{r7}
  403cb2:	b083      	sub	sp, #12
  403cb4:	af00      	add	r7, sp, #0
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
  403cb6:	f24a 53c8 	movw	r3, #42440	; 0xa5c8
  403cba:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403cbe:	681b      	ldr	r3, [r3, #0]
  403cc0:	2b00      	cmp	r3, #0
  403cc2:	d103      	bne.n	403ccc <xTaskGetSchedulerState+0x1c>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
  403cc4:	f04f 0300 	mov.w	r3, #0
  403cc8:	607b      	str	r3, [r7, #4]
  403cca:	e00d      	b.n	403ce8 <xTaskGetSchedulerState+0x38>
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  403ccc:	f24a 53cc 	movw	r3, #42444	; 0xa5cc
  403cd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403cd4:	681b      	ldr	r3, [r3, #0]
  403cd6:	2b00      	cmp	r3, #0
  403cd8:	d103      	bne.n	403ce2 <xTaskGetSchedulerState+0x32>
			{
				xReturn = taskSCHEDULER_RUNNING;
  403cda:	f04f 0301 	mov.w	r3, #1
  403cde:	607b      	str	r3, [r7, #4]
  403ce0:	e002      	b.n	403ce8 <xTaskGetSchedulerState+0x38>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
  403ce2:	f04f 0302 	mov.w	r3, #2
  403ce6:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
  403ce8:	687b      	ldr	r3, [r7, #4]
	}
  403cea:	4618      	mov	r0, r3
  403cec:	f107 070c 	add.w	r7, r7, #12
  403cf0:	46bd      	mov	sp, r7
  403cf2:	bc80      	pop	{r7}
  403cf4:	4770      	bx	lr
  403cf6:	bf00      	nop

00403cf8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle const pxMutexHolder )
	{
  403cf8:	b580      	push	{r7, lr}
  403cfa:	b084      	sub	sp, #16
  403cfc:	af00      	add	r7, sp, #0
  403cfe:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
  403d00:	687b      	ldr	r3, [r7, #4]
  403d02:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
  403d04:	687b      	ldr	r3, [r7, #4]
  403d06:	2b00      	cmp	r3, #0
  403d08:	f000 8095 	beq.w	403e36 <vTaskPriorityInherit+0x13e>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  403d0c:	68fb      	ldr	r3, [r7, #12]
  403d0e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403d10:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403d14:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d18:	681b      	ldr	r3, [r3, #0]
  403d1a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403d1c:	429a      	cmp	r2, r3
  403d1e:	f080 808a 	bcs.w	403e36 <vTaskPriorityInherit+0x13e>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  403d22:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403d26:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d2a:	681b      	ldr	r3, [r3, #0]
  403d2c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403d2e:	f1c3 0205 	rsb	r2, r3, #5
  403d32:	68fb      	ldr	r3, [r7, #12]
  403d34:	619a      	str	r2, [r3, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
  403d36:	68fb      	ldr	r3, [r7, #12]
  403d38:	6959      	ldr	r1, [r3, #20]
  403d3a:	68fb      	ldr	r3, [r7, #12]
  403d3c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403d3e:	4613      	mov	r3, r2
  403d40:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403d44:	189b      	adds	r3, r3, r2
  403d46:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403d4a:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  403d4e:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403d52:	189b      	adds	r3, r3, r2
  403d54:	4299      	cmp	r1, r3
  403d56:	d102      	bne.n	403d5e <vTaskPriorityInherit+0x66>
  403d58:	f04f 0301 	mov.w	r3, #1
  403d5c:	e001      	b.n	403d62 <vTaskPriorityInherit+0x6a>
  403d5e:	f04f 0300 	mov.w	r3, #0
  403d62:	2b00      	cmp	r3, #0
  403d64:	d05f      	beq.n	403e26 <vTaskPriorityInherit+0x12e>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  403d66:	68fb      	ldr	r3, [r7, #12]
  403d68:	f103 0304 	add.w	r3, r3, #4
  403d6c:	4618      	mov	r0, r3
  403d6e:	f641 4359 	movw	r3, #7257	; 0x1c59
  403d72:	f2c0 0340 	movt	r3, #64	; 0x40
  403d76:	4798      	blx	r3
  403d78:	4603      	mov	r3, r0
  403d7a:	2b00      	cmp	r3, #0
  403d7c:	d122      	bne.n	403dc4 <vTaskPriorityInherit+0xcc>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  403d7e:	68fb      	ldr	r3, [r7, #12]
  403d80:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  403d82:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  403d86:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403d8a:	460b      	mov	r3, r1
  403d8c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403d90:	185b      	adds	r3, r3, r1
  403d92:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403d96:	18d3      	adds	r3, r2, r3
  403d98:	681b      	ldr	r3, [r3, #0]
  403d9a:	2b00      	cmp	r3, #0
  403d9c:	d112      	bne.n	403dc4 <vTaskPriorityInherit+0xcc>
  403d9e:	68fb      	ldr	r3, [r7, #12]
  403da0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403da2:	f04f 0201 	mov.w	r2, #1
  403da6:	fa02 f303 	lsl.w	r3, r2, r3
  403daa:	ea6f 0203 	mvn.w	r2, r3
  403dae:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403db2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403db6:	681b      	ldr	r3, [r3, #0]
  403db8:	401a      	ands	r2, r3
  403dba:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403dbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403dc2:	601a      	str	r2, [r3, #0]
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  403dc4:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403dc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403dcc:	681b      	ldr	r3, [r3, #0]
  403dce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403dd0:	68fb      	ldr	r3, [r7, #12]
  403dd2:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
  403dd4:	68fb      	ldr	r3, [r7, #12]
  403dd6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403dd8:	f04f 0201 	mov.w	r2, #1
  403ddc:	fa02 f203 	lsl.w	r2, r2, r3
  403de0:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403de4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403de8:	681b      	ldr	r3, [r3, #0]
  403dea:	431a      	orrs	r2, r3
  403dec:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403df0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403df4:	601a      	str	r2, [r3, #0]
  403df6:	68fb      	ldr	r3, [r7, #12]
  403df8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403dfa:	4613      	mov	r3, r2
  403dfc:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403e00:	189b      	adds	r3, r3, r2
  403e02:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403e06:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  403e0a:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403e0e:	189a      	adds	r2, r3, r2
  403e10:	68fb      	ldr	r3, [r7, #12]
  403e12:	f103 0304 	add.w	r3, r3, #4
  403e16:	4610      	mov	r0, r2
  403e18:	4619      	mov	r1, r3
  403e1a:	f641 339d 	movw	r3, #7069	; 0x1b9d
  403e1e:	f2c0 0340 	movt	r3, #64	; 0x40
  403e22:	4798      	blx	r3
  403e24:	e007      	b.n	403e36 <vTaskPriorityInherit+0x13e>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  403e26:	f24a 43e4 	movw	r3, #42212	; 0xa4e4
  403e2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e2e:	681b      	ldr	r3, [r3, #0]
  403e30:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403e32:	68fb      	ldr	r3, [r7, #12]
  403e34:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
  403e36:	f107 0710 	add.w	r7, r7, #16
  403e3a:	46bd      	mov	sp, r7
  403e3c:	bd80      	pop	{r7, pc}
  403e3e:	bf00      	nop

00403e40 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder )
	{
  403e40:	b580      	push	{r7, lr}
  403e42:	b084      	sub	sp, #16
  403e44:	af00      	add	r7, sp, #0
  403e46:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
  403e48:	687b      	ldr	r3, [r7, #4]
  403e4a:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
  403e4c:	687b      	ldr	r3, [r7, #4]
  403e4e:	2b00      	cmp	r3, #0
  403e50:	d066      	beq.n	403f20 <vTaskPriorityDisinherit+0xe0>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  403e52:	68fb      	ldr	r3, [r7, #12]
  403e54:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403e56:	68fb      	ldr	r3, [r7, #12]
  403e58:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  403e5a:	429a      	cmp	r2, r3
  403e5c:	d060      	beq.n	403f20 <vTaskPriorityDisinherit+0xe0>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  403e5e:	68fb      	ldr	r3, [r7, #12]
  403e60:	f103 0304 	add.w	r3, r3, #4
  403e64:	4618      	mov	r0, r3
  403e66:	f641 4359 	movw	r3, #7257	; 0x1c59
  403e6a:	f2c0 0340 	movt	r3, #64	; 0x40
  403e6e:	4798      	blx	r3
  403e70:	4603      	mov	r3, r0
  403e72:	2b00      	cmp	r3, #0
  403e74:	d122      	bne.n	403ebc <vTaskPriorityDisinherit+0x7c>
				{
					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  403e76:	68fb      	ldr	r3, [r7, #12]
  403e78:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  403e7a:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  403e7e:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403e82:	460b      	mov	r3, r1
  403e84:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403e88:	185b      	adds	r3, r3, r1
  403e8a:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403e8e:	18d3      	adds	r3, r2, r3
  403e90:	681b      	ldr	r3, [r3, #0]
  403e92:	2b00      	cmp	r3, #0
  403e94:	d112      	bne.n	403ebc <vTaskPriorityDisinherit+0x7c>
  403e96:	68fb      	ldr	r3, [r7, #12]
  403e98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403e9a:	f04f 0201 	mov.w	r2, #1
  403e9e:	fa02 f303 	lsl.w	r3, r2, r3
  403ea2:	ea6f 0203 	mvn.w	r2, r3
  403ea6:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403eaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403eae:	681b      	ldr	r3, [r3, #0]
  403eb0:	401a      	ands	r2, r3
  403eb2:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403eb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403eba:	601a      	str	r2, [r3, #0]
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  403ebc:	68fb      	ldr	r3, [r7, #12]
  403ebe:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  403ec0:	68fb      	ldr	r3, [r7, #12]
  403ec2:	62da      	str	r2, [r3, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  403ec4:	68fb      	ldr	r3, [r7, #12]
  403ec6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403ec8:	f1c3 0205 	rsb	r2, r3, #5
  403ecc:	68fb      	ldr	r3, [r7, #12]
  403ece:	619a      	str	r2, [r3, #24]
				prvAddTaskToReadyList( pxTCB );
  403ed0:	68fb      	ldr	r3, [r7, #12]
  403ed2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  403ed4:	f04f 0201 	mov.w	r2, #1
  403ed8:	fa02 f203 	lsl.w	r2, r2, r3
  403edc:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403ee0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ee4:	681b      	ldr	r3, [r3, #0]
  403ee6:	431a      	orrs	r2, r3
  403ee8:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
  403eec:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ef0:	601a      	str	r2, [r3, #0]
  403ef2:	68fb      	ldr	r3, [r7, #12]
  403ef4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  403ef6:	4613      	mov	r3, r2
  403ef8:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403efc:	189b      	adds	r3, r3, r2
  403efe:	ea4f 0383 	mov.w	r3, r3, lsl #2
  403f02:	f24a 42e8 	movw	r2, #42216	; 0xa4e8
  403f06:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403f0a:	189a      	adds	r2, r3, r2
  403f0c:	68fb      	ldr	r3, [r7, #12]
  403f0e:	f103 0304 	add.w	r3, r3, #4
  403f12:	4610      	mov	r0, r2
  403f14:	4619      	mov	r1, r3
  403f16:	f641 339d 	movw	r3, #7069	; 0x1b9d
  403f1a:	f2c0 0340 	movt	r3, #64	; 0x40
  403f1e:	4798      	blx	r3
			}
		}
	}
  403f20:	f107 0710 	add.w	r7, r7, #16
  403f24:	46bd      	mov	sp, r7
  403f26:	bd80      	pop	{r7, pc}

00403f28 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
  403f28:	b590      	push	{r4, r7, lr}
  403f2a:	b087      	sub	sp, #28
  403f2c:	af04      	add	r7, sp, #16
portBASE_TYPE xReturn = pdFAIL;
  403f2e:	f04f 0300 	mov.w	r3, #0
  403f32:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
  403f34:	f244 5371 	movw	r3, #17777	; 0x4571
  403f38:	f2c0 0340 	movt	r3, #64	; 0x40
  403f3c:	4798      	blx	r3

	if( xTimerQueue != NULL )
  403f3e:	f24a 6310 	movw	r3, #42512	; 0xa610
  403f42:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403f46:	681b      	ldr	r3, [r3, #0]
  403f48:	2b00      	cmp	r3, #0
  403f4a:	d01d      	beq.n	403f88 <xTimerCreateTimerTask+0x60>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
  403f4c:	f04f 0302 	mov.w	r3, #2
  403f50:	9300      	str	r3, [sp, #0]
  403f52:	f04f 0300 	mov.w	r3, #0
  403f56:	9301      	str	r3, [sp, #4]
  403f58:	f04f 0300 	mov.w	r3, #0
  403f5c:	9302      	str	r3, [sp, #8]
  403f5e:	f04f 0300 	mov.w	r3, #0
  403f62:	9303      	str	r3, [sp, #12]
  403f64:	f244 1001 	movw	r0, #16641	; 0x4101
  403f68:	f2c0 0040 	movt	r0, #64	; 0x40
  403f6c:	f644 416c 	movw	r1, #19564	; 0x4c6c
  403f70:	f2c0 0140 	movt	r1, #64	; 0x40
  403f74:	f44f 7282 	mov.w	r2, #260	; 0x104
  403f78:	f04f 0300 	mov.w	r3, #0
  403f7c:	f642 34a5 	movw	r4, #11173	; 0x2ba5
  403f80:	f2c0 0440 	movt	r4, #64	; 0x40
  403f84:	47a0      	blx	r4
  403f86:	6078      	str	r0, [r7, #4]
		}
		#endif
	}

	configASSERT( xReturn );
  403f88:	687b      	ldr	r3, [r7, #4]
  403f8a:	2b00      	cmp	r3, #0
  403f8c:	d105      	bne.n	403f9a <xTimerCreateTimerTask+0x72>
  403f8e:	f641 7321 	movw	r3, #7969	; 0x1f21
  403f92:	f2c0 0340 	movt	r3, #64	; 0x40
  403f96:	4798      	blx	r3
  403f98:	e7fe      	b.n	403f98 <xTimerCreateTimerTask+0x70>
	return xReturn;
  403f9a:	687b      	ldr	r3, [r7, #4]
}
  403f9c:	4618      	mov	r0, r3
  403f9e:	f107 070c 	add.w	r7, r7, #12
  403fa2:	46bd      	mov	sp, r7
  403fa4:	bd90      	pop	{r4, r7, pc}
  403fa6:	bf00      	nop

00403fa8 <xTimerGenericCommand>:
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
  403fa8:	b590      	push	{r4, r7, lr}
  403faa:	b089      	sub	sp, #36	; 0x24
  403fac:	af00      	add	r7, sp, #0
  403fae:	60f8      	str	r0, [r7, #12]
  403fb0:	60b9      	str	r1, [r7, #8]
  403fb2:	607a      	str	r2, [r7, #4]
  403fb4:	603b      	str	r3, [r7, #0]
portBASE_TYPE xReturn = pdFAIL;
  403fb6:	f04f 0300 	mov.w	r3, #0
  403fba:	61fb      	str	r3, [r7, #28]
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
  403fbc:	f24a 6310 	movw	r3, #42512	; 0xa610
  403fc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403fc4:	681b      	ldr	r3, [r3, #0]
  403fc6:	2b00      	cmp	r3, #0
  403fc8:	d049      	beq.n	40405e <xTimerGenericCommand+0xb6>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
  403fca:	68bb      	ldr	r3, [r7, #8]
  403fcc:	613b      	str	r3, [r7, #16]
		xMessage.xMessageValue = xOptionalValue;
  403fce:	687b      	ldr	r3, [r7, #4]
  403fd0:	617b      	str	r3, [r7, #20]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
  403fd2:	68fb      	ldr	r3, [r7, #12]
  403fd4:	61bb      	str	r3, [r7, #24]

		if( pxHigherPriorityTaskWoken == NULL )
  403fd6:	683b      	ldr	r3, [r7, #0]
  403fd8:	2b00      	cmp	r3, #0
  403fda:	d12e      	bne.n	40403a <xTimerGenericCommand+0x92>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  403fdc:	f643 43b1 	movw	r3, #15537	; 0x3cb1
  403fe0:	f2c0 0340 	movt	r3, #64	; 0x40
  403fe4:	4798      	blx	r3
  403fe6:	4603      	mov	r3, r0
  403fe8:	2b01      	cmp	r3, #1
  403fea:	d112      	bne.n	404012 <xTimerGenericCommand+0x6a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
  403fec:	f24a 6310 	movw	r3, #42512	; 0xa610
  403ff0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ff4:	681a      	ldr	r2, [r3, #0]
  403ff6:	f107 0310 	add.w	r3, r7, #16
  403ffa:	4610      	mov	r0, r2
  403ffc:	4619      	mov	r1, r3
  403ffe:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  404000:	f04f 0300 	mov.w	r3, #0
  404004:	f242 14f9 	movw	r4, #8697	; 0x21f9
  404008:	f2c0 0440 	movt	r4, #64	; 0x40
  40400c:	47a0      	blx	r4
  40400e:	61f8      	str	r0, [r7, #28]
  404010:	e025      	b.n	40405e <xTimerGenericCommand+0xb6>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  404012:	f24a 6310 	movw	r3, #42512	; 0xa610
  404016:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40401a:	681a      	ldr	r2, [r3, #0]
  40401c:	f107 0310 	add.w	r3, r7, #16
  404020:	4610      	mov	r0, r2
  404022:	4619      	mov	r1, r3
  404024:	f04f 0200 	mov.w	r2, #0
  404028:	f04f 0300 	mov.w	r3, #0
  40402c:	f242 14f9 	movw	r4, #8697	; 0x21f9
  404030:	f2c0 0440 	movt	r4, #64	; 0x40
  404034:	47a0      	blx	r4
  404036:	61f8      	str	r0, [r7, #28]
  404038:	e011      	b.n	40405e <xTimerGenericCommand+0xb6>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  40403a:	f24a 6310 	movw	r3, #42512	; 0xa610
  40403e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404042:	681a      	ldr	r2, [r3, #0]
  404044:	f107 0310 	add.w	r3, r7, #16
  404048:	4610      	mov	r0, r2
  40404a:	4619      	mov	r1, r3
  40404c:	683a      	ldr	r2, [r7, #0]
  40404e:	f04f 0300 	mov.w	r3, #0
  404052:	f242 442d 	movw	r4, #9261	; 0x242d
  404056:	f2c0 0440 	movt	r4, #64	; 0x40
  40405a:	47a0      	blx	r4
  40405c:	61f8      	str	r0, [r7, #28]
		}

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
  40405e:	69fb      	ldr	r3, [r7, #28]
}
  404060:	4618      	mov	r0, r3
  404062:	f107 0724 	add.w	r7, r7, #36	; 0x24
  404066:	46bd      	mov	sp, r7
  404068:	bd90      	pop	{r4, r7, pc}
  40406a:	bf00      	nop

0040406c <prvProcessExpiredTimer>:

#endif
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
{
  40406c:	b590      	push	{r4, r7, lr}
  40406e:	b087      	sub	sp, #28
  404070:	af02      	add	r7, sp, #8
  404072:	6078      	str	r0, [r7, #4]
  404074:	6039      	str	r1, [r7, #0]
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  404076:	f24a 6308 	movw	r3, #42504	; 0xa608
  40407a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40407e:	681b      	ldr	r3, [r3, #0]
  404080:	68db      	ldr	r3, [r3, #12]
  404082:	68db      	ldr	r3, [r3, #12]
  404084:	60fb      	str	r3, [r7, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  404086:	68fb      	ldr	r3, [r7, #12]
  404088:	f103 0304 	add.w	r3, r3, #4
  40408c:	4618      	mov	r0, r3
  40408e:	f641 4359 	movw	r3, #7257	; 0x1c59
  404092:	f2c0 0340 	movt	r3, #64	; 0x40
  404096:	4798      	blx	r3
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  404098:	68fb      	ldr	r3, [r7, #12]
  40409a:	69db      	ldr	r3, [r3, #28]
  40409c:	2b01      	cmp	r3, #1
  40409e:	d127      	bne.n	4040f0 <prvProcessExpiredTimer+0x84>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
  4040a0:	68fb      	ldr	r3, [r7, #12]
  4040a2:	699a      	ldr	r2, [r3, #24]
  4040a4:	687b      	ldr	r3, [r7, #4]
  4040a6:	18d3      	adds	r3, r2, r3
  4040a8:	68f8      	ldr	r0, [r7, #12]
  4040aa:	4619      	mov	r1, r3
  4040ac:	683a      	ldr	r2, [r7, #0]
  4040ae:	687b      	ldr	r3, [r7, #4]
  4040b0:	f244 2495 	movw	r4, #17045	; 0x4295
  4040b4:	f2c0 0440 	movt	r4, #64	; 0x40
  4040b8:	47a0      	blx	r4
  4040ba:	4603      	mov	r3, r0
  4040bc:	2b01      	cmp	r3, #1
  4040be:	d117      	bne.n	4040f0 <prvProcessExpiredTimer+0x84>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  4040c0:	f04f 0300 	mov.w	r3, #0
  4040c4:	9300      	str	r3, [sp, #0]
  4040c6:	68f8      	ldr	r0, [r7, #12]
  4040c8:	f04f 0100 	mov.w	r1, #0
  4040cc:	687a      	ldr	r2, [r7, #4]
  4040ce:	f04f 0300 	mov.w	r3, #0
  4040d2:	f643 74a9 	movw	r4, #16297	; 0x3fa9
  4040d6:	f2c0 0440 	movt	r4, #64	; 0x40
  4040da:	47a0      	blx	r4
  4040dc:	60b8      	str	r0, [r7, #8]
			configASSERT( xResult );
  4040de:	68bb      	ldr	r3, [r7, #8]
  4040e0:	2b00      	cmp	r3, #0
  4040e2:	d105      	bne.n	4040f0 <prvProcessExpiredTimer+0x84>
  4040e4:	f641 7321 	movw	r3, #7969	; 0x1f21
  4040e8:	f2c0 0340 	movt	r3, #64	; 0x40
  4040ec:	4798      	blx	r3
  4040ee:	e7fe      	b.n	4040ee <prvProcessExpiredTimer+0x82>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  4040f0:	68fb      	ldr	r3, [r7, #12]
  4040f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4040f4:	68f8      	ldr	r0, [r7, #12]
  4040f6:	4798      	blx	r3
}
  4040f8:	f107 0714 	add.w	r7, r7, #20
  4040fc:	46bd      	mov	sp, r7
  4040fe:	bd90      	pop	{r4, r7, pc}

00404100 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
  404100:	b580      	push	{r7, lr}
  404102:	b084      	sub	sp, #16
  404104:	af00      	add	r7, sp, #0
  404106:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
  404108:	f107 0308 	add.w	r3, r7, #8
  40410c:	4618      	mov	r0, r3
  40410e:	f244 13dd 	movw	r3, #16861	; 0x41dd
  404112:	f2c0 0340 	movt	r3, #64	; 0x40
  404116:	4798      	blx	r3
  404118:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
  40411a:	68bb      	ldr	r3, [r7, #8]
  40411c:	68f8      	ldr	r0, [r7, #12]
  40411e:	4619      	mov	r1, r3
  404120:	f244 1339 	movw	r3, #16697	; 0x4139
  404124:	f2c0 0340 	movt	r3, #64	; 0x40
  404128:	4798      	blx	r3

		/* Empty the command queue. */
		prvProcessReceivedCommands();
  40412a:	f244 3335 	movw	r3, #17205	; 0x4335
  40412e:	f2c0 0340 	movt	r3, #64	; 0x40
  404132:	4798      	blx	r3
	}
  404134:	e7e8      	b.n	404108 <prvTimerTask+0x8>
  404136:	bf00      	nop

00404138 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
  404138:	b580      	push	{r7, lr}
  40413a:	b084      	sub	sp, #16
  40413c:	af00      	add	r7, sp, #0
  40413e:	6078      	str	r0, [r7, #4]
  404140:	6039      	str	r1, [r7, #0]
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  404142:	f642 735d 	movw	r3, #12125	; 0x2f5d
  404146:	f2c0 0340 	movt	r3, #64	; 0x40
  40414a:	4798      	blx	r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  40414c:	f107 0308 	add.w	r3, r7, #8
  404150:	4618      	mov	r0, r3
  404152:	f244 2331 	movw	r3, #16945	; 0x4231
  404156:	f2c0 0340 	movt	r3, #64	; 0x40
  40415a:	4798      	blx	r3
  40415c:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
  40415e:	68bb      	ldr	r3, [r7, #8]
  404160:	2b00      	cmp	r3, #0
  404162:	d130      	bne.n	4041c6 <prvProcessTimerOrBlockTask+0x8e>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  404164:	683b      	ldr	r3, [r7, #0]
  404166:	2b00      	cmp	r3, #0
  404168:	d110      	bne.n	40418c <prvProcessTimerOrBlockTask+0x54>
  40416a:	687a      	ldr	r2, [r7, #4]
  40416c:	68fb      	ldr	r3, [r7, #12]
  40416e:	429a      	cmp	r2, r3
  404170:	d80c      	bhi.n	40418c <prvProcessTimerOrBlockTask+0x54>
			{
				( void ) xTaskResumeAll();
  404172:	f642 7381 	movw	r3, #12161	; 0x2f81
  404176:	f2c0 0340 	movt	r3, #64	; 0x40
  40417a:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
  40417c:	6878      	ldr	r0, [r7, #4]
  40417e:	68f9      	ldr	r1, [r7, #12]
  404180:	f244 036d 	movw	r3, #16493	; 0x406d
  404184:	f2c0 0340 	movt	r3, #64	; 0x40
  404188:	4798      	blx	r3
  40418a:	e023      	b.n	4041d4 <prvProcessTimerOrBlockTask+0x9c>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
  40418c:	f24a 6310 	movw	r3, #42512	; 0xa610
  404190:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404194:	681a      	ldr	r2, [r3, #0]
  404196:	6879      	ldr	r1, [r7, #4]
  404198:	68fb      	ldr	r3, [r7, #12]
  40419a:	1acb      	subs	r3, r1, r3
  40419c:	4610      	mov	r0, r2
  40419e:	4619      	mov	r1, r3
  4041a0:	f642 2399 	movw	r3, #10905	; 0x2a99
  4041a4:	f2c0 0340 	movt	r3, #64	; 0x40
  4041a8:	4798      	blx	r3

				if( xTaskResumeAll() == pdFALSE )
  4041aa:	f642 7381 	movw	r3, #12161	; 0x2f81
  4041ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4041b2:	4798      	blx	r3
  4041b4:	4603      	mov	r3, r0
  4041b6:	2b00      	cmp	r3, #0
  4041b8:	d10b      	bne.n	4041d2 <prvProcessTimerOrBlockTask+0x9a>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
  4041ba:	f641 6395 	movw	r3, #7829	; 0x1e95
  4041be:	f2c0 0340 	movt	r3, #64	; 0x40
  4041c2:	4798      	blx	r3
  4041c4:	e005      	b.n	4041d2 <prvProcessTimerOrBlockTask+0x9a>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
  4041c6:	f642 7381 	movw	r3, #12161	; 0x2f81
  4041ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4041ce:	4798      	blx	r3
  4041d0:	e000      	b.n	4041d4 <prvProcessTimerOrBlockTask+0x9c>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
  4041d2:	bf00      	nop
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
  4041d4:	f107 0710 	add.w	r7, r7, #16
  4041d8:	46bd      	mov	sp, r7
  4041da:	bd80      	pop	{r7, pc}

004041dc <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
{
  4041dc:	b480      	push	{r7}
  4041de:	b085      	sub	sp, #20
  4041e0:	af00      	add	r7, sp, #0
  4041e2:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  4041e4:	f24a 6308 	movw	r3, #42504	; 0xa608
  4041e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4041ec:	681b      	ldr	r3, [r3, #0]
  4041ee:	681b      	ldr	r3, [r3, #0]
  4041f0:	2b00      	cmp	r3, #0
  4041f2:	bf14      	ite	ne
  4041f4:	2300      	movne	r3, #0
  4041f6:	2301      	moveq	r3, #1
  4041f8:	b2db      	uxtb	r3, r3
  4041fa:	461a      	mov	r2, r3
  4041fc:	687b      	ldr	r3, [r7, #4]
  4041fe:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
  404200:	687b      	ldr	r3, [r7, #4]
  404202:	681b      	ldr	r3, [r3, #0]
  404204:	2b00      	cmp	r3, #0
  404206:	d108      	bne.n	40421a <prvGetNextExpireTime+0x3e>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  404208:	f24a 6308 	movw	r3, #42504	; 0xa608
  40420c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404210:	681b      	ldr	r3, [r3, #0]
  404212:	68db      	ldr	r3, [r3, #12]
  404214:	681b      	ldr	r3, [r3, #0]
  404216:	60fb      	str	r3, [r7, #12]
  404218:	e002      	b.n	404220 <prvGetNextExpireTime+0x44>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
  40421a:	f04f 0300 	mov.w	r3, #0
  40421e:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
  404220:	68fb      	ldr	r3, [r7, #12]
}
  404222:	4618      	mov	r0, r3
  404224:	f107 0714 	add.w	r7, r7, #20
  404228:	46bd      	mov	sp, r7
  40422a:	bc80      	pop	{r7}
  40422c:	4770      	bx	lr
  40422e:	bf00      	nop

00404230 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
  404230:	b580      	push	{r7, lr}
  404232:	b084      	sub	sp, #16
  404234:	af00      	add	r7, sp, #0
  404236:	6078      	str	r0, [r7, #4]
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
  404238:	f243 1325 	movw	r3, #12581	; 0x3125
  40423c:	f2c0 0340 	movt	r3, #64	; 0x40
  404240:	4798      	blx	r3
  404242:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
  404244:	f24a 6314 	movw	r3, #42516	; 0xa614
  404248:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40424c:	681b      	ldr	r3, [r3, #0]
  40424e:	68fa      	ldr	r2, [r7, #12]
  404250:	429a      	cmp	r2, r3
  404252:	d20f      	bcs.n	404274 <prvSampleTimeNow+0x44>
	{
		prvSwitchTimerLists( xLastTime );
  404254:	f24a 6314 	movw	r3, #42516	; 0xa614
  404258:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40425c:	681b      	ldr	r3, [r3, #0]
  40425e:	4618      	mov	r0, r3
  404260:	f244 4371 	movw	r3, #17521	; 0x4471
  404264:	f2c0 0340 	movt	r3, #64	; 0x40
  404268:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
  40426a:	687b      	ldr	r3, [r7, #4]
  40426c:	f04f 0201 	mov.w	r2, #1
  404270:	601a      	str	r2, [r3, #0]
  404272:	e003      	b.n	40427c <prvSampleTimeNow+0x4c>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
  404274:	687b      	ldr	r3, [r7, #4]
  404276:	f04f 0200 	mov.w	r2, #0
  40427a:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
  40427c:	f24a 6314 	movw	r3, #42516	; 0xa614
  404280:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404284:	68fa      	ldr	r2, [r7, #12]
  404286:	601a      	str	r2, [r3, #0]

	return xTimeNow;
  404288:	68fb      	ldr	r3, [r7, #12]
}
  40428a:	4618      	mov	r0, r3
  40428c:	f107 0710 	add.w	r7, r7, #16
  404290:	46bd      	mov	sp, r7
  404292:	bd80      	pop	{r7, pc}

00404294 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
  404294:	b580      	push	{r7, lr}
  404296:	b086      	sub	sp, #24
  404298:	af00      	add	r7, sp, #0
  40429a:	60f8      	str	r0, [r7, #12]
  40429c:	60b9      	str	r1, [r7, #8]
  40429e:	607a      	str	r2, [r7, #4]
  4042a0:	603b      	str	r3, [r7, #0]
portBASE_TYPE xProcessTimerNow = pdFALSE;
  4042a2:	f04f 0300 	mov.w	r3, #0
  4042a6:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  4042a8:	68fb      	ldr	r3, [r7, #12]
  4042aa:	68ba      	ldr	r2, [r7, #8]
  4042ac:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  4042ae:	68fb      	ldr	r3, [r7, #12]
  4042b0:	68fa      	ldr	r2, [r7, #12]
  4042b2:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
  4042b4:	68ba      	ldr	r2, [r7, #8]
  4042b6:	687b      	ldr	r3, [r7, #4]
  4042b8:	429a      	cmp	r2, r3
  4042ba:	d81a      	bhi.n	4042f2 <prvInsertTimerInActiveList+0x5e>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
  4042bc:	687a      	ldr	r2, [r7, #4]
  4042be:	683b      	ldr	r3, [r7, #0]
  4042c0:	1ad2      	subs	r2, r2, r3
  4042c2:	68fb      	ldr	r3, [r7, #12]
  4042c4:	699b      	ldr	r3, [r3, #24]
  4042c6:	429a      	cmp	r2, r3
  4042c8:	d303      	bcc.n	4042d2 <prvInsertTimerInActiveList+0x3e>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  4042ca:	f04f 0301 	mov.w	r3, #1
  4042ce:	617b      	str	r3, [r7, #20]
  4042d0:	e02a      	b.n	404328 <prvInsertTimerInActiveList+0x94>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  4042d2:	f24a 630c 	movw	r3, #42508	; 0xa60c
  4042d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4042da:	681a      	ldr	r2, [r3, #0]
  4042dc:	68fb      	ldr	r3, [r7, #12]
  4042de:	f103 0304 	add.w	r3, r3, #4
  4042e2:	4610      	mov	r0, r2
  4042e4:	4619      	mov	r1, r3
  4042e6:	f641 33e5 	movw	r3, #7141	; 0x1be5
  4042ea:	f2c0 0340 	movt	r3, #64	; 0x40
  4042ee:	4798      	blx	r3
  4042f0:	e01a      	b.n	404328 <prvInsertTimerInActiveList+0x94>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  4042f2:	687a      	ldr	r2, [r7, #4]
  4042f4:	683b      	ldr	r3, [r7, #0]
  4042f6:	429a      	cmp	r2, r3
  4042f8:	d207      	bcs.n	40430a <prvInsertTimerInActiveList+0x76>
  4042fa:	68ba      	ldr	r2, [r7, #8]
  4042fc:	683b      	ldr	r3, [r7, #0]
  4042fe:	429a      	cmp	r2, r3
  404300:	d303      	bcc.n	40430a <prvInsertTimerInActiveList+0x76>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
  404302:	f04f 0301 	mov.w	r3, #1
  404306:	617b      	str	r3, [r7, #20]
  404308:	e00e      	b.n	404328 <prvInsertTimerInActiveList+0x94>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  40430a:	f24a 6308 	movw	r3, #42504	; 0xa608
  40430e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404312:	681a      	ldr	r2, [r3, #0]
  404314:	68fb      	ldr	r3, [r7, #12]
  404316:	f103 0304 	add.w	r3, r3, #4
  40431a:	4610      	mov	r0, r2
  40431c:	4619      	mov	r1, r3
  40431e:	f641 33e5 	movw	r3, #7141	; 0x1be5
  404322:	f2c0 0340 	movt	r3, #64	; 0x40
  404326:	4798      	blx	r3
		}
	}

	return xProcessTimerNow;
  404328:	697b      	ldr	r3, [r7, #20]
}
  40432a:	4618      	mov	r0, r3
  40432c:	f107 0718 	add.w	r7, r7, #24
  404330:	46bd      	mov	sp, r7
  404332:	bd80      	pop	{r7, pc}

00404334 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
  404334:	b590      	push	{r4, r7, lr}
  404336:	b08b      	sub	sp, #44	; 0x2c
  404338:	af02      	add	r7, sp, #8
xTIMER_MESSAGE xMessage;
xTIMER *pxTimer;
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  40433a:	e07e      	b.n	40443a <prvProcessReceivedCommands+0x106>
	{
		pxTimer = xMessage.pxTimer;
  40433c:	693b      	ldr	r3, [r7, #16]
  40433e:	61fb      	str	r3, [r7, #28]

		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
  404340:	69fb      	ldr	r3, [r7, #28]
  404342:	695b      	ldr	r3, [r3, #20]
  404344:	2b00      	cmp	r3, #0
  404346:	d008      	beq.n	40435a <prvProcessReceivedCommands+0x26>
		{
			/* The timer is in a list, remove it. */
			( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  404348:	69fb      	ldr	r3, [r7, #28]
  40434a:	f103 0304 	add.w	r3, r3, #4
  40434e:	4618      	mov	r0, r3
  404350:	f641 4359 	movw	r3, #7257	; 0x1c59
  404354:	f2c0 0340 	movt	r3, #64	; 0x40
  404358:	4798      	blx	r3
		it must be present in the function call.  prvSampleTimeNow() must be 
		called after the message is received from xTimerQueue so there is no 
		possibility of a higher priority task adding a message to the message
		queue with a time that is ahead of the timer daemon task (because it
		pre-empted the timer daemon task after the xTimeNow value was set). */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  40435a:	f107 0304 	add.w	r3, r7, #4
  40435e:	4618      	mov	r0, r3
  404360:	f244 2331 	movw	r3, #16945	; 0x4231
  404364:	f2c0 0340 	movt	r3, #64	; 0x40
  404368:	4798      	blx	r3
  40436a:	61b8      	str	r0, [r7, #24]

		switch( xMessage.xMessageID )
  40436c:	68bb      	ldr	r3, [r7, #8]
  40436e:	2b03      	cmp	r3, #3
  404370:	d860      	bhi.n	404434 <prvProcessReceivedCommands+0x100>
  404372:	a201      	add	r2, pc, #4	; (adr r2, 404378 <prvProcessReceivedCommands+0x44>)
  404374:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  404378:	00404389 	.word	0x00404389
  40437c:	00404435 	.word	0x00404435
  404380:	004043f1 	.word	0x004043f1
  404384:	00404427 	.word	0x00404427
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
  404388:	68fa      	ldr	r2, [r7, #12]
  40438a:	69fb      	ldr	r3, [r7, #28]
  40438c:	699b      	ldr	r3, [r3, #24]
  40438e:	18d2      	adds	r2, r2, r3
  404390:	68fb      	ldr	r3, [r7, #12]
  404392:	69f8      	ldr	r0, [r7, #28]
  404394:	4611      	mov	r1, r2
  404396:	69ba      	ldr	r2, [r7, #24]
  404398:	f244 2495 	movw	r4, #17045	; 0x4295
  40439c:	f2c0 0440 	movt	r4, #64	; 0x40
  4043a0:	47a0      	blx	r4
  4043a2:	4603      	mov	r3, r0
  4043a4:	2b01      	cmp	r3, #1
  4043a6:	d147      	bne.n	404438 <prvProcessReceivedCommands+0x104>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  4043a8:	69fb      	ldr	r3, [r7, #28]
  4043aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4043ac:	69f8      	ldr	r0, [r7, #28]
  4043ae:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  4043b0:	69fb      	ldr	r3, [r7, #28]
  4043b2:	69db      	ldr	r3, [r3, #28]
  4043b4:	2b01      	cmp	r3, #1
  4043b6:	d13f      	bne.n	404438 <prvProcessReceivedCommands+0x104>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  4043b8:	68fa      	ldr	r2, [r7, #12]
  4043ba:	69fb      	ldr	r3, [r7, #28]
  4043bc:	699b      	ldr	r3, [r3, #24]
  4043be:	18d3      	adds	r3, r2, r3
  4043c0:	f04f 0200 	mov.w	r2, #0
  4043c4:	9200      	str	r2, [sp, #0]
  4043c6:	69f8      	ldr	r0, [r7, #28]
  4043c8:	f04f 0100 	mov.w	r1, #0
  4043cc:	461a      	mov	r2, r3
  4043ce:	f04f 0300 	mov.w	r3, #0
  4043d2:	f643 74a9 	movw	r4, #16297	; 0x3fa9
  4043d6:	f2c0 0440 	movt	r4, #64	; 0x40
  4043da:	47a0      	blx	r4
  4043dc:	6178      	str	r0, [r7, #20]
						configASSERT( xResult );
  4043de:	697b      	ldr	r3, [r7, #20]
  4043e0:	2b00      	cmp	r3, #0
  4043e2:	d129      	bne.n	404438 <prvProcessReceivedCommands+0x104>
  4043e4:	f641 7321 	movw	r3, #7969	; 0x1f21
  4043e8:	f2c0 0340 	movt	r3, #64	; 0x40
  4043ec:	4798      	blx	r3
  4043ee:	e7fe      	b.n	4043ee <prvProcessReceivedCommands+0xba>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
  4043f0:	68fa      	ldr	r2, [r7, #12]
  4043f2:	69fb      	ldr	r3, [r7, #28]
  4043f4:	619a      	str	r2, [r3, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  4043f6:	69fb      	ldr	r3, [r7, #28]
  4043f8:	699b      	ldr	r3, [r3, #24]
  4043fa:	2b00      	cmp	r3, #0
  4043fc:	d105      	bne.n	40440a <prvProcessReceivedCommands+0xd6>
  4043fe:	f641 7321 	movw	r3, #7969	; 0x1f21
  404402:	f2c0 0340 	movt	r3, #64	; 0x40
  404406:	4798      	blx	r3
  404408:	e7fe      	b.n	404408 <prvProcessReceivedCommands+0xd4>
				longer or shorter than the old one.  The command time is 
				therefore set to the current time, and as the period cannot be
				zero the next expiry time can only be in the future, meaning
				(unlike for the xTimerStart() case above) there is no fail case
				that needs to be handled here. */
				( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  40440a:	69fb      	ldr	r3, [r7, #28]
  40440c:	699a      	ldr	r2, [r3, #24]
  40440e:	69bb      	ldr	r3, [r7, #24]
  404410:	18d3      	adds	r3, r2, r3
  404412:	69f8      	ldr	r0, [r7, #28]
  404414:	4619      	mov	r1, r3
  404416:	69ba      	ldr	r2, [r7, #24]
  404418:	69bb      	ldr	r3, [r7, #24]
  40441a:	f244 2495 	movw	r4, #17045	; 0x4295
  40441e:	f2c0 0440 	movt	r4, #64	; 0x40
  404422:	47a0      	blx	r4
				break;
  404424:	e009      	b.n	40443a <prvProcessReceivedCommands+0x106>

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
  404426:	69f8      	ldr	r0, [r7, #28]
  404428:	f240 6391 	movw	r3, #1681	; 0x691
  40442c:	f2c0 0340 	movt	r3, #64	; 0x40
  404430:	4798      	blx	r3
				break;
  404432:	e002      	b.n	40443a <prvProcessReceivedCommands+0x106>

			default	:
				/* Don't expect to get here. */
				break;
  404434:	bf00      	nop
  404436:	e000      	b.n	40443a <prvProcessReceivedCommands+0x106>
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
						configASSERT( xResult );
						( void ) xResult;
					}
				}
				break;
  404438:	bf00      	nop
xTIMER_MESSAGE xMessage;
xTIMER *pxTimer;
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  40443a:	f24a 6310 	movw	r3, #42512	; 0xa610
  40443e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404442:	681a      	ldr	r2, [r3, #0]
  404444:	f107 0308 	add.w	r3, r7, #8
  404448:	4610      	mov	r0, r2
  40444a:	4619      	mov	r1, r3
  40444c:	f04f 0200 	mov.w	r2, #0
  404450:	f04f 0300 	mov.w	r3, #0
  404454:	f242 5471 	movw	r4, #9585	; 0x2571
  404458:	f2c0 0440 	movt	r4, #64	; 0x40
  40445c:	47a0      	blx	r4
  40445e:	4603      	mov	r3, r0
  404460:	2b00      	cmp	r3, #0
  404462:	f47f af6b 	bne.w	40433c <prvProcessReceivedCommands+0x8>
			default	:
				/* Don't expect to get here. */
				break;
		}
	}
}
  404466:	f107 0724 	add.w	r7, r7, #36	; 0x24
  40446a:	46bd      	mov	sp, r7
  40446c:	bd90      	pop	{r4, r7, pc}
  40446e:	bf00      	nop

00404470 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
{
  404470:	b590      	push	{r4, r7, lr}
  404472:	b08b      	sub	sp, #44	; 0x2c
  404474:	af02      	add	r7, sp, #8
  404476:	6078      	str	r0, [r7, #4]

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  404478:	e057      	b.n	40452a <prvSwitchTimerLists+0xba>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  40447a:	f24a 6308 	movw	r3, #42504	; 0xa608
  40447e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404482:	681b      	ldr	r3, [r3, #0]
  404484:	68db      	ldr	r3, [r3, #12]
  404486:	681b      	ldr	r3, [r3, #0]
  404488:	61fb      	str	r3, [r7, #28]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  40448a:	f24a 6308 	movw	r3, #42504	; 0xa608
  40448e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404492:	681b      	ldr	r3, [r3, #0]
  404494:	68db      	ldr	r3, [r3, #12]
  404496:	68db      	ldr	r3, [r3, #12]
  404498:	61bb      	str	r3, [r7, #24]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  40449a:	69bb      	ldr	r3, [r7, #24]
  40449c:	f103 0304 	add.w	r3, r3, #4
  4044a0:	4618      	mov	r0, r3
  4044a2:	f641 4359 	movw	r3, #7257	; 0x1c59
  4044a6:	f2c0 0340 	movt	r3, #64	; 0x40
  4044aa:	4798      	blx	r3

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  4044ac:	69bb      	ldr	r3, [r7, #24]
  4044ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4044b0:	69b8      	ldr	r0, [r7, #24]
  4044b2:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  4044b4:	69bb      	ldr	r3, [r7, #24]
  4044b6:	69db      	ldr	r3, [r3, #28]
  4044b8:	2b01      	cmp	r3, #1
  4044ba:	d136      	bne.n	40452a <prvSwitchTimerLists+0xba>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  4044bc:	69bb      	ldr	r3, [r7, #24]
  4044be:	699a      	ldr	r2, [r3, #24]
  4044c0:	69fb      	ldr	r3, [r7, #28]
  4044c2:	18d3      	adds	r3, r2, r3
  4044c4:	617b      	str	r3, [r7, #20]
			if( xReloadTime > xNextExpireTime )
  4044c6:	697a      	ldr	r2, [r7, #20]
  4044c8:	69fb      	ldr	r3, [r7, #28]
  4044ca:	429a      	cmp	r2, r3
  4044cc:	d915      	bls.n	4044fa <prvSwitchTimerLists+0x8a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  4044ce:	69bb      	ldr	r3, [r7, #24]
  4044d0:	697a      	ldr	r2, [r7, #20]
  4044d2:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  4044d4:	69bb      	ldr	r3, [r7, #24]
  4044d6:	69ba      	ldr	r2, [r7, #24]
  4044d8:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  4044da:	f24a 6308 	movw	r3, #42504	; 0xa608
  4044de:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4044e2:	681a      	ldr	r2, [r3, #0]
  4044e4:	69bb      	ldr	r3, [r7, #24]
  4044e6:	f103 0304 	add.w	r3, r3, #4
  4044ea:	4610      	mov	r0, r2
  4044ec:	4619      	mov	r1, r3
  4044ee:	f641 33e5 	movw	r3, #7141	; 0x1be5
  4044f2:	f2c0 0340 	movt	r3, #64	; 0x40
  4044f6:	4798      	blx	r3
  4044f8:	e017      	b.n	40452a <prvSwitchTimerLists+0xba>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  4044fa:	f04f 0300 	mov.w	r3, #0
  4044fe:	9300      	str	r3, [sp, #0]
  404500:	69b8      	ldr	r0, [r7, #24]
  404502:	f04f 0100 	mov.w	r1, #0
  404506:	69fa      	ldr	r2, [r7, #28]
  404508:	f04f 0300 	mov.w	r3, #0
  40450c:	f643 74a9 	movw	r4, #16297	; 0x3fa9
  404510:	f2c0 0440 	movt	r4, #64	; 0x40
  404514:	47a0      	blx	r4
  404516:	6138      	str	r0, [r7, #16]
				configASSERT( xResult );
  404518:	693b      	ldr	r3, [r7, #16]
  40451a:	2b00      	cmp	r3, #0
  40451c:	d105      	bne.n	40452a <prvSwitchTimerLists+0xba>
  40451e:	f641 7321 	movw	r3, #7969	; 0x1f21
  404522:	f2c0 0340 	movt	r3, #64	; 0x40
  404526:	4798      	blx	r3
  404528:	e7fe      	b.n	404528 <prvSwitchTimerLists+0xb8>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  40452a:	f24a 6308 	movw	r3, #42504	; 0xa608
  40452e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404532:	681b      	ldr	r3, [r3, #0]
  404534:	681b      	ldr	r3, [r3, #0]
  404536:	2b00      	cmp	r3, #0
  404538:	d19f      	bne.n	40447a <prvSwitchTimerLists+0xa>
				( void ) xResult;
			}
		}
	}

	pxTemp = pxCurrentTimerList;
  40453a:	f24a 6308 	movw	r3, #42504	; 0xa608
  40453e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404542:	681b      	ldr	r3, [r3, #0]
  404544:	60fb      	str	r3, [r7, #12]
	pxCurrentTimerList = pxOverflowTimerList;
  404546:	f24a 630c 	movw	r3, #42508	; 0xa60c
  40454a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40454e:	681a      	ldr	r2, [r3, #0]
  404550:	f24a 6308 	movw	r3, #42504	; 0xa608
  404554:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404558:	601a      	str	r2, [r3, #0]
	pxOverflowTimerList = pxTemp;
  40455a:	f24a 630c 	movw	r3, #42508	; 0xa60c
  40455e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404562:	68fa      	ldr	r2, [r7, #12]
  404564:	601a      	str	r2, [r3, #0]
}
  404566:	f107 0724 	add.w	r7, r7, #36	; 0x24
  40456a:	46bd      	mov	sp, r7
  40456c:	bd90      	pop	{r4, r7, pc}
  40456e:	bf00      	nop

00404570 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  404570:	b580      	push	{r7, lr}
  404572:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  404574:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  404578:	f2c0 0340 	movt	r3, #64	; 0x40
  40457c:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
  40457e:	f24a 6310 	movw	r3, #42512	; 0xa610
  404582:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404586:	681b      	ldr	r3, [r3, #0]
  404588:	2b00      	cmp	r3, #0
  40458a:	d134      	bne.n	4045f6 <prvCheckForValidListAndQueue+0x86>
		{
			vListInitialise( &xActiveTimerList1 );
  40458c:	f24a 50e0 	movw	r0, #42464	; 0xa5e0
  404590:	f2c2 0000 	movt	r0, #8192	; 0x2000
  404594:	f641 3341 	movw	r3, #6977	; 0x1b41
  404598:	f2c0 0340 	movt	r3, #64	; 0x40
  40459c:	4798      	blx	r3
			vListInitialise( &xActiveTimerList2 );
  40459e:	f24a 50f4 	movw	r0, #42484	; 0xa5f4
  4045a2:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4045a6:	f641 3341 	movw	r3, #6977	; 0x1b41
  4045aa:	f2c0 0340 	movt	r3, #64	; 0x40
  4045ae:	4798      	blx	r3
			pxCurrentTimerList = &xActiveTimerList1;
  4045b0:	f24a 6308 	movw	r3, #42504	; 0xa608
  4045b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4045b8:	f24a 52e0 	movw	r2, #42464	; 0xa5e0
  4045bc:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4045c0:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
  4045c2:	f24a 630c 	movw	r3, #42508	; 0xa60c
  4045c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4045ca:	f24a 52f4 	movw	r2, #42484	; 0xa5f4
  4045ce:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4045d2:	601a      	str	r2, [r3, #0]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
  4045d4:	f04f 0005 	mov.w	r0, #5
  4045d8:	f04f 010c 	mov.w	r1, #12
  4045dc:	f04f 0200 	mov.w	r2, #0
  4045e0:	f242 134d 	movw	r3, #8525	; 0x214d
  4045e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4045e8:	4798      	blx	r3
  4045ea:	4602      	mov	r2, r0
  4045ec:	f24a 6310 	movw	r3, #42512	; 0xa610
  4045f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4045f4:	601a      	str	r2, [r3, #0]
		}
	}
	taskEXIT_CRITICAL();
  4045f6:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  4045fa:	f2c0 0340 	movt	r3, #64	; 0x40
  4045fe:	4798      	blx	r3
}
  404600:	bd80      	pop	{r7, pc}
  404602:	bf00      	nop

00404604 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field
 */
static __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  404604:	b480      	push	{r7}
  404606:	b085      	sub	sp, #20
  404608:	af00      	add	r7, sp, #0
  40460a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
  40460c:	687b      	ldr	r3, [r7, #4]
  40460e:	f003 0307 	and.w	r3, r3, #7
  404612:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  404614:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  404618:	f2ce 0300 	movt	r3, #57344	; 0xe000
  40461c:	68db      	ldr	r3, [r3, #12]
  40461e:	60bb      	str	r3, [r7, #8]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  404620:	68ba      	ldr	r2, [r7, #8]
  404622:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
  404626:	4013      	ands	r3, r2
  404628:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  40462a:	68fb      	ldr	r3, [r7, #12]
  40462c:	ea4f 2203 	mov.w	r2, r3, lsl #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
  404630:	68bb      	ldr	r3, [r7, #8]
  404632:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
  404634:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  404638:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  40463c:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
  40463e:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  404642:	f2ce 0300 	movt	r3, #57344	; 0xe000
  404646:	68ba      	ldr	r2, [r7, #8]
  404648:	60da      	str	r2, [r3, #12]
}
  40464a:	f107 0714 	add.w	r7, r7, #20
  40464e:	46bd      	mov	sp, r7
  404650:	bc80      	pop	{r7}
  404652:	4770      	bx	lr

00404654 <ioport_set_pin_dir>:
 * \param pin IOPORT pin to configure
 * \param dir Direction to set for the specified pin (\ref ioport_direction)
 */
static inline void ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
  404654:	b480      	push	{r7}
  404656:	b08d      	sub	sp, #52	; 0x34
  404658:	af00      	add	r7, sp, #0
  40465a:	6078      	str	r0, [r7, #4]
  40465c:	460b      	mov	r3, r1
  40465e:	70fb      	strb	r3, [r7, #3]
  404660:	687b      	ldr	r3, [r7, #4]
  404662:	62fb      	str	r3, [r7, #44]	; 0x2c
  404664:	78fb      	ldrb	r3, [r7, #3]
  404666:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  40466a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40466c:	627b      	str	r3, [r7, #36]	; 0x24
  40466e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  404670:	623b      	str	r3, [r7, #32]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  404672:	6a3b      	ldr	r3, [r7, #32]
  404674:	ea4f 1353 	mov.w	r3, r3, lsr #5
  404678:	61fb      	str	r3, [r7, #28]
}

__always_inline static Pio *arch_ioport_port_to_base(ioport_port_t port)
{
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40467a:	69fb      	ldr	r3, [r7, #28]
  40467c:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  404680:	f203 7307 	addw	r3, r3, #1799	; 0x707
  404684:	ea4f 2343 	mov.w	r3, r3, lsl #9
}

__always_inline static void arch_ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  404688:	61bb      	str	r3, [r7, #24]

	if (dir == IOPORT_DIR_OUTPUT) {
  40468a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  40468e:	2b01      	cmp	r3, #1
  404690:	d10c      	bne.n	4046ac <ioport_set_pin_dir+0x58>
  404692:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404694:	617b      	str	r3, [r7, #20]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  404696:	697b      	ldr	r3, [r7, #20]
  404698:	f003 031f 	and.w	r3, r3, #31
  40469c:	f04f 0201 	mov.w	r2, #1
  4046a0:	fa02 f303 	lsl.w	r3, r2, r3
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  4046a4:	461a      	mov	r2, r3
  4046a6:	69bb      	ldr	r3, [r7, #24]
  4046a8:	611a      	str	r2, [r3, #16]
  4046aa:	e00f      	b.n	4046cc <ioport_set_pin_dir+0x78>
	} else if (dir == IOPORT_DIR_INPUT) {
  4046ac:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  4046b0:	2b00      	cmp	r3, #0
  4046b2:	d10b      	bne.n	4046cc <ioport_set_pin_dir+0x78>
  4046b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4046b6:	613b      	str	r3, [r7, #16]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  4046b8:	693b      	ldr	r3, [r7, #16]
  4046ba:	f003 031f 	and.w	r3, r3, #31
  4046be:	f04f 0201 	mov.w	r2, #1
  4046c2:	fa02 f303 	lsl.w	r3, r2, r3
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  4046c6:	461a      	mov	r2, r3
  4046c8:	69bb      	ldr	r3, [r7, #24]
  4046ca:	615a      	str	r2, [r3, #20]
  4046cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4046ce:	60fb      	str	r3, [r7, #12]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  4046d0:	68fb      	ldr	r3, [r7, #12]
  4046d2:	f003 031f 	and.w	r3, r3, #31
  4046d6:	f04f 0201 	mov.w	r2, #1
  4046da:	fa02 f303 	lsl.w	r3, r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  4046de:	461a      	mov	r2, r3
  4046e0:	69bb      	ldr	r3, [r7, #24]
  4046e2:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	arch_ioport_set_pin_dir(pin, dir);
}
  4046e6:	f107 0734 	add.w	r7, r7, #52	; 0x34
  4046ea:	46bd      	mov	sp, r7
  4046ec:	bc80      	pop	{r7}
  4046ee:	4770      	bx	lr

004046f0 <main>:

/* See the documentation page for this demo on the FreeRTOS.org web site for
full information - including hardware setup requirements. */

int main( void )
{
  4046f0:	b580      	push	{r7, lr}
  4046f2:	b082      	sub	sp, #8
  4046f4:	af00      	add	r7, sp, #0
	volatile int x;
	volatile int other = 0;
  4046f6:	f04f 0300 	mov.w	r3, #0
  4046fa:	603b      	str	r3, [r7, #0]
	
	for(x = 0; x < 1000; ++x)
  4046fc:	f04f 0300 	mov.w	r3, #0
  404700:	607b      	str	r3, [r7, #4]
  404702:	e00a      	b.n	40471a <main+0x2a>
	{
		other = !other;
  404704:	683b      	ldr	r3, [r7, #0]
  404706:	2b00      	cmp	r3, #0
  404708:	bf14      	ite	ne
  40470a:	2300      	movne	r3, #0
  40470c:	2301      	moveq	r3, #1
  40470e:	b2db      	uxtb	r3, r3
  404710:	603b      	str	r3, [r7, #0]
int main( void )
{
	volatile int x;
	volatile int other = 0;
	
	for(x = 0; x < 1000; ++x)
  404712:	687b      	ldr	r3, [r7, #4]
  404714:	f103 0301 	add.w	r3, r3, #1
  404718:	607b      	str	r3, [r7, #4]
  40471a:	687a      	ldr	r2, [r7, #4]
  40471c:	f240 33e7 	movw	r3, #999	; 0x3e7
  404720:	429a      	cmp	r2, r3
  404722:	ddef      	ble.n	404704 <main+0x14>
	{
		other = !other;
	}
	/* Prepare the hardware to run this demo. */
	prvSetupHardware();
  404724:	f244 7359 	movw	r3, #18265	; 0x4759
  404728:	f2c0 0340 	movt	r3, #64	; 0x40
  40472c:	4798      	blx	r3
	
	ioport_set_pin_dir(LED_0_PIN, IOPORT_DIR_OUTPUT);
  40472e:	f04f 0057 	mov.w	r0, #87	; 0x57
  404732:	f04f 0101 	mov.w	r1, #1
  404736:	f244 6355 	movw	r3, #18005	; 0x4655
  40473a:	f2c0 0340 	movt	r3, #64	; 0x40
  40473e:	4798      	blx	r3

	/* The mainCREATE_SIMPLE_BLINKY_DEMO_ONLY setting is described at the top
	of this file. */
	#if mainCREATE_SIMPLE_BLINKY_DEMO_ONLY == 1
	{
		main_blinky();
  404740:	f244 73c1 	movw	r3, #18369	; 0x47c1
  404744:	f2c0 0340 	movt	r3, #64	; 0x40
  404748:	4798      	blx	r3
	{
		main_full();
	}
	#endif

	return 0;
  40474a:	f04f 0300 	mov.w	r3, #0
}
  40474e:	4618      	mov	r0, r3
  404750:	f107 0708 	add.w	r7, r7, #8
  404754:	46bd      	mov	sp, r7
  404756:	bd80      	pop	{r7, pc}

00404758 <prvSetupHardware>:
/*-----------------------------------------------------------*/

static void prvSetupHardware( void )
{
  404758:	b580      	push	{r7, lr}
  40475a:	af00      	add	r7, sp, #0
extern void SystemCoreClockUpdate( void );

	/* ASF function to setup clocking. */
	sysclk_init();
  40475c:	f640 437d 	movw	r3, #3197	; 0xc7d
  404760:	f2c0 0340 	movt	r3, #64	; 0x40
  404764:	4798      	blx	r3

	/* Ensure all priority bits are assigned as preemption priority bits. */
	NVIC_SetPriorityGrouping( 0 );
  404766:	f04f 0000 	mov.w	r0, #0
  40476a:	f244 6305 	movw	r3, #17925	; 0x4605
  40476e:	f2c0 0340 	movt	r3, #64	; 0x40
  404772:	4798      	blx	r3

	/* Atmel library function to setup for the evaluation kit being used. */
	board_init();
  404774:	f240 430d 	movw	r3, #1037	; 0x40d
  404778:	f2c0 0340 	movt	r3, #64	; 0x40
  40477c:	4798      	blx	r3

	/* Perform any configuration necessary to use the ParTest LED output
	functions. */
	vParTestInitialise();
  40477e:	f644 13b5 	movw	r3, #18869	; 0x49b5
  404782:	f2c0 0340 	movt	r3, #64	; 0x40
  404786:	4798      	blx	r3
}
  404788:	bd80      	pop	{r7, pc}
  40478a:	bf00      	nop

0040478c <vApplicationMallocFailedHook>:
/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
  40478c:	b580      	push	{r7, lr}
  40478e:	af00      	add	r7, sp, #0
	demo application.  If heap_1.c or heap_2.c are used, then the size of the
	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
  404790:	f641 7321 	movw	r3, #7969	; 0x1f21
  404794:	f2c0 0340 	movt	r3, #64	; 0x40
  404798:	4798      	blx	r3
	for( ;; );
  40479a:	e7fe      	b.n	40479a <vApplicationMallocFailedHook+0xe>

0040479c <vApplicationStackOverflowHook>:
	memory allocated by the kernel to any task that has since been deleted. */
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName )
{
  40479c:	b580      	push	{r7, lr}
  40479e:	b082      	sub	sp, #8
  4047a0:	af00      	add	r7, sp, #0
  4047a2:	6078      	str	r0, [r7, #4]
  4047a4:	6039      	str	r1, [r7, #0]
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
  4047a6:	f641 7321 	movw	r3, #7969	; 0x1f21
  4047aa:	f2c0 0340 	movt	r3, #64	; 0x40
  4047ae:	4798      	blx	r3
	for( ;; );
  4047b0:	e7fe      	b.n	4047b0 <vApplicationStackOverflowHook+0x14>
  4047b2:	bf00      	nop

004047b4 <vApplicationTickHook>:
}
/*-----------------------------------------------------------*/

void vApplicationTickHook( void )
{
  4047b4:	b480      	push	{r7}
  4047b6:	af00      	add	r7, sp, #0
	{
		/* In this case the tick hook is used as part of the queue set test. */
		vQueueSetAccessQueueSetFromISR();
	}
	#endif /* mainCREATE_SIMPLE_BLINKY_DEMO_ONLY */
}
  4047b8:	46bd      	mov	sp, r7
  4047ba:	bc80      	pop	{r7}
  4047bc:	4770      	bx	lr
  4047be:	bf00      	nop

004047c0 <main_blinky>:
static xQueueHandle xQueue = NULL;

/*-----------------------------------------------------------*/

void main_blinky( void )
{
  4047c0:	b590      	push	{r4, r7, lr}
  4047c2:	b085      	sub	sp, #20
  4047c4:	af04      	add	r7, sp, #16
	/* Create the queue. */
	xQueue = xQueueCreate( mainQUEUE_LENGTH, sizeof( unsigned long ) );
  4047c6:	f04f 0001 	mov.w	r0, #1
  4047ca:	f04f 0104 	mov.w	r1, #4
  4047ce:	f04f 0200 	mov.w	r2, #0
  4047d2:	f242 134d 	movw	r3, #8525	; 0x214d
  4047d6:	f2c0 0340 	movt	r3, #64	; 0x40
  4047da:	4798      	blx	r3
  4047dc:	4602      	mov	r2, r0
  4047de:	f24a 6318 	movw	r3, #42520	; 0xa618
  4047e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4047e6:	601a      	str	r2, [r3, #0]

	if( xQueue != NULL )
  4047e8:	f24a 6318 	movw	r3, #42520	; 0xa618
  4047ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4047f0:	681b      	ldr	r3, [r3, #0]
  4047f2:	2b00      	cmp	r3, #0
  4047f4:	d03e      	beq.n	404874 <main_blinky+0xb4>
	{
		/* Start the two tasks as described in the comments at the top of this
		file. */
		xTaskCreate( prvQueueReceiveTask,					/* The function that implements the task. */
  4047f6:	f04f 0302 	mov.w	r3, #2
  4047fa:	9300      	str	r3, [sp, #0]
  4047fc:	f04f 0300 	mov.w	r3, #0
  404800:	9301      	str	r3, [sp, #4]
  404802:	f04f 0300 	mov.w	r3, #0
  404806:	9302      	str	r3, [sp, #8]
  404808:	f04f 0300 	mov.w	r3, #0
  40480c:	9303      	str	r3, [sp, #12]
  40480e:	f644 00e5 	movw	r0, #18661	; 0x48e5
  404812:	f2c0 0040 	movt	r0, #64	; 0x40
  404816:	f644 4174 	movw	r1, #19572	; 0x4c74
  40481a:	f2c0 0140 	movt	r1, #64	; 0x40
  40481e:	f04f 0282 	mov.w	r2, #130	; 0x82
  404822:	f04f 0322 	mov.w	r3, #34	; 0x22
  404826:	f642 34a5 	movw	r4, #11173	; 0x2ba5
  40482a:	f2c0 0440 	movt	r4, #64	; 0x40
  40482e:	47a0      	blx	r4
					configMINIMAL_STACK_SIZE, 				/* The size of the stack to allocate to the task. */
					( void * ) mainQUEUE_RECEIVE_PARAMETER, /* The parameter passed to the task - just to check the functionality. */
					mainQUEUE_RECEIVE_TASK_PRIORITY, 		/* The priority assigned to the task. */
					NULL );									/* The task handle is not required, so NULL is passed. */

		xTaskCreate( prvQueueSendTask, ( signed char * ) "TX", configMINIMAL_STACK_SIZE, ( void * ) mainQUEUE_SEND_PARAMETER, mainQUEUE_SEND_TASK_PRIORITY, NULL );
  404830:	f04f 0301 	mov.w	r3, #1
  404834:	9300      	str	r3, [sp, #0]
  404836:	f04f 0300 	mov.w	r3, #0
  40483a:	9301      	str	r3, [sp, #4]
  40483c:	f04f 0300 	mov.w	r3, #0
  404840:	9302      	str	r3, [sp, #8]
  404842:	f04f 0300 	mov.w	r3, #0
  404846:	9303      	str	r3, [sp, #12]
  404848:	f644 0079 	movw	r0, #18553	; 0x4879
  40484c:	f2c0 0040 	movt	r0, #64	; 0x40
  404850:	f644 4178 	movw	r1, #19576	; 0x4c78
  404854:	f2c0 0140 	movt	r1, #64	; 0x40
  404858:	f04f 0282 	mov.w	r2, #130	; 0x82
  40485c:	f241 1311 	movw	r3, #4369	; 0x1111
  404860:	f642 34a5 	movw	r4, #11173	; 0x2ba5
  404864:	f2c0 0440 	movt	r4, #64	; 0x40
  404868:	47a0      	blx	r4

		/* Start the tasks and timer running. */
		vTaskStartScheduler();
  40486a:	f642 63b5 	movw	r3, #11957	; 0x2eb5
  40486e:	f2c0 0340 	movt	r3, #64	; 0x40
  404872:	4798      	blx	r3
	/* If all is well, the scheduler will now be running, and the following
	line will never be reached.  If the following line does execute, then
	there was insufficient FreeRTOS heap memory available for the idle and/or
	timer tasks	to be created.  See the memory management section on the
	FreeRTOS web site for more details. */
	for( ;; );
  404874:	e7fe      	b.n	404874 <main_blinky+0xb4>
  404876:	bf00      	nop

00404878 <prvQueueSendTask>:
}
/*-----------------------------------------------------------*/

static void prvQueueSendTask( void *pvParameters )
{
  404878:	b590      	push	{r4, r7, lr}
  40487a:	b085      	sub	sp, #20
  40487c:	af00      	add	r7, sp, #0
  40487e:	6078      	str	r0, [r7, #4]
portTickType xNextWakeTime;
const unsigned long ulValueToSend = 100UL;
  404880:	f04f 0364 	mov.w	r3, #100	; 0x64
  404884:	60bb      	str	r3, [r7, #8]

	/* Check the task parameter is as expected. */
	configASSERT( ( ( unsigned long ) pvParameters ) == mainQUEUE_SEND_PARAMETER );
  404886:	687a      	ldr	r2, [r7, #4]
  404888:	f241 1311 	movw	r3, #4369	; 0x1111
  40488c:	429a      	cmp	r2, r3
  40488e:	d005      	beq.n	40489c <prvQueueSendTask+0x24>
  404890:	f641 7321 	movw	r3, #7969	; 0x1f21
  404894:	f2c0 0340 	movt	r3, #64	; 0x40
  404898:	4798      	blx	r3
  40489a:	e7fe      	b.n	40489a <prvQueueSendTask+0x22>

	/* Initialise xNextWakeTime - this only needs to be done once. */
	xNextWakeTime = xTaskGetTickCount();
  40489c:	f243 1325 	movw	r3, #12581	; 0x3125
  4048a0:	f2c0 0340 	movt	r3, #64	; 0x40
  4048a4:	4798      	blx	r3
  4048a6:	4603      	mov	r3, r0
  4048a8:	60fb      	str	r3, [r7, #12]
	{
		/* Place this task in the blocked state until it is time to run again.
		The block time is specified in ticks, the constant used converts ticks
		to ms.  While in the Blocked state this task will not consume any CPU
		time. */
		vTaskDelayUntil( &xNextWakeTime, mainQUEUE_SEND_FREQUENCY_MS );
  4048aa:	f107 030c 	add.w	r3, r7, #12
  4048ae:	4618      	mov	r0, r3
  4048b0:	f04f 01c8 	mov.w	r1, #200	; 0xc8
  4048b4:	f642 5399 	movw	r3, #11673	; 0x2d99
  4048b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4048bc:	4798      	blx	r3

		/* Send to the queue - causing the queue receive task to unblock and
		toggle the LED.  0 is used as the block time so the sending operation
		will not block - it shouldn't need to block as the queue should always
		be empty at this point in the code. */
		xQueueSend( xQueue, &ulValueToSend, 0U );
  4048be:	f24a 6318 	movw	r3, #42520	; 0xa618
  4048c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4048c6:	681a      	ldr	r2, [r3, #0]
  4048c8:	f107 0308 	add.w	r3, r7, #8
  4048cc:	4610      	mov	r0, r2
  4048ce:	4619      	mov	r1, r3
  4048d0:	f04f 0200 	mov.w	r2, #0
  4048d4:	f04f 0300 	mov.w	r3, #0
  4048d8:	f242 14f9 	movw	r4, #8697	; 0x21f9
  4048dc:	f2c0 0440 	movt	r4, #64	; 0x40
  4048e0:	47a0      	blx	r4
	}
  4048e2:	e7e2      	b.n	4048aa <prvQueueSendTask+0x32>

004048e4 <prvQueueReceiveTask>:
}
/*-----------------------------------------------------------*/

static void prvQueueReceiveTask( void *pvParameters )
{
  4048e4:	b590      	push	{r4, r7, lr}
  4048e6:	b085      	sub	sp, #20
  4048e8:	af00      	add	r7, sp, #0
  4048ea:	6078      	str	r0, [r7, #4]
unsigned long ulReceivedValue;

	/* Check the task parameter is as expected. */
	configASSERT( ( ( unsigned long ) pvParameters ) == mainQUEUE_RECEIVE_PARAMETER );
  4048ec:	687b      	ldr	r3, [r7, #4]
  4048ee:	2b22      	cmp	r3, #34	; 0x22
  4048f0:	d006      	beq.n	404900 <prvQueueReceiveTask+0x1c>
  4048f2:	f641 7321 	movw	r3, #7969	; 0x1f21
  4048f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4048fa:	4798      	blx	r3
  4048fc:	e7fe      	b.n	4048fc <prvQueueReceiveTask+0x18>
		if( ulReceivedValue == 100UL )
		{
			vParTestToggleLED( 0 );
			ulReceivedValue = 0U;
		}
	}
  4048fe:	bf00      	nop
	for( ;; )
	{
		/* Wait until something arrives in the queue - this task will block
		indefinitely provided INCLUDE_vTaskSuspend is set to 1 in
		FreeRTOSConfig.h. */
		xQueueReceive( xQueue, &ulReceivedValue, portMAX_DELAY );
  404900:	f24a 6318 	movw	r3, #42520	; 0xa618
  404904:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404908:	681a      	ldr	r2, [r3, #0]
  40490a:	f107 030c 	add.w	r3, r7, #12
  40490e:	4610      	mov	r0, r2
  404910:	4619      	mov	r1, r3
  404912:	f04f 32ff 	mov.w	r2, #4294967295
  404916:	f04f 0300 	mov.w	r3, #0
  40491a:	f242 5471 	movw	r4, #9585	; 0x2571
  40491e:	f2c0 0440 	movt	r4, #64	; 0x40
  404922:	47a0      	blx	r4

		/*  To get here something must have been received from the queue, but
		is it the expected value?  If it is, toggle the LED. */
		if( ulReceivedValue == 100UL )
  404924:	68fb      	ldr	r3, [r7, #12]
  404926:	2b64      	cmp	r3, #100	; 0x64
  404928:	d1e9      	bne.n	4048fe <prvQueueReceiveTask+0x1a>
		{
			vParTestToggleLED( 0 );
  40492a:	f04f 0000 	mov.w	r0, #0
  40492e:	f644 2399 	movw	r3, #19097	; 0x4a99
  404932:	f2c0 0340 	movt	r3, #64	; 0x40
  404936:	4798      	blx	r3
			ulReceivedValue = 0U;
  404938:	f04f 0300 	mov.w	r3, #0
  40493c:	60fb      	str	r3, [r7, #12]
		}
	}
  40493e:	e7de      	b.n	4048fe <prvQueueReceiveTask+0x1a>

00404940 <ioport_toggle_pin_level>:
 * an output.
 *
 * \param pin IOPORT pin to toggle
 */
static inline void ioport_toggle_pin_level(ioport_pin_t pin)
{
  404940:	b480      	push	{r7}
  404942:	b08b      	sub	sp, #44	; 0x2c
  404944:	af00      	add	r7, sp, #0
  404946:	6078      	str	r0, [r7, #4]
  404948:	687b      	ldr	r3, [r7, #4]
  40494a:	627b      	str	r3, [r7, #36]	; 0x24
  40494c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40494e:	623b      	str	r3, [r7, #32]
  404950:	6a3b      	ldr	r3, [r7, #32]
  404952:	61fb      	str	r3, [r7, #28]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  404954:	69fb      	ldr	r3, [r7, #28]
  404956:	ea4f 1353 	mov.w	r3, r3, lsr #5
  40495a:	61bb      	str	r3, [r7, #24]
}

__always_inline static Pio *arch_ioport_port_to_base(ioport_port_t port)
{
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40495c:	69bb      	ldr	r3, [r7, #24]
  40495e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  404962:	f203 7307 	addw	r3, r3, #1799	; 0x707
  404966:	ea4f 2343 	mov.w	r3, r3, lsl #9
	return arch_ioport_port_to_base(port)->PIO_PDSR & mask;
}

__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	Pio *port = arch_ioport_pin_to_base(pin);
  40496a:	617b      	str	r3, [r7, #20]
  40496c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40496e:	613b      	str	r3, [r7, #16]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  404970:	693b      	ldr	r3, [r7, #16]
  404972:	f003 031f 	and.w	r3, r3, #31
  404976:	f04f 0201 	mov.w	r2, #1
  40497a:	fa02 f303 	lsl.w	r3, r2, r3
}

__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	Pio *port = arch_ioport_pin_to_base(pin);
	ioport_port_mask_t mask = arch_ioport_pin_to_mask(pin);
  40497e:	60fb      	str	r3, [r7, #12]

	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
  404980:	697b      	ldr	r3, [r7, #20]
  404982:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  404984:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  404986:	60bb      	str	r3, [r7, #8]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  404988:	68bb      	ldr	r3, [r7, #8]
  40498a:	f003 031f 	and.w	r3, r3, #31
  40498e:	f04f 0101 	mov.w	r1, #1
  404992:	fa01 f303 	lsl.w	r3, r1, r3
__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	Pio *port = arch_ioport_pin_to_base(pin);
	ioport_port_mask_t mask = arch_ioport_pin_to_mask(pin);

	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
  404996:	4013      	ands	r3, r2
  404998:	2b00      	cmp	r3, #0
  40499a:	d003      	beq.n	4049a4 <ioport_toggle_pin_level+0x64>
		port->PIO_CODR = mask;
  40499c:	697b      	ldr	r3, [r7, #20]
  40499e:	68fa      	ldr	r2, [r7, #12]
  4049a0:	635a      	str	r2, [r3, #52]	; 0x34
  4049a2:	e002      	b.n	4049aa <ioport_toggle_pin_level+0x6a>
	} else {
		port->PIO_SODR = mask;
  4049a4:	697b      	ldr	r3, [r7, #20]
  4049a6:	68fa      	ldr	r2, [r7, #12]
  4049a8:	631a      	str	r2, [r3, #48]	; 0x30
	arch_ioport_toggle_pin_level(pin);
}
  4049aa:	f107 072c 	add.w	r7, r7, #44	; 0x2c
  4049ae:	46bd      	mov	sp, r7
  4049b0:	bc80      	pop	{r7}
  4049b2:	4770      	bx	lr

004049b4 <vParTestInitialise>:
static const uint32_t ulLED[] = { LED_0_PIN, LED_0_PIN, LED_0_PIN };

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
  4049b4:	b580      	push	{r7, lr}
  4049b6:	b082      	sub	sp, #8
  4049b8:	af00      	add	r7, sp, #0
unsigned long ul;

	for( ul = 0; ul < partestNUM_LEDS; ul++ )
  4049ba:	f04f 0300 	mov.w	r3, #0
  4049be:	607b      	str	r3, [r7, #4]
  4049c0:	e01a      	b.n	4049f8 <vParTestInitialise+0x44>
	{
		/* Configure the LED, before ensuring it starts in the off state. */
		gpio_configure_pin( ulLED[ ul ],  ( PIO_OUTPUT_1 | PIO_DEFAULT ) );
  4049c2:	f644 437c 	movw	r3, #19580	; 0x4c7c
  4049c6:	f2c0 0340 	movt	r3, #64	; 0x40
  4049ca:	687a      	ldr	r2, [r7, #4]
  4049cc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4049d0:	4618      	mov	r0, r3
  4049d2:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  4049d6:	f640 73fd 	movw	r3, #4093	; 0xffd
  4049da:	f2c0 0340 	movt	r3, #64	; 0x40
  4049de:	4798      	blx	r3
		vParTestSetLED( ul, pdFALSE );
  4049e0:	6878      	ldr	r0, [r7, #4]
  4049e2:	f04f 0100 	mov.w	r1, #0
  4049e6:	f644 2309 	movw	r3, #18953	; 0x4a09
  4049ea:	f2c0 0340 	movt	r3, #64	; 0x40
  4049ee:	4798      	blx	r3

void vParTestInitialise( void )
{
unsigned long ul;

	for( ul = 0; ul < partestNUM_LEDS; ul++ )
  4049f0:	687b      	ldr	r3, [r7, #4]
  4049f2:	f103 0301 	add.w	r3, r3, #1
  4049f6:	607b      	str	r3, [r7, #4]
  4049f8:	687b      	ldr	r3, [r7, #4]
  4049fa:	2b02      	cmp	r3, #2
  4049fc:	d9e1      	bls.n	4049c2 <vParTestInitialise+0xe>
	{
		/* Configure the LED, before ensuring it starts in the off state. */
		gpio_configure_pin( ulLED[ ul ],  ( PIO_OUTPUT_1 | PIO_DEFAULT ) );
		vParTestSetLED( ul, pdFALSE );
	}
}
  4049fe:	f107 0708 	add.w	r7, r7, #8
  404a02:	46bd      	mov	sp, r7
  404a04:	bd80      	pop	{r7, pc}
  404a06:	bf00      	nop

00404a08 <vParTestSetLED>:
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{	
  404a08:	b580      	push	{r7, lr}
  404a0a:	b082      	sub	sp, #8
  404a0c:	af00      	add	r7, sp, #0
  404a0e:	6078      	str	r0, [r7, #4]
  404a10:	6039      	str	r1, [r7, #0]
	if( uxLED < partestNUM_LEDS )
  404a12:	687b      	ldr	r3, [r7, #4]
  404a14:	2b02      	cmp	r3, #2
  404a16:	d83b      	bhi.n	404a90 <vParTestSetLED+0x88>
	{
		if( uxLED == partstsINVERTED_LED )
  404a18:	687b      	ldr	r3, [r7, #4]
  404a1a:	2b00      	cmp	r3, #0
  404a1c:	d106      	bne.n	404a2c <vParTestSetLED+0x24>
		{
			xValue = !xValue;					
  404a1e:	683b      	ldr	r3, [r7, #0]
  404a20:	2b00      	cmp	r3, #0
  404a22:	bf14      	ite	ne
  404a24:	2300      	movne	r3, #0
  404a26:	2301      	moveq	r3, #1
  404a28:	b2db      	uxtb	r3, r3
  404a2a:	603b      	str	r3, [r7, #0]
		}
		
		if( xValue != pdFALSE )
  404a2c:	683b      	ldr	r3, [r7, #0]
  404a2e:	2b00      	cmp	r3, #0
  404a30:	d017      	beq.n	404a62 <vParTestSetLED+0x5a>
		{
			/* Turn the LED on. */
			taskENTER_CRITICAL();
  404a32:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  404a36:	f2c0 0340 	movt	r3, #64	; 0x40
  404a3a:	4798      	blx	r3
			{
				gpio_set_pin_low( ulLED[ uxLED ]);
  404a3c:	f644 437c 	movw	r3, #19580	; 0x4c7c
  404a40:	f2c0 0340 	movt	r3, #64	; 0x40
  404a44:	687a      	ldr	r2, [r7, #4]
  404a46:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  404a4a:	4618      	mov	r0, r3
  404a4c:	f640 73c1 	movw	r3, #4033	; 0xfc1
  404a50:	f2c0 0340 	movt	r3, #64	; 0x40
  404a54:	4798      	blx	r3
			}
			taskEXIT_CRITICAL();
  404a56:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  404a5a:	f2c0 0340 	movt	r3, #64	; 0x40
  404a5e:	4798      	blx	r3
  404a60:	e016      	b.n	404a90 <vParTestSetLED+0x88>
		}
		else
		{
			/* Turn the LED off. */
			taskENTER_CRITICAL();
  404a62:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  404a66:	f2c0 0340 	movt	r3, #64	; 0x40
  404a6a:	4798      	blx	r3
			{
				gpio_set_pin_high( ulLED[ uxLED ]);
  404a6c:	f644 437c 	movw	r3, #19580	; 0x4c7c
  404a70:	f2c0 0340 	movt	r3, #64	; 0x40
  404a74:	687a      	ldr	r2, [r7, #4]
  404a76:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  404a7a:	4618      	mov	r0, r3
  404a7c:	f640 7385 	movw	r3, #3973	; 0xf85
  404a80:	f2c0 0340 	movt	r3, #64	; 0x40
  404a84:	4798      	blx	r3
			}
			taskEXIT_CRITICAL();
  404a86:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  404a8a:	f2c0 0340 	movt	r3, #64	; 0x40
  404a8e:	4798      	blx	r3
		}
	}
}
  404a90:	f107 0708 	add.w	r7, r7, #8
  404a94:	46bd      	mov	sp, r7
  404a96:	bd80      	pop	{r7, pc}

00404a98 <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
  404a98:	b580      	push	{r7, lr}
  404a9a:	b082      	sub	sp, #8
  404a9c:	af00      	add	r7, sp, #0
  404a9e:	6078      	str	r0, [r7, #4]
	if( uxLED < partestNUM_LEDS )
  404aa0:	687b      	ldr	r3, [r7, #4]
  404aa2:	2b02      	cmp	r3, #2
  404aa4:	d810      	bhi.n	404ac8 <vParTestToggleLED+0x30>
	{
		taskENTER_CRITICAL();
  404aa6:	f641 63b5 	movw	r3, #7861	; 0x1eb5
  404aaa:	f2c0 0340 	movt	r3, #64	; 0x40
  404aae:	4798      	blx	r3
		{			
			//gpio_toggle_pin( ulLED[ uxLED ] );
			ioport_toggle_pin_level(LED_0_PIN);
  404ab0:	f04f 0057 	mov.w	r0, #87	; 0x57
  404ab4:	f644 1341 	movw	r3, #18753	; 0x4941
  404ab8:	f2c0 0340 	movt	r3, #64	; 0x40
  404abc:	4798      	blx	r3
		}
		taskEXIT_CRITICAL();		
  404abe:	f641 63e5 	movw	r3, #7909	; 0x1ee5
  404ac2:	f2c0 0340 	movt	r3, #64	; 0x40
  404ac6:	4798      	blx	r3
	}
}
  404ac8:	f107 0708 	add.w	r7, r7, #8
  404acc:	46bd      	mov	sp, r7
  404ace:	bd80      	pop	{r7, pc}

00404ad0 <__register_exitproc>:
  404ad0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  404ad4:	4698      	mov	r8, r3
  404ad6:	4b23      	ldr	r3, [pc, #140]	; (404b64 <__register_exitproc+0x94>)
  404ad8:	681c      	ldr	r4, [r3, #0]
  404ada:	4606      	mov	r6, r0
  404adc:	f8d4 0148 	ldr.w	r0, [r4, #328]	; 0x148
  404ae0:	460f      	mov	r7, r1
  404ae2:	4691      	mov	r9, r2
  404ae4:	b918      	cbnz	r0, 404aee <__register_exitproc+0x1e>
  404ae6:	f504 70a6 	add.w	r0, r4, #332	; 0x14c
  404aea:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  404aee:	6841      	ldr	r1, [r0, #4]
  404af0:	291f      	cmp	r1, #31
  404af2:	dd16      	ble.n	404b22 <__register_exitproc+0x52>
  404af4:	481c      	ldr	r0, [pc, #112]	; (404b68 <__register_exitproc+0x98>)
  404af6:	b918      	cbnz	r0, 404b00 <__register_exitproc+0x30>
  404af8:	f04f 30ff 	mov.w	r0, #4294967295
  404afc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  404b00:	f44f 70c8 	mov.w	r0, #400	; 0x190
  404b04:	f3af 8000 	nop.w
  404b08:	2800      	cmp	r0, #0
  404b0a:	d0f5      	beq.n	404af8 <__register_exitproc+0x28>
  404b0c:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  404b10:	2500      	movs	r5, #0
  404b12:	6045      	str	r5, [r0, #4]
  404b14:	6002      	str	r2, [r0, #0]
  404b16:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  404b1a:	f8c0 5188 	str.w	r5, [r0, #392]	; 0x188
  404b1e:	f8c0 518c 	str.w	r5, [r0, #396]	; 0x18c
  404b22:	b1b6      	cbz	r6, 404b52 <__register_exitproc+0x82>
  404b24:	6844      	ldr	r4, [r0, #4]
  404b26:	f8d0 1188 	ldr.w	r1, [r0, #392]	; 0x188
  404b2a:	2201      	movs	r2, #1
  404b2c:	eb00 0384 	add.w	r3, r0, r4, lsl #2
  404b30:	fa02 f204 	lsl.w	r2, r2, r4
  404b34:	4311      	orrs	r1, r2
  404b36:	2e02      	cmp	r6, #2
  404b38:	f8c3 9088 	str.w	r9, [r3, #136]	; 0x88
  404b3c:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  404b40:	461c      	mov	r4, r3
  404b42:	f8c3 8108 	str.w	r8, [r3, #264]	; 0x108
  404b46:	d104      	bne.n	404b52 <__register_exitproc+0x82>
  404b48:	f8d0 318c 	ldr.w	r3, [r0, #396]	; 0x18c
  404b4c:	431a      	orrs	r2, r3
  404b4e:	f8c0 218c 	str.w	r2, [r0, #396]	; 0x18c
  404b52:	6841      	ldr	r1, [r0, #4]
  404b54:	1c8b      	adds	r3, r1, #2
  404b56:	1c4a      	adds	r2, r1, #1
  404b58:	f840 7023 	str.w	r7, [r0, r3, lsl #2]
  404b5c:	6042      	str	r2, [r0, #4]
  404b5e:	2000      	movs	r0, #0
  404b60:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  404b64:	00404c88 	.word	0x00404c88
  404b68:	00000000 	.word	0x00000000

00404b6c <__libc_fini_array>:
  404b6c:	b570      	push	{r4, r5, r6, lr}
  404b6e:	4b08      	ldr	r3, [pc, #32]	; (404b90 <__libc_fini_array+0x24>)
  404b70:	4c08      	ldr	r4, [pc, #32]	; (404b94 <__libc_fini_array+0x28>)
  404b72:	1ae0      	subs	r0, r4, r3
  404b74:	1084      	asrs	r4, r0, #2
  404b76:	eb03 0684 	add.w	r6, r3, r4, lsl #2
  404b7a:	2500      	movs	r5, #0
  404b7c:	3d04      	subs	r5, #4
  404b7e:	b11c      	cbz	r4, 404b88 <__libc_fini_array+0x1c>
  404b80:	5972      	ldr	r2, [r6, r5]
  404b82:	4790      	blx	r2
  404b84:	3c01      	subs	r4, #1
  404b86:	e7f9      	b.n	404b7c <__libc_fini_array+0x10>
  404b88:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  404b8c:	f000 b88a 	b.w	404ca4 <_fini>
  404b90:	00404cb0 	.word	0x00404cb0
  404b94:	00404cb4 	.word	0x00404cb4

00404b98 <__libc_init_array>:
  404b98:	b538      	push	{r3, r4, r5, lr}
  404b9a:	4d0e      	ldr	r5, [pc, #56]	; (404bd4 <__libc_init_array+0x3c>)
  404b9c:	4b0e      	ldr	r3, [pc, #56]	; (404bd8 <__libc_init_array+0x40>)
  404b9e:	1ae8      	subs	r0, r5, r3
  404ba0:	1085      	asrs	r5, r0, #2
  404ba2:	2400      	movs	r4, #0
  404ba4:	42ac      	cmp	r4, r5
  404ba6:	d005      	beq.n	404bb4 <__libc_init_array+0x1c>
  404ba8:	490b      	ldr	r1, [pc, #44]	; (404bd8 <__libc_init_array+0x40>)
  404baa:	f851 2024 	ldr.w	r2, [r1, r4, lsl #2]
  404bae:	4790      	blx	r2
  404bb0:	3401      	adds	r4, #1
  404bb2:	e7f7      	b.n	404ba4 <__libc_init_array+0xc>
  404bb4:	f000 f86c 	bl	404c90 <_init>
  404bb8:	4908      	ldr	r1, [pc, #32]	; (404bdc <__libc_init_array+0x44>)
  404bba:	4a09      	ldr	r2, [pc, #36]	; (404be0 <__libc_init_array+0x48>)
  404bbc:	1a54      	subs	r4, r2, r1
  404bbe:	10a5      	asrs	r5, r4, #2
  404bc0:	2400      	movs	r4, #0
  404bc2:	42ac      	cmp	r4, r5
  404bc4:	d005      	beq.n	404bd2 <__libc_init_array+0x3a>
  404bc6:	4b05      	ldr	r3, [pc, #20]	; (404bdc <__libc_init_array+0x44>)
  404bc8:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  404bcc:	4780      	blx	r0
  404bce:	3401      	adds	r4, #1
  404bd0:	e7f7      	b.n	404bc2 <__libc_init_array+0x2a>
  404bd2:	bd38      	pop	{r3, r4, r5, pc}
  404bd4:	00404c9c 	.word	0x00404c9c
  404bd8:	00404c9c 	.word	0x00404c9c
  404bdc:	00404c9c 	.word	0x00404c9c
  404be0:	00404ca4 	.word	0x00404ca4

00404be4 <memcmp>:
  404be4:	b530      	push	{r4, r5, lr}
  404be6:	2300      	movs	r3, #0
  404be8:	4293      	cmp	r3, r2
  404bea:	d008      	beq.n	404bfe <memcmp+0x1a>
  404bec:	5cc5      	ldrb	r5, [r0, r3]
  404bee:	3301      	adds	r3, #1
  404bf0:	18cc      	adds	r4, r1, r3
  404bf2:	f814 4c01 	ldrb.w	r4, [r4, #-1]
  404bf6:	42a5      	cmp	r5, r4
  404bf8:	d0f6      	beq.n	404be8 <memcmp+0x4>
  404bfa:	1b28      	subs	r0, r5, r4
  404bfc:	bd30      	pop	{r4, r5, pc}
  404bfe:	2000      	movs	r0, #0
  404c00:	bd30      	pop	{r4, r5, pc}

00404c02 <memcpy>:
  404c02:	b510      	push	{r4, lr}
  404c04:	2300      	movs	r3, #0
  404c06:	4293      	cmp	r3, r2
  404c08:	d003      	beq.n	404c12 <memcpy+0x10>
  404c0a:	5ccc      	ldrb	r4, [r1, r3]
  404c0c:	54c4      	strb	r4, [r0, r3]
  404c0e:	3301      	adds	r3, #1
  404c10:	e7f9      	b.n	404c06 <memcpy+0x4>
  404c12:	bd10      	pop	{r4, pc}

00404c14 <memset>:
  404c14:	1882      	adds	r2, r0, r2
  404c16:	4603      	mov	r3, r0
  404c18:	4293      	cmp	r3, r2
  404c1a:	d002      	beq.n	404c22 <memset+0xe>
  404c1c:	f803 1b01 	strb.w	r1, [r3], #1
  404c20:	e7fa      	b.n	404c18 <memset+0x4>
  404c22:	4770      	bx	lr

00404c24 <register_fini>:
  404c24:	4b02      	ldr	r3, [pc, #8]	; (404c30 <register_fini+0xc>)
  404c26:	b113      	cbz	r3, 404c2e <register_fini+0xa>
  404c28:	4802      	ldr	r0, [pc, #8]	; (404c34 <register_fini+0x10>)
  404c2a:	f000 b805 	b.w	404c38 <atexit>
  404c2e:	4770      	bx	lr
  404c30:	00000000 	.word	0x00000000
  404c34:	00404b6d 	.word	0x00404b6d

00404c38 <atexit>:
  404c38:	4601      	mov	r1, r0
  404c3a:	2000      	movs	r0, #0
  404c3c:	4602      	mov	r2, r0
  404c3e:	4603      	mov	r3, r0
  404c40:	f7ff bf46 	b.w	404ad0 <__register_exitproc>

00404c44 <heapSTRUCT_SIZE>:
  404c44:	0008 0000                                   ....

00404c48 <xTotalHeapSize>:
  404c48:	9ff8 0000                                   ....

00404c4c <pcInterruptPriorityRegisters>:
  404c4c:	e3f0 e000 4449 454c 0000 0000               ....IDLE....

00404c58 <ucExpectedStackBytes.5224>:
  404c58:	a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5     ................
  404c68:	a5a5 a5a5 6d54 2072 7653 0063 7852 0000     ....Tmr Svc.Rx..
  404c78:	5854 0000                                   TX..

00404c7c <ulLED>:
  404c7c:	0057 0000 0057 0000 0057 0000               W...W...W...

00404c88 <_global_impure_ptr>:
  404c88:	0018 2000 0043 0000                         ... C...

00404c90 <_init>:
  404c90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  404c92:	bf00      	nop
  404c94:	bcf8      	pop	{r3, r4, r5, r6, r7}
  404c96:	bc08      	pop	{r3}
  404c98:	469e      	mov	lr, r3
  404c9a:	4770      	bx	lr

00404c9c <__init_array_start>:
  404c9c:	00404c25 	.word	0x00404c25

00404ca0 <__frame_dummy_init_array_entry>:
  404ca0:	00400149                                I.@.

00404ca4 <_fini>:
  404ca4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  404ca6:	bf00      	nop
  404ca8:	bcf8      	pop	{r3, r4, r5, r6, r7}
  404caa:	bc08      	pop	{r3}
  404cac:	469e      	mov	lr, r3
  404cae:	4770      	bx	lr

00404cb0 <__fini_array_start>:
  404cb0:	00400121 	.word	0x00400121


RTOSDemo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00009828  00400000  00400000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000450  20000000  00409828  00018000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000a358  20000450  00409c78  00018450  2**2
                  ALLOC
  3 .stack        00003000  2000a7a8  00413fd0  00018450  2**0
                  ALLOC
  4 .ARM.attributes 0000002a  00000000  00000000  00018450  2**0
                  CONTENTS, READONLY
  5 .comment      00000071  00000000  00000000  0001847a  2**0
                  CONTENTS, READONLY
  6 .debug_info   0000d454  00000000  00000000  000184eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000304d  00000000  00000000  0002593f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00005619  00000000  00000000  0002898c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00001058  00000000  00000000  0002dfa5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000d88  00000000  00000000  0002effd  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00013f79  00000000  00000000  0002fd85  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000125b7  00000000  00000000  00043cfe  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0004f9bc  00000000  00000000  000562b5  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003018  00000000  00000000  000a5c74  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	2000d7a8 	.word	0x2000d7a8
  400004:	004026e5 	.word	0x004026e5
  400008:	004026dd 	.word	0x004026dd
  40000c:	004026dd 	.word	0x004026dd
  400010:	004026dd 	.word	0x004026dd
  400014:	004026dd 	.word	0x004026dd
  400018:	004026dd 	.word	0x004026dd
	...
  40002c:	00402d05 	.word	0x00402d05
  400030:	004026dd 	.word	0x004026dd
  400034:	00000000 	.word	0x00000000
  400038:	00402f01 	.word	0x00402f01
  40003c:	00402f3d 	.word	0x00402f3d
  400040:	004026dd 	.word	0x004026dd
  400044:	004026dd 	.word	0x004026dd
  400048:	004026dd 	.word	0x004026dd
  40004c:	004026dd 	.word	0x004026dd
  400050:	004026dd 	.word	0x004026dd
  400054:	004026dd 	.word	0x004026dd
  400058:	004026dd 	.word	0x004026dd
  40005c:	004026dd 	.word	0x004026dd
  400060:	004026dd 	.word	0x004026dd
  400064:	004026dd 	.word	0x004026dd
  400068:	004026dd 	.word	0x004026dd
  40006c:	004022a9 	.word	0x004022a9
  400070:	004022c5 	.word	0x004022c5
  400074:	004022e1 	.word	0x004022e1
  400078:	004026dd 	.word	0x004026dd
  40007c:	004016c9 	.word	0x004016c9
  400080:	004026dd 	.word	0x004026dd
  400084:	004026dd 	.word	0x004026dd
  400088:	004026dd 	.word	0x004026dd
  40008c:	004026dd 	.word	0x004026dd
  400090:	004026dd 	.word	0x004026dd
  400094:	004026dd 	.word	0x004026dd
  400098:	004026dd 	.word	0x004026dd
  40009c:	004026dd 	.word	0x004026dd
  4000a0:	004026dd 	.word	0x004026dd
  4000a4:	004026dd 	.word	0x004026dd
  4000a8:	004026dd 	.word	0x004026dd
  4000ac:	004026dd 	.word	0x004026dd
  4000b0:	004026dd 	.word	0x004026dd
  4000b4:	004026dd 	.word	0x004026dd
  4000b8:	004026dd 	.word	0x004026dd
  4000bc:	004026dd 	.word	0x004026dd
  4000c0:	004026dd 	.word	0x004026dd
  4000c4:	004026dd 	.word	0x004026dd
  4000c8:	004026dd 	.word	0x004026dd
  4000cc:	004026dd 	.word	0x004026dd

004000d0 <deregister_tm_clones>:
  4000d0:	b508      	push	{r3, lr}
  4000d2:	4805      	ldr	r0, [pc, #20]	; (4000e8 <deregister_tm_clones+0x18>)
  4000d4:	4b05      	ldr	r3, [pc, #20]	; (4000ec <deregister_tm_clones+0x1c>)
  4000d6:	1a19      	subs	r1, r3, r0
  4000d8:	2906      	cmp	r1, #6
  4000da:	d800      	bhi.n	4000de <deregister_tm_clones+0xe>
  4000dc:	bd08      	pop	{r3, pc}
  4000de:	4a04      	ldr	r2, [pc, #16]	; (4000f0 <deregister_tm_clones+0x20>)
  4000e0:	2a00      	cmp	r2, #0
  4000e2:	d0fb      	beq.n	4000dc <deregister_tm_clones+0xc>
  4000e4:	4790      	blx	r2
  4000e6:	e7f9      	b.n	4000dc <deregister_tm_clones+0xc>
  4000e8:	00409828 	.word	0x00409828
  4000ec:	0040982b 	.word	0x0040982b
  4000f0:	00000000 	.word	0x00000000

004000f4 <register_tm_clones>:
  4000f4:	b508      	push	{r3, lr}
  4000f6:	4807      	ldr	r0, [pc, #28]	; (400114 <register_tm_clones+0x20>)
  4000f8:	4b07      	ldr	r3, [pc, #28]	; (400118 <register_tm_clones+0x24>)
  4000fa:	1a19      	subs	r1, r3, r0
  4000fc:	108a      	asrs	r2, r1, #2
  4000fe:	eb02 73d2 	add.w	r3, r2, r2, lsr #31
  400102:	1059      	asrs	r1, r3, #1
  400104:	d100      	bne.n	400108 <register_tm_clones+0x14>
  400106:	bd08      	pop	{r3, pc}
  400108:	4a04      	ldr	r2, [pc, #16]	; (40011c <register_tm_clones+0x28>)
  40010a:	2a00      	cmp	r2, #0
  40010c:	d0fb      	beq.n	400106 <register_tm_clones+0x12>
  40010e:	4790      	blx	r2
  400110:	e7f9      	b.n	400106 <register_tm_clones+0x12>
  400112:	bf00      	nop
  400114:	00409828 	.word	0x00409828
  400118:	00409828 	.word	0x00409828
  40011c:	00000000 	.word	0x00000000

00400120 <__do_global_dtors_aux>:
  400120:	b510      	push	{r4, lr}
  400122:	4c06      	ldr	r4, [pc, #24]	; (40013c <__do_global_dtors_aux+0x1c>)
  400124:	7823      	ldrb	r3, [r4, #0]
  400126:	b943      	cbnz	r3, 40013a <__do_global_dtors_aux+0x1a>
  400128:	f7ff ffd2 	bl	4000d0 <deregister_tm_clones>
  40012c:	4804      	ldr	r0, [pc, #16]	; (400140 <__do_global_dtors_aux+0x20>)
  40012e:	b110      	cbz	r0, 400136 <__do_global_dtors_aux+0x16>
  400130:	4804      	ldr	r0, [pc, #16]	; (400144 <__do_global_dtors_aux+0x24>)
  400132:	f3af 8000 	nop.w
  400136:	2101      	movs	r1, #1
  400138:	7021      	strb	r1, [r4, #0]
  40013a:	bd10      	pop	{r4, pc}
  40013c:	20000450 	.word	0x20000450
  400140:	00000000 	.word	0x00000000
  400144:	00409828 	.word	0x00409828

00400148 <frame_dummy>:
  400148:	b508      	push	{r3, lr}
  40014a:	4b08      	ldr	r3, [pc, #32]	; (40016c <frame_dummy+0x24>)
  40014c:	b11b      	cbz	r3, 400156 <frame_dummy+0xe>
  40014e:	4808      	ldr	r0, [pc, #32]	; (400170 <frame_dummy+0x28>)
  400150:	4908      	ldr	r1, [pc, #32]	; (400174 <frame_dummy+0x2c>)
  400152:	f3af 8000 	nop.w
  400156:	4808      	ldr	r0, [pc, #32]	; (400178 <frame_dummy+0x30>)
  400158:	6801      	ldr	r1, [r0, #0]
  40015a:	b111      	cbz	r1, 400162 <frame_dummy+0x1a>
  40015c:	4a07      	ldr	r2, [pc, #28]	; (40017c <frame_dummy+0x34>)
  40015e:	b102      	cbz	r2, 400162 <frame_dummy+0x1a>
  400160:	4790      	blx	r2
  400162:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  400166:	f7ff bfc5 	b.w	4000f4 <register_tm_clones>
  40016a:	bf00      	nop
  40016c:	00000000 	.word	0x00000000
  400170:	00409828 	.word	0x00409828
  400174:	20000454 	.word	0x20000454
  400178:	00409828 	.word	0x00409828
  40017c:	00000000 	.word	0x00000000

00400180 <usart_set_async_baudrate>:
 * \retval 1 Baud rate set point is out of range for the given input clock 
 * frequency.
 */
static uint32_t usart_set_async_baudrate(Usart *p_usart,
		uint32_t baudrate, uint32_t ul_mck)
{
  400180:	b480      	push	{r7}
  400182:	b089      	sub	sp, #36	; 0x24
  400184:	af00      	add	r7, sp, #0
  400186:	60f8      	str	r0, [r7, #12]
  400188:	60b9      	str	r1, [r7, #8]
  40018a:	607a      	str	r2, [r7, #4]
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
  40018c:	68bb      	ldr	r3, [r7, #8]
  40018e:	ea4f 1203 	mov.w	r2, r3, lsl #4
  400192:	687b      	ldr	r3, [r7, #4]
  400194:	429a      	cmp	r2, r3
  400196:	d803      	bhi.n	4001a0 <usart_set_async_baudrate+0x20>
		over = HIGH_FRQ_SAMPLE_DIV;
  400198:	f04f 0310 	mov.w	r3, #16
  40019c:	61fb      	str	r3, [r7, #28]
  40019e:	e002      	b.n	4001a6 <usart_set_async_baudrate+0x26>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
  4001a0:	f04f 0308 	mov.w	r3, #8
  4001a4:	61fb      	str	r3, [r7, #28]
	}

	/* Calculate the clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  4001a6:	687b      	ldr	r3, [r7, #4]
  4001a8:	ea4f 02c3 	mov.w	r2, r3, lsl #3
  4001ac:	69fb      	ldr	r3, [r7, #28]
  4001ae:	68b9      	ldr	r1, [r7, #8]
  4001b0:	fb01 f303 	mul.w	r3, r1, r3
  4001b4:	ea4f 0353 	mov.w	r3, r3, lsr #1
  4001b8:	18d2      	adds	r2, r2, r3
  4001ba:	69fb      	ldr	r3, [r7, #28]
  4001bc:	68b9      	ldr	r1, [r7, #8]
  4001be:	fb01 f303 	mul.w	r3, r1, r3
  4001c2:	fbb2 f3f3 	udiv	r3, r2, r3
  4001c6:	61bb      	str	r3, [r7, #24]
	cd = cd_fp >> 3;
  4001c8:	69bb      	ldr	r3, [r7, #24]
  4001ca:	ea4f 03d3 	mov.w	r3, r3, lsr #3
  4001ce:	617b      	str	r3, [r7, #20]
	fp = cd_fp & 0x07;
  4001d0:	69bb      	ldr	r3, [r7, #24]
  4001d2:	f003 0307 	and.w	r3, r3, #7
  4001d6:	613b      	str	r3, [r7, #16]
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  4001d8:	697b      	ldr	r3, [r7, #20]
  4001da:	2b00      	cmp	r3, #0
  4001dc:	d004      	beq.n	4001e8 <usart_set_async_baudrate+0x68>
  4001de:	697a      	ldr	r2, [r7, #20]
  4001e0:	f64f 73ff 	movw	r3, #65535	; 0xffff
  4001e4:	429a      	cmp	r2, r3
  4001e6:	d902      	bls.n	4001ee <usart_set_async_baudrate+0x6e>
		return 1;
  4001e8:	f04f 0301 	mov.w	r3, #1
  4001ec:	e011      	b.n	400212 <usart_set_async_baudrate+0x92>
	}

	/* Configure the OVER bit in MR register. */
	if (over == 8) {
  4001ee:	69fb      	ldr	r3, [r7, #28]
  4001f0:	2b08      	cmp	r3, #8
  4001f2:	d105      	bne.n	400200 <usart_set_async_baudrate+0x80>
		p_usart->US_MR |= US_MR_OVER;
  4001f4:	68fb      	ldr	r3, [r7, #12]
  4001f6:	685b      	ldr	r3, [r3, #4]
  4001f8:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
  4001fc:	68fb      	ldr	r3, [r7, #12]
  4001fe:	605a      	str	r2, [r3, #4]
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
  400200:	693b      	ldr	r3, [r7, #16]
  400202:	ea4f 4203 	mov.w	r2, r3, lsl #16
  400206:	697b      	ldr	r3, [r7, #20]
  400208:	431a      	orrs	r2, r3
  40020a:	68fb      	ldr	r3, [r7, #12]
  40020c:	621a      	str	r2, [r3, #32]

	return 0;
  40020e:	f04f 0300 	mov.w	r3, #0
}
  400212:	4618      	mov	r0, r3
  400214:	f107 0724 	add.w	r7, r7, #36	; 0x24
  400218:	46bd      	mov	sp, r7
  40021a:	bc80      	pop	{r7}
  40021c:	4770      	bx	lr
  40021e:	bf00      	nop

00400220 <usart_reset>:
 * \brief Reset the USART and disable TX and RX.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset(Usart *p_usart)
{
  400220:	b580      	push	{r7, lr}
  400222:	b082      	sub	sp, #8
  400224:	af00      	add	r7, sp, #0
  400226:	6078      	str	r0, [r7, #4]
	/* Disable the Write Protect. Some register can't be written if the write protect is enabled. */
	usart_disable_writeprotect(p_usart);
  400228:	6878      	ldr	r0, [r7, #4]
  40022a:	f240 5325 	movw	r3, #1317	; 0x525
  40022e:	f2c0 0340 	movt	r3, #64	; 0x40
  400232:	4798      	blx	r3

	/* Reset mode and other registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
  400234:	687b      	ldr	r3, [r7, #4]
  400236:	f04f 0200 	mov.w	r2, #0
  40023a:	605a      	str	r2, [r3, #4]
	p_usart->US_RTOR = 0;
  40023c:	687b      	ldr	r3, [r7, #4]
  40023e:	f04f 0200 	mov.w	r2, #0
  400242:	625a      	str	r2, [r3, #36]	; 0x24
	p_usart->US_TTGR = 0;
  400244:	687b      	ldr	r3, [r7, #4]
  400246:	f04f 0200 	mov.w	r2, #0
  40024a:	629a      	str	r2, [r3, #40]	; 0x28

	/* Disable TX and RX, reset status bits and turn off RTS and DTR if exist. */
	usart_reset_tx(p_usart);
  40024c:	6878      	ldr	r0, [r7, #4]
  40024e:	f240 335d 	movw	r3, #861	; 0x35d
  400252:	f2c0 0340 	movt	r3, #64	; 0x40
  400256:	4798      	blx	r3
	usart_reset_rx(p_usart);
  400258:	6878      	ldr	r0, [r7, #4]
  40025a:	f240 3395 	movw	r3, #917	; 0x395
  40025e:	f2c0 0340 	movt	r3, #64	; 0x40
  400262:	4798      	blx	r3
	usart_reset_status(p_usart);
  400264:	6878      	ldr	r0, [r7, #4]
  400266:	f240 4319 	movw	r3, #1049	; 0x419
  40026a:	f2c0 0340 	movt	r3, #64	; 0x40
  40026e:	4798      	blx	r3
	usart_drive_RTS_pin_high(p_usart);
  400270:	6878      	ldr	r0, [r7, #4]
  400272:	f240 4351 	movw	r3, #1105	; 0x451
  400276:	f2c0 0340 	movt	r3, #64	; 0x40
  40027a:	4798      	blx	r3
#if (SAM3S || SAM4S || SAM3U)
	usart_drive_DTR_pin_high(p_usart);
  40027c:	6878      	ldr	r0, [r7, #4]
  40027e:	f240 4335 	movw	r3, #1077	; 0x435
  400282:	f2c0 0340 	movt	r3, #64	; 0x40
  400286:	4798      	blx	r3
#endif
}
  400288:	f107 0708 	add.w	r7, r7, #8
  40028c:	46bd      	mov	sp, r7
  40028e:	bd80      	pop	{r7, pc}

00400290 <usart_init_rs232>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_init_rs232(Usart *p_usart,
		const sam_usart_opt_t *p_usart_opt, uint32_t ul_mck)
{
  400290:	b580      	push	{r7, lr}
  400292:	b084      	sub	sp, #16
  400294:	af00      	add	r7, sp, #0
  400296:	60f8      	str	r0, [r7, #12]
  400298:	60b9      	str	r1, [r7, #8]
  40029a:	607a      	str	r2, [r7, #4]
	static uint32_t ul_reg_val;

	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);
  40029c:	68f8      	ldr	r0, [r7, #12]
  40029e:	f240 2321 	movw	r3, #545	; 0x221
  4002a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4002a6:	4798      	blx	r3

	ul_reg_val = 0;
  4002a8:	f240 436c 	movw	r3, #1132	; 0x46c
  4002ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4002b0:	f04f 0200 	mov.w	r2, #0
  4002b4:	601a      	str	r2, [r3, #0]
	/* Check whether the input values are legal. */
	if (!p_usart_opt ||
  4002b6:	68bb      	ldr	r3, [r7, #8]
  4002b8:	2b00      	cmp	r3, #0
  4002ba:	d00c      	beq.n	4002d6 <usart_init_rs232+0x46>
		usart_set_async_baudrate(p_usart, p_usart_opt->baudrate, ul_mck)) {
  4002bc:	68bb      	ldr	r3, [r7, #8]
  4002be:	681b      	ldr	r3, [r3, #0]
  4002c0:	68f8      	ldr	r0, [r7, #12]
  4002c2:	4619      	mov	r1, r3
  4002c4:	687a      	ldr	r2, [r7, #4]
  4002c6:	f240 1381 	movw	r3, #385	; 0x181
  4002ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4002ce:	4798      	blx	r3
  4002d0:	4603      	mov	r3, r0
	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);

	ul_reg_val = 0;
	/* Check whether the input values are legal. */
	if (!p_usart_opt ||
  4002d2:	2b00      	cmp	r3, #0
  4002d4:	d002      	beq.n	4002dc <usart_init_rs232+0x4c>
		usart_set_async_baudrate(p_usart, p_usart_opt->baudrate, ul_mck)) {
		return 1;
  4002d6:	f04f 0301 	mov.w	r3, #1
  4002da:	e02b      	b.n	400334 <usart_init_rs232+0xa4>
	}

	/* Configure the character length, parity type, channel mode and stop bit length. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  4002dc:	68bb      	ldr	r3, [r7, #8]
  4002de:	685a      	ldr	r2, [r3, #4]
  4002e0:	68bb      	ldr	r3, [r7, #8]
  4002e2:	689b      	ldr	r3, [r3, #8]
  4002e4:	431a      	orrs	r2, r3
				p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  4002e6:	68bb      	ldr	r3, [r7, #8]
  4002e8:	691b      	ldr	r3, [r3, #16]
		usart_set_async_baudrate(p_usart, p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the character length, parity type, channel mode and stop bit length. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  4002ea:	431a      	orrs	r2, r3
				p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  4002ec:	68bb      	ldr	r3, [r7, #8]
  4002ee:	68db      	ldr	r3, [r3, #12]
  4002f0:	431a      	orrs	r2, r3
		usart_set_async_baudrate(p_usart, p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the character length, parity type, channel mode and stop bit length. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  4002f2:	f240 436c 	movw	r3, #1132	; 0x46c
  4002f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4002fa:	681b      	ldr	r3, [r3, #0]
  4002fc:	431a      	orrs	r2, r3
  4002fe:	f240 436c 	movw	r3, #1132	; 0x46c
  400302:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400306:	601a      	str	r2, [r3, #0]
				p_usart_opt->channel_mode | p_usart_opt->stop_bits;
	
	/* Configure the USART mode as normal mode. */
	ul_reg_val |= US_MR_USART_MODE_NORMAL;
  400308:	f240 436c 	movw	r3, #1132	; 0x46c
  40030c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400310:	681a      	ldr	r2, [r3, #0]
  400312:	f240 436c 	movw	r3, #1132	; 0x46c
  400316:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40031a:	601a      	str	r2, [r3, #0]
	
	p_usart->US_MR |= ul_reg_val;
  40031c:	68fb      	ldr	r3, [r7, #12]
  40031e:	685a      	ldr	r2, [r3, #4]
  400320:	f240 436c 	movw	r3, #1132	; 0x46c
  400324:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400328:	681b      	ldr	r3, [r3, #0]
  40032a:	431a      	orrs	r2, r3
  40032c:	68fb      	ldr	r3, [r7, #12]
  40032e:	605a      	str	r2, [r3, #4]
	
	return 0;
  400330:	f04f 0300 	mov.w	r3, #0
}
  400334:	4618      	mov	r0, r3
  400336:	f107 0710 	add.w	r7, r7, #16
  40033a:	46bd      	mov	sp, r7
  40033c:	bd80      	pop	{r7, pc}
  40033e:	bf00      	nop

00400340 <usart_enable_tx>:
 * \brief Enable USART transmitter.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_tx(Usart *p_usart)
{
  400340:	b480      	push	{r7}
  400342:	b083      	sub	sp, #12
  400344:	af00      	add	r7, sp, #0
  400346:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_TXEN;
  400348:	687b      	ldr	r3, [r7, #4]
  40034a:	f04f 0240 	mov.w	r2, #64	; 0x40
  40034e:	601a      	str	r2, [r3, #0]
}
  400350:	f107 070c 	add.w	r7, r7, #12
  400354:	46bd      	mov	sp, r7
  400356:	bc80      	pop	{r7}
  400358:	4770      	bx	lr
  40035a:	bf00      	nop

0040035c <usart_reset_tx>:
 * \brief Immediately stop and disable USART transmitter.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_tx(Usart *p_usart)
{
  40035c:	b480      	push	{r7}
  40035e:	b083      	sub	sp, #12
  400360:	af00      	add	r7, sp, #0
  400362:	6078      	str	r0, [r7, #4]
	/* Reset transmitter */
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  400364:	687b      	ldr	r3, [r7, #4]
  400366:	f04f 0288 	mov.w	r2, #136	; 0x88
  40036a:	601a      	str	r2, [r3, #0]
}
  40036c:	f107 070c 	add.w	r7, r7, #12
  400370:	46bd      	mov	sp, r7
  400372:	bc80      	pop	{r7}
  400374:	4770      	bx	lr
  400376:	bf00      	nop

00400378 <usart_enable_rx>:
 * \brief Enable USART receiver.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_rx(Usart *p_usart)
{
  400378:	b480      	push	{r7}
  40037a:	b083      	sub	sp, #12
  40037c:	af00      	add	r7, sp, #0
  40037e:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RXEN;
  400380:	687b      	ldr	r3, [r7, #4]
  400382:	f04f 0210 	mov.w	r2, #16
  400386:	601a      	str	r2, [r3, #0]
}
  400388:	f107 070c 	add.w	r7, r7, #12
  40038c:	46bd      	mov	sp, r7
  40038e:	bc80      	pop	{r7}
  400390:	4770      	bx	lr
  400392:	bf00      	nop

00400394 <usart_reset_rx>:
 * \brief Immediately stop and disable USART receiver.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_rx(Usart *p_usart)
{
  400394:	b480      	push	{r7}
  400396:	b083      	sub	sp, #12
  400398:	af00      	add	r7, sp, #0
  40039a:	6078      	str	r0, [r7, #4]
	/* Reset Receiver */
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  40039c:	687b      	ldr	r3, [r7, #4]
  40039e:	f04f 0224 	mov.w	r2, #36	; 0x24
  4003a2:	601a      	str	r2, [r3, #0]
}
  4003a4:	f107 070c 	add.w	r7, r7, #12
  4003a8:	46bd      	mov	sp, r7
  4003aa:	bc80      	pop	{r7}
  4003ac:	4770      	bx	lr
  4003ae:	bf00      	nop

004003b0 <usart_enable_interrupt>:
 *
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_enable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
  4003b0:	b480      	push	{r7}
  4003b2:	b083      	sub	sp, #12
  4003b4:	af00      	add	r7, sp, #0
  4003b6:	6078      	str	r0, [r7, #4]
  4003b8:	6039      	str	r1, [r7, #0]
	p_usart->US_IER = ul_sources;
  4003ba:	687b      	ldr	r3, [r7, #4]
  4003bc:	683a      	ldr	r2, [r7, #0]
  4003be:	609a      	str	r2, [r3, #8]
}
  4003c0:	f107 070c 	add.w	r7, r7, #12
  4003c4:	46bd      	mov	sp, r7
  4003c6:	bc80      	pop	{r7}
  4003c8:	4770      	bx	lr
  4003ca:	bf00      	nop

004003cc <usart_disable_interrupt>:
 *
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_disable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
  4003cc:	b480      	push	{r7}
  4003ce:	b083      	sub	sp, #12
  4003d0:	af00      	add	r7, sp, #0
  4003d2:	6078      	str	r0, [r7, #4]
  4003d4:	6039      	str	r1, [r7, #0]
	p_usart->US_IDR = ul_sources;
  4003d6:	687b      	ldr	r3, [r7, #4]
  4003d8:	683a      	ldr	r2, [r7, #0]
  4003da:	60da      	str	r2, [r3, #12]
}
  4003dc:	f107 070c 	add.w	r7, r7, #12
  4003e0:	46bd      	mov	sp, r7
  4003e2:	bc80      	pop	{r7}
  4003e4:	4770      	bx	lr
  4003e6:	bf00      	nop

004003e8 <usart_get_interrupt_mask>:
 * \param p_usart Pointer to a USART peripheral.
 *
 * \return The interrupt mask value.
 */
uint32_t usart_get_interrupt_mask(Usart *p_usart)
{
  4003e8:	b480      	push	{r7}
  4003ea:	b083      	sub	sp, #12
  4003ec:	af00      	add	r7, sp, #0
  4003ee:	6078      	str	r0, [r7, #4]
	return p_usart->US_IMR;
  4003f0:	687b      	ldr	r3, [r7, #4]
  4003f2:	691b      	ldr	r3, [r3, #16]
}
  4003f4:	4618      	mov	r0, r3
  4003f6:	f107 070c 	add.w	r7, r7, #12
  4003fa:	46bd      	mov	sp, r7
  4003fc:	bc80      	pop	{r7}
  4003fe:	4770      	bx	lr

00400400 <usart_get_status>:
 * \param p_usart Pointer to a USART instance.
 *
 * \return The current USART status.
 */
uint32_t usart_get_status(Usart *p_usart)
{
  400400:	b480      	push	{r7}
  400402:	b083      	sub	sp, #12
  400404:	af00      	add	r7, sp, #0
  400406:	6078      	str	r0, [r7, #4]
	return p_usart->US_CSR;
  400408:	687b      	ldr	r3, [r7, #4]
  40040a:	695b      	ldr	r3, [r3, #20]
}
  40040c:	4618      	mov	r0, r3
  40040e:	f107 070c 	add.w	r7, r7, #12
  400412:	46bd      	mov	sp, r7
  400414:	bc80      	pop	{r7}
  400416:	4770      	bx	lr

00400418 <usart_reset_status>:
 * \brief Reset status bits (PARE, OVER, MANERR, UNRE and PXBRK in US_CSR).
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
  400418:	b480      	push	{r7}
  40041a:	b083      	sub	sp, #12
  40041c:	af00      	add	r7, sp, #0
  40041e:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RSTSTA;
  400420:	687b      	ldr	r3, [r7, #4]
  400422:	f44f 7280 	mov.w	r2, #256	; 0x100
  400426:	601a      	str	r2, [r3, #0]
}
  400428:	f107 070c 	add.w	r7, r7, #12
  40042c:	46bd      	mov	sp, r7
  40042e:	bc80      	pop	{r7}
  400430:	4770      	bx	lr
  400432:	bf00      	nop

00400434 <usart_drive_DTR_pin_high>:
 * \brief Drive the pin DTR to 1.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_DTR_pin_high(Usart *p_usart)
{
  400434:	b480      	push	{r7}
  400436:	b083      	sub	sp, #12
  400438:	af00      	add	r7, sp, #0
  40043a:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_DTRDIS;
  40043c:	687b      	ldr	r3, [r7, #4]
  40043e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  400442:	601a      	str	r2, [r3, #0]
}
  400444:	f107 070c 	add.w	r7, r7, #12
  400448:	46bd      	mov	sp, r7
  40044a:	bc80      	pop	{r7}
  40044c:	4770      	bx	lr
  40044e:	bf00      	nop

00400450 <usart_drive_RTS_pin_high>:
 * \brief Drive the pin RTS to 1.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_RTS_pin_high(Usart *p_usart)
{
  400450:	b480      	push	{r7}
  400452:	b083      	sub	sp, #12
  400454:	af00      	add	r7, sp, #0
  400456:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RTSDIS;
  400458:	687b      	ldr	r3, [r7, #4]
  40045a:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  40045e:	601a      	str	r2, [r3, #0]
}
  400460:	f107 070c 	add.w	r7, r7, #12
  400464:	46bd      	mov	sp, r7
  400466:	bc80      	pop	{r7}
  400468:	4770      	bx	lr
  40046a:	bf00      	nop

0040046c <usart_putchar>:
 *
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_putchar(Usart *p_usart, uint32_t c)
{
  40046c:	b480      	push	{r7}
  40046e:	b085      	sub	sp, #20
  400470:	af00      	add	r7, sp, #0
  400472:	6078      	str	r0, [r7, #4]
  400474:	6039      	str	r1, [r7, #0]
	uint32_t timeout = USART_DEFAULT_TIMEOUT;
  400476:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  40047a:	60fb      	str	r3, [r7, #12]

	while (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  40047c:	e00e      	b.n	40049c <usart_putchar+0x30>
		if (!timeout--) {
  40047e:	68fb      	ldr	r3, [r7, #12]
  400480:	2b00      	cmp	r3, #0
  400482:	bf14      	ite	ne
  400484:	2300      	movne	r3, #0
  400486:	2301      	moveq	r3, #1
  400488:	b2db      	uxtb	r3, r3
  40048a:	68fa      	ldr	r2, [r7, #12]
  40048c:	f102 32ff 	add.w	r2, r2, #4294967295
  400490:	60fa      	str	r2, [r7, #12]
  400492:	2b00      	cmp	r3, #0
  400494:	d002      	beq.n	40049c <usart_putchar+0x30>
			return 1;
  400496:	f04f 0301 	mov.w	r3, #1
  40049a:	e00e      	b.n	4004ba <usart_putchar+0x4e>
 */
uint32_t usart_putchar(Usart *p_usart, uint32_t c)
{
	uint32_t timeout = USART_DEFAULT_TIMEOUT;

	while (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  40049c:	687b      	ldr	r3, [r7, #4]
  40049e:	695b      	ldr	r3, [r3, #20]
  4004a0:	f003 0302 	and.w	r3, r3, #2
  4004a4:	2b00      	cmp	r3, #0
  4004a6:	d0ea      	beq.n	40047e <usart_putchar+0x12>
		if (!timeout--) {
			return 1;
		}
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  4004a8:	683b      	ldr	r3, [r7, #0]
  4004aa:	ea4f 53c3 	mov.w	r3, r3, lsl #23
  4004ae:	ea4f 53d3 	mov.w	r3, r3, lsr #23
  4004b2:	687a      	ldr	r2, [r7, #4]
  4004b4:	61d3      	str	r3, [r2, #28]

	return 0;
  4004b6:	f04f 0300 	mov.w	r3, #0
}
  4004ba:	4618      	mov	r0, r3
  4004bc:	f107 0714 	add.w	r7, r7, #20
  4004c0:	46bd      	mov	sp, r7
  4004c2:	bc80      	pop	{r7}
  4004c4:	4770      	bx	lr
  4004c6:	bf00      	nop

004004c8 <usart_getchar>:
 *
 * \retval 0 Data has been received.
 * \retval 1 on failure.
 */
uint32_t usart_getchar(Usart *p_usart, uint32_t *c)
{
  4004c8:	b480      	push	{r7}
  4004ca:	b085      	sub	sp, #20
  4004cc:	af00      	add	r7, sp, #0
  4004ce:	6078      	str	r0, [r7, #4]
  4004d0:	6039      	str	r1, [r7, #0]
	uint32_t timeout = USART_DEFAULT_TIMEOUT;
  4004d2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  4004d6:	60fb      	str	r3, [r7, #12]

	/* If the receiver is empty, wait until it's not empty or timeout has reached. */
	while (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  4004d8:	e00e      	b.n	4004f8 <usart_getchar+0x30>
		if (!timeout--) {
  4004da:	68fb      	ldr	r3, [r7, #12]
  4004dc:	2b00      	cmp	r3, #0
  4004de:	bf14      	ite	ne
  4004e0:	2300      	movne	r3, #0
  4004e2:	2301      	moveq	r3, #1
  4004e4:	b2db      	uxtb	r3, r3
  4004e6:	68fa      	ldr	r2, [r7, #12]
  4004e8:	f102 32ff 	add.w	r2, r2, #4294967295
  4004ec:	60fa      	str	r2, [r7, #12]
  4004ee:	2b00      	cmp	r3, #0
  4004f0:	d002      	beq.n	4004f8 <usart_getchar+0x30>
			return 1;
  4004f2:	f04f 0301 	mov.w	r3, #1
  4004f6:	e00f      	b.n	400518 <usart_getchar+0x50>
uint32_t usart_getchar(Usart *p_usart, uint32_t *c)
{
	uint32_t timeout = USART_DEFAULT_TIMEOUT;

	/* If the receiver is empty, wait until it's not empty or timeout has reached. */
	while (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  4004f8:	687b      	ldr	r3, [r7, #4]
  4004fa:	695b      	ldr	r3, [r3, #20]
  4004fc:	f003 0301 	and.w	r3, r3, #1
  400500:	2b00      	cmp	r3, #0
  400502:	d0ea      	beq.n	4004da <usart_getchar+0x12>
			return 1;
		}
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  400504:	687b      	ldr	r3, [r7, #4]
  400506:	699b      	ldr	r3, [r3, #24]
  400508:	ea4f 53c3 	mov.w	r3, r3, lsl #23
  40050c:	ea4f 53d3 	mov.w	r3, r3, lsr #23
  400510:	683a      	ldr	r2, [r7, #0]
  400512:	6013      	str	r3, [r2, #0]

	return 0;
  400514:	f04f 0300 	mov.w	r3, #0
}
  400518:	4618      	mov	r0, r3
  40051a:	f107 0714 	add.w	r7, r7, #20
  40051e:	46bd      	mov	sp, r7
  400520:	bc80      	pop	{r7}
  400522:	4770      	bx	lr

00400524 <usart_disable_writeprotect>:
 * \brief Disable write protect of USART registers.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
  400524:	b480      	push	{r7}
  400526:	b083      	sub	sp, #12
  400528:	af00      	add	r7, sp, #0
  40052a:	6078      	str	r0, [r7, #4]
	p_usart->US_WPMR = US_WPMR_WPKEY(US_WPKEY_VALUE);
  40052c:	687a      	ldr	r2, [r7, #4]
  40052e:	f44f 4382 	mov.w	r3, #16640	; 0x4100
  400532:	f2c5 5353 	movt	r3, #21843	; 0x5553
  400536:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
}
  40053a:	f107 070c 	add.w	r7, r7, #12
  40053e:	46bd      	mov	sp, r7
  400540:	bc80      	pop	{r7}
  400542:	4770      	bx	lr

00400544 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  400544:	b580      	push	{r7, lr}
  400546:	b086      	sub	sp, #24
  400548:	af00      	add	r7, sp, #0
  40054a:	6078      	str	r0, [r7, #4]
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
  40054c:	f04f 0300 	mov.w	r3, #0
  400550:	60fb      	str	r3, [r7, #12]

	vTaskSuspendAll();
  400552:	f644 03f9 	movw	r3, #18681	; 0x48f9
  400556:	f2c0 0340 	movt	r3, #64	; 0x40
  40055a:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
  40055c:	f24a 4378 	movw	r3, #42104	; 0xa478
  400560:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400564:	681b      	ldr	r3, [r3, #0]
  400566:	2b00      	cmp	r3, #0
  400568:	d104      	bne.n	400574 <pvPortMalloc+0x30>
		{
			prvHeapInit();
  40056a:	f240 7399 	movw	r3, #1945	; 0x799
  40056e:	f2c0 0340 	movt	r3, #64	; 0x40
  400572:	4798      	blx	r3

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the xBlockLink structure 
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
  400574:	f24a 437c 	movw	r3, #42108	; 0xa47c
  400578:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40057c:	681a      	ldr	r2, [r3, #0]
  40057e:	687b      	ldr	r3, [r7, #4]
  400580:	4013      	ands	r3, r2
  400582:	2b00      	cmp	r3, #0
  400584:	f040 808b 	bne.w	40069e <pvPortMalloc+0x15a>
		{
			/* The wanted size is increased so it can contain a xBlockLink
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
  400588:	687b      	ldr	r3, [r7, #4]
  40058a:	2b00      	cmp	r3, #0
  40058c:	d012      	beq.n	4005b4 <pvPortMalloc+0x70>
			{
				xWantedSize += heapSTRUCT_SIZE;
  40058e:	f249 6388 	movw	r3, #38536	; 0x9688
  400592:	f2c0 0340 	movt	r3, #64	; 0x40
  400596:	881b      	ldrh	r3, [r3, #0]
  400598:	687a      	ldr	r2, [r7, #4]
  40059a:	18d3      	adds	r3, r2, r3
  40059c:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number 
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
  40059e:	687b      	ldr	r3, [r7, #4]
  4005a0:	f003 0307 	and.w	r3, r3, #7
  4005a4:	2b00      	cmp	r3, #0
  4005a6:	d005      	beq.n	4005b4 <pvPortMalloc+0x70>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  4005a8:	687b      	ldr	r3, [r7, #4]
  4005aa:	f023 0307 	bic.w	r3, r3, #7
  4005ae:	f103 0308 	add.w	r3, r3, #8
  4005b2:	607b      	str	r3, [r7, #4]
				}
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
  4005b4:	687b      	ldr	r3, [r7, #4]
  4005b6:	2b00      	cmp	r3, #0
  4005b8:	d071      	beq.n	40069e <pvPortMalloc+0x15a>
  4005ba:	f240 0300 	movw	r3, #0
  4005be:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4005c2:	681b      	ldr	r3, [r3, #0]
  4005c4:	687a      	ldr	r2, [r7, #4]
  4005c6:	429a      	cmp	r2, r3
  4005c8:	d869      	bhi.n	40069e <pvPortMalloc+0x15a>
			{
				/* Traverse the list from the start	(lowest address) block until 
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
  4005ca:	f24a 4370 	movw	r3, #42096	; 0xa470
  4005ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4005d2:	613b      	str	r3, [r7, #16]
				pxBlock = xStart.pxNextFreeBlock;
  4005d4:	f24a 4370 	movw	r3, #42096	; 0xa470
  4005d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4005dc:	681b      	ldr	r3, [r3, #0]
  4005de:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  4005e0:	e004      	b.n	4005ec <pvPortMalloc+0xa8>
				{
					pxPreviousBlock = pxBlock;
  4005e2:	697b      	ldr	r3, [r7, #20]
  4005e4:	613b      	str	r3, [r7, #16]
					pxBlock = pxBlock->pxNextFreeBlock;
  4005e6:	697b      	ldr	r3, [r7, #20]
  4005e8:	681b      	ldr	r3, [r3, #0]
  4005ea:	617b      	str	r3, [r7, #20]
			{
				/* Traverse the list from the start	(lowest address) block until 
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  4005ec:	697b      	ldr	r3, [r7, #20]
  4005ee:	685a      	ldr	r2, [r3, #4]
  4005f0:	687b      	ldr	r3, [r7, #4]
  4005f2:	429a      	cmp	r2, r3
  4005f4:	d203      	bcs.n	4005fe <pvPortMalloc+0xba>
  4005f6:	697b      	ldr	r3, [r7, #20]
  4005f8:	681b      	ldr	r3, [r3, #0]
  4005fa:	2b00      	cmp	r3, #0
  4005fc:	d1f1      	bne.n	4005e2 <pvPortMalloc+0x9e>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size 
				was	not found. */
				if( pxBlock != pxEnd )
  4005fe:	f24a 4378 	movw	r3, #42104	; 0xa478
  400602:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400606:	681b      	ldr	r3, [r3, #0]
  400608:	697a      	ldr	r2, [r7, #20]
  40060a:	429a      	cmp	r2, r3
  40060c:	d047      	beq.n	40069e <pvPortMalloc+0x15a>
				{
					/* Return the memory space pointed to - jumping over the 
					xBlockLink structure at its start. */
					pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
  40060e:	693b      	ldr	r3, [r7, #16]
  400610:	681a      	ldr	r2, [r3, #0]
  400612:	f249 6388 	movw	r3, #38536	; 0x9688
  400616:	f2c0 0340 	movt	r3, #64	; 0x40
  40061a:	881b      	ldrh	r3, [r3, #0]
  40061c:	18d3      	adds	r3, r2, r3
  40061e:	60fb      	str	r3, [r7, #12]

					/* This block is being returned for use so must be taken out 
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  400620:	697b      	ldr	r3, [r7, #20]
  400622:	681a      	ldr	r2, [r3, #0]
  400624:	693b      	ldr	r3, [r7, #16]
  400626:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into 
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  400628:	697b      	ldr	r3, [r7, #20]
  40062a:	685a      	ldr	r2, [r3, #4]
  40062c:	687b      	ldr	r3, [r7, #4]
  40062e:	1ad2      	subs	r2, r2, r3
  400630:	f249 6388 	movw	r3, #38536	; 0x9688
  400634:	f2c0 0340 	movt	r3, #64	; 0x40
  400638:	881b      	ldrh	r3, [r3, #0]
  40063a:	ea4f 0343 	mov.w	r3, r3, lsl #1
  40063e:	429a      	cmp	r2, r3
  400640:	d912      	bls.n	400668 <pvPortMalloc+0x124>
					{
						/* This block is to be split into two.  Create a new 
						block following the number of bytes requested. The void 
						cast is used to prevent byte alignment warnings from the 
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
  400642:	697a      	ldr	r2, [r7, #20]
  400644:	687b      	ldr	r3, [r7, #4]
  400646:	18d3      	adds	r3, r2, r3
  400648:	60bb      	str	r3, [r7, #8]

						/* Calculate the sizes of two blocks split from the 
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  40064a:	697b      	ldr	r3, [r7, #20]
  40064c:	685a      	ldr	r2, [r3, #4]
  40064e:	687b      	ldr	r3, [r7, #4]
  400650:	1ad2      	subs	r2, r2, r3
  400652:	68bb      	ldr	r3, [r7, #8]
  400654:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
  400656:	697b      	ldr	r3, [r7, #20]
  400658:	687a      	ldr	r2, [r7, #4]
  40065a:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
  40065c:	68b8      	ldr	r0, [r7, #8]
  40065e:	f640 0395 	movw	r3, #2197	; 0x895
  400662:	f2c0 0340 	movt	r3, #64	; 0x40
  400666:	4798      	blx	r3
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
  400668:	f240 0300 	movw	r3, #0
  40066c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400670:	681a      	ldr	r2, [r3, #0]
  400672:	697b      	ldr	r3, [r7, #20]
  400674:	685b      	ldr	r3, [r3, #4]
  400676:	1ad2      	subs	r2, r2, r3
  400678:	f240 0300 	movw	r3, #0
  40067c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400680:	601a      	str	r2, [r3, #0]

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
  400682:	697b      	ldr	r3, [r7, #20]
  400684:	685a      	ldr	r2, [r3, #4]
  400686:	f24a 437c 	movw	r3, #42108	; 0xa47c
  40068a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40068e:	681b      	ldr	r3, [r3, #0]
  400690:	431a      	orrs	r2, r3
  400692:	697b      	ldr	r3, [r7, #20]
  400694:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
  400696:	697b      	ldr	r3, [r7, #20]
  400698:	f04f 0200 	mov.w	r2, #0
  40069c:	601a      	str	r2, [r3, #0]
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	xTaskResumeAll();
  40069e:	f644 131d 	movw	r3, #18717	; 0x491d
  4006a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4006a6:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
  4006a8:	68fb      	ldr	r3, [r7, #12]
  4006aa:	2b00      	cmp	r3, #0
  4006ac:	d104      	bne.n	4006b8 <pvPortMalloc+0x174>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
  4006ae:	f249 1341 	movw	r3, #37185	; 0x9141
  4006b2:	f2c0 0340 	movt	r3, #64	; 0x40
  4006b6:	4798      	blx	r3
		}
	}
	#endif

	return pvReturn;
  4006b8:	68fb      	ldr	r3, [r7, #12]
}
  4006ba:	4618      	mov	r0, r3
  4006bc:	f107 0718 	add.w	r7, r7, #24
  4006c0:	46bd      	mov	sp, r7
  4006c2:	bd80      	pop	{r7, pc}

004006c4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  4006c4:	b580      	push	{r7, lr}
  4006c6:	b084      	sub	sp, #16
  4006c8:	af00      	add	r7, sp, #0
  4006ca:	6078      	str	r0, [r7, #4]
unsigned char *puc = ( unsigned char * ) pv;
  4006cc:	687b      	ldr	r3, [r7, #4]
  4006ce:	60fb      	str	r3, [r7, #12]
xBlockLink *pxLink;

	if( pv != NULL )
  4006d0:	687b      	ldr	r3, [r7, #4]
  4006d2:	2b00      	cmp	r3, #0
  4006d4:	d05c      	beq.n	400790 <vPortFree+0xcc>
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
  4006d6:	f249 6388 	movw	r3, #38536	; 0x9688
  4006da:	f2c0 0340 	movt	r3, #64	; 0x40
  4006de:	881b      	ldrh	r3, [r3, #0]
  4006e0:	f1c3 0300 	rsb	r3, r3, #0
  4006e4:	68fa      	ldr	r2, [r7, #12]
  4006e6:	18d3      	adds	r3, r2, r3
  4006e8:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
  4006ea:	68fb      	ldr	r3, [r7, #12]
  4006ec:	60bb      	str	r3, [r7, #8]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
  4006ee:	68bb      	ldr	r3, [r7, #8]
  4006f0:	685a      	ldr	r2, [r3, #4]
  4006f2:	f24a 437c 	movw	r3, #42108	; 0xa47c
  4006f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4006fa:	681b      	ldr	r3, [r3, #0]
  4006fc:	4013      	ands	r3, r2
  4006fe:	2b00      	cmp	r3, #0
  400700:	d105      	bne.n	40070e <vPortFree+0x4a>
  400702:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  400706:	f2c0 0340 	movt	r3, #64	; 0x40
  40070a:	4798      	blx	r3
  40070c:	e7fe      	b.n	40070c <vPortFree+0x48>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
  40070e:	68bb      	ldr	r3, [r7, #8]
  400710:	681b      	ldr	r3, [r3, #0]
  400712:	2b00      	cmp	r3, #0
  400714:	d005      	beq.n	400722 <vPortFree+0x5e>
  400716:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  40071a:	f2c0 0340 	movt	r3, #64	; 0x40
  40071e:	4798      	blx	r3
  400720:	e7fe      	b.n	400720 <vPortFree+0x5c>
		
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
  400722:	68bb      	ldr	r3, [r7, #8]
  400724:	685a      	ldr	r2, [r3, #4]
  400726:	f24a 437c 	movw	r3, #42108	; 0xa47c
  40072a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40072e:	681b      	ldr	r3, [r3, #0]
  400730:	4013      	ands	r3, r2
  400732:	2b00      	cmp	r3, #0
  400734:	d02c      	beq.n	400790 <vPortFree+0xcc>
		{
			if( pxLink->pxNextFreeBlock == NULL )
  400736:	68bb      	ldr	r3, [r7, #8]
  400738:	681b      	ldr	r3, [r3, #0]
  40073a:	2b00      	cmp	r3, #0
  40073c:	d128      	bne.n	400790 <vPortFree+0xcc>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
  40073e:	68bb      	ldr	r3, [r7, #8]
  400740:	685a      	ldr	r2, [r3, #4]
  400742:	f24a 437c 	movw	r3, #42108	; 0xa47c
  400746:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40074a:	681b      	ldr	r3, [r3, #0]
  40074c:	ea6f 0303 	mvn.w	r3, r3
  400750:	401a      	ands	r2, r3
  400752:	68bb      	ldr	r3, [r7, #8]
  400754:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
  400756:	f644 03f9 	movw	r3, #18681	; 0x48f9
  40075a:	f2c0 0340 	movt	r3, #64	; 0x40
  40075e:	4798      	blx	r3
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
  400760:	68bb      	ldr	r3, [r7, #8]
  400762:	685a      	ldr	r2, [r3, #4]
  400764:	f240 0300 	movw	r3, #0
  400768:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40076c:	681b      	ldr	r3, [r3, #0]
  40076e:	18d2      	adds	r2, r2, r3
  400770:	f240 0300 	movw	r3, #0
  400774:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400778:	601a      	str	r2, [r3, #0]
					prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
  40077a:	68b8      	ldr	r0, [r7, #8]
  40077c:	f640 0395 	movw	r3, #2197	; 0x895
  400780:	f2c0 0340 	movt	r3, #64	; 0x40
  400784:	4798      	blx	r3
					traceFREE( pv, pxLink->xBlockSize );
				}
				xTaskResumeAll();
  400786:	f644 131d 	movw	r3, #18717	; 0x491d
  40078a:	f2c0 0340 	movt	r3, #64	; 0x40
  40078e:	4798      	blx	r3
			}
		}
	}
}
  400790:	f107 0710 	add.w	r7, r7, #16
  400794:	46bd      	mov	sp, r7
  400796:	bd80      	pop	{r7, pc}

00400798 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
  400798:	b580      	push	{r7, lr}
  40079a:	b084      	sub	sp, #16
  40079c:	af00      	add	r7, sp, #0
xBlockLink *pxFirstFreeBlock;
unsigned char *pucHeapEnd, *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
  40079e:	4b3c      	ldr	r3, [pc, #240]	; (400890 <prvHeapInit+0xf8>)
  4007a0:	f023 0307 	bic.w	r3, r3, #7
  4007a4:	60fb      	str	r3, [r7, #12]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  4007a6:	f24a 4370 	movw	r3, #42096	; 0xa470
  4007aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4007ae:	68fa      	ldr	r2, [r7, #12]
  4007b0:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
  4007b2:	f24a 4370 	movw	r3, #42096	; 0xa470
  4007b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4007ba:	f04f 0200 	mov.w	r2, #0
  4007be:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = pucAlignedHeap + xTotalHeapSize;
  4007c0:	f249 638c 	movw	r3, #38540	; 0x968c
  4007c4:	f2c0 0340 	movt	r3, #64	; 0x40
  4007c8:	681b      	ldr	r3, [r3, #0]
  4007ca:	68fa      	ldr	r2, [r7, #12]
  4007cc:	18d3      	adds	r3, r2, r3
  4007ce:	60bb      	str	r3, [r7, #8]
	pucHeapEnd -= heapSTRUCT_SIZE;
  4007d0:	f249 6388 	movw	r3, #38536	; 0x9688
  4007d4:	f2c0 0340 	movt	r3, #64	; 0x40
  4007d8:	881b      	ldrh	r3, [r3, #0]
  4007da:	f1c3 0300 	rsb	r3, r3, #0
  4007de:	68ba      	ldr	r2, [r7, #8]
  4007e0:	18d3      	adds	r3, r2, r3
  4007e2:	60bb      	str	r3, [r7, #8]
	pxEnd = ( void * ) pucHeapEnd;
  4007e4:	f24a 4378 	movw	r3, #42104	; 0xa478
  4007e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4007ec:	68ba      	ldr	r2, [r7, #8]
  4007ee:	601a      	str	r2, [r3, #0]
	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
  4007f0:	f24a 4378 	movw	r3, #42104	; 0xa478
  4007f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4007f8:	681b      	ldr	r3, [r3, #0]
  4007fa:	f003 0307 	and.w	r3, r3, #7
  4007fe:	2b00      	cmp	r3, #0
  400800:	d005      	beq.n	40080e <prvHeapInit+0x76>
  400802:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  400806:	f2c0 0340 	movt	r3, #64	; 0x40
  40080a:	4798      	blx	r3
  40080c:	e7fe      	b.n	40080c <prvHeapInit+0x74>
	pxEnd->xBlockSize = 0;
  40080e:	f24a 4378 	movw	r3, #42104	; 0xa478
  400812:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400816:	681b      	ldr	r3, [r3, #0]
  400818:	f04f 0200 	mov.w	r2, #0
  40081c:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
  40081e:	f24a 4378 	movw	r3, #42104	; 0xa478
  400822:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400826:	681b      	ldr	r3, [r3, #0]
  400828:	f04f 0200 	mov.w	r2, #0
  40082c:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
  40082e:	68fb      	ldr	r3, [r7, #12]
  400830:	607b      	str	r3, [r7, #4]
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
  400832:	f249 638c 	movw	r3, #38540	; 0x968c
  400836:	f2c0 0340 	movt	r3, #64	; 0x40
  40083a:	681a      	ldr	r2, [r3, #0]
  40083c:	f249 6388 	movw	r3, #38536	; 0x9688
  400840:	f2c0 0340 	movt	r3, #64	; 0x40
  400844:	881b      	ldrh	r3, [r3, #0]
  400846:	1ad2      	subs	r2, r2, r3
  400848:	687b      	ldr	r3, [r7, #4]
  40084a:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  40084c:	f24a 4378 	movw	r3, #42104	; 0xa478
  400850:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400854:	681a      	ldr	r2, [r3, #0]
  400856:	687b      	ldr	r3, [r7, #4]
  400858:	601a      	str	r2, [r3, #0]

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
  40085a:	f240 0300 	movw	r3, #0
  40085e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400862:	681a      	ldr	r2, [r3, #0]
  400864:	f249 6388 	movw	r3, #38536	; 0x9688
  400868:	f2c0 0340 	movt	r3, #64	; 0x40
  40086c:	881b      	ldrh	r3, [r3, #0]
  40086e:	1ad2      	subs	r2, r2, r3
  400870:	f240 0300 	movw	r3, #0
  400874:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400878:	601a      	str	r2, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  40087a:	f24a 437c 	movw	r3, #42108	; 0xa47c
  40087e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400882:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  400886:	601a      	str	r2, [r3, #0]
}
  400888:	f107 0710 	add.w	r7, r7, #16
  40088c:	46bd      	mov	sp, r7
  40088e:	bd80      	pop	{r7, pc}
  400890:	20000478 	.word	0x20000478

00400894 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
  400894:	b480      	push	{r7}
  400896:	b085      	sub	sp, #20
  400898:	af00      	add	r7, sp, #0
  40089a:	6078      	str	r0, [r7, #4]
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  40089c:	f24a 4370 	movw	r3, #42096	; 0xa470
  4008a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4008a4:	60fb      	str	r3, [r7, #12]
  4008a6:	e002      	b.n	4008ae <prvInsertBlockIntoFreeList+0x1a>
  4008a8:	68fb      	ldr	r3, [r7, #12]
  4008aa:	681b      	ldr	r3, [r3, #0]
  4008ac:	60fb      	str	r3, [r7, #12]
  4008ae:	68fb      	ldr	r3, [r7, #12]
  4008b0:	681a      	ldr	r2, [r3, #0]
  4008b2:	687b      	ldr	r3, [r7, #4]
  4008b4:	429a      	cmp	r2, r3
  4008b6:	d3f7      	bcc.n	4008a8 <prvInsertBlockIntoFreeList+0x14>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
  4008b8:	68fb      	ldr	r3, [r7, #12]
  4008ba:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
  4008bc:	68fb      	ldr	r3, [r7, #12]
  4008be:	685b      	ldr	r3, [r3, #4]
  4008c0:	68ba      	ldr	r2, [r7, #8]
  4008c2:	18d2      	adds	r2, r2, r3
  4008c4:	687b      	ldr	r3, [r7, #4]
  4008c6:	429a      	cmp	r2, r3
  4008c8:	d108      	bne.n	4008dc <prvInsertBlockIntoFreeList+0x48>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  4008ca:	68fb      	ldr	r3, [r7, #12]
  4008cc:	685a      	ldr	r2, [r3, #4]
  4008ce:	687b      	ldr	r3, [r7, #4]
  4008d0:	685b      	ldr	r3, [r3, #4]
  4008d2:	18d2      	adds	r2, r2, r3
  4008d4:	68fb      	ldr	r3, [r7, #12]
  4008d6:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
  4008d8:	68fb      	ldr	r3, [r7, #12]
  4008da:	607b      	str	r3, [r7, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
  4008dc:	687b      	ldr	r3, [r7, #4]
  4008de:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
  4008e0:	687b      	ldr	r3, [r7, #4]
  4008e2:	685b      	ldr	r3, [r3, #4]
  4008e4:	68ba      	ldr	r2, [r7, #8]
  4008e6:	18d2      	adds	r2, r2, r3
  4008e8:	68fb      	ldr	r3, [r7, #12]
  4008ea:	681b      	ldr	r3, [r3, #0]
  4008ec:	429a      	cmp	r2, r3
  4008ee:	d11e      	bne.n	40092e <prvInsertBlockIntoFreeList+0x9a>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  4008f0:	68fb      	ldr	r3, [r7, #12]
  4008f2:	681a      	ldr	r2, [r3, #0]
  4008f4:	f24a 4378 	movw	r3, #42104	; 0xa478
  4008f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4008fc:	681b      	ldr	r3, [r3, #0]
  4008fe:	429a      	cmp	r2, r3
  400900:	d00d      	beq.n	40091e <prvInsertBlockIntoFreeList+0x8a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  400902:	687b      	ldr	r3, [r7, #4]
  400904:	685a      	ldr	r2, [r3, #4]
  400906:	68fb      	ldr	r3, [r7, #12]
  400908:	681b      	ldr	r3, [r3, #0]
  40090a:	685b      	ldr	r3, [r3, #4]
  40090c:	18d2      	adds	r2, r2, r3
  40090e:	687b      	ldr	r3, [r7, #4]
  400910:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  400912:	68fb      	ldr	r3, [r7, #12]
  400914:	681b      	ldr	r3, [r3, #0]
  400916:	681a      	ldr	r2, [r3, #0]
  400918:	687b      	ldr	r3, [r7, #4]
  40091a:	601a      	str	r2, [r3, #0]
  40091c:	e00b      	b.n	400936 <prvInsertBlockIntoFreeList+0xa2>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  40091e:	f24a 4378 	movw	r3, #42104	; 0xa478
  400922:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400926:	681a      	ldr	r2, [r3, #0]
  400928:	687b      	ldr	r3, [r7, #4]
  40092a:	601a      	str	r2, [r3, #0]
  40092c:	e003      	b.n	400936 <prvInsertBlockIntoFreeList+0xa2>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
  40092e:	68fb      	ldr	r3, [r7, #12]
  400930:	681a      	ldr	r2, [r3, #0]
  400932:	687b      	ldr	r3, [r7, #4]
  400934:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  400936:	68fa      	ldr	r2, [r7, #12]
  400938:	687b      	ldr	r3, [r7, #4]
  40093a:	429a      	cmp	r2, r3
  40093c:	d002      	beq.n	400944 <prvInsertBlockIntoFreeList+0xb0>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  40093e:	68fb      	ldr	r3, [r7, #12]
  400940:	687a      	ldr	r2, [r7, #4]
  400942:	601a      	str	r2, [r3, #0]
	}
}
  400944:	f107 0714 	add.w	r7, r7, #20
  400948:	46bd      	mov	sp, r7
  40094a:	bc80      	pop	{r7}
  40094c:	4770      	bx	lr
  40094e:	bf00      	nop

00400950 <vStartQueueSetTasks>:
xTaskHandle xQueueSetSendingTask, xQueueSetReceivingTask;

/*-----------------------------------------------------------*/

void vStartQueueSetTasks( void )
{
  400950:	b590      	push	{r4, r7, lr}
  400952:	b085      	sub	sp, #20
  400954:	af04      	add	r7, sp, #16
	/* Create the tasks. */
	xTaskCreate( prvQueueSetSendingTask, ( signed char * ) "SetTx", configMINIMAL_STACK_SIZE, NULL, queuesetMEDIUM_PRIORITY, &xQueueSetSendingTask );
  400956:	f04f 0301 	mov.w	r3, #1
  40095a:	9300      	str	r3, [sp, #0]
  40095c:	f24a 7398 	movw	r3, #42904	; 0xa798
  400960:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400964:	9301      	str	r3, [sp, #4]
  400966:	f04f 0300 	mov.w	r3, #0
  40096a:	9302      	str	r3, [sp, #8]
  40096c:	f04f 0300 	mov.w	r3, #0
  400970:	9303      	str	r3, [sp, #12]
  400972:	f640 20e5 	movw	r0, #2789	; 0xae5
  400976:	f2c0 0040 	movt	r0, #64	; 0x40
  40097a:	f249 6190 	movw	r1, #38544	; 0x9690
  40097e:	f2c0 0140 	movt	r1, #64	; 0x40
  400982:	f04f 0282 	mov.w	r2, #130	; 0x82
  400986:	f04f 0300 	mov.w	r3, #0
  40098a:	f244 0415 	movw	r4, #16405	; 0x4015
  40098e:	f2c0 0440 	movt	r4, #64	; 0x40
  400992:	47a0      	blx	r4
	xTaskCreate( prvQueueSetReceivingTask, ( signed char * ) "SetRx", configMINIMAL_STACK_SIZE, ( void * ) xQueueSetSendingTask, queuesetMEDIUM_PRIORITY, &xQueueSetReceivingTask );
  400994:	f24a 7398 	movw	r3, #42904	; 0xa798
  400998:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40099c:	681c      	ldr	r4, [r3, #0]
  40099e:	f04f 0301 	mov.w	r3, #1
  4009a2:	9300      	str	r3, [sp, #0]
  4009a4:	f24a 739c 	movw	r3, #42908	; 0xa79c
  4009a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4009ac:	9301      	str	r3, [sp, #4]
  4009ae:	f04f 0300 	mov.w	r3, #0
  4009b2:	9302      	str	r3, [sp, #8]
  4009b4:	f04f 0300 	mov.w	r3, #0
  4009b8:	9303      	str	r3, [sp, #12]
  4009ba:	f640 40a5 	movw	r0, #3237	; 0xca5
  4009be:	f2c0 0040 	movt	r0, #64	; 0x40
  4009c2:	f249 6198 	movw	r1, #38552	; 0x9698
  4009c6:	f2c0 0140 	movt	r1, #64	; 0x40
  4009ca:	f04f 0282 	mov.w	r2, #130	; 0x82
  4009ce:	4623      	mov	r3, r4
  4009d0:	f244 0415 	movw	r4, #16405	; 0x4015
  4009d4:	f2c0 0440 	movt	r4, #64	; 0x40
  4009d8:	47a0      	blx	r4
	/* It is important that the sending task does not attempt to write to a
	queue before the queue has been created.  It is therefore placed into the
	suspended state before the scheduler has started.  It is resumed by the
	receiving task after the receiving task has created the queues and added the
	queues to the queue set. */
	vTaskSuspend( xQueueSetSendingTask );
  4009da:	f24a 7398 	movw	r3, #42904	; 0xa798
  4009de:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4009e2:	681b      	ldr	r3, [r3, #0]
  4009e4:	4618      	mov	r0, r3
  4009e6:	f244 53c9 	movw	r3, #17865	; 0x45c9
  4009ea:	f2c0 0340 	movt	r3, #64	; 0x40
  4009ee:	4798      	blx	r3
}
  4009f0:	f107 0704 	add.w	r7, r7, #4
  4009f4:	46bd      	mov	sp, r7
  4009f6:	bd90      	pop	{r4, r7, pc}

004009f8 <xAreQueueSetTasksStillRunning>:
/*-----------------------------------------------------------*/

portBASE_TYPE xAreQueueSetTasksStillRunning( void )
{
  4009f8:	b480      	push	{r7}
  4009fa:	b083      	sub	sp, #12
  4009fc:	af00      	add	r7, sp, #0
static unsigned long ulLastCycleCounter, ulLastISRTxValue = 0;
static unsigned long ulLastQueueUsedCounter[ queuesetNUM_QUEUES_IN_SET ] = { 0 };
portBASE_TYPE xReturn = pdPASS, x;
  4009fe:	f04f 0301 	mov.w	r3, #1
  400a02:	607b      	str	r3, [r7, #4]

	if( ulLastCycleCounter == ulCycleCounter )
  400a04:	f24a 43bc 	movw	r3, #42172	; 0xa4bc
  400a08:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400a0c:	681a      	ldr	r2, [r3, #0]
  400a0e:	f24a 439c 	movw	r3, #42140	; 0xa49c
  400a12:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400a16:	681b      	ldr	r3, [r3, #0]
  400a18:	429a      	cmp	r2, r3
  400a1a:	d102      	bne.n	400a22 <xAreQueueSetTasksStillRunning+0x2a>
	{
		/* The cycle counter is no longer being incremented.  Either one of the
		tasks is stalled or an error has been detected. */
		xReturn = pdFAIL;
  400a1c:	f04f 0300 	mov.w	r3, #0
  400a20:	607b      	str	r3, [r7, #4]
	}

	ulLastCycleCounter = ulCycleCounter;
  400a22:	f24a 439c 	movw	r3, #42140	; 0xa49c
  400a26:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400a2a:	681a      	ldr	r2, [r3, #0]
  400a2c:	f24a 43bc 	movw	r3, #42172	; 0xa4bc
  400a30:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400a34:	601a      	str	r2, [r3, #0]

	/* Ensure that all the queues in the set have been used.  This ensures the
	test is working as intended and guards against the rand() in the Tx task
	missing some values. */
	for( x = 0; x < queuesetNUM_QUEUES_IN_SET; x++ )
  400a36:	f04f 0300 	mov.w	r3, #0
  400a3a:	603b      	str	r3, [r7, #0]
  400a3c:	e024      	b.n	400a88 <xAreQueueSetTasksStillRunning+0x90>
	{
		if( ulLastQueueUsedCounter[ x ] == ulQueueUsedCounter[ x ] )
  400a3e:	f24a 43c0 	movw	r3, #42176	; 0xa4c0
  400a42:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400a46:	683a      	ldr	r2, [r7, #0]
  400a48:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  400a4c:	f24a 438c 	movw	r3, #42124	; 0xa48c
  400a50:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400a54:	6839      	ldr	r1, [r7, #0]
  400a56:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
  400a5a:	429a      	cmp	r2, r3
  400a5c:	d102      	bne.n	400a64 <xAreQueueSetTasksStillRunning+0x6c>
		{
			xReturn = pdFAIL;
  400a5e:	f04f 0300 	mov.w	r3, #0
  400a62:	607b      	str	r3, [r7, #4]
		}

		ulLastQueueUsedCounter[ x ] = ulQueueUsedCounter[ x ];
  400a64:	f24a 438c 	movw	r3, #42124	; 0xa48c
  400a68:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400a6c:	683a      	ldr	r2, [r7, #0]
  400a6e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  400a72:	f24a 43c0 	movw	r3, #42176	; 0xa4c0
  400a76:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400a7a:	683a      	ldr	r2, [r7, #0]
  400a7c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	ulLastCycleCounter = ulCycleCounter;

	/* Ensure that all the queues in the set have been used.  This ensures the
	test is working as intended and guards against the rand() in the Tx task
	missing some values. */
	for( x = 0; x < queuesetNUM_QUEUES_IN_SET; x++ )
  400a80:	683b      	ldr	r3, [r7, #0]
  400a82:	f103 0301 	add.w	r3, r3, #1
  400a86:	603b      	str	r3, [r7, #0]
  400a88:	683b      	ldr	r3, [r7, #0]
  400a8a:	2b02      	cmp	r3, #2
  400a8c:	ddd7      	ble.n	400a3e <xAreQueueSetTasksStillRunning+0x46>

		ulLastQueueUsedCounter[ x ] = ulQueueUsedCounter[ x ];
	}

	/* Check the global status flag. */
	if( xQueueSetTasksStatus != pdPASS )
  400a8e:	f240 0304 	movw	r3, #4
  400a92:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400a96:	681b      	ldr	r3, [r3, #0]
  400a98:	2b01      	cmp	r3, #1
  400a9a:	d002      	beq.n	400aa2 <xAreQueueSetTasksStillRunning+0xaa>
	{
		xReturn = pdFAIL;
  400a9c:	f04f 0300 	mov.w	r3, #0
  400aa0:	607b      	str	r3, [r7, #4]
	}

	/* Check that the ISR is still sending values to the queues too. */
	if( ulISRTxValue == ulLastISRTxValue )
  400aa2:	f240 0308 	movw	r3, #8
  400aa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400aaa:	681a      	ldr	r2, [r3, #0]
  400aac:	f24a 43cc 	movw	r3, #42188	; 0xa4cc
  400ab0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400ab4:	681b      	ldr	r3, [r3, #0]
  400ab6:	429a      	cmp	r2, r3
  400ab8:	d103      	bne.n	400ac2 <xAreQueueSetTasksStillRunning+0xca>
	{
		xReturn = pdFAIL;
  400aba:	f04f 0300 	mov.w	r3, #0
  400abe:	607b      	str	r3, [r7, #4]
  400ac0:	e009      	b.n	400ad6 <xAreQueueSetTasksStillRunning+0xde>
	}
	else
	{
		ulLastISRTxValue = ulISRTxValue;
  400ac2:	f240 0308 	movw	r3, #8
  400ac6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400aca:	681a      	ldr	r2, [r3, #0]
  400acc:	f24a 43cc 	movw	r3, #42188	; 0xa4cc
  400ad0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400ad4:	601a      	str	r2, [r3, #0]
	}

	return xReturn;
  400ad6:	687b      	ldr	r3, [r7, #4]
}
  400ad8:	4618      	mov	r0, r3
  400ada:	f107 070c 	add.w	r7, r7, #12
  400ade:	46bd      	mov	sp, r7
  400ae0:	bc80      	pop	{r7}
  400ae2:	4770      	bx	lr

00400ae4 <prvQueueSetSendingTask>:
/*-----------------------------------------------------------*/

static void prvQueueSetSendingTask( void *pvParameters )
{
  400ae4:	b590      	push	{r4, r7, lr}
  400ae6:	b087      	sub	sp, #28
  400ae8:	af00      	add	r7, sp, #0
  400aea:	6078      	str	r0, [r7, #4]
unsigned long ulTaskTxValue = 0, ulQueueToWriteTo;
  400aec:	f04f 0300 	mov.w	r3, #0
  400af0:	60fb      	str	r3, [r7, #12]

	/* Remove compiler warning about the unused parameter. */
	( void ) pvParameters;

	/* Seed mini pseudo random number generator. */
	prvSRand( ( unsigned long ) &ulTaskTxValue );
  400af2:	f107 030c 	add.w	r3, r7, #12
  400af6:	4618      	mov	r0, r3
  400af8:	f241 3345 	movw	r3, #4933	; 0x1345
  400afc:	f2c0 0340 	movt	r3, #64	; 0x40
  400b00:	4798      	blx	r3

	for( ;; )
	{
		/* Generate the index for the queue to which a value is to be sent. */
		ulQueueToWriteTo = prvRand() % queuesetNUM_QUEUES_IN_SET;
  400b02:	f241 23f9 	movw	r3, #4857	; 0x12f9
  400b06:	f2c0 0340 	movt	r3, #64	; 0x40
  400b0a:	4798      	blx	r3
  400b0c:	4602      	mov	r2, r0
  400b0e:	f64a 23ab 	movw	r3, #43691	; 0xaaab
  400b12:	f6ca 23aa 	movt	r3, #43690	; 0xaaaa
  400b16:	fba3 1302 	umull	r1, r3, r3, r2
  400b1a:	ea4f 0153 	mov.w	r1, r3, lsr #1
  400b1e:	460b      	mov	r3, r1
  400b20:	ea4f 0343 	mov.w	r3, r3, lsl #1
  400b24:	185b      	adds	r3, r3, r1
  400b26:	1ad3      	subs	r3, r2, r3
  400b28:	617b      	str	r3, [r7, #20]
		xQueueInUse = xQueues[ ulQueueToWriteTo ];
  400b2a:	f24a 4380 	movw	r3, #42112	; 0xa480
  400b2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400b32:	697a      	ldr	r2, [r7, #20]
  400b34:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  400b38:	613b      	str	r3, [r7, #16]

		/* Note which index is being written to to ensure all the queues are
		used. */
		( ulQueueUsedCounter[ ulQueueToWriteTo ] )++;
  400b3a:	f24a 438c 	movw	r3, #42124	; 0xa48c
  400b3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400b42:	697a      	ldr	r2, [r7, #20]
  400b44:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  400b48:	f103 0101 	add.w	r1, r3, #1
  400b4c:	f24a 438c 	movw	r3, #42124	; 0xa48c
  400b50:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400b54:	697a      	ldr	r2, [r7, #20]
  400b56:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

		/* Send to the queue to unblock the task that is waiting for data to
		arrive on a queue within the queue set to which this queue belongs. */
		if( xQueueSendToBack( xQueueInUse, &ulTaskTxValue, portMAX_DELAY ) != pdPASS )
  400b5a:	f107 030c 	add.w	r3, r7, #12
  400b5e:	6938      	ldr	r0, [r7, #16]
  400b60:	4619      	mov	r1, r3
  400b62:	f04f 32ff 	mov.w	r2, #4294967295
  400b66:	f04f 0300 	mov.w	r3, #0
  400b6a:	f243 34f1 	movw	r4, #13297	; 0x33f1
  400b6e:	f2c0 0440 	movt	r4, #64	; 0x40
  400b72:	47a0      	blx	r4
  400b74:	4603      	mov	r3, r0
  400b76:	2b01      	cmp	r3, #1
  400b78:	d006      	beq.n	400b88 <prvQueueSetSendingTask+0xa4>
		{
			/* The send should always pass as an infinite block time was
			used. */
			xQueueSetTasksStatus = pdFAIL;
  400b7a:	f240 0304 	movw	r3, #4
  400b7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400b82:	f04f 0200 	mov.w	r2, #0
  400b86:	601a      	str	r2, [r3, #0]

		#if( configUSE_PREEMPTION == 0 )
			taskYIELD();
		#endif

		ulTaskTxValue++;
  400b88:	68fb      	ldr	r3, [r7, #12]
  400b8a:	f103 0301 	add.w	r3, r3, #1
  400b8e:	60fb      	str	r3, [r7, #12]

		/* If the Tx value has reached the range used by the ISR then set it
		back to 0. */
		if( ulTaskTxValue == queuesetINITIAL_ISR_TX_VALUE )
  400b90:	68fa      	ldr	r2, [r7, #12]
  400b92:	f64f 73ff 	movw	r3, #65535	; 0xffff
  400b96:	429a      	cmp	r2, r3
  400b98:	d102      	bne.n	400ba0 <prvQueueSetSendingTask+0xbc>
		{
			ulTaskTxValue = 0;
  400b9a:	f04f 0300 	mov.w	r3, #0
  400b9e:	60fb      	str	r3, [r7, #12]
		}

		/* Increase test coverage by occasionally change the priorities of the
		two tasks relative to each other. */
		prvChangeRelativePriorities();
  400ba0:	f640 33ad 	movw	r3, #2989	; 0xbad
  400ba4:	f2c0 0340 	movt	r3, #64	; 0x40
  400ba8:	4798      	blx	r3
	}
  400baa:	e7aa      	b.n	400b02 <prvQueueSetSendingTask+0x1e>

00400bac <prvChangeRelativePriorities>:
}
/*-----------------------------------------------------------*/

static void prvChangeRelativePriorities( void )
{
  400bac:	b580      	push	{r7, lr}
  400bae:	af00      	add	r7, sp, #0
static unsigned portBASE_TYPE ulLoops = 0;
static eRelativePriorities ePriorities = eEqualPriority;

	/* Occasionally change the task priority relative to the priority of
	the receiving task. */
	ulLoops++;
  400bb0:	f24a 43b4 	movw	r3, #42164	; 0xa4b4
  400bb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400bb8:	681b      	ldr	r3, [r3, #0]
  400bba:	f103 0201 	add.w	r2, r3, #1
  400bbe:	f24a 43b4 	movw	r3, #42164	; 0xa4b4
  400bc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400bc6:	601a      	str	r2, [r3, #0]
	if( ulLoops >= queuesetPRIORITY_CHANGE_LOOPS )
  400bc8:	f24a 43b4 	movw	r3, #42164	; 0xa4b4
  400bcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400bd0:	681b      	ldr	r3, [r3, #0]
  400bd2:	2b11      	cmp	r3, #17
  400bd4:	d964      	bls.n	400ca0 <prvChangeRelativePriorities+0xf4>
	{
		ulLoops = 0;
  400bd6:	f24a 43b4 	movw	r3, #42164	; 0xa4b4
  400bda:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400bde:	f04f 0200 	mov.w	r2, #0
  400be2:	601a      	str	r2, [r3, #0]

		switch( ePriorities )
  400be4:	f24a 43b8 	movw	r3, #42168	; 0xa4b8
  400be8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400bec:	781b      	ldrb	r3, [r3, #0]
  400bee:	2b01      	cmp	r3, #1
  400bf0:	d018      	beq.n	400c24 <prvChangeRelativePriorities+0x78>
  400bf2:	2b02      	cmp	r3, #2
  400bf4:	d038      	beq.n	400c68 <prvChangeRelativePriorities+0xbc>
  400bf6:	2b00      	cmp	r3, #0
  400bf8:	d152      	bne.n	400ca0 <prvChangeRelativePriorities+0xf4>
		{
			case eEqualPriority:
				/* Both tasks are running with medium priority.  Now lower the
				priority of the receiving task so the Tx task has the higher
				relative priority. */
				vTaskPrioritySet( xQueueSetReceivingTask, queuesetLOW_PRIORITY );
  400bfa:	f24a 739c 	movw	r3, #42908	; 0xa79c
  400bfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400c02:	681b      	ldr	r3, [r3, #0]
  400c04:	4618      	mov	r0, r3
  400c06:	f04f 0100 	mov.w	r1, #0
  400c0a:	f244 431d 	movw	r3, #17437	; 0x441d
  400c0e:	f2c0 0340 	movt	r3, #64	; 0x40
  400c12:	4798      	blx	r3
				ePriorities = eTxHigherPriority;
  400c14:	f24a 43b8 	movw	r3, #42168	; 0xa4b8
  400c18:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400c1c:	f04f 0201 	mov.w	r2, #1
  400c20:	701a      	strb	r2, [r3, #0]
				break;
  400c22:	e03d      	b.n	400ca0 <prvChangeRelativePriorities+0xf4>

			case eTxHigherPriority:
				/* The Tx task is running with a higher priority than the Rx
				task.  Switch the priorities around so the Rx task has the
				higher relative priority. */
				vTaskPrioritySet( xQueueSetReceivingTask, queuesetMEDIUM_PRIORITY );
  400c24:	f24a 739c 	movw	r3, #42908	; 0xa79c
  400c28:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400c2c:	681b      	ldr	r3, [r3, #0]
  400c2e:	4618      	mov	r0, r3
  400c30:	f04f 0101 	mov.w	r1, #1
  400c34:	f244 431d 	movw	r3, #17437	; 0x441d
  400c38:	f2c0 0340 	movt	r3, #64	; 0x40
  400c3c:	4798      	blx	r3
				vTaskPrioritySet( xQueueSetSendingTask, queuesetLOW_PRIORITY );
  400c3e:	f24a 7398 	movw	r3, #42904	; 0xa798
  400c42:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400c46:	681b      	ldr	r3, [r3, #0]
  400c48:	4618      	mov	r0, r3
  400c4a:	f04f 0100 	mov.w	r1, #0
  400c4e:	f244 431d 	movw	r3, #17437	; 0x441d
  400c52:	f2c0 0340 	movt	r3, #64	; 0x40
  400c56:	4798      	blx	r3
				ePriorities = eTxLowerPriority;
  400c58:	f24a 43b8 	movw	r3, #42168	; 0xa4b8
  400c5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400c60:	f04f 0202 	mov.w	r2, #2
  400c64:	701a      	strb	r2, [r3, #0]
				break;
  400c66:	e01b      	b.n	400ca0 <prvChangeRelativePriorities+0xf4>

			case eTxLowerPriority:
				/* The Tx task is running with a lower priority than the Rx
				task.  Make the priorities equal again. */
				vTaskPrioritySet( xQueueSetSendingTask, queuesetMEDIUM_PRIORITY );
  400c68:	f24a 7398 	movw	r3, #42904	; 0xa798
  400c6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400c70:	681b      	ldr	r3, [r3, #0]
  400c72:	4618      	mov	r0, r3
  400c74:	f04f 0101 	mov.w	r1, #1
  400c78:	f244 431d 	movw	r3, #17437	; 0x441d
  400c7c:	f2c0 0340 	movt	r3, #64	; 0x40
  400c80:	4798      	blx	r3
				ePriorities = eEqualPriority;
  400c82:	f24a 43b8 	movw	r3, #42168	; 0xa4b8
  400c86:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400c8a:	f04f 0200 	mov.w	r2, #0
  400c8e:	701a      	strb	r2, [r3, #0]

				/* When both tasks are using a non-idle priority the queue set
				tasks will starve idle priority tasks of execution time - so
				relax a bit before the next iteration to minimise the impact. */
				vTaskDelay( queuesetTX_LOOP_DELAY );
  400c90:	f04f 00c8 	mov.w	r0, #200	; 0xc8
  400c94:	f244 332d 	movw	r3, #17197	; 0x432d
  400c98:	f2c0 0340 	movt	r3, #64	; 0x40
  400c9c:	4798      	blx	r3

				break;
  400c9e:	bf00      	nop
		}
	}
}
  400ca0:	bd80      	pop	{r7, pc}
  400ca2:	bf00      	nop

00400ca4 <prvQueueSetReceivingTask>:
/*-----------------------------------------------------------*/

static void prvQueueSetReceivingTask( void *pvParameters )
{
  400ca4:	b590      	push	{r4, r7, lr}
  400ca6:	b085      	sub	sp, #20
  400ca8:	af00      	add	r7, sp, #0
  400caa:	6078      	str	r0, [r7, #4]
	/* Remove compiler warnings. */
	( void ) pvParameters;

	/* Create the queues and add them to the queue set before resuming the Tx
	task. */
	prvSetupTest();
  400cac:	f241 0395 	movw	r3, #4245	; 0x1095
  400cb0:	f2c0 0340 	movt	r3, #64	; 0x40
  400cb4:	4798      	blx	r3
  400cb6:	e000      	b.n	400cba <prvQueueSetReceivingTask+0x16>

		if( xQueueSetTasksStatus == pdPASS )
		{
			ulCycleCounter++;
		}
	}
  400cb8:	bf00      	nop
	prvSetupTest();

	for( ;; )
	{
		/* Wait for a message to arrive on one of the queues in the set. */
		xActivatedQueue = xQueueSelectFromSet( xQueueSet, portMAX_DELAY );
  400cba:	f24a 4398 	movw	r3, #42136	; 0xa498
  400cbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400cc2:	681b      	ldr	r3, [r3, #0]
  400cc4:	4618      	mov	r0, r3
  400cc6:	f04f 31ff 	mov.w	r1, #4294967295
  400cca:	f643 731d 	movw	r3, #16157	; 0x3f1d
  400cce:	f2c0 0340 	movt	r3, #64	; 0x40
  400cd2:	4798      	blx	r3
  400cd4:	60f8      	str	r0, [r7, #12]
		configASSERT( xActivatedQueue );
  400cd6:	68fb      	ldr	r3, [r7, #12]
  400cd8:	2b00      	cmp	r3, #0
  400cda:	d105      	bne.n	400ce8 <prvQueueSetReceivingTask+0x44>
  400cdc:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  400ce0:	f2c0 0340 	movt	r3, #64	; 0x40
  400ce4:	4798      	blx	r3
  400ce6:	e7fe      	b.n	400ce6 <prvQueueSetReceivingTask+0x42>

		if( xActivatedQueue == NULL )
  400ce8:	68fb      	ldr	r3, [r7, #12]
  400cea:	2b00      	cmp	r3, #0
  400cec:	d107      	bne.n	400cfe <prvQueueSetReceivingTask+0x5a>
		{
			/* This should not happen as an infinite delay was used. */
			xQueueSetTasksStatus = pdFAIL;
  400cee:	f240 0304 	movw	r3, #4
  400cf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400cf6:	f04f 0200 	mov.w	r2, #0
  400cfa:	601a      	str	r2, [r3, #0]
  400cfc:	e027      	b.n	400d4e <prvQueueSetReceivingTask+0xaa>
		else
		{
			/* Reading from the queue should pass with a zero block time as
			this task will only run when something has been posted to a task
			in the queue set. */
			if( xQueueReceive( xActivatedQueue, &ulReceived, queuesetDONT_BLOCK ) != pdPASS )
  400cfe:	f107 0308 	add.w	r3, r7, #8
  400d02:	68f8      	ldr	r0, [r7, #12]
  400d04:	4619      	mov	r1, r3
  400d06:	f04f 0200 	mov.w	r2, #0
  400d0a:	f04f 0300 	mov.w	r3, #0
  400d0e:	f243 7469 	movw	r4, #14185	; 0x3769
  400d12:	f2c0 0440 	movt	r4, #64	; 0x40
  400d16:	47a0      	blx	r4
  400d18:	4603      	mov	r3, r0
  400d1a:	2b01      	cmp	r3, #1
  400d1c:	d006      	beq.n	400d2c <prvQueueSetReceivingTask+0x88>
			{
				xQueueSetTasksStatus = pdFAIL;
  400d1e:	f240 0304 	movw	r3, #4
  400d22:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400d26:	f04f 0200 	mov.w	r2, #0
  400d2a:	601a      	str	r2, [r3, #0]
			}

			/* Ensure the value received was the value expected.  This function
			manipulates file scope data and is also called from an ISR, hence
			the critical section. */
			taskENTER_CRITICAL();
  400d2c:	f642 6379 	movw	r3, #11897	; 0x2e79
  400d30:	f2c0 0340 	movt	r3, #64	; 0x40
  400d34:	4798      	blx	r3
			{
				prvCheckReceivedValue( ulReceived );
  400d36:	68bb      	ldr	r3, [r7, #8]
  400d38:	4618      	mov	r0, r3
  400d3a:	f640 53d5 	movw	r3, #3541	; 0xdd5
  400d3e:	f2c0 0340 	movt	r3, #64	; 0x40
  400d42:	4798      	blx	r3
			}
			taskEXIT_CRITICAL();
  400d44:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  400d48:	f2c0 0340 	movt	r3, #64	; 0x40
  400d4c:	4798      	blx	r3
		}

		if( xQueueSetTasksStatus == pdPASS )
  400d4e:	f240 0304 	movw	r3, #4
  400d52:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400d56:	681b      	ldr	r3, [r3, #0]
  400d58:	2b01      	cmp	r3, #1
  400d5a:	d1ad      	bne.n	400cb8 <prvQueueSetReceivingTask+0x14>
		{
			ulCycleCounter++;
  400d5c:	f24a 439c 	movw	r3, #42140	; 0xa49c
  400d60:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400d64:	681b      	ldr	r3, [r3, #0]
  400d66:	f103 0201 	add.w	r2, r3, #1
  400d6a:	f24a 439c 	movw	r3, #42140	; 0xa49c
  400d6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400d72:	601a      	str	r2, [r3, #0]
		}
	}
  400d74:	e7a0      	b.n	400cb8 <prvQueueSetReceivingTask+0x14>
  400d76:	bf00      	nop

00400d78 <vQueueSetAccessQueueSetFromISR>:
}
/*-----------------------------------------------------------*/

void vQueueSetAccessQueueSetFromISR( void )
{
  400d78:	b580      	push	{r7, lr}
  400d7a:	af00      	add	r7, sp, #0
static unsigned long ulCallCount = 0;

	/* xSetupComplete is set to pdTRUE when the queues have been created and
	are available for use. */
	if( xSetupComplete == pdTRUE )
  400d7c:	f24a 43a0 	movw	r3, #42144	; 0xa4a0
  400d80:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400d84:	681b      	ldr	r3, [r3, #0]
  400d86:	2b01      	cmp	r3, #1
  400d88:	d123      	bne.n	400dd2 <vQueueSetAccessQueueSetFromISR+0x5a>
	{
		/* It is intended that this function is called from the tick hook
		function, so each call is one tick period apart. */
		ulCallCount++;
  400d8a:	f24a 43b0 	movw	r3, #42160	; 0xa4b0
  400d8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400d92:	681b      	ldr	r3, [r3, #0]
  400d94:	f103 0201 	add.w	r2, r3, #1
  400d98:	f24a 43b0 	movw	r3, #42160	; 0xa4b0
  400d9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400da0:	601a      	str	r2, [r3, #0]
		if( ulCallCount > queuesetISR_TX_PERIOD )
  400da2:	f24a 43b0 	movw	r3, #42160	; 0xa4b0
  400da6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400daa:	681b      	ldr	r3, [r3, #0]
  400dac:	2b64      	cmp	r3, #100	; 0x64
  400dae:	d910      	bls.n	400dd2 <vQueueSetAccessQueueSetFromISR+0x5a>
		{
			ulCallCount = 0;
  400db0:	f24a 43b0 	movw	r3, #42160	; 0xa4b0
  400db4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400db8:	f04f 0200 	mov.w	r2, #0
  400dbc:	601a      	str	r2, [r3, #0]

			/* First attempt to read from the queue set. */
			prvReceiveFromQueueInSetFromISR();
  400dbe:	f640 7389 	movw	r3, #3977	; 0xf89
  400dc2:	f2c0 0340 	movt	r3, #64	; 0x40
  400dc6:	4798      	blx	r3

			/* Then write to the queue set. */
			prvSendToQueueInSetFromISR();
  400dc8:	f640 73ed 	movw	r3, #4077	; 0xfed
  400dcc:	f2c0 0340 	movt	r3, #64	; 0x40
  400dd0:	4798      	blx	r3
		}
	}
}
  400dd2:	bd80      	pop	{r7, pc}

00400dd4 <prvCheckReceivedValue>:
/*-----------------------------------------------------------*/

static void prvCheckReceivedValue( unsigned long ulReceived )
{
  400dd4:	b580      	push	{r7, lr}
  400dd6:	b082      	sub	sp, #8
  400dd8:	af00      	add	r7, sp, #0
  400dda:	6078      	str	r0, [r7, #4]
	values, rather than a single absolute value.  To make the range testing
	easier values in the range limits are ignored. */

	/* If the received value is equal to or greater than
	queuesetINITIAL_ISR_TX_VALUE then it was sent by an ISR. */
	if( ulReceived >= queuesetINITIAL_ISR_TX_VALUE )
  400ddc:	687a      	ldr	r2, [r7, #4]
  400dde:	f64f 73fe 	movw	r3, #65534	; 0xfffe
  400de2:	429a      	cmp	r2, r3
  400de4:	d948      	bls.n	400e78 <prvCheckReceivedValue+0xa4>
	{
		/* The value was sent from the ISR. */
		if( ( ulReceived - queuesetINITIAL_ISR_TX_VALUE ) < queuesetIGNORED_BOUNDARY )
  400de6:	687b      	ldr	r3, [r7, #4]
  400de8:	f5a3 437f 	sub.w	r3, r3, #65280	; 0xff00
  400dec:	f1a3 03ff 	sub.w	r3, r3, #255	; 0xff
  400df0:	2b05      	cmp	r3, #5
  400df2:	d919      	bls.n	400e28 <prvCheckReceivedValue+0x54>
		{
			/* The value received is at the lower limit of the expected range.
			Don't test it and expect to receive one higher next time. */
		}
		else if( ( ULONG_MAX - ulReceived ) <= queuesetIGNORED_BOUNDARY )
  400df4:	687b      	ldr	r3, [r7, #4]
  400df6:	f113 0f08 	cmn.w	r3, #8
  400dfa:	d815      	bhi.n	400e28 <prvCheckReceivedValue+0x54>
			Don't test it and expect to wrap soon. */
		}
		else
		{
			/* Check the value against its expected value range. */
			if( prvCheckReceivedValueWithinExpectedRange( ulReceived, ulExpectedReceivedFromISR ) != pdPASS )
  400dfc:	f240 030c 	movw	r3, #12
  400e00:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400e04:	681b      	ldr	r3, [r3, #0]
  400e06:	6878      	ldr	r0, [r7, #4]
  400e08:	4619      	mov	r1, r3
  400e0a:	f640 7315 	movw	r3, #3861	; 0xf15
  400e0e:	f2c0 0340 	movt	r3, #64	; 0x40
  400e12:	4798      	blx	r3
  400e14:	4603      	mov	r3, r0
  400e16:	2b01      	cmp	r3, #1
  400e18:	d006      	beq.n	400e28 <prvCheckReceivedValue+0x54>
			{
				xQueueSetTasksStatus = pdFAIL;
  400e1a:	f240 0304 	movw	r3, #4
  400e1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400e22:	f04f 0200 	mov.w	r2, #0
  400e26:	601a      	str	r2, [r3, #0]
			}
		}

		configASSERT( xQueueSetTasksStatus );
  400e28:	f240 0304 	movw	r3, #4
  400e2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400e30:	681b      	ldr	r3, [r3, #0]
  400e32:	2b00      	cmp	r3, #0
  400e34:	d105      	bne.n	400e42 <prvCheckReceivedValue+0x6e>
  400e36:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  400e3a:	f2c0 0340 	movt	r3, #64	; 0x40
  400e3e:	4798      	blx	r3
  400e40:	e7fe      	b.n	400e40 <prvCheckReceivedValue+0x6c>

		/* It is expected to receive an incrementing number. */
		ulExpectedReceivedFromISR++;
  400e42:	f240 030c 	movw	r3, #12
  400e46:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400e4a:	681b      	ldr	r3, [r3, #0]
  400e4c:	f103 0201 	add.w	r2, r3, #1
  400e50:	f240 030c 	movw	r3, #12
  400e54:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400e58:	601a      	str	r2, [r3, #0]
		if( ulExpectedReceivedFromISR == 0 )
  400e5a:	f240 030c 	movw	r3, #12
  400e5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400e62:	681b      	ldr	r3, [r3, #0]
  400e64:	2b00      	cmp	r3, #0
  400e66:	d150      	bne.n	400f0a <prvCheckReceivedValue+0x136>
		{
			ulExpectedReceivedFromISR = queuesetINITIAL_ISR_TX_VALUE;
  400e68:	f240 030c 	movw	r3, #12
  400e6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400e70:	f64f 72ff 	movw	r2, #65535	; 0xffff
  400e74:	601a      	str	r2, [r3, #0]
  400e76:	e048      	b.n	400f0a <prvCheckReceivedValue+0x136>
		}
	}
	else
	{
		/* The value was sent from the Tx task. */
		if( ulReceived < queuesetIGNORED_BOUNDARY )
  400e78:	687b      	ldr	r3, [r7, #4]
  400e7a:	2b05      	cmp	r3, #5
  400e7c:	d91c      	bls.n	400eb8 <prvCheckReceivedValue+0xe4>
		{
			/* The value received is at the lower limit of the expected range.
			Don't test it, and expect to receive one higher next time. */
		}
		else if( ( ( queuesetINITIAL_ISR_TX_VALUE - 1 ) - ulReceived ) <= queuesetIGNORED_BOUNDARY )
  400e7e:	687b      	ldr	r3, [r7, #4]
  400e80:	f5c3 437f 	rsb	r3, r3, #65280	; 0xff00
  400e84:	f103 03fe 	add.w	r3, r3, #254	; 0xfe
  400e88:	2b06      	cmp	r3, #6
  400e8a:	d915      	bls.n	400eb8 <prvCheckReceivedValue+0xe4>
			Don't test it and expect to wrap soon. */
		}
		else
		{
			/* Check the value against its expected value range. */
			if( prvCheckReceivedValueWithinExpectedRange( ulReceived, ulExpectedReceivedFromTask ) != pdPASS )
  400e8c:	f24a 43ac 	movw	r3, #42156	; 0xa4ac
  400e90:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400e94:	681b      	ldr	r3, [r3, #0]
  400e96:	6878      	ldr	r0, [r7, #4]
  400e98:	4619      	mov	r1, r3
  400e9a:	f640 7315 	movw	r3, #3861	; 0xf15
  400e9e:	f2c0 0340 	movt	r3, #64	; 0x40
  400ea2:	4798      	blx	r3
  400ea4:	4603      	mov	r3, r0
  400ea6:	2b01      	cmp	r3, #1
  400ea8:	d006      	beq.n	400eb8 <prvCheckReceivedValue+0xe4>
			{
				xQueueSetTasksStatus = pdFAIL;
  400eaa:	f240 0304 	movw	r3, #4
  400eae:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400eb2:	f04f 0200 	mov.w	r2, #0
  400eb6:	601a      	str	r2, [r3, #0]
			}
		}

		configASSERT( xQueueSetTasksStatus );
  400eb8:	f240 0304 	movw	r3, #4
  400ebc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400ec0:	681b      	ldr	r3, [r3, #0]
  400ec2:	2b00      	cmp	r3, #0
  400ec4:	d105      	bne.n	400ed2 <prvCheckReceivedValue+0xfe>
  400ec6:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  400eca:	f2c0 0340 	movt	r3, #64	; 0x40
  400ece:	4798      	blx	r3
  400ed0:	e7fe      	b.n	400ed0 <prvCheckReceivedValue+0xfc>

		/* It is expected to receive an incrementing number. */
		ulExpectedReceivedFromTask++;
  400ed2:	f24a 43ac 	movw	r3, #42156	; 0xa4ac
  400ed6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400eda:	681b      	ldr	r3, [r3, #0]
  400edc:	f103 0201 	add.w	r2, r3, #1
  400ee0:	f24a 43ac 	movw	r3, #42156	; 0xa4ac
  400ee4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400ee8:	601a      	str	r2, [r3, #0]
		if( ulExpectedReceivedFromTask >= queuesetINITIAL_ISR_TX_VALUE )
  400eea:	f24a 43ac 	movw	r3, #42156	; 0xa4ac
  400eee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400ef2:	681a      	ldr	r2, [r3, #0]
  400ef4:	f64f 73fe 	movw	r3, #65534	; 0xfffe
  400ef8:	429a      	cmp	r2, r3
  400efa:	d906      	bls.n	400f0a <prvCheckReceivedValue+0x136>
		{
			ulExpectedReceivedFromTask = 0;
  400efc:	f24a 43ac 	movw	r3, #42156	; 0xa4ac
  400f00:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400f04:	f04f 0200 	mov.w	r2, #0
  400f08:	601a      	str	r2, [r3, #0]
		}
	}
}
  400f0a:	f107 0708 	add.w	r7, r7, #8
  400f0e:	46bd      	mov	sp, r7
  400f10:	bd80      	pop	{r7, pc}
  400f12:	bf00      	nop

00400f14 <prvCheckReceivedValueWithinExpectedRange>:
/*-----------------------------------------------------------*/

static portBASE_TYPE prvCheckReceivedValueWithinExpectedRange( unsigned long ulReceived, unsigned long ulExpectedReceived )
{
  400f14:	b580      	push	{r7, lr}
  400f16:	b084      	sub	sp, #16
  400f18:	af00      	add	r7, sp, #0
  400f1a:	6078      	str	r0, [r7, #4]
  400f1c:	6039      	str	r1, [r7, #0]
portBASE_TYPE xReturn = pdPASS;
  400f1e:	f04f 0301 	mov.w	r3, #1
  400f22:	60fb      	str	r3, [r7, #12]

	if( ulReceived > ulExpectedReceived )
  400f24:	687a      	ldr	r2, [r7, #4]
  400f26:	683b      	ldr	r3, [r7, #0]
  400f28:	429a      	cmp	r2, r3
  400f2a:	d913      	bls.n	400f54 <prvCheckReceivedValueWithinExpectedRange+0x40>
	{
		configASSERT( ( ulReceived - ulExpectedReceived ) <= queuesetALLOWABLE_RX_DEVIATION );
  400f2c:	687a      	ldr	r2, [r7, #4]
  400f2e:	683b      	ldr	r3, [r7, #0]
  400f30:	1ad3      	subs	r3, r2, r3
  400f32:	2b03      	cmp	r3, #3
  400f34:	d905      	bls.n	400f42 <prvCheckReceivedValueWithinExpectedRange+0x2e>
  400f36:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  400f3a:	f2c0 0340 	movt	r3, #64	; 0x40
  400f3e:	4798      	blx	r3
  400f40:	e7fe      	b.n	400f40 <prvCheckReceivedValueWithinExpectedRange+0x2c>
		if( ( ulReceived - ulExpectedReceived ) > queuesetALLOWABLE_RX_DEVIATION )
  400f42:	687a      	ldr	r2, [r7, #4]
  400f44:	683b      	ldr	r3, [r7, #0]
  400f46:	1ad3      	subs	r3, r2, r3
  400f48:	2b03      	cmp	r3, #3
  400f4a:	d916      	bls.n	400f7a <prvCheckReceivedValueWithinExpectedRange+0x66>
		{
			xReturn = pdFALSE;
  400f4c:	f04f 0300 	mov.w	r3, #0
  400f50:	60fb      	str	r3, [r7, #12]
  400f52:	e012      	b.n	400f7a <prvCheckReceivedValueWithinExpectedRange+0x66>
		}
	}
	else
	{
		configASSERT( ( ulExpectedReceived - ulReceived ) <= queuesetALLOWABLE_RX_DEVIATION );
  400f54:	683a      	ldr	r2, [r7, #0]
  400f56:	687b      	ldr	r3, [r7, #4]
  400f58:	1ad3      	subs	r3, r2, r3
  400f5a:	2b03      	cmp	r3, #3
  400f5c:	d905      	bls.n	400f6a <prvCheckReceivedValueWithinExpectedRange+0x56>
  400f5e:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  400f62:	f2c0 0340 	movt	r3, #64	; 0x40
  400f66:	4798      	blx	r3
  400f68:	e7fe      	b.n	400f68 <prvCheckReceivedValueWithinExpectedRange+0x54>
		if( ( ulExpectedReceived - ulReceived ) > queuesetALLOWABLE_RX_DEVIATION )
  400f6a:	683a      	ldr	r2, [r7, #0]
  400f6c:	687b      	ldr	r3, [r7, #4]
  400f6e:	1ad3      	subs	r3, r2, r3
  400f70:	2b03      	cmp	r3, #3
  400f72:	d902      	bls.n	400f7a <prvCheckReceivedValueWithinExpectedRange+0x66>
		{
			xReturn = pdFALSE;
  400f74:	f04f 0300 	mov.w	r3, #0
  400f78:	60fb      	str	r3, [r7, #12]
		}
	}

	return xReturn;
  400f7a:	68fb      	ldr	r3, [r7, #12]
}
  400f7c:	4618      	mov	r0, r3
  400f7e:	f107 0710 	add.w	r7, r7, #16
  400f82:	46bd      	mov	sp, r7
  400f84:	bd80      	pop	{r7, pc}
  400f86:	bf00      	nop

00400f88 <prvReceiveFromQueueInSetFromISR>:
/*-----------------------------------------------------------*/

static void prvReceiveFromQueueInSetFromISR( void )
{
  400f88:	b580      	push	{r7, lr}
  400f8a:	b082      	sub	sp, #8
  400f8c:	af00      	add	r7, sp, #0
xQueueSetMemberHandle xActivatedQueue;
unsigned long ulReceived;

	/* See if any of the queues in the set contain data. */
	xActivatedQueue = xQueueSelectFromSetFromISR( xQueueSet );
  400f8e:	f24a 4398 	movw	r3, #42136	; 0xa498
  400f92:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400f96:	681b      	ldr	r3, [r3, #0]
  400f98:	4618      	mov	r0, r3
  400f9a:	f643 7351 	movw	r3, #16209	; 0x3f51
  400f9e:	f2c0 0340 	movt	r3, #64	; 0x40
  400fa2:	4798      	blx	r3
  400fa4:	6078      	str	r0, [r7, #4]

	if( xActivatedQueue != NULL )
  400fa6:	687b      	ldr	r3, [r7, #4]
  400fa8:	2b00      	cmp	r3, #0
  400faa:	d01a      	beq.n	400fe2 <prvReceiveFromQueueInSetFromISR+0x5a>
	{
		/* Reading from the queue for test purposes only. */
		if( xQueueReceiveFromISR( xActivatedQueue, &ulReceived, NULL ) != pdPASS )
  400fac:	463b      	mov	r3, r7
  400fae:	6878      	ldr	r0, [r7, #4]
  400fb0:	4619      	mov	r1, r3
  400fb2:	f04f 0200 	mov.w	r2, #0
  400fb6:	f643 13cd 	movw	r3, #14797	; 0x39cd
  400fba:	f2c0 0340 	movt	r3, #64	; 0x40
  400fbe:	4798      	blx	r3
  400fc0:	4603      	mov	r3, r0
  400fc2:	2b01      	cmp	r3, #1
  400fc4:	d006      	beq.n	400fd4 <prvReceiveFromQueueInSetFromISR+0x4c>
		{
			/* Data should have been available as the handle was returned from
			xQueueSelectFromSetFromISR(). */
			xQueueSetTasksStatus = pdFAIL;
  400fc6:	f240 0304 	movw	r3, #4
  400fca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400fce:	f04f 0200 	mov.w	r2, #0
  400fd2:	601a      	str	r2, [r3, #0]
		}

		/* Ensure the value received was the value expected. */
		prvCheckReceivedValue( ulReceived );
  400fd4:	683b      	ldr	r3, [r7, #0]
  400fd6:	4618      	mov	r0, r3
  400fd8:	f640 53d5 	movw	r3, #3541	; 0xdd5
  400fdc:	f2c0 0340 	movt	r3, #64	; 0x40
  400fe0:	4798      	blx	r3
	}
}
  400fe2:	f107 0708 	add.w	r7, r7, #8
  400fe6:	46bd      	mov	sp, r7
  400fe8:	bd80      	pop	{r7, pc}
  400fea:	bf00      	nop

00400fec <prvSendToQueueInSetFromISR>:
/*-----------------------------------------------------------*/

static void prvSendToQueueInSetFromISR( void )
{
  400fec:	b598      	push	{r3, r4, r7, lr}
  400fee:	af00      	add	r7, sp, #0
static portBASE_TYPE xQueueToWriteTo = 0;

	if( xQueueSendFromISR( xQueues[ xQueueToWriteTo ], ( void * ) &ulISRTxValue, NULL ) == pdPASS )
  400ff0:	f24a 43a8 	movw	r3, #42152	; 0xa4a8
  400ff4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400ff8:	681a      	ldr	r2, [r3, #0]
  400ffa:	f24a 4380 	movw	r3, #42112	; 0xa480
  400ffe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401002:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  401006:	4618      	mov	r0, r3
  401008:	f240 0108 	movw	r1, #8
  40100c:	f2c2 0100 	movt	r1, #8192	; 0x2000
  401010:	f04f 0200 	mov.w	r2, #0
  401014:	f04f 0300 	mov.w	r3, #0
  401018:	f243 6425 	movw	r4, #13861	; 0x3625
  40101c:	f2c0 0440 	movt	r4, #64	; 0x40
  401020:	47a0      	blx	r4
  401022:	4603      	mov	r3, r0
  401024:	2b01      	cmp	r3, #1
  401026:	d133      	bne.n	401090 <prvSendToQueueInSetFromISR+0xa4>
	{
		ulISRTxValue++;
  401028:	f240 0308 	movw	r3, #8
  40102c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401030:	681b      	ldr	r3, [r3, #0]
  401032:	f103 0201 	add.w	r2, r3, #1
  401036:	f240 0308 	movw	r3, #8
  40103a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40103e:	601a      	str	r2, [r3, #0]

		/* If the Tx value has wrapped then set it back to its
		initial	value. */
		if( ulISRTxValue == 0UL )
  401040:	f240 0308 	movw	r3, #8
  401044:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401048:	681b      	ldr	r3, [r3, #0]
  40104a:	2b00      	cmp	r3, #0
  40104c:	d106      	bne.n	40105c <prvSendToQueueInSetFromISR+0x70>
		{
			ulISRTxValue = queuesetINITIAL_ISR_TX_VALUE;
  40104e:	f240 0308 	movw	r3, #8
  401052:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401056:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40105a:	601a      	str	r2, [r3, #0]
		}

		/* Use a different queue next time. */
		xQueueToWriteTo++;
  40105c:	f24a 43a8 	movw	r3, #42152	; 0xa4a8
  401060:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401064:	681b      	ldr	r3, [r3, #0]
  401066:	f103 0201 	add.w	r2, r3, #1
  40106a:	f24a 43a8 	movw	r3, #42152	; 0xa4a8
  40106e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401072:	601a      	str	r2, [r3, #0]
		if( xQueueToWriteTo >= queuesetNUM_QUEUES_IN_SET )
  401074:	f24a 43a8 	movw	r3, #42152	; 0xa4a8
  401078:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40107c:	681b      	ldr	r3, [r3, #0]
  40107e:	2b02      	cmp	r3, #2
  401080:	dd06      	ble.n	401090 <prvSendToQueueInSetFromISR+0xa4>
		{
			xQueueToWriteTo = 0;
  401082:	f24a 43a8 	movw	r3, #42152	; 0xa4a8
  401086:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40108a:	f04f 0200 	mov.w	r2, #0
  40108e:	601a      	str	r2, [r3, #0]
		}
	}
}
  401090:	bd98      	pop	{r3, r4, r7, pc}
  401092:	bf00      	nop

00401094 <prvSetupTest>:
/*-----------------------------------------------------------*/

static void prvSetupTest( void )
{
  401094:	b590      	push	{r4, r7, lr}
  401096:	b083      	sub	sp, #12
  401098:	af00      	add	r7, sp, #0
portBASE_TYPE x;
unsigned long ulValueToSend = 0;
  40109a:	f04f 0300 	mov.w	r3, #0
  40109e:	603b      	str	r3, [r7, #0]
	/* Ensure the queues are created and the queue set configured before the
	sending task is unsuspended.

	First Create the queue set such that it will be able to hold a message for
	every space in every queue in the set. */
	xQueueSet = xQueueCreateSet( queuesetNUM_QUEUES_IN_SET * queuesetQUEUE_LENGTH );
  4010a0:	f04f 0009 	mov.w	r0, #9
  4010a4:	f643 6339 	movw	r3, #15929	; 0x3e39
  4010a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4010ac:	4798      	blx	r3
  4010ae:	4602      	mov	r2, r0
  4010b0:	f24a 4398 	movw	r3, #42136	; 0xa498
  4010b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4010b8:	601a      	str	r2, [r3, #0]

	for( x = 0; x < queuesetNUM_QUEUES_IN_SET; x++ )
  4010ba:	f04f 0300 	mov.w	r3, #0
  4010be:	607b      	str	r3, [r7, #4]
  4010c0:	e060      	b.n	401184 <prvSetupTest+0xf0>
	{
		/* Create the queue and add it to the set.  The queue is just holding
		unsigned long value. */
		xQueues[ x ] = xQueueCreate( queuesetQUEUE_LENGTH, sizeof( unsigned long ) );
  4010c2:	f04f 0003 	mov.w	r0, #3
  4010c6:	f04f 0104 	mov.w	r1, #4
  4010ca:	f04f 0200 	mov.w	r2, #0
  4010ce:	f243 1311 	movw	r3, #12561	; 0x3111
  4010d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4010d6:	4798      	blx	r3
  4010d8:	4601      	mov	r1, r0
  4010da:	f24a 4380 	movw	r3, #42112	; 0xa480
  4010de:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4010e2:	687a      	ldr	r2, [r7, #4]
  4010e4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		configASSERT( xQueues[ x ] );
  4010e8:	f24a 4380 	movw	r3, #42112	; 0xa480
  4010ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4010f0:	687a      	ldr	r2, [r7, #4]
  4010f2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4010f6:	2b00      	cmp	r3, #0
  4010f8:	d105      	bne.n	401106 <prvSetupTest+0x72>
  4010fa:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4010fe:	f2c0 0340 	movt	r3, #64	; 0x40
  401102:	4798      	blx	r3
  401104:	e7fe      	b.n	401104 <prvSetupTest+0x70>
		if( xQueueAddToSet( xQueues[ x ], xQueueSet ) != pdPASS )
  401106:	f24a 4380 	movw	r3, #42112	; 0xa480
  40110a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40110e:	687a      	ldr	r2, [r7, #4]
  401110:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  401114:	f24a 4398 	movw	r3, #42136	; 0xa498
  401118:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40111c:	681b      	ldr	r3, [r3, #0]
  40111e:	4610      	mov	r0, r2
  401120:	4619      	mov	r1, r3
  401122:	f643 6365 	movw	r3, #15973	; 0x3e65
  401126:	f2c0 0340 	movt	r3, #64	; 0x40
  40112a:	4798      	blx	r3
  40112c:	4603      	mov	r3, r0
  40112e:	2b01      	cmp	r3, #1
  401130:	d007      	beq.n	401142 <prvSetupTest+0xae>
		{
			xQueueSetTasksStatus = pdFAIL;
  401132:	f240 0304 	movw	r3, #4
  401136:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40113a:	f04f 0200 	mov.w	r2, #0
  40113e:	601a      	str	r2, [r3, #0]
  401140:	e01c      	b.n	40117c <prvSetupTest+0xe8>
		}
		else
		{
			/* The queue has now been added to the queue set and cannot be added to
			another. */
			if( xQueueAddToSet( xQueues[ x ], xQueueSet ) != pdFAIL )
  401142:	f24a 4380 	movw	r3, #42112	; 0xa480
  401146:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40114a:	687a      	ldr	r2, [r7, #4]
  40114c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  401150:	f24a 4398 	movw	r3, #42136	; 0xa498
  401154:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401158:	681b      	ldr	r3, [r3, #0]
  40115a:	4610      	mov	r0, r2
  40115c:	4619      	mov	r1, r3
  40115e:	f643 6365 	movw	r3, #15973	; 0x3e65
  401162:	f2c0 0340 	movt	r3, #64	; 0x40
  401166:	4798      	blx	r3
  401168:	4603      	mov	r3, r0
  40116a:	2b00      	cmp	r3, #0
  40116c:	d006      	beq.n	40117c <prvSetupTest+0xe8>
			{
				xQueueSetTasksStatus = pdFAIL;
  40116e:	f240 0304 	movw	r3, #4
  401172:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401176:	f04f 0200 	mov.w	r2, #0
  40117a:	601a      	str	r2, [r3, #0]

	First Create the queue set such that it will be able to hold a message for
	every space in every queue in the set. */
	xQueueSet = xQueueCreateSet( queuesetNUM_QUEUES_IN_SET * queuesetQUEUE_LENGTH );

	for( x = 0; x < queuesetNUM_QUEUES_IN_SET; x++ )
  40117c:	687b      	ldr	r3, [r7, #4]
  40117e:	f103 0301 	add.w	r3, r3, #1
  401182:	607b      	str	r3, [r7, #4]
  401184:	687b      	ldr	r3, [r7, #4]
  401186:	2b02      	cmp	r3, #2
  401188:	dd9b      	ble.n	4010c2 <prvSetupTest+0x2e>
		}
	}

	/* Attempt to remove a queue from a queue set it does not belong
	to (NULL being passed as the queue set in this case). */
	if( xQueueRemoveFromSet( xQueues[ 0 ], NULL ) != pdFAIL )
  40118a:	f24a 4380 	movw	r3, #42112	; 0xa480
  40118e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401192:	681b      	ldr	r3, [r3, #0]
  401194:	4618      	mov	r0, r3
  401196:	f04f 0100 	mov.w	r1, #0
  40119a:	f643 63bd 	movw	r3, #16061	; 0x3ebd
  40119e:	f2c0 0340 	movt	r3, #64	; 0x40
  4011a2:	4798      	blx	r3
  4011a4:	4603      	mov	r3, r0
  4011a6:	2b00      	cmp	r3, #0
  4011a8:	d006      	beq.n	4011b8 <prvSetupTest+0x124>
	{
		/* It is not possible to successfully remove a queue from a queue
		set it does not belong to. */
		xQueueSetTasksStatus = pdFAIL;
  4011aa:	f240 0304 	movw	r3, #4
  4011ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4011b2:	f04f 0200 	mov.w	r2, #0
  4011b6:	601a      	str	r2, [r3, #0]
	}

	/* Attempt to remove a queue from the queue set it does belong to. */
	if( xQueueRemoveFromSet( xQueues[ 0 ], xQueueSet ) != pdPASS )
  4011b8:	f24a 4380 	movw	r3, #42112	; 0xa480
  4011bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4011c0:	681a      	ldr	r2, [r3, #0]
  4011c2:	f24a 4398 	movw	r3, #42136	; 0xa498
  4011c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4011ca:	681b      	ldr	r3, [r3, #0]
  4011cc:	4610      	mov	r0, r2
  4011ce:	4619      	mov	r1, r3
  4011d0:	f643 63bd 	movw	r3, #16061	; 0x3ebd
  4011d4:	f2c0 0340 	movt	r3, #64	; 0x40
  4011d8:	4798      	blx	r3
  4011da:	4603      	mov	r3, r0
  4011dc:	2b01      	cmp	r3, #1
  4011de:	d006      	beq.n	4011ee <prvSetupTest+0x15a>
	{
		/* It should be possible to remove the queue from the queue set it
		does belong to. */
		xQueueSetTasksStatus = pdFAIL;
  4011e0:	f240 0304 	movw	r3, #4
  4011e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4011e8:	f04f 0200 	mov.w	r2, #0
  4011ec:	601a      	str	r2, [r3, #0]
	}

	/* Add an item to the queue before attempting to add it back into the
	set. */
	xQueueSend( xQueues[ 0 ], ( void * ) &ulValueToSend, 0 );
  4011ee:	f24a 4380 	movw	r3, #42112	; 0xa480
  4011f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4011f6:	681a      	ldr	r2, [r3, #0]
  4011f8:	463b      	mov	r3, r7
  4011fa:	4610      	mov	r0, r2
  4011fc:	4619      	mov	r1, r3
  4011fe:	f04f 0200 	mov.w	r2, #0
  401202:	f04f 0300 	mov.w	r3, #0
  401206:	f243 34f1 	movw	r4, #13297	; 0x33f1
  40120a:	f2c0 0440 	movt	r4, #64	; 0x40
  40120e:	47a0      	blx	r4
	if( xQueueAddToSet( xQueues[ 0 ], xQueueSet ) != pdFAIL )
  401210:	f24a 4380 	movw	r3, #42112	; 0xa480
  401214:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401218:	681a      	ldr	r2, [r3, #0]
  40121a:	f24a 4398 	movw	r3, #42136	; 0xa498
  40121e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401222:	681b      	ldr	r3, [r3, #0]
  401224:	4610      	mov	r0, r2
  401226:	4619      	mov	r1, r3
  401228:	f643 6365 	movw	r3, #15973	; 0x3e65
  40122c:	f2c0 0340 	movt	r3, #64	; 0x40
  401230:	4798      	blx	r3
  401232:	4603      	mov	r3, r0
  401234:	2b00      	cmp	r3, #0
  401236:	d006      	beq.n	401246 <prvSetupTest+0x1b2>
	{
		/* Should not be able to add a non-empty queue to a set. */
		xQueueSetTasksStatus = pdFAIL;
  401238:	f240 0304 	movw	r3, #4
  40123c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401240:	f04f 0200 	mov.w	r2, #0
  401244:	601a      	str	r2, [r3, #0]
	}

	/* Remove the item from the queue before adding the queue back into the
	set so the dynamic tests can begin. */
	xQueueReceive( xQueues[ 0 ], &ulValueToSend, 0 );
  401246:	f24a 4380 	movw	r3, #42112	; 0xa480
  40124a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40124e:	681a      	ldr	r2, [r3, #0]
  401250:	463b      	mov	r3, r7
  401252:	4610      	mov	r0, r2
  401254:	4619      	mov	r1, r3
  401256:	f04f 0200 	mov.w	r2, #0
  40125a:	f04f 0300 	mov.w	r3, #0
  40125e:	f243 7469 	movw	r4, #14185	; 0x3769
  401262:	f2c0 0440 	movt	r4, #64	; 0x40
  401266:	47a0      	blx	r4
	if( xQueueAddToSet( xQueues[ 0 ], xQueueSet ) != pdPASS )
  401268:	f24a 4380 	movw	r3, #42112	; 0xa480
  40126c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401270:	681a      	ldr	r2, [r3, #0]
  401272:	f24a 4398 	movw	r3, #42136	; 0xa498
  401276:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40127a:	681b      	ldr	r3, [r3, #0]
  40127c:	4610      	mov	r0, r2
  40127e:	4619      	mov	r1, r3
  401280:	f643 6365 	movw	r3, #15973	; 0x3e65
  401284:	f2c0 0340 	movt	r3, #64	; 0x40
  401288:	4798      	blx	r3
  40128a:	4603      	mov	r3, r0
  40128c:	2b01      	cmp	r3, #1
  40128e:	d006      	beq.n	40129e <prvSetupTest+0x20a>
	{
		/* If the queue was successfully removed from the queue set then it
		should be possible to add it back in again. */
		xQueueSetTasksStatus = pdFAIL;
  401290:	f240 0304 	movw	r3, #4
  401294:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401298:	f04f 0200 	mov.w	r2, #0
  40129c:	601a      	str	r2, [r3, #0]
	}

	/* The task that sends to the queues is not running yet, so attempting to
	read from the queue set should fail. */
	if( xQueueSelectFromSet( xQueueSet, queuesetSHORT_DELAY ) != NULL )
  40129e:	f24a 4398 	movw	r3, #42136	; 0xa498
  4012a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4012a6:	681b      	ldr	r3, [r3, #0]
  4012a8:	4618      	mov	r0, r3
  4012aa:	f04f 01c8 	mov.w	r1, #200	; 0xc8
  4012ae:	f643 731d 	movw	r3, #16157	; 0x3f1d
  4012b2:	f2c0 0340 	movt	r3, #64	; 0x40
  4012b6:	4798      	blx	r3
  4012b8:	4603      	mov	r3, r0
  4012ba:	2b00      	cmp	r3, #0
  4012bc:	d006      	beq.n	4012cc <prvSetupTest+0x238>
	{
		xQueueSetTasksStatus = pdFAIL;
  4012be:	f240 0304 	movw	r3, #4
  4012c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4012c6:	f04f 0200 	mov.w	r2, #0
  4012ca:	601a      	str	r2, [r3, #0]
	}

	/* Resume the task that writes to the queues. */
	vTaskResume( xQueueSetSendingTask );
  4012cc:	f24a 7398 	movw	r3, #42904	; 0xa798
  4012d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4012d4:	681b      	ldr	r3, [r3, #0]
  4012d6:	4618      	mov	r0, r3
  4012d8:	f244 736d 	movw	r3, #18285	; 0x476d
  4012dc:	f2c0 0340 	movt	r3, #64	; 0x40
  4012e0:	4798      	blx	r3

	/* Let the ISR access the queues also. */
	xSetupComplete = pdTRUE;
  4012e2:	f24a 43a0 	movw	r3, #42144	; 0xa4a0
  4012e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4012ea:	f04f 0201 	mov.w	r2, #1
  4012ee:	601a      	str	r2, [r3, #0]
}
  4012f0:	f107 070c 	add.w	r7, r7, #12
  4012f4:	46bd      	mov	sp, r7
  4012f6:	bd90      	pop	{r4, r7, pc}

004012f8 <prvRand>:
/*-----------------------------------------------------------*/

static unsigned long prvRand( void )
{
  4012f8:	b480      	push	{r7}
  4012fa:	af00      	add	r7, sp, #0
	ulNextRand = ( ulNextRand * 1103515245UL ) + 12345UL;
  4012fc:	f24a 43a4 	movw	r3, #42148	; 0xa4a4
  401300:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401304:	681a      	ldr	r2, [r3, #0]
  401306:	f644 636d 	movw	r3, #20077	; 0x4e6d
  40130a:	f2c4 13c6 	movt	r3, #16838	; 0x41c6
  40130e:	fb03 f302 	mul.w	r3, r3, r2
  401312:	f503 5240 	add.w	r2, r3, #12288	; 0x3000
  401316:	f102 0239 	add.w	r2, r2, #57	; 0x39
  40131a:	f24a 43a4 	movw	r3, #42148	; 0xa4a4
  40131e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401322:	601a      	str	r2, [r3, #0]
    return ( ulNextRand / 65536UL ) % 32768UL;
  401324:	f24a 43a4 	movw	r3, #42148	; 0xa4a4
  401328:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40132c:	681b      	ldr	r3, [r3, #0]
  40132e:	ea4f 4313 	mov.w	r3, r3, lsr #16
  401332:	ea4f 4343 	mov.w	r3, r3, lsl #17
  401336:	ea4f 4353 	mov.w	r3, r3, lsr #17
}
  40133a:	4618      	mov	r0, r3
  40133c:	46bd      	mov	sp, r7
  40133e:	bc80      	pop	{r7}
  401340:	4770      	bx	lr
  401342:	bf00      	nop

00401344 <prvSRand>:
/*-----------------------------------------------------------*/

static void prvSRand( unsigned long ulSeed )
{
  401344:	b480      	push	{r7}
  401346:	b083      	sub	sp, #12
  401348:	af00      	add	r7, sp, #0
  40134a:	6078      	str	r0, [r7, #4]
    ulNextRand = ulSeed;
  40134c:	f24a 43a4 	movw	r3, #42148	; 0xa4a4
  401350:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401354:	687a      	ldr	r2, [r7, #4]
  401356:	601a      	str	r2, [r3, #0]
}
  401358:	f107 070c 	add.w	r7, r7, #12
  40135c:	46bd      	mov	sp, r7
  40135e:	bc80      	pop	{r7}
  401360:	4770      	bx	lr
  401362:	bf00      	nop

00401364 <NVIC_EnableIRQ>:
    The interrupt number cannot be a negative value.

    \param [in]      IRQn  Number of the external interrupt to enable
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  401364:	b480      	push	{r7}
  401366:	b083      	sub	sp, #12
  401368:	af00      	add	r7, sp, #0
  40136a:	4603      	mov	r3, r0
  40136c:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  40136e:	f44f 4361 	mov.w	r3, #57600	; 0xe100
  401372:	f2ce 0300 	movt	r3, #57344	; 0xe000
  401376:	f997 2007 	ldrsb.w	r2, [r7, #7]
  40137a:	ea4f 1252 	mov.w	r2, r2, lsr #5
  40137e:	79f9      	ldrb	r1, [r7, #7]
  401380:	f001 011f 	and.w	r1, r1, #31
  401384:	f04f 0001 	mov.w	r0, #1
  401388:	fa00 f101 	lsl.w	r1, r0, r1
  40138c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
  401390:	f107 070c 	add.w	r7, r7, #12
  401394:	46bd      	mov	sp, r7
  401396:	bc80      	pop	{r7}
  401398:	4770      	bx	lr
  40139a:	bf00      	nop

0040139c <NVIC_SetPriority>:

    \param [in]      IRQn  Number of the interrupt for set priority
    \param [in]  priority  Priority to set
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  40139c:	b480      	push	{r7}
  40139e:	b083      	sub	sp, #12
  4013a0:	af00      	add	r7, sp, #0
  4013a2:	4603      	mov	r3, r0
  4013a4:	6039      	str	r1, [r7, #0]
  4013a6:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  4013a8:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4013ac:	2b00      	cmp	r3, #0
  4013ae:	da10      	bge.n	4013d2 <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  4013b0:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  4013b4:	f2ce 0300 	movt	r3, #57344	; 0xe000
  4013b8:	79fa      	ldrb	r2, [r7, #7]
  4013ba:	f002 020f 	and.w	r2, r2, #15
  4013be:	f1a2 0104 	sub.w	r1, r2, #4
  4013c2:	683a      	ldr	r2, [r7, #0]
  4013c4:	b2d2      	uxtb	r2, r2
  4013c6:	ea4f 1202 	mov.w	r2, r2, lsl #4
  4013ca:	b2d2      	uxtb	r2, r2
  4013cc:	185b      	adds	r3, r3, r1
  4013ce:	761a      	strb	r2, [r3, #24]
  4013d0:	e00d      	b.n	4013ee <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  4013d2:	f44f 4361 	mov.w	r3, #57600	; 0xe100
  4013d6:	f2ce 0300 	movt	r3, #57344	; 0xe000
  4013da:	f997 1007 	ldrsb.w	r1, [r7, #7]
  4013de:	683a      	ldr	r2, [r7, #0]
  4013e0:	b2d2      	uxtb	r2, r2
  4013e2:	ea4f 1202 	mov.w	r2, r2, lsl #4
  4013e6:	b2d2      	uxtb	r2, r2
  4013e8:	185b      	adds	r3, r3, r1
  4013ea:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  4013ee:	f107 070c 	add.w	r7, r7, #12
  4013f2:	46bd      	mov	sp, r7
  4013f4:	bc80      	pop	{r7}
  4013f6:	4770      	bx	lr

004013f8 <osc_get_rate>:

	return 0;
}

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  4013f8:	b480      	push	{r7}
  4013fa:	b083      	sub	sp, #12
  4013fc:	af00      	add	r7, sp, #0
  4013fe:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  401400:	687b      	ldr	r3, [r7, #4]
  401402:	2b07      	cmp	r3, #7
  401404:	d834      	bhi.n	401470 <osc_get_rate+0x78>
  401406:	a201      	add	r2, pc, #4	; (adr r2, 40140c <osc_get_rate+0x14>)
  401408:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40140c:	0040142d 	.word	0x0040142d
  401410:	00401433 	.word	0x00401433
  401414:	00401439 	.word	0x00401439
  401418:	0040143f 	.word	0x0040143f
  40141c:	00401449 	.word	0x00401449
  401420:	00401453 	.word	0x00401453
  401424:	0040145d 	.word	0x0040145d
  401428:	00401467 	.word	0x00401467
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  40142c:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  401430:	e020      	b.n	401474 <osc_get_rate+0x7c>

#ifdef BOARD_FREQ_SLCK_XTAL
	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  401432:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401436:	e01d      	b.n	401474 <osc_get_rate+0x7c>
#endif

#ifdef BOARD_FREQ_SLCK_BYPASS
	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  401438:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40143c:	e01a      	b.n	401474 <osc_get_rate+0x7c>
#endif

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
  40143e:	f44f 6310 	mov.w	r3, #2304	; 0x900
  401442:	f2c0 033d 	movt	r3, #61	; 0x3d
  401446:	e015      	b.n	401474 <osc_get_rate+0x7c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  401448:	f44f 5390 	mov.w	r3, #4608	; 0x1200
  40144c:	f2c0 037a 	movt	r3, #122	; 0x7a
  401450:	e010      	b.n	401474 <osc_get_rate+0x7c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
  401452:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  401456:	f2c0 03b7 	movt	r3, #183	; 0xb7
  40145a:	e00b      	b.n	401474 <osc_get_rate+0x7c>

#ifdef BOARD_FREQ_MAINCK_XTAL
	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  40145c:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  401460:	f2c0 03b7 	movt	r3, #183	; 0xb7
  401464:	e006      	b.n	401474 <osc_get_rate+0x7c>
#endif

#ifdef BOARD_FREQ_MAINCK_BYPASS
	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  401466:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  40146a:	f2c0 03b7 	movt	r3, #183	; 0xb7
  40146e:	e001      	b.n	401474 <osc_get_rate+0x7c>
#endif
	}

	return 0;
  401470:	f04f 0300 	mov.w	r3, #0
}
  401474:	4618      	mov	r0, r3
  401476:	f107 070c 	add.w	r7, r7, #12
  40147a:	46bd      	mov	sp, r7
  40147c:	bc80      	pop	{r7}
  40147e:	4770      	bx	lr

00401480 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
  401480:	b580      	push	{r7, lr}
  401482:	af00      	add	r7, sp, #0
    case SYSCLK_SRC_MAINCK_BYPASS:
		return OSC_MAINCK_BYPASS_HZ;

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLLACK:
		return pll_get_default_rate(0);	
  401484:	f04f 0006 	mov.w	r0, #6
  401488:	f241 33f9 	movw	r3, #5113	; 0x13f9
  40148c:	f2c0 0340 	movt	r3, #64	; 0x40
  401490:	4798      	blx	r3
  401492:	4602      	mov	r2, r0
  401494:	4613      	mov	r3, r2
  401496:	ea4f 0383 	mov.w	r3, r3, lsl #2
  40149a:	189b      	adds	r3, r3, r2
  40149c:	ea4f 0383 	mov.w	r3, r3, lsl #2
	
	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
  4014a0:	4618      	mov	r0, r3
  4014a2:	bd80      	pop	{r7, pc}

004014a4 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
  4014a4:	b580      	push	{r7, lr}
  4014a6:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediat value. */
	return sysclk_get_main_hz() / ((CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos) + 1);
  4014a8:	f241 4381 	movw	r3, #5249	; 0x1481
  4014ac:	f2c0 0340 	movt	r3, #64	; 0x40
  4014b0:	4798      	blx	r3
  4014b2:	4603      	mov	r3, r0
  4014b4:	ea4f 0353 	mov.w	r3, r3, lsr #1
}
  4014b8:	4618      	mov	r0, r3
  4014ba:	bd80      	pop	{r7, pc}

004014bc <xSerialPortInitMinimal>:

/*
 * See the serial.h header file.
 */
xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
  4014bc:	b580      	push	{r7, lr}
  4014be:	b08a      	sub	sp, #40	; 0x28
  4014c0:	af00      	add	r7, sp, #0
  4014c2:	6078      	str	r0, [r7, #4]
  4014c4:	6039      	str	r1, [r7, #0]
uint32_t ulChar;
xComPortHandle xReturn;
const sam_usart_opt_t xUSARTSettings = 
  4014c6:	687b      	ldr	r3, [r7, #4]
  4014c8:	60bb      	str	r3, [r7, #8]
  4014ca:	f04f 03c0 	mov.w	r3, #192	; 0xc0
  4014ce:	60fb      	str	r3, [r7, #12]
  4014d0:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4014d4:	613b      	str	r3, [r7, #16]
  4014d6:	f04f 0300 	mov.w	r3, #0
  4014da:	617b      	str	r3, [r7, #20]
  4014dc:	f04f 0300 	mov.w	r3, #0
  4014e0:	61bb      	str	r3, [r7, #24]
  4014e2:	f04f 0300 	mov.w	r3, #0
  4014e6:	61fb      	str	r3, [r7, #28]
	US_MR_CHMODE_NORMAL,	
	0 /* Only used in IrDA mode. */
};

	/* Create the queues used to hold Rx/Tx characters. */
	xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
  4014e8:	6838      	ldr	r0, [r7, #0]
  4014ea:	f04f 0101 	mov.w	r1, #1
  4014ee:	f04f 0200 	mov.w	r2, #0
  4014f2:	f243 1311 	movw	r3, #12561	; 0x3111
  4014f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4014fa:	4798      	blx	r3
  4014fc:	4602      	mov	r2, r0
  4014fe:	f24a 43d0 	movw	r3, #42192	; 0xa4d0
  401502:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401506:	601a      	str	r2, [r3, #0]
	xCharsForTx = xQueueCreate( uxQueueLength + 1, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
  401508:	683b      	ldr	r3, [r7, #0]
  40150a:	f103 0301 	add.w	r3, r3, #1
  40150e:	4618      	mov	r0, r3
  401510:	f04f 0101 	mov.w	r1, #1
  401514:	f04f 0200 	mov.w	r2, #0
  401518:	f243 1311 	movw	r3, #12561	; 0x3111
  40151c:	f2c0 0340 	movt	r3, #64	; 0x40
  401520:	4798      	blx	r3
  401522:	4602      	mov	r2, r0
  401524:	f24a 43d4 	movw	r3, #42196	; 0xa4d4
  401528:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40152c:	601a      	str	r2, [r3, #0]
	
	/* If the queues were created correctly then setup the serial port
	hardware. */
	if( ( xRxedChars != serINVALID_QUEUE ) && ( xCharsForTx != serINVALID_QUEUE ) )
  40152e:	f24a 43d0 	movw	r3, #42192	; 0xa4d0
  401532:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401536:	681b      	ldr	r3, [r3, #0]
  401538:	2b00      	cmp	r3, #0
  40153a:	d065      	beq.n	401608 <xSerialPortInitMinimal+0x14c>
  40153c:	f24a 43d4 	movw	r3, #42196	; 0xa4d4
  401540:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401544:	681b      	ldr	r3, [r3, #0]
  401546:	2b00      	cmp	r3, #0
  401548:	d05e      	beq.n	401608 <xSerialPortInitMinimal+0x14c>
	{
		/* Enable the peripheral clock in the PMC. */
		pmc_enable_periph_clk( serPMC_USART_ID );
  40154a:	f04f 000f 	mov.w	r0, #15
  40154e:	f242 6335 	movw	r3, #9781	; 0x2635
  401552:	f2c0 0340 	movt	r3, #64	; 0x40
  401556:	4798      	blx	r3

		/* Configure USART in serial mode. */
		usart_init_rs232( serUSART_PORT, &xUSARTSettings, sysclk_get_cpu_hz() );
  401558:	f241 43a5 	movw	r3, #5285	; 0x14a5
  40155c:	f2c0 0340 	movt	r3, #64	; 0x40
  401560:	4798      	blx	r3
  401562:	4603      	mov	r3, r0
  401564:	f107 0208 	add.w	r2, r7, #8
  401568:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  40156c:	f2c4 0002 	movt	r0, #16386	; 0x4002
  401570:	4611      	mov	r1, r2
  401572:	461a      	mov	r2, r3
  401574:	f240 2391 	movw	r3, #657	; 0x291
  401578:	f2c0 0340 	movt	r3, #64	; 0x40
  40157c:	4798      	blx	r3

		/* Disable all the interrupts. */
		usart_disable_interrupt( serUSART_PORT, serMASK_ALL_INTERRUPTS );
  40157e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  401582:	f2c4 0002 	movt	r0, #16386	; 0x4002
  401586:	f04f 31ff 	mov.w	r1, #4294967295
  40158a:	f240 33cd 	movw	r3, #973	; 0x3cd
  40158e:	f2c0 0340 	movt	r3, #64	; 0x40
  401592:	4798      	blx	r3

		/* Enable the receiver and transmitter. */
		usart_enable_tx( serUSART_PORT );
  401594:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  401598:	f2c4 0002 	movt	r0, #16386	; 0x4002
  40159c:	f240 3341 	movw	r3, #833	; 0x341
  4015a0:	f2c0 0340 	movt	r3, #64	; 0x40
  4015a4:	4798      	blx	r3
		usart_enable_rx( serUSART_PORT );
  4015a6:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  4015aa:	f2c4 0002 	movt	r0, #16386	; 0x4002
  4015ae:	f240 3379 	movw	r3, #889	; 0x379
  4015b2:	f2c0 0340 	movt	r3, #64	; 0x40
  4015b6:	4798      	blx	r3
		
		/* Clear any characters before enabling interrupt. */
		usart_getchar( serUSART_PORT, &ulChar );
  4015b8:	f107 0320 	add.w	r3, r7, #32
  4015bc:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  4015c0:	f2c4 0002 	movt	r0, #16386	; 0x4002
  4015c4:	4619      	mov	r1, r3
  4015c6:	f240 43c9 	movw	r3, #1225	; 0x4c9
  4015ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4015ce:	4798      	blx	r3
		
		/* Enable Rx end interrupt. */
		usart_enable_interrupt( serUSART_PORT, US_IER_RXRDY );
  4015d0:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  4015d4:	f2c4 0002 	movt	r0, #16386	; 0x4002
  4015d8:	f04f 0101 	mov.w	r1, #1
  4015dc:	f240 33b1 	movw	r3, #945	; 0x3b1
  4015e0:	f2c0 0340 	movt	r3, #64	; 0x40
  4015e4:	4798      	blx	r3

		/* Configure and enable interrupt of USART. */
		NVIC_SetPriority( serUSART_IRQ, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY );
  4015e6:	f04f 000f 	mov.w	r0, #15
  4015ea:	f04f 010a 	mov.w	r1, #10
  4015ee:	f241 339d 	movw	r3, #5021	; 0x139d
  4015f2:	f2c0 0340 	movt	r3, #64	; 0x40
  4015f6:	4798      	blx	r3
		NVIC_EnableIRQ( serUSART_IRQ );
  4015f8:	f04f 000f 	mov.w	r0, #15
  4015fc:	f241 3365 	movw	r3, #4965	; 0x1365
  401600:	f2c0 0340 	movt	r3, #64	; 0x40
  401604:	4798      	blx	r3
  401606:	e002      	b.n	40160e <xSerialPortInitMinimal+0x152>
	}
	else
	{
		xReturn = ( xComPortHandle ) 0;
  401608:	f04f 0300 	mov.w	r3, #0
  40160c:	627b      	str	r3, [r7, #36]	; 0x24
	}

	/* This demo file only supports a single port but we have to return
	something to comply with the standard demo header file. */
	return xReturn;
  40160e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
  401610:	4618      	mov	r0, r3
  401612:	f107 0728 	add.w	r7, r7, #40	; 0x28
  401616:	46bd      	mov	sp, r7
  401618:	bd80      	pop	{r7, pc}
  40161a:	bf00      	nop

0040161c <xSerialGetChar>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialGetChar( xComPortHandle pxPort, signed char *pcRxedChar, portTickType xBlockTime )
{
  40161c:	b590      	push	{r4, r7, lr}
  40161e:	b085      	sub	sp, #20
  401620:	af00      	add	r7, sp, #0
  401622:	60f8      	str	r0, [r7, #12]
  401624:	60b9      	str	r1, [r7, #8]
  401626:	607a      	str	r2, [r7, #4]
	/* The port handle is not required as this driver only supports one port. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
  401628:	f24a 43d0 	movw	r3, #42192	; 0xa4d0
  40162c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401630:	681b      	ldr	r3, [r3, #0]
  401632:	4618      	mov	r0, r3
  401634:	68b9      	ldr	r1, [r7, #8]
  401636:	687a      	ldr	r2, [r7, #4]
  401638:	f04f 0300 	mov.w	r3, #0
  40163c:	f243 7469 	movw	r4, #14185	; 0x3769
  401640:	f2c0 0440 	movt	r4, #64	; 0x40
  401644:	47a0      	blx	r4
  401646:	4603      	mov	r3, r0
  401648:	2b00      	cmp	r3, #0
  40164a:	d002      	beq.n	401652 <xSerialGetChar+0x36>
	{
		return pdTRUE;
  40164c:	f04f 0301 	mov.w	r3, #1
  401650:	e001      	b.n	401656 <xSerialGetChar+0x3a>
	}
	else
	{
		return pdFALSE;
  401652:	f04f 0300 	mov.w	r3, #0
	}
}
  401656:	4618      	mov	r0, r3
  401658:	f107 0714 	add.w	r7, r7, #20
  40165c:	46bd      	mov	sp, r7
  40165e:	bd90      	pop	{r4, r7, pc}

00401660 <xSerialPutChar>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, portTickType xBlockTime )
{
  401660:	b590      	push	{r4, r7, lr}
  401662:	b087      	sub	sp, #28
  401664:	af00      	add	r7, sp, #0
  401666:	60f8      	str	r0, [r7, #12]
  401668:	460b      	mov	r3, r1
  40166a:	607a      	str	r2, [r7, #4]
  40166c:	72fb      	strb	r3, [r7, #11]
signed portBASE_TYPE xReturn;

	/* This simple example only supports one port. */
	( void ) pxPort;

	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) == pdPASS )
  40166e:	f24a 43d4 	movw	r3, #42196	; 0xa4d4
  401672:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401676:	681a      	ldr	r2, [r3, #0]
  401678:	f107 030b 	add.w	r3, r7, #11
  40167c:	4610      	mov	r0, r2
  40167e:	4619      	mov	r1, r3
  401680:	687a      	ldr	r2, [r7, #4]
  401682:	f04f 0300 	mov.w	r3, #0
  401686:	f243 34f1 	movw	r4, #13297	; 0x33f1
  40168a:	f2c0 0440 	movt	r4, #64	; 0x40
  40168e:	47a0      	blx	r4
  401690:	4603      	mov	r3, r0
  401692:	2b01      	cmp	r3, #1
  401694:	d10e      	bne.n	4016b4 <xSerialPutChar+0x54>
	{
		xReturn = pdPASS;
  401696:	f04f 0301 	mov.w	r3, #1
  40169a:	617b      	str	r3, [r7, #20]
		usart_enable_interrupt( serUSART_PORT, US_IER_TXRDY );
  40169c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  4016a0:	f2c4 0002 	movt	r0, #16386	; 0x4002
  4016a4:	f04f 0102 	mov.w	r1, #2
  4016a8:	f240 33b1 	movw	r3, #945	; 0x3b1
  4016ac:	f2c0 0340 	movt	r3, #64	; 0x40
  4016b0:	4798      	blx	r3
  4016b2:	e002      	b.n	4016ba <xSerialPutChar+0x5a>
	}
	else
	{
		xReturn = pdFAIL;
  4016b4:	f04f 0300 	mov.w	r3, #0
  4016b8:	617b      	str	r3, [r7, #20]
	}

	return xReturn;
  4016ba:	697b      	ldr	r3, [r7, #20]
}
  4016bc:	4618      	mov	r0, r3
  4016be:	f107 071c 	add.w	r7, r7, #28
  4016c2:	46bd      	mov	sp, r7
  4016c4:	bd90      	pop	{r4, r7, pc}
  4016c6:	bf00      	nop

004016c8 <USART1_Handler>:
 * inside an interrupt service routine.  The serial driver used here is *not* 
 * intended to represent an efficient implementation.  Real applications should 
 * make use of the USARTS peripheral DMA channel (PDC).
 */
void USART1_Handler( void )
{
  4016c8:	b590      	push	{r4, r7, lr}
  4016ca:	b087      	sub	sp, #28
  4016cc:	af00      	add	r7, sp, #0
portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
  4016ce:	f04f 0300 	mov.w	r3, #0
  4016d2:	60fb      	str	r3, [r7, #12]
uint8_t ucChar;
uint32_t ulChar;
uint32_t ulUSARTStatus, ulUSARTMask;

	ulUSARTStatus = usart_get_status( serUSART_PORT );
  4016d4:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  4016d8:	f2c4 0002 	movt	r0, #16386	; 0x4002
  4016dc:	f240 4301 	movw	r3, #1025	; 0x401
  4016e0:	f2c0 0340 	movt	r3, #64	; 0x40
  4016e4:	4798      	blx	r3
  4016e6:	6178      	str	r0, [r7, #20]
	ulUSARTMask = usart_get_interrupt_mask( serUSART_PORT );
  4016e8:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  4016ec:	f2c4 0002 	movt	r0, #16386	; 0x4002
  4016f0:	f240 33e9 	movw	r3, #1001	; 0x3e9
  4016f4:	f2c0 0340 	movt	r3, #64	; 0x40
  4016f8:	4798      	blx	r3
  4016fa:	6138      	str	r0, [r7, #16]
	ulUSARTStatus &= ulUSARTMask;
  4016fc:	697a      	ldr	r2, [r7, #20]
  4016fe:	693b      	ldr	r3, [r7, #16]
  401700:	4013      	ands	r3, r2
  401702:	617b      	str	r3, [r7, #20]

	if( ( ulUSARTStatus & US_CSR_TXRDY ) != 0UL )
  401704:	697b      	ldr	r3, [r7, #20]
  401706:	f003 0302 	and.w	r3, r3, #2
  40170a:	2b00      	cmp	r3, #0
  40170c:	d02a      	beq.n	401764 <USART1_Handler+0x9c>
	{
		/* The interrupt was caused by the TX register becoming empty.  Are 
		there any more characters to transmit? */
		if( xQueueReceiveFromISR( xCharsForTx, &ucChar, &xHigherPriorityTaskWoken ) == pdTRUE )
  40170e:	f24a 43d4 	movw	r3, #42196	; 0xa4d4
  401712:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401716:	6819      	ldr	r1, [r3, #0]
  401718:	f107 020b 	add.w	r2, r7, #11
  40171c:	f107 030c 	add.w	r3, r7, #12
  401720:	4608      	mov	r0, r1
  401722:	4611      	mov	r1, r2
  401724:	461a      	mov	r2, r3
  401726:	f643 13cd 	movw	r3, #14797	; 0x39cd
  40172a:	f2c0 0340 	movt	r3, #64	; 0x40
  40172e:	4798      	blx	r3
  401730:	4603      	mov	r3, r0
  401732:	2b01      	cmp	r3, #1
  401734:	d10b      	bne.n	40174e <USART1_Handler+0x86>
		{
			/* A character was retrieved from the queue so can be sent to the
			USART now. */
			usart_putchar( serUSART_PORT, ( uint32_t ) ucChar );
  401736:	7afb      	ldrb	r3, [r7, #11]
  401738:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  40173c:	f2c4 0002 	movt	r0, #16386	; 0x4002
  401740:	4619      	mov	r1, r3
  401742:	f240 436d 	movw	r3, #1133	; 0x46d
  401746:	f2c0 0340 	movt	r3, #64	; 0x40
  40174a:	4798      	blx	r3
  40174c:	e00a      	b.n	401764 <USART1_Handler+0x9c>
		}
		else
		{
			usart_disable_interrupt( serUSART_PORT, US_IER_TXRDY );		
  40174e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  401752:	f2c4 0002 	movt	r0, #16386	; 0x4002
  401756:	f04f 0102 	mov.w	r1, #2
  40175a:	f240 33cd 	movw	r3, #973	; 0x3cd
  40175e:	f2c0 0340 	movt	r3, #64	; 0x40
  401762:	4798      	blx	r3
		}		
	}
	
	if( ( ulUSARTStatus & US_CSR_RXRDY ) != 0UL )
  401764:	697b      	ldr	r3, [r7, #20]
  401766:	f003 0301 	and.w	r3, r3, #1
  40176a:	2b00      	cmp	r3, #0
  40176c:	d021      	beq.n	4017b2 <USART1_Handler+0xea>
	{
		/* A character has been received on the USART, send it to the Rx
		handler task. */
		usart_getchar( serUSART_PORT, &ulChar );
  40176e:	f107 0304 	add.w	r3, r7, #4
  401772:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  401776:	f2c4 0002 	movt	r0, #16386	; 0x4002
  40177a:	4619      	mov	r1, r3
  40177c:	f240 43c9 	movw	r3, #1225	; 0x4c9
  401780:	f2c0 0340 	movt	r3, #64	; 0x40
  401784:	4798      	blx	r3
		ucChar = ( uint8_t ) ( ulChar & 0xffUL );
  401786:	687b      	ldr	r3, [r7, #4]
  401788:	b2db      	uxtb	r3, r3
  40178a:	72fb      	strb	r3, [r7, #11]
		xQueueSendFromISR( xRxedChars, &ucChar, &xHigherPriorityTaskWoken );
  40178c:	f24a 43d0 	movw	r3, #42192	; 0xa4d0
  401790:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401794:	6819      	ldr	r1, [r3, #0]
  401796:	f107 020b 	add.w	r2, r7, #11
  40179a:	f107 030c 	add.w	r3, r7, #12
  40179e:	4608      	mov	r0, r1
  4017a0:	4611      	mov	r1, r2
  4017a2:	461a      	mov	r2, r3
  4017a4:	f04f 0300 	mov.w	r3, #0
  4017a8:	f243 6425 	movw	r4, #13861	; 0x3625
  4017ac:	f2c0 0440 	movt	r4, #64	; 0x40
  4017b0:	47a0      	blx	r4
	the unblocked task has a priority equal to or higher than the currently 
	running task (the task this ISR interrupted), then xHigherPriorityTaskWoken 
	will have automatically been set to pdTRUE within the queue send or receive 
	function.  portEND_SWITCHING_ISR() will then ensure that this ISR returns 
	directly to the higher priority unblocked task. */
	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
  4017b2:	68fb      	ldr	r3, [r7, #12]
  4017b4:	2b00      	cmp	r3, #0
  4017b6:	d006      	beq.n	4017c6 <USART1_Handler+0xfe>
  4017b8:	f64e 5304 	movw	r3, #60676	; 0xed04
  4017bc:	f2ce 0300 	movt	r3, #57344	; 0xe000
  4017c0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4017c4:	601a      	str	r2, [r3, #0]
}
  4017c6:	f107 071c 	add.w	r7, r7, #28
  4017ca:	46bd      	mov	sp, r7
  4017cc:	bd90      	pop	{r4, r7, pc}
  4017ce:	bf00      	nop

004017d0 <osc_enable>:
#define OSC_MAINCK_XTAL_HZ			BOARD_FREQ_MAINCK_XTAL			//!< External crystal oscillator.
#define OSC_MAINCK_BYPASS_HZ		BOARD_FREQ_MAINCK_BYPASS		//!< External bypass oscillator.
//@}

static inline void osc_enable(uint32_t ul_id)
{
  4017d0:	b580      	push	{r7, lr}
  4017d2:	b082      	sub	sp, #8
  4017d4:	af00      	add	r7, sp, #0
  4017d6:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4017d8:	687b      	ldr	r3, [r7, #4]
  4017da:	2b07      	cmp	r3, #7
  4017dc:	d84a      	bhi.n	401874 <osc_enable+0xa4>
  4017de:	a201      	add	r2, pc, #4	; (adr r2, 4017e4 <osc_enable+0x14>)
  4017e0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4017e4:	00401875 	.word	0x00401875
  4017e8:	00401805 	.word	0x00401805
  4017ec:	00401815 	.word	0x00401815
  4017f0:	00401825 	.word	0x00401825
  4017f4:	00401835 	.word	0x00401835
  4017f8:	00401845 	.word	0x00401845
  4017fc:	00401855 	.word	0x00401855
  401800:	00401865 	.word	0x00401865
	case OSC_SLCK_32K_RC:
		break;

	case OSC_SLCK_32K_XTAL:
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  401804:	f04f 0000 	mov.w	r0, #0
  401808:	f242 33a9 	movw	r3, #9129	; 0x23a9
  40180c:	f2c0 0340 	movt	r3, #64	; 0x40
  401810:	4798      	blx	r3
		break;
  401812:	e02f      	b.n	401874 <osc_enable+0xa4>

	case OSC_SLCK_32K_BYPASS:
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
  401814:	f04f 0001 	mov.w	r0, #1
  401818:	f242 33a9 	movw	r3, #9129	; 0x23a9
  40181c:	f2c0 0340 	movt	r3, #64	; 0x40
  401820:	4798      	blx	r3
		break;
  401822:	e027      	b.n	401874 <osc_enable+0xa4>


	case OSC_MAINCK_4M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_4_MHz);
  401824:	f04f 0000 	mov.w	r0, #0
  401828:	f242 4335 	movw	r3, #9269	; 0x2435
  40182c:	f2c0 0340 	movt	r3, #64	; 0x40
  401830:	4798      	blx	r3
		break;
  401832:	e01f      	b.n	401874 <osc_enable+0xa4>

	case OSC_MAINCK_8M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
  401834:	f04f 0010 	mov.w	r0, #16
  401838:	f242 4335 	movw	r3, #9269	; 0x2435
  40183c:	f2c0 0340 	movt	r3, #64	; 0x40
  401840:	4798      	blx	r3
		break;
  401842:	e017      	b.n	401874 <osc_enable+0xa4>

	case OSC_MAINCK_12M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
  401844:	f04f 0020 	mov.w	r0, #32
  401848:	f242 4335 	movw	r3, #9269	; 0x2435
  40184c:	f2c0 0340 	movt	r3, #64	; 0x40
  401850:	4798      	blx	r3
		break;
  401852:	e00f      	b.n	401874 <osc_enable+0xa4>


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL);
  401854:	f04f 0000 	mov.w	r0, #0
  401858:	f242 5315 	movw	r3, #9493	; 0x2515
  40185c:	f2c0 0340 	movt	r3, #64	; 0x40
  401860:	4798      	blx	r3
		break;
  401862:	e007      	b.n	401874 <osc_enable+0xa4>

	case OSC_MAINCK_BYPASS:
		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS);
  401864:	f04f 0001 	mov.w	r0, #1
  401868:	f242 5315 	movw	r3, #9493	; 0x2515
  40186c:	f2c0 0340 	movt	r3, #64	; 0x40
  401870:	4798      	blx	r3
		break;
  401872:	bf00      	nop
	}
}
  401874:	f107 0708 	add.w	r7, r7, #8
  401878:	46bd      	mov	sp, r7
  40187a:	bd80      	pop	{r7, pc}

0040187c <osc_is_ready>:
		break;
	}
}

static inline bool osc_is_ready(uint32_t ul_id)
{
  40187c:	b580      	push	{r7, lr}
  40187e:	b082      	sub	sp, #8
  401880:	af00      	add	r7, sp, #0
  401882:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  401884:	687b      	ldr	r3, [r7, #4]
  401886:	2b07      	cmp	r3, #7
  401888:	d82d      	bhi.n	4018e6 <osc_is_ready+0x6a>
  40188a:	a201      	add	r2, pc, #4	; (adr r2, 401890 <osc_is_ready+0x14>)
  40188c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401890:	004018b1 	.word	0x004018b1
  401894:	004018b7 	.word	0x004018b7
  401898:	004018b7 	.word	0x004018b7
  40189c:	004018cf 	.word	0x004018cf
  4018a0:	004018cf 	.word	0x004018cf
  4018a4:	004018cf 	.word	0x004018cf
  4018a8:	004018cf 	.word	0x004018cf
  4018ac:	004018cf 	.word	0x004018cf
	case OSC_SLCK_32K_RC:
		return 1;
  4018b0:	f04f 0301 	mov.w	r3, #1
  4018b4:	e019      	b.n	4018ea <osc_is_ready+0x6e>

	case OSC_SLCK_32K_XTAL:
	case OSC_SLCK_32K_BYPASS:
		return pmc_osc_is_ready_32kxtal();
  4018b6:	f242 33f9 	movw	r3, #9209	; 0x23f9
  4018ba:	f2c0 0340 	movt	r3, #64	; 0x40
  4018be:	4798      	blx	r3
  4018c0:	4603      	mov	r3, r0
  4018c2:	2b00      	cmp	r3, #0
  4018c4:	bf0c      	ite	eq
  4018c6:	2300      	moveq	r3, #0
  4018c8:	2301      	movne	r3, #1
  4018ca:	b2db      	uxtb	r3, r3
  4018cc:	e00d      	b.n	4018ea <osc_is_ready+0x6e>
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  4018ce:	f242 53b1 	movw	r3, #9649	; 0x25b1
  4018d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4018d6:	4798      	blx	r3
  4018d8:	4603      	mov	r3, r0
  4018da:	2b00      	cmp	r3, #0
  4018dc:	bf0c      	ite	eq
  4018de:	2300      	moveq	r3, #0
  4018e0:	2301      	movne	r3, #1
  4018e2:	b2db      	uxtb	r3, r3
  4018e4:	e001      	b.n	4018ea <osc_is_ready+0x6e>
	}

	return 0;
  4018e6:	f04f 0300 	mov.w	r3, #0
}
  4018ea:	4618      	mov	r0, r3
  4018ec:	f107 0708 	add.w	r7, r7, #8
  4018f0:	46bd      	mov	sp, r7
  4018f2:	bd80      	pop	{r7, pc}

004018f4 <osc_get_rate>:

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  4018f4:	b480      	push	{r7}
  4018f6:	b083      	sub	sp, #12
  4018f8:	af00      	add	r7, sp, #0
  4018fa:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4018fc:	687b      	ldr	r3, [r7, #4]
  4018fe:	2b07      	cmp	r3, #7
  401900:	d834      	bhi.n	40196c <osc_get_rate+0x78>
  401902:	a201      	add	r2, pc, #4	; (adr r2, 401908 <osc_get_rate+0x14>)
  401904:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401908:	00401929 	.word	0x00401929
  40190c:	0040192f 	.word	0x0040192f
  401910:	00401935 	.word	0x00401935
  401914:	0040193b 	.word	0x0040193b
  401918:	00401945 	.word	0x00401945
  40191c:	0040194f 	.word	0x0040194f
  401920:	00401959 	.word	0x00401959
  401924:	00401963 	.word	0x00401963
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  401928:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  40192c:	e020      	b.n	401970 <osc_get_rate+0x7c>

#ifdef BOARD_FREQ_SLCK_XTAL
	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  40192e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401932:	e01d      	b.n	401970 <osc_get_rate+0x7c>
#endif

#ifdef BOARD_FREQ_SLCK_BYPASS
	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  401934:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401938:	e01a      	b.n	401970 <osc_get_rate+0x7c>
#endif

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
  40193a:	f44f 6310 	mov.w	r3, #2304	; 0x900
  40193e:	f2c0 033d 	movt	r3, #61	; 0x3d
  401942:	e015      	b.n	401970 <osc_get_rate+0x7c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  401944:	f44f 5390 	mov.w	r3, #4608	; 0x1200
  401948:	f2c0 037a 	movt	r3, #122	; 0x7a
  40194c:	e010      	b.n	401970 <osc_get_rate+0x7c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
  40194e:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  401952:	f2c0 03b7 	movt	r3, #183	; 0xb7
  401956:	e00b      	b.n	401970 <osc_get_rate+0x7c>

#ifdef BOARD_FREQ_MAINCK_XTAL
	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  401958:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  40195c:	f2c0 03b7 	movt	r3, #183	; 0xb7
  401960:	e006      	b.n	401970 <osc_get_rate+0x7c>
#endif

#ifdef BOARD_FREQ_MAINCK_BYPASS
	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  401962:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  401966:	f2c0 03b7 	movt	r3, #183	; 0xb7
  40196a:	e001      	b.n	401970 <osc_get_rate+0x7c>
#endif
	}

	return 0;
  40196c:	f04f 0300 	mov.w	r3, #0
}
  401970:	4618      	mov	r0, r3
  401972:	f107 070c 	add.w	r7, r7, #12
  401976:	46bd      	mov	sp, r7
  401978:	bc80      	pop	{r7}
  40197a:	4770      	bx	lr

0040197c <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
  40197c:	b580      	push	{r7, lr}
  40197e:	b082      	sub	sp, #8
  401980:	af00      	add	r7, sp, #0
  401982:	4603      	mov	r3, r0
  401984:	71fb      	strb	r3, [r7, #7]
	while (!osc_is_ready(id)) {
  401986:	bf00      	nop
  401988:	79fb      	ldrb	r3, [r7, #7]
  40198a:	4618      	mov	r0, r3
  40198c:	f641 037d 	movw	r3, #6269	; 0x187d
  401990:	f2c0 0340 	movt	r3, #64	; 0x40
  401994:	4798      	blx	r3
  401996:	4603      	mov	r3, r0
  401998:	f083 0301 	eor.w	r3, r3, #1
  40199c:	b2db      	uxtb	r3, r3
  40199e:	2b00      	cmp	r3, #0
  4019a0:	d1f2      	bne.n	401988 <osc_wait_ready+0xc>
		/* Do nothing */
	}
}
  4019a2:	f107 0708 	add.w	r7, r7, #8
  4019a6:	46bd      	mov	sp, r7
  4019a8:	bd80      	pop	{r7, pc}
  4019aa:	bf00      	nop

004019ac <pll_config_init>:
 * \note The SAM3S PLL hardware interprets mul as mul+1. For readability the hardware mul+1
 * is hidden in this implementation. Use mul as mul effective value.
 */
static inline void pll_config_init(struct pll_config *p_cfg,
		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
{
  4019ac:	b580      	push	{r7, lr}
  4019ae:	b086      	sub	sp, #24
  4019b0:	af00      	add	r7, sp, #0
  4019b2:	60f8      	str	r0, [r7, #12]
  4019b4:	607a      	str	r2, [r7, #4]
  4019b6:	603b      	str	r3, [r7, #0]
  4019b8:	460b      	mov	r3, r1
  4019ba:	72fb      	strb	r3, [r7, #11]
	uint32_t vco_hz;

	Assert(e_src < PLL_NR_SOURCES);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(e_src) / ul_div;
  4019bc:	7afb      	ldrb	r3, [r7, #11]
  4019be:	4618      	mov	r0, r3
  4019c0:	f641 03f5 	movw	r3, #6389	; 0x18f5
  4019c4:	f2c0 0340 	movt	r3, #64	; 0x40
  4019c8:	4798      	blx	r3
  4019ca:	4602      	mov	r2, r0
  4019cc:	687b      	ldr	r3, [r7, #4]
  4019ce:	fbb2 f3f3 	udiv	r3, r2, r3
  4019d2:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_INPUT_MIN_HZ);
	Assert(vco_hz <= PLL_INPUT_MAX_HZ);
	
	vco_hz *= ul_mul;
  4019d4:	697b      	ldr	r3, [r7, #20]
  4019d6:	683a      	ldr	r2, [r7, #0]
  4019d8:	fb02 f303 	mul.w	r3, r2, r3
  4019dc:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_OUTPUT_MIN_HZ);
	Assert(vco_hz <= PLL_OUTPUT_MAX_HZ);

	/* PMC hardware will automatically make it mul+1 */
	p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_DIVA(ul_div) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
  4019de:	683b      	ldr	r3, [r7, #0]
  4019e0:	f103 33ff 	add.w	r3, r3, #4294967295
  4019e4:	ea4f 4203 	mov.w	r2, r3, lsl #16
  4019e8:	f04f 0300 	mov.w	r3, #0
  4019ec:	f2c0 73ff 	movt	r3, #2047	; 0x7ff
  4019f0:	4013      	ands	r3, r2
  4019f2:	687a      	ldr	r2, [r7, #4]
  4019f4:	b2d2      	uxtb	r2, r2
  4019f6:	4313      	orrs	r3, r2
  4019f8:	f443 527c 	orr.w	r2, r3, #16128	; 0x3f00
  4019fc:	68fb      	ldr	r3, [r7, #12]
  4019fe:	601a      	str	r2, [r3, #0]
}
  401a00:	f107 0718 	add.w	r7, r7, #24
  401a04:	46bd      	mov	sp, r7
  401a06:	bd80      	pop	{r7, pc}

00401a08 <pll_enable>:
		PMC->CKGR_PLLBR = p_cfg->ctrl;
	}
}

static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
  401a08:	b580      	push	{r7, lr}
  401a0a:	b082      	sub	sp, #8
  401a0c:	af00      	add	r7, sp, #0
  401a0e:	6078      	str	r0, [r7, #4]
  401a10:	6039      	str	r1, [r7, #0]
	Assert(ul_pll_id < NR_PLLS);
	
	if (ul_pll_id == PLLA_ID) {
  401a12:	683b      	ldr	r3, [r7, #0]
  401a14:	2b00      	cmp	r3, #0
  401a16:	d10e      	bne.n	401a36 <pll_enable+0x2e>
		pmc_disable_pllack(); // Always stop PLL first!
  401a18:	f242 53cd 	movw	r3, #9677	; 0x25cd
  401a1c:	f2c0 0340 	movt	r3, #64	; 0x40
  401a20:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  401a22:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401a26:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401a2a:	687a      	ldr	r2, [r7, #4]
  401a2c:	6812      	ldr	r2, [r2, #0]
  401a2e:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  401a32:	629a      	str	r2, [r3, #40]	; 0x28
  401a34:	e00b      	b.n	401a4e <pll_enable+0x46>
	} else {
		pmc_disable_pllbck();
  401a36:	f242 6301 	movw	r3, #9729	; 0x2601
  401a3a:	f2c0 0340 	movt	r3, #64	; 0x40
  401a3e:	4798      	blx	r3
		PMC->CKGR_PLLBR = p_cfg->ctrl;
  401a40:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401a44:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401a48:	687a      	ldr	r2, [r7, #4]
  401a4a:	6812      	ldr	r2, [r2, #0]
  401a4c:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
  401a4e:	f107 0708 	add.w	r7, r7, #8
  401a52:	46bd      	mov	sp, r7
  401a54:	bd80      	pop	{r7, pc}
  401a56:	bf00      	nop

00401a58 <pll_is_locked>:
	else
		pmc_disable_pllbck();
}

static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
  401a58:	b580      	push	{r7, lr}
  401a5a:	b082      	sub	sp, #8
  401a5c:	af00      	add	r7, sp, #0
  401a5e:	6078      	str	r0, [r7, #4]
	Assert(ul_pll_id < NR_PLLS);
	
	if (ul_pll_id == PLLA_ID)
  401a60:	687b      	ldr	r3, [r7, #4]
  401a62:	2b00      	cmp	r3, #0
  401a64:	d106      	bne.n	401a74 <pll_is_locked+0x1c>
		return pmc_is_locked_pllack();
  401a66:	f242 53e5 	movw	r3, #9701	; 0x25e5
  401a6a:	f2c0 0340 	movt	r3, #64	; 0x40
  401a6e:	4798      	blx	r3
  401a70:	4603      	mov	r3, r0
  401a72:	e005      	b.n	401a80 <pll_is_locked+0x28>
	else
		return pmc_is_locked_pllbck();
  401a74:	f242 6319 	movw	r3, #9753	; 0x2619
  401a78:	f2c0 0340 	movt	r3, #64	; 0x40
  401a7c:	4798      	blx	r3
  401a7e:	4603      	mov	r3, r0
}
  401a80:	4618      	mov	r0, r3
  401a82:	f107 0708 	add.w	r7, r7, #8
  401a86:	46bd      	mov	sp, r7
  401a88:	bd80      	pop	{r7, pc}
  401a8a:	bf00      	nop

00401a8c <pll_enable_source>:

static inline void pll_enable_source(enum pll_source e_src)
{
  401a8c:	b580      	push	{r7, lr}
  401a8e:	b082      	sub	sp, #8
  401a90:	af00      	add	r7, sp, #0
  401a92:	4603      	mov	r3, r0
  401a94:	71fb      	strb	r3, [r7, #7]
	switch (e_src) {
  401a96:	79fb      	ldrb	r3, [r7, #7]
  401a98:	f1a3 0303 	sub.w	r3, r3, #3
  401a9c:	2b04      	cmp	r3, #4
  401a9e:	d80e      	bhi.n	401abe <pll_enable_source+0x32>
	case PLL_SRC_MAINCK_4M_RC:
	case PLL_SRC_MAINCK_8M_RC:
	case PLL_SRC_MAINCK_12M_RC:
	case PLL_SRC_MAINCK_XTAL:
	case PLL_SRC_MAINCK_BYPASS:
		osc_enable(e_src);
  401aa0:	79fb      	ldrb	r3, [r7, #7]
  401aa2:	4618      	mov	r0, r3
  401aa4:	f241 73d1 	movw	r3, #6097	; 0x17d1
  401aa8:	f2c0 0340 	movt	r3, #64	; 0x40
  401aac:	4798      	blx	r3
		osc_wait_ready(e_src);
  401aae:	79fb      	ldrb	r3, [r7, #7]
  401ab0:	4618      	mov	r0, r3
  401ab2:	f641 137d 	movw	r3, #6525	; 0x197d
  401ab6:	f2c0 0340 	movt	r3, #64	; 0x40
  401aba:	4798      	blx	r3
		break;
  401abc:	e000      	b.n	401ac0 <pll_enable_source+0x34>

	default:
		Assert(false);
		break;
  401abe:	bf00      	nop
	}
}
  401ac0:	f107 0708 	add.w	r7, r7, #8
  401ac4:	46bd      	mov	sp, r7
  401ac6:	bd80      	pop	{r7, pc}

00401ac8 <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
  401ac8:	b580      	push	{r7, lr}
  401aca:	b082      	sub	sp, #8
  401acc:	af00      	add	r7, sp, #0
  401ace:	6078      	str	r0, [r7, #4]
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  401ad0:	bf00      	nop
  401ad2:	6878      	ldr	r0, [r7, #4]
  401ad4:	f641 2359 	movw	r3, #6745	; 0x1a59
  401ad8:	f2c0 0340 	movt	r3, #64	; 0x40
  401adc:	4798      	blx	r3
  401ade:	4603      	mov	r3, r0
  401ae0:	2b00      	cmp	r3, #0
  401ae2:	d0f6      	beq.n	401ad2 <pll_wait_for_lock+0xa>
		/* Do nothing */
	}

	return 0;
  401ae4:	f04f 0300 	mov.w	r3, #0
}
  401ae8:	4618      	mov	r0, r3
  401aea:	f107 0708 	add.w	r7, r7, #8
  401aee:	46bd      	mov	sp, r7
  401af0:	bd80      	pop	{r7, pc}
  401af2:	bf00      	nop

00401af4 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
  401af4:	b580      	push	{r7, lr}
  401af6:	af00      	add	r7, sp, #0
    case SYSCLK_SRC_MAINCK_BYPASS:
		return OSC_MAINCK_BYPASS_HZ;

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLLACK:
		return pll_get_default_rate(0);	
  401af8:	f04f 0006 	mov.w	r0, #6
  401afc:	f641 03f5 	movw	r3, #6389	; 0x18f5
  401b00:	f2c0 0340 	movt	r3, #64	; 0x40
  401b04:	4798      	blx	r3
  401b06:	4602      	mov	r2, r0
  401b08:	4613      	mov	r3, r2
  401b0a:	ea4f 0383 	mov.w	r3, r3, lsl #2
  401b0e:	189b      	adds	r3, r3, r2
  401b10:	ea4f 0383 	mov.w	r3, r3, lsl #2
	
	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
  401b14:	4618      	mov	r0, r3
  401b16:	bd80      	pop	{r7, pc}

00401b18 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
  401b18:	b580      	push	{r7, lr}
  401b1a:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediat value. */
	return sysclk_get_main_hz() / ((CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos) + 1);
  401b1c:	f641 23f5 	movw	r3, #6901	; 0x1af5
  401b20:	f2c0 0340 	movt	r3, #64	; 0x40
  401b24:	4798      	blx	r3
  401b26:	4603      	mov	r3, r0
  401b28:	ea4f 0353 	mov.w	r3, r3, lsr #1
}
  401b2c:	4618      	mov	r0, r3
  401b2e:	bd80      	pop	{r7, pc}

00401b30 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  401b30:	b590      	push	{r4, r7, lr}
  401b32:	b083      	sub	sp, #12
  401b34:	af00      	add	r7, sp, #0
	struct pll_config pllcfg;

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  401b36:	f641 3319 	movw	r3, #6937	; 0x1b19
  401b3a:	f2c0 0340 	movt	r3, #64	; 0x40
  401b3e:	4798      	blx	r3
  401b40:	4603      	mov	r3, r0
  401b42:	4618      	mov	r0, r3
  401b44:	f642 236d 	movw	r3, #10861	; 0x2a6d
  401b48:	f2c0 0340 	movt	r3, #64	; 0x40
  401b4c:	4798      	blx	r3
		pmc_switch_mck_to_mainck(CONFIG_SYSCLK_PRES);
		break;

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLLACK:
		pll_enable_source(CONFIG_PLL0_SOURCE);
  401b4e:	f04f 0006 	mov.w	r0, #6
  401b52:	f641 238d 	movw	r3, #6797	; 0x1a8d
  401b56:	f2c0 0340 	movt	r3, #64	; 0x40
  401b5a:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
  401b5c:	f107 0304 	add.w	r3, r7, #4
  401b60:	4618      	mov	r0, r3
  401b62:	f04f 0106 	mov.w	r1, #6
  401b66:	f04f 0201 	mov.w	r2, #1
  401b6a:	f04f 0314 	mov.w	r3, #20
  401b6e:	f641 14ad 	movw	r4, #6573	; 0x19ad
  401b72:	f2c0 0440 	movt	r4, #64	; 0x40
  401b76:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
  401b78:	f107 0304 	add.w	r3, r7, #4
  401b7c:	4618      	mov	r0, r3
  401b7e:	f04f 0100 	mov.w	r1, #0
  401b82:	f641 2309 	movw	r3, #6665	; 0x1a09
  401b86:	f2c0 0340 	movt	r3, #64	; 0x40
  401b8a:	4798      	blx	r3
		pll_wait_for_lock(0);
  401b8c:	f04f 0000 	mov.w	r0, #0
  401b90:	f641 23c9 	movw	r3, #6857	; 0x1ac9
  401b94:	f2c0 0340 	movt	r3, #64	; 0x40
  401b98:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  401b9a:	f04f 0010 	mov.w	r0, #16
  401b9e:	f242 23fd 	movw	r3, #8957	; 0x22fd
  401ba2:	f2c0 0340 	movt	r3, #64	; 0x40
  401ba6:	4798      	blx	r3
		break;	
  401ba8:	bf00      	nop
		break;
#endif	
	}

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  401baa:	f242 73b9 	movw	r3, #10169	; 0x27b9
  401bae:	f2c0 0340 	movt	r3, #64	; 0x40
  401bb2:	4798      	blx	r3
	
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
  401bb4:	f107 070c 	add.w	r7, r7, #12
  401bb8:	46bd      	mov	sp, r7
  401bba:	bd90      	pop	{r4, r7, pc}

00401bbc <board_init>:
#include "board.h"
#include "conf_board.h"
#include "gpio.h"

void board_init(void)
{
  401bbc:	b580      	push	{r7, lr}
  401bbe:	af00      	add	r7, sp, #0
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT 
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
  401bc0:	f241 4350 	movw	r3, #5200	; 0x1450
  401bc4:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401bc8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  401bcc:	605a      	str	r2, [r3, #4]
#endif

	/* Configure LED pins */
	gpio_configure_pin(LED0_GPIO, LED0_FLAGS);
  401bce:	f04f 0013 	mov.w	r0, #19
  401bd2:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  401bd6:	f641 73c1 	movw	r3, #8129	; 0x1fc1
  401bda:	f2c0 0340 	movt	r3, #64	; 0x40
  401bde:	4798      	blx	r3
	gpio_configure_pin(LED1_GPIO, LED1_FLAGS);
  401be0:	f04f 0014 	mov.w	r0, #20
  401be4:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  401be8:	f641 73c1 	movw	r3, #8129	; 0x1fc1
  401bec:	f2c0 0340 	movt	r3, #64	; 0x40
  401bf0:	4798      	blx	r3
	
	/* Configure Push Button pins */
	gpio_configure_pin(GPIO_PUSH_BUTTON_1, GPIO_PUSH_BUTTON_1_FLAGS);
  401bf2:	f04f 0023 	mov.w	r0, #35	; 0x23
  401bf6:	f04f 0179 	mov.w	r1, #121	; 0x79
  401bfa:	f6c2 0100 	movt	r1, #10240	; 0x2800
  401bfe:	f641 73c1 	movw	r3, #8129	; 0x1fc1
  401c02:	f2c0 0340 	movt	r3, #64	; 0x40
  401c06:	4798      	blx	r3
	gpio_configure_pin(GPIO_PUSH_BUTTON_2, GPIO_PUSH_BUTTON_2_FLAGS);
  401c08:	f04f 004c 	mov.w	r0, #76	; 0x4c
  401c0c:	f04f 0159 	mov.w	r1, #89	; 0x59
  401c10:	f6c2 0100 	movt	r1, #10240	; 0x2800
  401c14:	f641 73c1 	movw	r3, #8129	; 0x1fc1
  401c18:	f2c0 0340 	movt	r3, #64	; 0x40
  401c1c:	4798      	blx	r3
	#endif
#endif

#ifdef CONF_BOARD_USART_RXD
	/* Configure USART RXD pin */
	gpio_configure_pin(PIN_USART1_RXD_IDX, PIN_USART1_RXD_FLAGS);
  401c1e:	f04f 0015 	mov.w	r0, #21
  401c22:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  401c26:	f641 73c1 	movw	r3, #8129	; 0x1fc1
  401c2a:	f2c0 0340 	movt	r3, #64	; 0x40
  401c2e:	4798      	blx	r3
#endif

#ifdef CONF_BOARD_USART_TXD
	/* Configure USART TXD pin */
	gpio_configure_pin(PIN_USART1_TXD_IDX, PIN_USART1_TXD_FLAGS);
  401c30:	f04f 0016 	mov.w	r0, #22
  401c34:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  401c38:	f641 73c1 	movw	r3, #8129	; 0x1fc1
  401c3c:	f2c0 0340 	movt	r3, #64	; 0x40
  401c40:	4798      	blx	r3
	gpio_configure_pin(PIN_USART1_SCK_IDX, PIN_USART1_SCK_FLAGS);
#endif

#ifdef CONF_BOARD_ADM3312_EN
	/* Configure ADM33312 enable pin */
	gpio_configure_pin(PIN_USART1_EN_IDX, PIN_USART1_EN_FLAGS);
  401c42:	f04f 0017 	mov.w	r0, #23
  401c46:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  401c4a:	f641 73c1 	movw	r3, #8129	; 0x1fc1
  401c4e:	f2c0 0340 	movt	r3, #64	; 0x40
  401c52:	4798      	blx	r3
	gpio_set_pin_low(PIN_USART1_EN_IDX);
  401c54:	f04f 0017 	mov.w	r0, #23
  401c58:	f641 731d 	movw	r3, #7965	; 0x1f1d
  401c5c:	f2c0 0340 	movt	r3, #64	; 0x40
  401c60:	4798      	blx	r3
	gpio_configure_pin(SPI_MOSI_GPIO, SPI_MOSI_FLAGS);
	gpio_configure_pin(SPI_SPCK_GPIO, SPI_SPCK_FLAGS);
	gpio_configure_pin(SPI_NPCS0_GPIO, SPI_NPCS0_FLAGS);
	gpio_configure_pin(PIN_TSC_BUSY_IDX, PIN_TSC_BUSY_FLAG);
#endif
}
  401c62:	bd80      	pop	{r7, pc}

00401c64 <pio_pull_up>:
 * \param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be
 * configured.
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
  401c64:	b480      	push	{r7}
  401c66:	b085      	sub	sp, #20
  401c68:	af00      	add	r7, sp, #0
  401c6a:	60f8      	str	r0, [r7, #12]
  401c6c:	60b9      	str	r1, [r7, #8]
  401c6e:	607a      	str	r2, [r7, #4]
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  401c70:	687b      	ldr	r3, [r7, #4]
  401c72:	2b00      	cmp	r3, #0
  401c74:	d003      	beq.n	401c7e <pio_pull_up+0x1a>
		p_pio->PIO_PUER = ul_mask;
  401c76:	68fb      	ldr	r3, [r7, #12]
  401c78:	68ba      	ldr	r2, [r7, #8]
  401c7a:	665a      	str	r2, [r3, #100]	; 0x64
  401c7c:	e002      	b.n	401c84 <pio_pull_up+0x20>
	} else {
		p_pio->PIO_PUDR = ul_mask;
  401c7e:	68fb      	ldr	r3, [r7, #12]
  401c80:	68ba      	ldr	r2, [r7, #8]
  401c82:	661a      	str	r2, [r3, #96]	; 0x60
	}
}
  401c84:	f107 0714 	add.w	r7, r7, #20
  401c88:	46bd      	mov	sp, r7
  401c8a:	bc80      	pop	{r7}
  401c8c:	4770      	bx	lr
  401c8e:	bf00      	nop

00401c90 <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  401c90:	b480      	push	{r7}
  401c92:	b087      	sub	sp, #28
  401c94:	af00      	add	r7, sp, #0
  401c96:	60f8      	str	r0, [r7, #12]
  401c98:	60b9      	str	r1, [r7, #8]
  401c9a:	607a      	str	r2, [r7, #4]
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  401c9c:	68fb      	ldr	r3, [r7, #12]
  401c9e:	687a      	ldr	r2, [r7, #4]
  401ca0:	645a      	str	r2, [r3, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S)
	switch (ul_type) {
  401ca2:	68bb      	ldr	r3, [r7, #8]
  401ca4:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  401ca8:	d04d      	beq.n	401d46 <pio_set_peripheral+0xb6>
  401caa:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  401cae:	d808      	bhi.n	401cc2 <pio_set_peripheral+0x32>
  401cb0:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  401cb4:	d016      	beq.n	401ce4 <pio_set_peripheral+0x54>
  401cb6:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  401cba:	d02e      	beq.n	401d1a <pio_set_peripheral+0x8a>
  401cbc:	2b00      	cmp	r3, #0
  401cbe:	d06d      	beq.n	401d9c <pio_set_peripheral+0x10c>
  401cc0:	e068      	b.n	401d94 <pio_set_peripheral+0x104>
  401cc2:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  401cc6:	d069      	beq.n	401d9c <pio_set_peripheral+0x10c>
  401cc8:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  401ccc:	d803      	bhi.n	401cd6 <pio_set_peripheral+0x46>
  401cce:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  401cd2:	d04e      	beq.n	401d72 <pio_set_peripheral+0xe2>
  401cd4:	e05e      	b.n	401d94 <pio_set_peripheral+0x104>
  401cd6:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  401cda:	d05f      	beq.n	401d9c <pio_set_peripheral+0x10c>
  401cdc:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  401ce0:	d05c      	beq.n	401d9c <pio_set_peripheral+0x10c>
  401ce2:	e057      	b.n	401d94 <pio_set_peripheral+0x104>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401ce4:	68fb      	ldr	r3, [r7, #12]
  401ce6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  401ce8:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  401cea:	68fb      	ldr	r3, [r7, #12]
  401cec:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  401cee:	687b      	ldr	r3, [r7, #4]
  401cf0:	ea6f 0103 	mvn.w	r1, r3
  401cf4:	697b      	ldr	r3, [r7, #20]
  401cf6:	400b      	ands	r3, r1
  401cf8:	401a      	ands	r2, r3
  401cfa:	68fb      	ldr	r3, [r7, #12]
  401cfc:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401cfe:	68fb      	ldr	r3, [r7, #12]
  401d00:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  401d02:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  401d04:	68fb      	ldr	r3, [r7, #12]
  401d06:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  401d08:	687b      	ldr	r3, [r7, #4]
  401d0a:	ea6f 0103 	mvn.w	r1, r3
  401d0e:	697b      	ldr	r3, [r7, #20]
  401d10:	400b      	ands	r3, r1
  401d12:	401a      	ands	r2, r3
  401d14:	68fb      	ldr	r3, [r7, #12]
  401d16:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  401d18:	e03c      	b.n	401d94 <pio_set_peripheral+0x104>

	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401d1a:	68fb      	ldr	r3, [r7, #12]
  401d1c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  401d1e:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  401d20:	687a      	ldr	r2, [r7, #4]
  401d22:	697b      	ldr	r3, [r7, #20]
  401d24:	431a      	orrs	r2, r3
  401d26:	68fb      	ldr	r3, [r7, #12]
  401d28:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401d2a:	68fb      	ldr	r3, [r7, #12]
  401d2c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  401d2e:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  401d30:	68fb      	ldr	r3, [r7, #12]
  401d32:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  401d34:	687b      	ldr	r3, [r7, #4]
  401d36:	ea6f 0103 	mvn.w	r1, r3
  401d3a:	697b      	ldr	r3, [r7, #20]
  401d3c:	400b      	ands	r3, r1
  401d3e:	401a      	ands	r2, r3
  401d40:	68fb      	ldr	r3, [r7, #12]
  401d42:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  401d44:	e026      	b.n	401d94 <pio_set_peripheral+0x104>

	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401d46:	68fb      	ldr	r3, [r7, #12]
  401d48:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  401d4a:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  401d4c:	68fb      	ldr	r3, [r7, #12]
  401d4e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  401d50:	687b      	ldr	r3, [r7, #4]
  401d52:	ea6f 0103 	mvn.w	r1, r3
  401d56:	697b      	ldr	r3, [r7, #20]
  401d58:	400b      	ands	r3, r1
  401d5a:	401a      	ands	r2, r3
  401d5c:	68fb      	ldr	r3, [r7, #12]
  401d5e:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401d60:	68fb      	ldr	r3, [r7, #12]
  401d62:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  401d64:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  401d66:	687a      	ldr	r2, [r7, #4]
  401d68:	697b      	ldr	r3, [r7, #20]
  401d6a:	431a      	orrs	r2, r3
  401d6c:	68fb      	ldr	r3, [r7, #12]
  401d6e:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  401d70:	e010      	b.n	401d94 <pio_set_peripheral+0x104>

	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401d72:	68fb      	ldr	r3, [r7, #12]
  401d74:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  401d76:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  401d78:	687a      	ldr	r2, [r7, #4]
  401d7a:	697b      	ldr	r3, [r7, #20]
  401d7c:	431a      	orrs	r2, r3
  401d7e:	68fb      	ldr	r3, [r7, #12]
  401d80:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401d82:	68fb      	ldr	r3, [r7, #12]
  401d84:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  401d86:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  401d88:	687a      	ldr	r2, [r7, #4]
  401d8a:	697b      	ldr	r3, [r7, #20]
  401d8c:	431a      	orrs	r2, r3
  401d8e:	68fb      	ldr	r3, [r7, #12]
  401d90:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  401d92:	bf00      	nop
#else
#error "Unsupported device"
#endif

	// Remove the pins from under the control of PIO
	p_pio->PIO_PDR = ul_mask;
  401d94:	68fb      	ldr	r3, [r7, #12]
  401d96:	687a      	ldr	r2, [r7, #4]
  401d98:	605a      	str	r2, [r3, #4]
  401d9a:	e000      	b.n	401d9e <pio_set_peripheral+0x10e>
		// other types are invalid in this function
	case PIO_INPUT:
	case PIO_OUTPUT_0:
	case PIO_OUTPUT_1:
	case PIO_NOT_A_PIN:
		return;
  401d9c:	bf00      	nop
#error "Unsupported device"
#endif

	// Remove the pins from under the control of PIO
	p_pio->PIO_PDR = ul_mask;
}
  401d9e:	f107 071c 	add.w	r7, r7, #28
  401da2:	46bd      	mov	sp, r7
  401da4:	bc80      	pop	{r7}
  401da6:	4770      	bx	lr

00401da8 <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
  401da8:	b580      	push	{r7, lr}
  401daa:	b084      	sub	sp, #16
  401dac:	af00      	add	r7, sp, #0
  401dae:	60f8      	str	r0, [r7, #12]
  401db0:	60b9      	str	r1, [r7, #8]
  401db2:	607a      	str	r2, [r7, #4]
	pio_disable_interrupt(p_pio, ul_mask);
  401db4:	68f8      	ldr	r0, [r7, #12]
  401db6:	68b9      	ldr	r1, [r7, #8]
  401db8:	f641 6395 	movw	r3, #7829	; 0x1e95
  401dbc:	f2c0 0340 	movt	r3, #64	; 0x40
  401dc0:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);
  401dc2:	687b      	ldr	r3, [r7, #4]
  401dc4:	f003 0301 	and.w	r3, r3, #1
  401dc8:	68f8      	ldr	r0, [r7, #12]
  401dca:	68b9      	ldr	r1, [r7, #8]
  401dcc:	461a      	mov	r2, r3
  401dce:	f641 4365 	movw	r3, #7269	; 0x1c65
  401dd2:	f2c0 0340 	movt	r3, #64	; 0x40
  401dd6:	4798      	blx	r3

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  401dd8:	687b      	ldr	r3, [r7, #4]
  401dda:	f003 030a 	and.w	r3, r3, #10
  401dde:	2b00      	cmp	r3, #0
  401de0:	d003      	beq.n	401dea <pio_set_input+0x42>
		p_pio->PIO_IFER = ul_mask;
  401de2:	68fb      	ldr	r3, [r7, #12]
  401de4:	68ba      	ldr	r2, [r7, #8]
  401de6:	621a      	str	r2, [r3, #32]
  401de8:	e002      	b.n	401df0 <pio_set_input+0x48>
	} else {
		p_pio->PIO_IFDR = ul_mask;
  401dea:	68fb      	ldr	r3, [r7, #12]
  401dec:	68ba      	ldr	r2, [r7, #8]
  401dee:	625a      	str	r2, [r3, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  401df0:	687b      	ldr	r3, [r7, #4]
  401df2:	f003 0302 	and.w	r3, r3, #2
  401df6:	2b00      	cmp	r3, #0
  401df8:	d004      	beq.n	401e04 <pio_set_input+0x5c>
		p_pio->PIO_IFSCDR = ul_mask;
  401dfa:	68fb      	ldr	r3, [r7, #12]
  401dfc:	68ba      	ldr	r2, [r7, #8]
  401dfe:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  401e02:	e008      	b.n	401e16 <pio_set_input+0x6e>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  401e04:	687b      	ldr	r3, [r7, #4]
  401e06:	f003 0308 	and.w	r3, r3, #8
  401e0a:	2b00      	cmp	r3, #0
  401e0c:	d003      	beq.n	401e16 <pio_set_input+0x6e>
			p_pio->PIO_IFSCER = ul_mask;
  401e0e:	68fb      	ldr	r3, [r7, #12]
  401e10:	68ba      	ldr	r2, [r7, #8]
  401e12:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  401e16:	68fb      	ldr	r3, [r7, #12]
  401e18:	68ba      	ldr	r2, [r7, #8]
  401e1a:	615a      	str	r2, [r3, #20]
	p_pio->PIO_PER = ul_mask;
  401e1c:	68fb      	ldr	r3, [r7, #12]
  401e1e:	68ba      	ldr	r2, [r7, #8]
  401e20:	601a      	str	r2, [r3, #0]
}
  401e22:	f107 0710 	add.w	r7, r7, #16
  401e26:	46bd      	mov	sp, r7
  401e28:	bd80      	pop	{r7, pc}
  401e2a:	bf00      	nop

00401e2c <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
  401e2c:	b580      	push	{r7, lr}
  401e2e:	b084      	sub	sp, #16
  401e30:	af00      	add	r7, sp, #0
  401e32:	60f8      	str	r0, [r7, #12]
  401e34:	60b9      	str	r1, [r7, #8]
  401e36:	607a      	str	r2, [r7, #4]
  401e38:	603b      	str	r3, [r7, #0]
	pio_disable_interrupt(p_pio, ul_mask);
  401e3a:	68f8      	ldr	r0, [r7, #12]
  401e3c:	68b9      	ldr	r1, [r7, #8]
  401e3e:	f641 6395 	movw	r3, #7829	; 0x1e95
  401e42:	f2c0 0340 	movt	r3, #64	; 0x40
  401e46:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);
  401e48:	68f8      	ldr	r0, [r7, #12]
  401e4a:	68b9      	ldr	r1, [r7, #8]
  401e4c:	69ba      	ldr	r2, [r7, #24]
  401e4e:	f641 4365 	movw	r3, #7269	; 0x1c65
  401e52:	f2c0 0340 	movt	r3, #64	; 0x40
  401e56:	4798      	blx	r3

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  401e58:	683b      	ldr	r3, [r7, #0]
  401e5a:	2b00      	cmp	r3, #0
  401e5c:	d003      	beq.n	401e66 <pio_set_output+0x3a>
		p_pio->PIO_MDER = ul_mask;
  401e5e:	68fb      	ldr	r3, [r7, #12]
  401e60:	68ba      	ldr	r2, [r7, #8]
  401e62:	651a      	str	r2, [r3, #80]	; 0x50
  401e64:	e002      	b.n	401e6c <pio_set_output+0x40>
	} else {
		p_pio->PIO_MDDR = ul_mask;
  401e66:	68fb      	ldr	r3, [r7, #12]
  401e68:	68ba      	ldr	r2, [r7, #8]
  401e6a:	655a      	str	r2, [r3, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
  401e6c:	687b      	ldr	r3, [r7, #4]
  401e6e:	2b00      	cmp	r3, #0
  401e70:	d003      	beq.n	401e7a <pio_set_output+0x4e>
		p_pio->PIO_SODR = ul_mask;
  401e72:	68fb      	ldr	r3, [r7, #12]
  401e74:	68ba      	ldr	r2, [r7, #8]
  401e76:	631a      	str	r2, [r3, #48]	; 0x30
  401e78:	e002      	b.n	401e80 <pio_set_output+0x54>
	} else {
		p_pio->PIO_CODR = ul_mask;
  401e7a:	68fb      	ldr	r3, [r7, #12]
  401e7c:	68ba      	ldr	r2, [r7, #8]
  401e7e:	635a      	str	r2, [r3, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  401e80:	68fb      	ldr	r3, [r7, #12]
  401e82:	68ba      	ldr	r2, [r7, #8]
  401e84:	611a      	str	r2, [r3, #16]
	p_pio->PIO_PER = ul_mask;
  401e86:	68fb      	ldr	r3, [r7, #12]
  401e88:	68ba      	ldr	r2, [r7, #8]
  401e8a:	601a      	str	r2, [r3, #0]
}
  401e8c:	f107 0710 	add.w	r7, r7, #16
  401e90:	46bd      	mov	sp, r7
  401e92:	bd80      	pop	{r7, pc}

00401e94 <pio_disable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  401e94:	b480      	push	{r7}
  401e96:	b083      	sub	sp, #12
  401e98:	af00      	add	r7, sp, #0
  401e9a:	6078      	str	r0, [r7, #4]
  401e9c:	6039      	str	r1, [r7, #0]
	p_pio->PIO_IDR = ul_mask;
  401e9e:	687b      	ldr	r3, [r7, #4]
  401ea0:	683a      	ldr	r2, [r7, #0]
  401ea2:	645a      	str	r2, [r3, #68]	; 0x44
}
  401ea4:	f107 070c 	add.w	r7, r7, #12
  401ea8:	46bd      	mov	sp, r7
  401eaa:	bc80      	pop	{r7}
  401eac:	4770      	bx	lr
  401eae:	bf00      	nop

00401eb0 <pio_get_interrupt_status>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
  401eb0:	b480      	push	{r7}
  401eb2:	b083      	sub	sp, #12
  401eb4:	af00      	add	r7, sp, #0
  401eb6:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_ISR;
  401eb8:	687b      	ldr	r3, [r7, #4]
  401eba:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
  401ebc:	4618      	mov	r0, r3
  401ebe:	f107 070c 	add.w	r7, r7, #12
  401ec2:	46bd      	mov	sp, r7
  401ec4:	bc80      	pop	{r7}
  401ec6:	4770      	bx	lr

00401ec8 <pio_get_interrupt_mask>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
  401ec8:	b480      	push	{r7}
  401eca:	b083      	sub	sp, #12
  401ecc:	af00      	add	r7, sp, #0
  401ece:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_IMR;
  401ed0:	687b      	ldr	r3, [r7, #4]
  401ed2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
  401ed4:	4618      	mov	r0, r3
  401ed6:	f107 070c 	add.w	r7, r7, #12
  401eda:	46bd      	mov	sp, r7
  401edc:	bc80      	pop	{r7}
  401ede:	4770      	bx	lr

00401ee0 <pio_set_pin_high>:
 * \param ul_pin The pin index.
 *
 * \note The function \ref pio_configure_pin must be called beforehand.
 */
void pio_set_pin_high(uint32_t ul_pin)
{
  401ee0:	b480      	push	{r7}
  401ee2:	b085      	sub	sp, #20
  401ee4:	af00      	add	r7, sp, #0
  401ee6:	6078      	str	r0, [r7, #4]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  401ee8:	687b      	ldr	r3, [r7, #4]
  401eea:	ea4f 1353 	mov.w	r3, r3, lsr #5
  401eee:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401ef2:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401ef6:	ea4f 2343 	mov.w	r3, r3, lsl #9
  401efa:	60fb      	str	r3, [r7, #12]
	// Value to be driven on the I/O line: 1.
	p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  401efc:	687b      	ldr	r3, [r7, #4]
  401efe:	f003 031f 	and.w	r3, r3, #31
  401f02:	f04f 0201 	mov.w	r2, #1
  401f06:	fa02 f303 	lsl.w	r3, r2, r3
  401f0a:	461a      	mov	r2, r3
  401f0c:	68fb      	ldr	r3, [r7, #12]
  401f0e:	631a      	str	r2, [r3, #48]	; 0x30
}
  401f10:	f107 0714 	add.w	r7, r7, #20
  401f14:	46bd      	mov	sp, r7
  401f16:	bc80      	pop	{r7}
  401f18:	4770      	bx	lr
  401f1a:	bf00      	nop

00401f1c <pio_set_pin_low>:
 * \param ul_pin The pin index.
 *
 * \note The function \ref pio_configure_pin must be called before.
 */
void pio_set_pin_low(uint32_t ul_pin)
{
  401f1c:	b480      	push	{r7}
  401f1e:	b085      	sub	sp, #20
  401f20:	af00      	add	r7, sp, #0
  401f22:	6078      	str	r0, [r7, #4]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  401f24:	687b      	ldr	r3, [r7, #4]
  401f26:	ea4f 1353 	mov.w	r3, r3, lsr #5
  401f2a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401f2e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401f32:	ea4f 2343 	mov.w	r3, r3, lsl #9
  401f36:	60fb      	str	r3, [r7, #12]
	// Value to be driven on the I/O line: 0.
	p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  401f38:	687b      	ldr	r3, [r7, #4]
  401f3a:	f003 031f 	and.w	r3, r3, #31
  401f3e:	f04f 0201 	mov.w	r2, #1
  401f42:	fa02 f303 	lsl.w	r3, r2, r3
  401f46:	461a      	mov	r2, r3
  401f48:	68fb      	ldr	r3, [r7, #12]
  401f4a:	635a      	str	r2, [r3, #52]	; 0x34
}
  401f4c:	f107 0714 	add.w	r7, r7, #20
  401f50:	46bd      	mov	sp, r7
  401f52:	bc80      	pop	{r7}
  401f54:	4770      	bx	lr
  401f56:	bf00      	nop

00401f58 <pio_toggle_pin>:
 * \param ul_pin The pin index.
 *
 * \note The function \ref pio_configure_pin must be called before.
 */
void pio_toggle_pin(uint32_t ul_pin)
{
  401f58:	b480      	push	{r7}
  401f5a:	b085      	sub	sp, #20
  401f5c:	af00      	add	r7, sp, #0
  401f5e:	6078      	str	r0, [r7, #4]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  401f60:	687b      	ldr	r3, [r7, #4]
  401f62:	ea4f 1353 	mov.w	r3, r3, lsr #5
  401f66:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401f6a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401f6e:	ea4f 2343 	mov.w	r3, r3, lsl #9
  401f72:	60fb      	str	r3, [r7, #12]
	if (p_pio->PIO_ODSR & (1 << (ul_pin & 0x1F))) {
  401f74:	68fb      	ldr	r3, [r7, #12]
  401f76:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  401f78:	687b      	ldr	r3, [r7, #4]
  401f7a:	f003 031f 	and.w	r3, r3, #31
  401f7e:	f04f 0101 	mov.w	r1, #1
  401f82:	fa01 f303 	lsl.w	r3, r1, r3
  401f86:	4013      	ands	r3, r2
  401f88:	2b00      	cmp	r3, #0
  401f8a:	d00a      	beq.n	401fa2 <pio_toggle_pin+0x4a>
		// Value to be driven on the I/O line: 0.
		p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  401f8c:	687b      	ldr	r3, [r7, #4]
  401f8e:	f003 031f 	and.w	r3, r3, #31
  401f92:	f04f 0201 	mov.w	r2, #1
  401f96:	fa02 f303 	lsl.w	r3, r2, r3
  401f9a:	461a      	mov	r2, r3
  401f9c:	68fb      	ldr	r3, [r7, #12]
  401f9e:	635a      	str	r2, [r3, #52]	; 0x34
  401fa0:	e009      	b.n	401fb6 <pio_toggle_pin+0x5e>
	} else {
		// Value to be driven on the I/O line: 1.
		p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  401fa2:	687b      	ldr	r3, [r7, #4]
  401fa4:	f003 031f 	and.w	r3, r3, #31
  401fa8:	f04f 0201 	mov.w	r2, #1
  401fac:	fa02 f303 	lsl.w	r3, r2, r3
  401fb0:	461a      	mov	r2, r3
  401fb2:	68fb      	ldr	r3, [r7, #12]
  401fb4:	631a      	str	r2, [r3, #48]	; 0x30
	}
}
  401fb6:	f107 0714 	add.w	r7, r7, #20
  401fba:	46bd      	mov	sp, r7
  401fbc:	bc80      	pop	{r7}
  401fbe:	4770      	bx	lr

00401fc0 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  401fc0:	b590      	push	{r4, r7, lr}
  401fc2:	b087      	sub	sp, #28
  401fc4:	af02      	add	r7, sp, #8
  401fc6:	6078      	str	r0, [r7, #4]
  401fc8:	6039      	str	r1, [r7, #0]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  401fca:	687b      	ldr	r3, [r7, #4]
  401fcc:	ea4f 1353 	mov.w	r3, r3, lsr #5
  401fd0:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401fd4:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401fd8:	ea4f 2343 	mov.w	r3, r3, lsl #9
  401fdc:	60fb      	str	r3, [r7, #12]

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  401fde:	683b      	ldr	r3, [r7, #0]
  401fe0:	f003 43f0 	and.w	r3, r3, #2013265920	; 0x78000000
  401fe4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  401fe8:	f000 8086 	beq.w	4020f8 <pio_configure_pin+0x138>
  401fec:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  401ff0:	d809      	bhi.n	402006 <pio_configure_pin+0x46>
  401ff2:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  401ff6:	d037      	beq.n	402068 <pio_configure_pin+0xa8>
  401ff8:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  401ffc:	d058      	beq.n	4020b0 <pio_configure_pin+0xf0>
  401ffe:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  402002:	d00d      	beq.n	402020 <pio_configure_pin+0x60>
  402004:	e0cf      	b.n	4021a6 <pio_configure_pin+0x1e6>
  402006:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  40200a:	f000 80a9 	beq.w	402160 <pio_configure_pin+0x1a0>
  40200e:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  402012:	f000 80a5 	beq.w	402160 <pio_configure_pin+0x1a0>
  402016:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  40201a:	f000 8091 	beq.w	402140 <pio_configure_pin+0x180>
  40201e:	e0c2      	b.n	4021a6 <pio_configure_pin+0x1e6>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
  402020:	687b      	ldr	r3, [r7, #4]
  402022:	f003 031f 	and.w	r3, r3, #31
  402026:	f04f 0201 	mov.w	r2, #1
  40202a:	fa02 f303 	lsl.w	r3, r2, r3
  40202e:	68f8      	ldr	r0, [r7, #12]
  402030:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  402034:	461a      	mov	r2, r3
  402036:	f641 4391 	movw	r3, #7313	; 0x1c91
  40203a:	f2c0 0340 	movt	r3, #64	; 0x40
  40203e:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  402040:	687b      	ldr	r3, [r7, #4]
  402042:	f003 031f 	and.w	r3, r3, #31
  402046:	f04f 0201 	mov.w	r2, #1
  40204a:	fa02 f303 	lsl.w	r3, r2, r3
  40204e:	461a      	mov	r2, r3
  402050:	683b      	ldr	r3, [r7, #0]
  402052:	f003 0301 	and.w	r3, r3, #1
  402056:	68f8      	ldr	r0, [r7, #12]
  402058:	4611      	mov	r1, r2
  40205a:	461a      	mov	r2, r3
  40205c:	f641 4365 	movw	r3, #7269	; 0x1c65
  402060:	f2c0 0340 	movt	r3, #64	; 0x40
  402064:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
  402066:	e0a1      	b.n	4021ac <pio_configure_pin+0x1ec>
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
  402068:	687b      	ldr	r3, [r7, #4]
  40206a:	f003 031f 	and.w	r3, r3, #31
  40206e:	f04f 0201 	mov.w	r2, #1
  402072:	fa02 f303 	lsl.w	r3, r2, r3
  402076:	68f8      	ldr	r0, [r7, #12]
  402078:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  40207c:	461a      	mov	r2, r3
  40207e:	f641 4391 	movw	r3, #7313	; 0x1c91
  402082:	f2c0 0340 	movt	r3, #64	; 0x40
  402086:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  402088:	687b      	ldr	r3, [r7, #4]
  40208a:	f003 031f 	and.w	r3, r3, #31
  40208e:	f04f 0201 	mov.w	r2, #1
  402092:	fa02 f303 	lsl.w	r3, r2, r3
  402096:	461a      	mov	r2, r3
  402098:	683b      	ldr	r3, [r7, #0]
  40209a:	f003 0301 	and.w	r3, r3, #1
  40209e:	68f8      	ldr	r0, [r7, #12]
  4020a0:	4611      	mov	r1, r2
  4020a2:	461a      	mov	r2, r3
  4020a4:	f641 4365 	movw	r3, #7269	; 0x1c65
  4020a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4020ac:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
  4020ae:	e07d      	b.n	4021ac <pio_configure_pin+0x1ec>
#     if (SAM3S || SAM3N || SAM4S)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
  4020b0:	687b      	ldr	r3, [r7, #4]
  4020b2:	f003 031f 	and.w	r3, r3, #31
  4020b6:	f04f 0201 	mov.w	r2, #1
  4020ba:	fa02 f303 	lsl.w	r3, r2, r3
  4020be:	68f8      	ldr	r0, [r7, #12]
  4020c0:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  4020c4:	461a      	mov	r2, r3
  4020c6:	f641 4391 	movw	r3, #7313	; 0x1c91
  4020ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4020ce:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  4020d0:	687b      	ldr	r3, [r7, #4]
  4020d2:	f003 031f 	and.w	r3, r3, #31
  4020d6:	f04f 0201 	mov.w	r2, #1
  4020da:	fa02 f303 	lsl.w	r3, r2, r3
  4020de:	461a      	mov	r2, r3
  4020e0:	683b      	ldr	r3, [r7, #0]
  4020e2:	f003 0301 	and.w	r3, r3, #1
  4020e6:	68f8      	ldr	r0, [r7, #12]
  4020e8:	4611      	mov	r1, r2
  4020ea:	461a      	mov	r2, r3
  4020ec:	f641 4365 	movw	r3, #7269	; 0x1c65
  4020f0:	f2c0 0340 	movt	r3, #64	; 0x40
  4020f4:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
  4020f6:	e059      	b.n	4021ac <pio_configure_pin+0x1ec>
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  4020f8:	687b      	ldr	r3, [r7, #4]
  4020fa:	f003 031f 	and.w	r3, r3, #31
  4020fe:	f04f 0201 	mov.w	r2, #1
  402102:	fa02 f303 	lsl.w	r3, r2, r3
  402106:	68f8      	ldr	r0, [r7, #12]
  402108:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  40210c:	461a      	mov	r2, r3
  40210e:	f641 4391 	movw	r3, #7313	; 0x1c91
  402112:	f2c0 0340 	movt	r3, #64	; 0x40
  402116:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  402118:	687b      	ldr	r3, [r7, #4]
  40211a:	f003 031f 	and.w	r3, r3, #31
  40211e:	f04f 0201 	mov.w	r2, #1
  402122:	fa02 f303 	lsl.w	r3, r2, r3
  402126:	461a      	mov	r2, r3
  402128:	683b      	ldr	r3, [r7, #0]
  40212a:	f003 0301 	and.w	r3, r3, #1
  40212e:	68f8      	ldr	r0, [r7, #12]
  402130:	4611      	mov	r1, r2
  402132:	461a      	mov	r2, r3
  402134:	f641 4365 	movw	r3, #7269	; 0x1c65
  402138:	f2c0 0340 	movt	r3, #64	; 0x40
  40213c:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
  40213e:	e035      	b.n	4021ac <pio_configure_pin+0x1ec>
#     endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  402140:	687b      	ldr	r3, [r7, #4]
  402142:	f003 031f 	and.w	r3, r3, #31
  402146:	f04f 0201 	mov.w	r2, #1
  40214a:	fa02 f303 	lsl.w	r3, r2, r3
  40214e:	68f8      	ldr	r0, [r7, #12]
  402150:	4619      	mov	r1, r3
  402152:	683a      	ldr	r2, [r7, #0]
  402154:	f641 53a9 	movw	r3, #7593	; 0x1da9
  402158:	f2c0 0340 	movt	r3, #64	; 0x40
  40215c:	4798      	blx	r3
		break;
  40215e:	e025      	b.n	4021ac <pio_configure_pin+0x1ec>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  402160:	687b      	ldr	r3, [r7, #4]
  402162:	f003 031f 	and.w	r3, r3, #31
  402166:	f04f 0201 	mov.w	r2, #1
  40216a:	fa02 f303 	lsl.w	r3, r2, r3
  40216e:	4619      	mov	r1, r3
  402170:	683b      	ldr	r3, [r7, #0]
  402172:	f003 5260 	and.w	r2, r3, #939524096	; 0x38000000
				(ul_flags & PIO_TYPE_PIO_OUTPUT_1),
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  402176:	683b      	ldr	r3, [r7, #0]
  402178:	f003 0304 	and.w	r3, r3, #4
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  40217c:	2b00      	cmp	r3, #0
  40217e:	bf0c      	ite	eq
  402180:	2300      	moveq	r3, #0
  402182:	2301      	movne	r3, #1
  402184:	b2db      	uxtb	r3, r3
				(ul_flags & PIO_TYPE_PIO_OUTPUT_1),
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
  402186:	6838      	ldr	r0, [r7, #0]
  402188:	f000 0001 	and.w	r0, r0, #1
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  40218c:	2800      	cmp	r0, #0
  40218e:	bf0c      	ite	eq
  402190:	2000      	moveq	r0, #0
  402192:	2001      	movne	r0, #1
  402194:	b2c0      	uxtb	r0, r0
  402196:	9000      	str	r0, [sp, #0]
  402198:	68f8      	ldr	r0, [r7, #12]
  40219a:	f641 642d 	movw	r4, #7725	; 0x1e2d
  40219e:	f2c0 0440 	movt	r4, #64	; 0x40
  4021a2:	47a0      	blx	r4
				(ul_flags & PIO_TYPE_PIO_OUTPUT_1),
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
  4021a4:	e002      	b.n	4021ac <pio_configure_pin+0x1ec>

	default:
		return 0;
  4021a6:	f04f 0300 	mov.w	r3, #0
  4021aa:	e001      	b.n	4021b0 <pio_configure_pin+0x1f0>
	}

	return 1;
  4021ac:	f04f 0301 	mov.w	r3, #1
}
  4021b0:	4618      	mov	r0, r3
  4021b2:	f107 0714 	add.w	r7, r7, #20
  4021b6:	46bd      	mov	sp, r7
  4021b8:	bd90      	pop	{r4, r7, pc}
  4021ba:	bf00      	nop

004021bc <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  4021bc:	b580      	push	{r7, lr}
  4021be:	b084      	sub	sp, #16
  4021c0:	af00      	add	r7, sp, #0
  4021c2:	6078      	str	r0, [r7, #4]
  4021c4:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  4021c6:	6878      	ldr	r0, [r7, #4]
  4021c8:	f641 63b1 	movw	r3, #7857	; 0x1eb1
  4021cc:	f2c0 0340 	movt	r3, #64	; 0x40
  4021d0:	4798      	blx	r3
  4021d2:	60f8      	str	r0, [r7, #12]
	status &= pio_get_interrupt_mask(p_pio);
  4021d4:	6878      	ldr	r0, [r7, #4]
  4021d6:	f641 63c9 	movw	r3, #7881	; 0x1ec9
  4021da:	f2c0 0340 	movt	r3, #64	; 0x40
  4021de:	4798      	blx	r3
  4021e0:	4603      	mov	r3, r0
  4021e2:	68fa      	ldr	r2, [r7, #12]
  4021e4:	4013      	ands	r3, r2
  4021e6:	60fb      	str	r3, [r7, #12]

	/* Check pending events */
	if (status != 0) {
  4021e8:	68fb      	ldr	r3, [r7, #12]
  4021ea:	2b00      	cmp	r3, #0
  4021ec:	d057      	beq.n	40229e <pio_handler_process+0xe2>
		/* Find triggering source */
		i = 0;
  4021ee:	f04f 0300 	mov.w	r3, #0
  4021f2:	60bb      	str	r3, [r7, #8]
		while (status != 0) {
  4021f4:	e050      	b.n	402298 <pio_handler_process+0xdc>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  4021f6:	f24a 43d8 	movw	r3, #42200	; 0xa4d8
  4021fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4021fe:	68ba      	ldr	r2, [r7, #8]
  402200:	ea4f 1202 	mov.w	r2, r2, lsl #4
  402204:	189b      	adds	r3, r3, r2
  402206:	681a      	ldr	r2, [r3, #0]
  402208:	683b      	ldr	r3, [r7, #0]
  40220a:	429a      	cmp	r2, r3
  40220c:	d140      	bne.n	402290 <pio_handler_process+0xd4>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  40220e:	f24a 43d8 	movw	r3, #42200	; 0xa4d8
  402212:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402216:	68ba      	ldr	r2, [r7, #8]
  402218:	ea4f 1202 	mov.w	r2, r2, lsl #4
  40221c:	189b      	adds	r3, r3, r2
  40221e:	f103 0304 	add.w	r3, r3, #4
  402222:	681a      	ldr	r2, [r3, #0]
  402224:	68fb      	ldr	r3, [r7, #12]
  402226:	4013      	ands	r3, r2
  402228:	2b00      	cmp	r3, #0
  40222a:	d031      	beq.n	402290 <pio_handler_process+0xd4>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  40222c:	f24a 43d8 	movw	r3, #42200	; 0xa4d8
  402230:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402234:	68ba      	ldr	r2, [r7, #8]
  402236:	ea4f 1202 	mov.w	r2, r2, lsl #4
  40223a:	189b      	adds	r3, r3, r2
  40223c:	f103 030c 	add.w	r3, r3, #12
  402240:	681a      	ldr	r2, [r3, #0]
  402242:	f24a 43d8 	movw	r3, #42200	; 0xa4d8
  402246:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40224a:	68b9      	ldr	r1, [r7, #8]
  40224c:	ea4f 1101 	mov.w	r1, r1, lsl #4
  402250:	185b      	adds	r3, r3, r1
  402252:	6819      	ldr	r1, [r3, #0]
  402254:	f24a 43d8 	movw	r3, #42200	; 0xa4d8
  402258:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40225c:	68b8      	ldr	r0, [r7, #8]
  40225e:	ea4f 1000 	mov.w	r0, r0, lsl #4
  402262:	181b      	adds	r3, r3, r0
  402264:	f103 0304 	add.w	r3, r3, #4
  402268:	681b      	ldr	r3, [r3, #0]
  40226a:	4608      	mov	r0, r1
  40226c:	4619      	mov	r1, r3
  40226e:	4790      	blx	r2
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  402270:	f24a 43d8 	movw	r3, #42200	; 0xa4d8
  402274:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402278:	68ba      	ldr	r2, [r7, #8]
  40227a:	ea4f 1202 	mov.w	r2, r2, lsl #4
  40227e:	189b      	adds	r3, r3, r2
  402280:	f103 0304 	add.w	r3, r3, #4
  402284:	681b      	ldr	r3, [r3, #0]
  402286:	ea6f 0303 	mvn.w	r3, r3
  40228a:	68fa      	ldr	r2, [r7, #12]
  40228c:	4013      	ands	r3, r2
  40228e:	60fb      	str	r3, [r7, #12]
				}
			}
			i++;
  402290:	68bb      	ldr	r3, [r7, #8]
  402292:	f103 0301 	add.w	r3, r3, #1
  402296:	60bb      	str	r3, [r7, #8]

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  402298:	68fb      	ldr	r3, [r7, #12]
  40229a:	2b00      	cmp	r3, #0
  40229c:	d1ab      	bne.n	4021f6 <pio_handler_process+0x3a>
				}
			}
			i++;
		}
	}
}
  40229e:	f107 0710 	add.w	r7, r7, #16
  4022a2:	46bd      	mov	sp, r7
  4022a4:	bd80      	pop	{r7, pc}
  4022a6:	bf00      	nop

004022a8 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  4022a8:	b580      	push	{r7, lr}
  4022aa:	af00      	add	r7, sp, #0
	pio_handler_process(PIOA, ID_PIOA);
  4022ac:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  4022b0:	f2c4 000e 	movt	r0, #16398	; 0x400e
  4022b4:	f04f 010b 	mov.w	r1, #11
  4022b8:	f242 13bd 	movw	r3, #8637	; 0x21bd
  4022bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4022c0:	4798      	blx	r3
}
  4022c2:	bd80      	pop	{r7, pc}

004022c4 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  4022c4:	b580      	push	{r7, lr}
  4022c6:	af00      	add	r7, sp, #0
    pio_handler_process(PIOB, ID_PIOB);
  4022c8:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  4022cc:	f2c4 000e 	movt	r0, #16398	; 0x400e
  4022d0:	f04f 010c 	mov.w	r1, #12
  4022d4:	f242 13bd 	movw	r3, #8637	; 0x21bd
  4022d8:	f2c0 0340 	movt	r3, #64	; 0x40
  4022dc:	4798      	blx	r3
}
  4022de:	bd80      	pop	{r7, pc}

004022e0 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  4022e0:	b580      	push	{r7, lr}
  4022e2:	af00      	add	r7, sp, #0
	pio_handler_process(PIOC, ID_PIOC);
  4022e4:	f44f 5090 	mov.w	r0, #4608	; 0x1200
  4022e8:	f2c4 000e 	movt	r0, #16398	; 0x400e
  4022ec:	f04f 010d 	mov.w	r1, #13
  4022f0:	f242 13bd 	movw	r3, #8637	; 0x21bd
  4022f4:	f2c0 0340 	movt	r3, #64	; 0x40
  4022f8:	4798      	blx	r3
}
  4022fa:	bd80      	pop	{r7, pc}

004022fc <pmc_switch_mck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
  4022fc:	b480      	push	{r7}
  4022fe:	b085      	sub	sp, #20
  402300:	af00      	add	r7, sp, #0
  402302:	6078      	str	r0, [r7, #4]
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  402304:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402308:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40230c:	f44f 6280 	mov.w	r2, #1024	; 0x400
  402310:	f2c4 020e 	movt	r2, #16398	; 0x400e
  402314:	6b12      	ldr	r2, [r2, #48]	; 0x30
  402316:	f022 0170 	bic.w	r1, r2, #112	; 0x70
  40231a:	687a      	ldr	r2, [r7, #4]
  40231c:	430a      	orrs	r2, r1
  40231e:	631a      	str	r2, [r3, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  402320:	f44f 6300 	mov.w	r3, #2048	; 0x800
  402324:	60fb      	str	r3, [r7, #12]
  402326:	e009      	b.n	40233c <pmc_switch_mck_to_pllack+0x40>
			--ul_timeout) {
		if (ul_timeout == 0) {
  402328:	68fb      	ldr	r3, [r7, #12]
  40232a:	2b00      	cmp	r3, #0
  40232c:	d102      	bne.n	402334 <pmc_switch_mck_to_pllack+0x38>
			return 1;
  40232e:	f04f 0301 	mov.w	r3, #1
  402332:	e033      	b.n	40239c <pmc_switch_mck_to_pllack+0xa0>
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
  402334:	68fb      	ldr	r3, [r7, #12]
  402336:	f103 33ff 	add.w	r3, r3, #4294967295
  40233a:	60fb      	str	r3, [r7, #12]
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40233c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402340:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402344:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  402346:	f003 0308 	and.w	r3, r3, #8
  40234a:	2b00      	cmp	r3, #0
  40234c:	d0ec      	beq.n	402328 <pmc_switch_mck_to_pllack+0x2c>
		if (ul_timeout == 0) {
			return 1;
		}
	}
	
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  40234e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402352:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402356:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40235a:	f2c4 020e 	movt	r2, #16398	; 0x400e
  40235e:	6b12      	ldr	r2, [r2, #48]	; 0x30
  402360:	f022 0203 	bic.w	r2, r2, #3
  402364:	f042 0202 	orr.w	r2, r2, #2
  402368:	631a      	str	r2, [r3, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40236a:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40236e:	60fb      	str	r3, [r7, #12]
  402370:	e009      	b.n	402386 <pmc_switch_mck_to_pllack+0x8a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  402372:	68fb      	ldr	r3, [r7, #12]
  402374:	2b00      	cmp	r3, #0
  402376:	d102      	bne.n	40237e <pmc_switch_mck_to_pllack+0x82>
			return 1;
  402378:	f04f 0301 	mov.w	r3, #1
  40237c:	e00e      	b.n	40239c <pmc_switch_mck_to_pllack+0xa0>
	
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
  40237e:	68fb      	ldr	r3, [r7, #12]
  402380:	f103 33ff 	add.w	r3, r3, #4294967295
  402384:	60fb      	str	r3, [r7, #12]
	}
	
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  402386:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40238a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40238e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  402390:	f003 0308 	and.w	r3, r3, #8
  402394:	2b00      	cmp	r3, #0
  402396:	d0ec      	beq.n	402372 <pmc_switch_mck_to_pllack+0x76>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  402398:	f04f 0300 	mov.w	r3, #0
}
  40239c:	4618      	mov	r0, r3
  40239e:	f107 0714 	add.w	r7, r7, #20
  4023a2:	46bd      	mov	sp, r7
  4023a4:	bc80      	pop	{r7}
  4023a6:	4770      	bx	lr

004023a8 <pmc_switch_sclk_to_32kxtal>:
 * power supply.
 *
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
  4023a8:	b480      	push	{r7}
  4023aa:	b083      	sub	sp, #12
  4023ac:	af00      	add	r7, sp, #0
  4023ae:	6078      	str	r0, [r7, #4]
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  4023b0:	687b      	ldr	r3, [r7, #4]
  4023b2:	2b01      	cmp	r3, #1
  4023b4:	d10d      	bne.n	4023d2 <pmc_switch_sclk_to_32kxtal+0x2a>
		SUPC->SUPC_MR |= SUPC_MR_KEY(SUPC_KEY_VALUE) |
  4023b6:	f241 4310 	movw	r3, #5136	; 0x1410
  4023ba:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4023be:	f241 4210 	movw	r2, #5136	; 0x1410
  4023c2:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4023c6:	6892      	ldr	r2, [r2, #8]
  4023c8:	f042 4225 	orr.w	r2, r2, #2768240640	; 0xa5000000
  4023cc:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
  4023d0:	609a      	str	r2, [r3, #8]
				SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR |= SUPC_CR_KEY(SUPC_KEY_VALUE) | SUPC_CR_XTALSEL;
  4023d2:	f241 4310 	movw	r3, #5136	; 0x1410
  4023d6:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4023da:	f241 4210 	movw	r2, #5136	; 0x1410
  4023de:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4023e2:	6812      	ldr	r2, [r2, #0]
  4023e4:	f042 4225 	orr.w	r2, r2, #2768240640	; 0xa5000000
  4023e8:	f042 0208 	orr.w	r2, r2, #8
  4023ec:	601a      	str	r2, [r3, #0]
}
  4023ee:	f107 070c 	add.w	r7, r7, #12
  4023f2:	46bd      	mov	sp, r7
  4023f4:	bc80      	pop	{r7}
  4023f6:	4770      	bx	lr

004023f8 <pmc_osc_is_ready_32kxtal>:
 *
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
  4023f8:	b480      	push	{r7}
  4023fa:	af00      	add	r7, sp, #0
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  4023fc:	f241 4310 	movw	r3, #5136	; 0x1410
  402400:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402404:	695b      	ldr	r3, [r3, #20]
  402406:	f003 0380 	and.w	r3, r3, #128	; 0x80
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  40240a:	2b00      	cmp	r3, #0
  40240c:	d00b      	beq.n	402426 <pmc_osc_is_ready_32kxtal+0x2e>
  40240e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402412:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402416:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  402418:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40241c:	2b00      	cmp	r3, #0
  40241e:	d002      	beq.n	402426 <pmc_osc_is_ready_32kxtal+0x2e>
  402420:	f04f 0301 	mov.w	r3, #1
  402424:	e001      	b.n	40242a <pmc_osc_is_ready_32kxtal+0x32>
  402426:	f04f 0300 	mov.w	r3, #0
}
  40242a:	4618      	mov	r0, r3
  40242c:	46bd      	mov	sp, r7
  40242e:	bc80      	pop	{r7}
  402430:	4770      	bx	lr
  402432:	bf00      	nop

00402434 <pmc_switch_mainck_to_fastrc>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
  402434:	b480      	push	{r7}
  402436:	b085      	sub	sp, #20
  402438:	af00      	add	r7, sp, #0
  40243a:	6078      	str	r0, [r7, #4]
	uint32_t ul_needXTEN = 0;
  40243c:	f04f 0300 	mov.w	r3, #0
  402440:	60fb      	str	r3, [r7, #12]

	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	if (PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN) {
  402442:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402446:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40244a:	6a1b      	ldr	r3, [r3, #32]
  40244c:	f003 0301 	and.w	r3, r3, #1
  402450:	2b00      	cmp	r3, #0
  402452:	d014      	beq.n	40247e <pmc_switch_mainck_to_fastrc+0x4a>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  402454:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402458:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40245c:	f44f 6280 	mov.w	r2, #1024	; 0x400
  402460:	f2c4 020e 	movt	r2, #16398	; 0x400e
  402464:	6a12      	ldr	r2, [r2, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
  402466:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  40246a:	f022 0278 	bic.w	r2, r2, #120	; 0x78
  40246e:	6879      	ldr	r1, [r7, #4]
  402470:	430a      	orrs	r2, r1
  402472:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  402476:	f042 0208 	orr.w	r2, r2, #8
{
	uint32_t ul_needXTEN = 0;

	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	if (PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  40247a:	621a      	str	r2, [r3, #32]
				CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME) |
				ul_moscrcf;
	}

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  40247c:	e018      	b.n	4024b0 <pmc_switch_mainck_to_fastrc+0x7c>
	if (PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
				ul_moscrcf;
	} else {
		ul_needXTEN = 1;
  40247e:	f04f 0301 	mov.w	r3, #1
  402482:	60fb      	str	r3, [r7, #12]
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  402484:	f44f 6280 	mov.w	r2, #1024	; 0x400
  402488:	f2c4 020e 	movt	r2, #16398	; 0x400e
  40248c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402490:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402494:	6a19      	ldr	r1, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
				CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME) |
  402496:	f24c 0386 	movw	r3, #49286	; 0xc086
  40249a:	f6cf 73c8 	movt	r3, #65480	; 0xffc8
  40249e:	400b      	ands	r3, r1
  4024a0:	6879      	ldr	r1, [r7, #4]
  4024a2:	4319      	orrs	r1, r3
  4024a4:	f643 7309 	movw	r3, #16137	; 0x3f09
  4024a8:	f2c0 0337 	movt	r3, #55	; 0x37
  4024ac:	430b      	orrs	r3, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
				ul_moscrcf;
	} else {
		ul_needXTEN = 1;
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4024ae:	6213      	str	r3, [r2, #32]
				CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME) |
				ul_moscrcf;
	}

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4024b0:	bf00      	nop
  4024b2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4024b6:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4024ba:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4024bc:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  4024c0:	2b00      	cmp	r3, #0
  4024c2:	d0f6      	beq.n	4024b2 <pmc_switch_mainck_to_fastrc+0x7e>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) | PMC_CKGR_MOR_KEY_VALUE;
  4024c4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4024c8:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4024cc:	f44f 6280 	mov.w	r2, #1024	; 0x400
  4024d0:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4024d4:	6a12      	ldr	r2, [r2, #32]
  4024d6:	f022 729b 	bic.w	r2, r2, #20316160	; 0x1360000
  4024da:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  4024de:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  4024e2:	621a      	str	r2, [r3, #32]

	// BUG FIX : clock_example3_sam3s does not switch sclk->mainck with XT disabled.
	if (ul_needXTEN) {
  4024e4:	68fb      	ldr	r3, [r7, #12]
  4024e6:	2b00      	cmp	r3, #0
  4024e8:	d00f      	beq.n	40250a <pmc_switch_mainck_to_fastrc+0xd6>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4024ea:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4024ee:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4024f2:	f44f 6280 	mov.w	r2, #1024	; 0x400
  4024f6:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4024fa:	6a12      	ldr	r2, [r2, #32]
  4024fc:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  402500:	f022 0201 	bic.w	r2, r2, #1
  402504:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  402508:	621a      	str	r2, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE;
	}
}
  40250a:	f107 0714 	add.w	r7, r7, #20
  40250e:	46bd      	mov	sp, r7
  402510:	bc80      	pop	{r7}
  402512:	4770      	bx	lr

00402514 <pmc_switch_mainck_to_xtal>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass)
{
  402514:	b480      	push	{r7}
  402516:	b083      	sub	sp, #12
  402518:	af00      	add	r7, sp, #0
  40251a:	6078      	str	r0, [r7, #4]
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  40251c:	687b      	ldr	r3, [r7, #4]
  40251e:	2b00      	cmp	r3, #0
  402520:	d014      	beq.n	40254c <pmc_switch_mainck_to_xtal+0x38>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  402522:	f44f 6180 	mov.w	r1, #1024	; 0x400
  402526:	f2c4 010e 	movt	r1, #16398	; 0x400e
  40252a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40252e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402532:	6a1b      	ldr	r3, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
  402534:	f64f 72fc 	movw	r2, #65532	; 0xfffc
  402538:	f6cf 62c8 	movt	r2, #65224	; 0xfec8
  40253c:	401a      	ands	r2, r3
  40253e:	f04f 0302 	mov.w	r3, #2
  402542:	f2c0 1337 	movt	r3, #311	; 0x137
  402546:	4313      	orrs	r3, r2
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  402548:	620b      	str	r3, [r1, #32]
  40254a:	e02b      	b.n	4025a4 <pmc_switch_mainck_to_xtal+0x90>
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40254c:	f44f 6180 	mov.w	r1, #1024	; 0x400
  402550:	f2c4 010e 	movt	r1, #16398	; 0x400e
  402554:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402558:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40255c:	6a1b      	ldr	r3, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
  40255e:	f24c 02fc 	movw	r2, #49404	; 0xc0fc
  402562:	f6cf 72c8 	movt	r2, #65480	; 0xffc8
  402566:	401a      	ands	r2, r3
  402568:	f643 7301 	movw	r3, #16129	; 0x3f01
  40256c:	f2c0 0337 	movt	r3, #55	; 0x37
  402570:	4313      	orrs	r3, r2
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  402572:	620b      	str	r3, [r1, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  402574:	bf00      	nop
  402576:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40257a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40257e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  402580:	f003 0301 	and.w	r3, r3, #1
  402584:	2b00      	cmp	r3, #0
  402586:	d0f6      	beq.n	402576 <pmc_switch_mainck_to_xtal+0x62>

		PMC->CKGR_MOR |= PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCSEL;
  402588:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40258c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402590:	f44f 6280 	mov.w	r2, #1024	; 0x400
  402594:	f2c4 020e 	movt	r2, #16398	; 0x400e
  402598:	6a12      	ldr	r2, [r2, #32]
  40259a:	f042 729b 	orr.w	r2, r2, #20316160	; 0x1360000
  40259e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  4025a2:	621a      	str	r2, [r3, #32]
	}
}
  4025a4:	f107 070c 	add.w	r7, r7, #12
  4025a8:	46bd      	mov	sp, r7
  4025aa:	bc80      	pop	{r7}
  4025ac:	4770      	bx	lr
  4025ae:	bf00      	nop

004025b0 <pmc_osc_is_ready_mainck>:
 *
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
  4025b0:	b480      	push	{r7}
  4025b2:	af00      	add	r7, sp, #0
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4025b4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4025b8:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4025bc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4025be:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
  4025c2:	4618      	mov	r0, r3
  4025c4:	46bd      	mov	sp, r7
  4025c6:	bc80      	pop	{r7}
  4025c8:	4770      	bx	lr
  4025ca:	bf00      	nop

004025cc <pmc_disable_pllack>:

/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
  4025cc:	b480      	push	{r7}
  4025ce:	af00      	add	r7, sp, #0
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  4025d0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4025d4:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4025d8:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  4025dc:	629a      	str	r2, [r3, #40]	; 0x28
}
  4025de:	46bd      	mov	sp, r7
  4025e0:	bc80      	pop	{r7}
  4025e2:	4770      	bx	lr

004025e4 <pmc_is_locked_pllack>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
  4025e4:	b480      	push	{r7}
  4025e6:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  4025e8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4025ec:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4025f0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4025f2:	f003 0302 	and.w	r3, r3, #2
}
  4025f6:	4618      	mov	r0, r3
  4025f8:	46bd      	mov	sp, r7
  4025fa:	bc80      	pop	{r7}
  4025fc:	4770      	bx	lr
  4025fe:	bf00      	nop

00402600 <pmc_disable_pllbck>:

/**
 * \brief Disable PLLB clock.
 */
void pmc_disable_pllbck(void)
{
  402600:	b480      	push	{r7}
  402602:	af00      	add	r7, sp, #0
	PMC->CKGR_PLLBR = CKGR_PLLBR_MULB(0);
  402604:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402608:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40260c:	f04f 0200 	mov.w	r2, #0
  402610:	62da      	str	r2, [r3, #44]	; 0x2c
}
  402612:	46bd      	mov	sp, r7
  402614:	bc80      	pop	{r7}
  402616:	4770      	bx	lr

00402618 <pmc_is_locked_pllbck>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllbck(void)
{
  402618:	b480      	push	{r7}
  40261a:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKB);
  40261c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402620:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402624:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  402626:	f003 0304 	and.w	r3, r3, #4
}
  40262a:	4618      	mov	r0, r3
  40262c:	46bd      	mov	sp, r7
  40262e:	bc80      	pop	{r7}
  402630:	4770      	bx	lr
  402632:	bf00      	nop

00402634 <pmc_enable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
  402634:	b480      	push	{r7}
  402636:	b083      	sub	sp, #12
  402638:	af00      	add	r7, sp, #0
  40263a:	6078      	str	r0, [r7, #4]
	if (ul_id > MAX_PERIPH_ID) {
  40263c:	687b      	ldr	r3, [r7, #4]
  40263e:	2b22      	cmp	r3, #34	; 0x22
  402640:	d902      	bls.n	402648 <pmc_enable_periph_clk+0x14>
		return 1;
  402642:	f04f 0301 	mov.w	r3, #1
  402646:	e043      	b.n	4026d0 <pmc_enable_periph_clk+0x9c>
	}

	if (ul_id < 32) {
  402648:	687b      	ldr	r3, [r7, #4]
  40264a:	2b1f      	cmp	r3, #31
  40264c:	d81c      	bhi.n	402688 <pmc_enable_periph_clk+0x54>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  40264e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402652:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402656:	699a      	ldr	r2, [r3, #24]
  402658:	687b      	ldr	r3, [r7, #4]
  40265a:	f04f 0101 	mov.w	r1, #1
  40265e:	fa01 f303 	lsl.w	r3, r1, r3
  402662:	401a      	ands	r2, r3
  402664:	687b      	ldr	r3, [r7, #4]
  402666:	f04f 0101 	mov.w	r1, #1
  40266a:	fa01 f303 	lsl.w	r3, r1, r3
  40266e:	429a      	cmp	r2, r3
  402670:	d02c      	beq.n	4026cc <pmc_enable_periph_clk+0x98>
			PMC->PMC_PCER0 = 1 << ul_id;
  402672:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402676:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40267a:	687a      	ldr	r2, [r7, #4]
  40267c:	f04f 0101 	mov.w	r1, #1
  402680:	fa01 f202 	lsl.w	r2, r1, r2
  402684:	611a      	str	r2, [r3, #16]
  402686:	e021      	b.n	4026cc <pmc_enable_periph_clk+0x98>
		}
#if (SAM3S || SAM3XA || SAM4S)
	} else {
		ul_id -= 32;
  402688:	687b      	ldr	r3, [r7, #4]
  40268a:	f1a3 0320 	sub.w	r3, r3, #32
  40268e:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  402690:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402694:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402698:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  40269c:	687b      	ldr	r3, [r7, #4]
  40269e:	f04f 0101 	mov.w	r1, #1
  4026a2:	fa01 f303 	lsl.w	r3, r1, r3
  4026a6:	401a      	ands	r2, r3
  4026a8:	687b      	ldr	r3, [r7, #4]
  4026aa:	f04f 0101 	mov.w	r1, #1
  4026ae:	fa01 f303 	lsl.w	r3, r1, r3
  4026b2:	429a      	cmp	r2, r3
  4026b4:	d00a      	beq.n	4026cc <pmc_enable_periph_clk+0x98>
			PMC->PMC_PCER1 = 1 << ul_id;
  4026b6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4026ba:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4026be:	687a      	ldr	r2, [r7, #4]
  4026c0:	f04f 0101 	mov.w	r1, #1
  4026c4:	fa01 f202 	lsl.w	r2, r1, r2
  4026c8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
		}
#endif
	}
	
	return 0;
  4026cc:	f04f 0300 	mov.w	r3, #0
}
  4026d0:	4618      	mov	r0, r3
  4026d2:	f107 070c 	add.w	r7, r7, #12
  4026d6:	46bd      	mov	sp, r7
  4026d8:	bc80      	pop	{r7}
  4026da:	4770      	bx	lr

004026dc <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4026dc:	b480      	push	{r7}
  4026de:	af00      	add	r7, sp, #0
	while (1) {
	}
  4026e0:	e7fe      	b.n	4026e0 <Dummy_Handler+0x4>
  4026e2:	bf00      	nop

004026e4 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  4026e4:	b580      	push	{r7, lr}
  4026e6:	b082      	sub	sp, #8
  4026e8:	af00      	add	r7, sp, #0
	uint32_t *pSrc, *pDest;

	/* Initialize the relocate segment */
	pSrc = &_etext;
  4026ea:	f649 0328 	movw	r3, #38952	; 0x9828
  4026ee:	f2c0 0340 	movt	r3, #64	; 0x40
  4026f2:	607b      	str	r3, [r7, #4]
	pDest = &_srelocate;
  4026f4:	f240 0300 	movw	r3, #0
  4026f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4026fc:	603b      	str	r3, [r7, #0]

	if (pSrc != pDest) {
  4026fe:	687a      	ldr	r2, [r7, #4]
  402700:	683b      	ldr	r3, [r7, #0]
  402702:	429a      	cmp	r2, r3
  402704:	d013      	beq.n	40272e <Reset_Handler+0x4a>
		for (; pDest < &_erelocate;) {
  402706:	e00b      	b.n	402720 <Reset_Handler+0x3c>
			*pDest++ = *pSrc++;
  402708:	687b      	ldr	r3, [r7, #4]
  40270a:	681a      	ldr	r2, [r3, #0]
  40270c:	683b      	ldr	r3, [r7, #0]
  40270e:	601a      	str	r2, [r3, #0]
  402710:	683b      	ldr	r3, [r7, #0]
  402712:	f103 0304 	add.w	r3, r3, #4
  402716:	603b      	str	r3, [r7, #0]
  402718:	687b      	ldr	r3, [r7, #4]
  40271a:	f103 0304 	add.w	r3, r3, #4
  40271e:	607b      	str	r3, [r7, #4]
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
  402720:	683a      	ldr	r2, [r7, #0]
  402722:	f240 4350 	movw	r3, #1104	; 0x450
  402726:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40272a:	429a      	cmp	r2, r3
  40272c:	d3ec      	bcc.n	402708 <Reset_Handler+0x24>
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40272e:	f240 4350 	movw	r3, #1104	; 0x450
  402732:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402736:	603b      	str	r3, [r7, #0]
  402738:	e007      	b.n	40274a <Reset_Handler+0x66>
		*pDest++ = 0;
  40273a:	683b      	ldr	r3, [r7, #0]
  40273c:	f04f 0200 	mov.w	r2, #0
  402740:	601a      	str	r2, [r3, #0]
  402742:	683b      	ldr	r3, [r7, #0]
  402744:	f103 0304 	add.w	r3, r3, #4
  402748:	603b      	str	r3, [r7, #0]
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40274a:	683a      	ldr	r2, [r7, #0]
  40274c:	f24a 73a8 	movw	r3, #42920	; 0xa7a8
  402750:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402754:	429a      	cmp	r2, r3
  402756:	d3f0      	bcc.n	40273a <Reset_Handler+0x56>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
  402758:	f240 0300 	movw	r3, #0
  40275c:	f2c0 0340 	movt	r3, #64	; 0x40
  402760:	607b      	str	r3, [r7, #4]
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  402762:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  402766:	f2ce 0300 	movt	r3, #57344	; 0xe000
  40276a:	687a      	ldr	r2, [r7, #4]
  40276c:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
  402770:	609a      	str	r2, [r3, #8]

	if (((uint32_t) pSrc >= IRAM_ADDR) && ((uint32_t) pSrc < IRAM_ADDR + IRAM_SIZE)) {
  402772:	687a      	ldr	r2, [r7, #4]
  402774:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
  402778:	429a      	cmp	r2, r3
  40277a:	d912      	bls.n	4027a2 <Reset_Handler+0xbe>
  40277c:	687a      	ldr	r2, [r7, #4]
  40277e:	f64f 73ff 	movw	r3, #65535	; 0xffff
  402782:	f2c2 0301 	movt	r3, #8193	; 0x2001
  402786:	429a      	cmp	r2, r3
  402788:	d80b      	bhi.n	4027a2 <Reset_Handler+0xbe>
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
  40278a:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  40278e:	f2ce 0300 	movt	r3, #57344	; 0xe000
  402792:	f44f 426d 	mov.w	r2, #60672	; 0xed00
  402796:	f2ce 0200 	movt	r2, #57344	; 0xe000
  40279a:	6892      	ldr	r2, [r2, #8]
  40279c:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  4027a0:	609a      	str	r2, [r3, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
  4027a2:	f249 53dd 	movw	r3, #38365	; 0x95dd
  4027a6:	f2c0 0340 	movt	r3, #64	; 0x40
  4027aa:	4798      	blx	r3

	/* Branch to main function */
	main();
  4027ac:	f249 03ed 	movw	r3, #37101	; 0x90ed
  4027b0:	f2c0 0340 	movt	r3, #64	; 0x40
  4027b4:	4798      	blx	r3

	/* Infinite loop */
	while (1);
  4027b6:	e7fe      	b.n	4027b6 <Reset_Handler+0xd2>

004027b8 <SystemCoreClockUpdate>:

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate(void)
{
  4027b8:	b480      	push	{r7}
  4027ba:	af00      	add	r7, sp, #0
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  4027bc:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4027c0:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4027c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4027c6:	f003 0303 	and.w	r3, r3, #3
  4027ca:	2b03      	cmp	r3, #3
  4027cc:	f200 8119 	bhi.w	402a02 <SystemCoreClockUpdate+0x24a>
  4027d0:	a101      	add	r1, pc, #4	; (adr r1, 4027d8 <SystemCoreClockUpdate+0x20>)
  4027d2:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
  4027d6:	bf00      	nop
  4027d8:	004027e9 	.word	0x004027e9
  4027dc:	0040281b 	.word	0x0040281b
  4027e0:	004028ad 	.word	0x004028ad
  4027e4:	004028ad 	.word	0x004028ad
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  4027e8:	f241 4310 	movw	r3, #5136	; 0x1410
  4027ec:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4027f0:	695b      	ldr	r3, [r3, #20]
  4027f2:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4027f6:	2b00      	cmp	r3, #0
  4027f8:	d007      	beq.n	40280a <SystemCoreClockUpdate+0x52>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  4027fa:	f240 0310 	movw	r3, #16
  4027fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402802:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  402806:	601a      	str	r2, [r3, #0]
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
		}
		break;
  402808:	e0fc      	b.n	402a04 <SystemCoreClockUpdate+0x24c>
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  40280a:	f240 0310 	movw	r3, #16
  40280e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402812:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  402816:	601a      	str	r2, [r3, #0]
		}
		break;
  402818:	e0f4      	b.n	402a04 <SystemCoreClockUpdate+0x24c>
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  40281a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40281e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402822:	6a1b      	ldr	r3, [r3, #32]
  402824:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  402828:	2b00      	cmp	r3, #0
  40282a:	d009      	beq.n	402840 <SystemCoreClockUpdate+0x88>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  40282c:	f240 0310 	movw	r3, #16
  402830:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402834:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  402838:	f2c0 02b7 	movt	r2, #183	; 0xb7
  40283c:	601a      	str	r2, [r3, #0]
				break;
			default:
				break;
			}
		}
		break;
  40283e:	e0e1      	b.n	402a04 <SystemCoreClockUpdate+0x24c>
		break;
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  402840:	f240 0310 	movw	r3, #16
  402844:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402848:	f44f 6210 	mov.w	r2, #2304	; 0x900
  40284c:	f2c0 023d 	movt	r2, #61	; 0x3d
  402850:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  402852:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402856:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40285a:	6a1b      	ldr	r3, [r3, #32]
  40285c:	f003 0370 	and.w	r3, r3, #112	; 0x70
  402860:	2b10      	cmp	r3, #16
  402862:	d004      	beq.n	40286e <SystemCoreClockUpdate+0xb6>
  402864:	2b20      	cmp	r3, #32
  402866:	d00f      	beq.n	402888 <SystemCoreClockUpdate+0xd0>
  402868:	2b00      	cmp	r3, #0
  40286a:	d01d      	beq.n	4028a8 <SystemCoreClockUpdate+0xf0>
  40286c:	e01b      	b.n	4028a6 <SystemCoreClockUpdate+0xee>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
  40286e:	f240 0310 	movw	r3, #16
  402872:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402876:	681b      	ldr	r3, [r3, #0]
  402878:	ea4f 0243 	mov.w	r2, r3, lsl #1
  40287c:	f240 0310 	movw	r3, #16
  402880:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402884:	601a      	str	r2, [r3, #0]
				break;
  402886:	e010      	b.n	4028aa <SystemCoreClockUpdate+0xf2>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
  402888:	f240 0310 	movw	r3, #16
  40288c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402890:	681a      	ldr	r2, [r3, #0]
  402892:	4613      	mov	r3, r2
  402894:	ea4f 0343 	mov.w	r3, r3, lsl #1
  402898:	189a      	adds	r2, r3, r2
  40289a:	f240 0310 	movw	r3, #16
  40289e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4028a2:	601a      	str	r2, [r3, #0]
				break;
  4028a4:	e001      	b.n	4028aa <SystemCoreClockUpdate+0xf2>
			default:
				break;
  4028a6:	e000      	b.n	4028aa <SystemCoreClockUpdate+0xf2>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
  4028a8:	bf00      	nop
				break;
			default:
				break;
			}
		}
		break;
  4028aa:	e0ab      	b.n	402a04 <SystemCoreClockUpdate+0x24c>
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  4028ac:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4028b0:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4028b4:	6a1b      	ldr	r3, [r3, #32]
  4028b6:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  4028ba:	2b00      	cmp	r3, #0
  4028bc:	d009      	beq.n	4028d2 <SystemCoreClockUpdate+0x11a>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  4028be:	f240 0310 	movw	r3, #16
  4028c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4028c6:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  4028ca:	f2c0 02b7 	movt	r2, #183	; 0xb7
  4028ce:	601a      	str	r2, [r3, #0]
  4028d0:	e034      	b.n	40293c <SystemCoreClockUpdate+0x184>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  4028d2:	f240 0310 	movw	r3, #16
  4028d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4028da:	f44f 6210 	mov.w	r2, #2304	; 0x900
  4028de:	f2c0 023d 	movt	r2, #61	; 0x3d
  4028e2:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  4028e4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4028e8:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4028ec:	6a1b      	ldr	r3, [r3, #32]
  4028ee:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4028f2:	2b10      	cmp	r3, #16
  4028f4:	d004      	beq.n	402900 <SystemCoreClockUpdate+0x148>
  4028f6:	2b20      	cmp	r3, #32
  4028f8:	d00f      	beq.n	40291a <SystemCoreClockUpdate+0x162>
  4028fa:	2b00      	cmp	r3, #0
  4028fc:	d01d      	beq.n	40293a <SystemCoreClockUpdate+0x182>
  4028fe:	e01b      	b.n	402938 <SystemCoreClockUpdate+0x180>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
  402900:	f240 0310 	movw	r3, #16
  402904:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402908:	681b      	ldr	r3, [r3, #0]
  40290a:	ea4f 0243 	mov.w	r2, r3, lsl #1
  40290e:	f240 0310 	movw	r3, #16
  402912:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402916:	601a      	str	r2, [r3, #0]
				break;
  402918:	e010      	b.n	40293c <SystemCoreClockUpdate+0x184>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
  40291a:	f240 0310 	movw	r3, #16
  40291e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402922:	681a      	ldr	r2, [r3, #0]
  402924:	4613      	mov	r3, r2
  402926:	ea4f 0343 	mov.w	r3, r3, lsl #1
  40292a:	189a      	adds	r2, r3, r2
  40292c:	f240 0310 	movw	r3, #16
  402930:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402934:	601a      	str	r2, [r3, #0]
				break;
  402936:	e001      	b.n	40293c <SystemCoreClockUpdate+0x184>
			default:
				break;
  402938:	e000      	b.n	40293c <SystemCoreClockUpdate+0x184>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
  40293a:	bf00      	nop
				break;
			default:
				break;
			}
		}
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
  40293c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402940:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402944:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402946:	f003 0303 	and.w	r3, r3, #3
  40294a:	2b02      	cmp	r3, #2
  40294c:	d12c      	bne.n	4029a8 <SystemCoreClockUpdate+0x1f0>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  40294e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402952:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402956:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  402958:	f04f 0300 	mov.w	r3, #0
  40295c:	f2c0 73ff 	movt	r3, #2047	; 0x7ff
  402960:	4013      	ands	r3, r2
  402962:	ea4f 4313 	mov.w	r3, r3, lsr #16
				                          CKGR_PLLAR_MULA_Pos) + 1U);
  402966:	f103 0201 	add.w	r2, r3, #1
			default:
				break;
			}
		}
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  40296a:	f240 0310 	movw	r3, #16
  40296e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402972:	681b      	ldr	r3, [r3, #0]
  402974:	fb03 f202 	mul.w	r2, r3, r2
  402978:	f240 0310 	movw	r3, #16
  40297c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402980:	601a      	str	r2, [r3, #0]
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
  402982:	f240 0310 	movw	r3, #16
  402986:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40298a:	681a      	ldr	r2, [r3, #0]
  40298c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402990:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402994:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402996:	b2db      	uxtb	r3, r3
  402998:	fbb2 f2f3 	udiv	r2, r2, r3
  40299c:	f240 0310 	movw	r3, #16
  4029a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4029a4:	601a      	str	r2, [r3, #0]
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
				                           CKGR_PLLBR_MULB_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk) >> 
				                               CKGR_PLLBR_DIVB_Pos));
		}
		break;
  4029a6:	e02d      	b.n	402a04 <SystemCoreClockUpdate+0x24c>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
				                          CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
  4029a8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4029ac:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4029b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4029b2:	f04f 0300 	mov.w	r3, #0
  4029b6:	f2c0 73ff 	movt	r3, #2047	; 0x7ff
  4029ba:	4013      	ands	r3, r2
  4029bc:	ea4f 4313 	mov.w	r3, r3, lsr #16
				                           CKGR_PLLBR_MULB_Pos) + 1U);
  4029c0:	f103 0201 	add.w	r2, r3, #1
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
				                          CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
  4029c4:	f240 0310 	movw	r3, #16
  4029c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4029cc:	681b      	ldr	r3, [r3, #0]
  4029ce:	fb03 f202 	mul.w	r2, r3, r2
  4029d2:	f240 0310 	movw	r3, #16
  4029d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4029da:	601a      	str	r2, [r3, #0]
				                           CKGR_PLLBR_MULB_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk) >> 
  4029dc:	f240 0310 	movw	r3, #16
  4029e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4029e4:	681a      	ldr	r2, [r3, #0]
  4029e6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4029ea:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4029ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4029f0:	b2db      	uxtb	r3, r3
  4029f2:	fbb2 f2f3 	udiv	r2, r2, r3
  4029f6:	f240 0310 	movw	r3, #16
  4029fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4029fe:	601a      	str	r2, [r3, #0]
				                               CKGR_PLLBR_DIVB_Pos));
		}
		break;
  402a00:	e000      	b.n	402a04 <SystemCoreClockUpdate+0x24c>
	default:
		break;
  402a02:	bf00      	nop
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  402a04:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402a08:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402a0c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402a0e:	f003 0370 	and.w	r3, r3, #112	; 0x70
  402a12:	2b70      	cmp	r3, #112	; 0x70
  402a14:	d112      	bne.n	402a3c <SystemCoreClockUpdate+0x284>
		SystemCoreClock /= 3U;
  402a16:	f240 0310 	movw	r3, #16
  402a1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402a1e:	681a      	ldr	r2, [r3, #0]
  402a20:	f64a 23ab 	movw	r3, #43691	; 0xaaab
  402a24:	f6ca 23aa 	movt	r3, #43690	; 0xaaaa
  402a28:	fba3 1302 	umull	r1, r3, r3, r2
  402a2c:	ea4f 0253 	mov.w	r2, r3, lsr #1
  402a30:	f240 0310 	movw	r3, #16
  402a34:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402a38:	601a      	str	r2, [r3, #0]
  402a3a:	e014      	b.n	402a66 <SystemCoreClockUpdate+0x2ae>
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  402a3c:	f240 0310 	movw	r3, #16
  402a40:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402a44:	681a      	ldr	r2, [r3, #0]
  402a46:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402a4a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402a4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402a50:	f003 0370 	and.w	r3, r3, #112	; 0x70
  402a54:	ea4f 1313 	mov.w	r3, r3, lsr #4
  402a58:	fa22 f203 	lsr.w	r2, r2, r3
  402a5c:	f240 0310 	movw	r3, #16
  402a60:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402a64:	601a      	str	r2, [r3, #0]
	}
}
  402a66:	46bd      	mov	sp, r7
  402a68:	bc80      	pop	{r7}
  402a6a:	4770      	bx	lr

00402a6c <system_init_flash>:

/** 
 * Initialize flash.
 */
void system_init_flash(uint32_t ul_clk)
{
  402a6c:	b480      	push	{r7}
  402a6e:	b083      	sub	sp, #12
  402a70:	af00      	add	r7, sp, #0
  402a72:	6078      	str	r0, [r7, #4]
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
  402a74:	687a      	ldr	r2, [r7, #4]
  402a76:	f642 43ff 	movw	r3, #11519	; 0x2cff
  402a7a:	f2c0 1331 	movt	r3, #305	; 0x131
  402a7e:	429a      	cmp	r2, r3
  402a80:	d807      	bhi.n	402a92 <system_init_flash+0x26>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0);
  402a82:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  402a86:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402a8a:	f04f 0200 	mov.w	r2, #0
  402a8e:	601a      	str	r2, [r3, #0]
  402a90:	e033      	b.n	402afa <system_init_flash+0x8e>
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
  402a92:	687a      	ldr	r2, [r7, #4]
  402a94:	f645 13ff 	movw	r3, #23039	; 0x59ff
  402a98:	f2c0 2362 	movt	r3, #610	; 0x262
  402a9c:	429a      	cmp	r2, r3
  402a9e:	d807      	bhi.n	402ab0 <system_init_flash+0x44>
		EFC->EEFC_FMR = EEFC_FMR_FWS(1);
  402aa0:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  402aa4:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402aa8:	f44f 7280 	mov.w	r2, #256	; 0x100
  402aac:	601a      	str	r2, [r3, #0]
  402aae:	e024      	b.n	402afa <system_init_flash+0x8e>
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
  402ab0:	687a      	ldr	r2, [r7, #4]
  402ab2:	f248 63ff 	movw	r3, #34559	; 0x86ff
  402ab6:	f2c0 3393 	movt	r3, #915	; 0x393
  402aba:	429a      	cmp	r2, r3
  402abc:	d807      	bhi.n	402ace <system_init_flash+0x62>
		EFC->EEFC_FMR = EEFC_FMR_FWS(2);
  402abe:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  402ac2:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402ac6:	f44f 7200 	mov.w	r2, #512	; 0x200
  402aca:	601a      	str	r2, [r3, #0]
  402acc:	e015      	b.n	402afa <system_init_flash+0x8e>
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
  402ace:	687a      	ldr	r2, [r7, #4]
  402ad0:	f24b 33ff 	movw	r3, #46079	; 0xb3ff
  402ad4:	f2c0 43c4 	movt	r3, #1220	; 0x4c4
  402ad8:	429a      	cmp	r2, r3
  402ada:	d807      	bhi.n	402aec <system_init_flash+0x80>
		EFC->EEFC_FMR = EEFC_FMR_FWS(3);
  402adc:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  402ae0:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402ae4:	f44f 7240 	mov.w	r2, #768	; 0x300
  402ae8:	601a      	str	r2, [r3, #0]
  402aea:	e006      	b.n	402afa <system_init_flash+0x8e>
	} else {
		EFC->EEFC_FMR = EEFC_FMR_FWS(4);
  402aec:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  402af0:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402af4:	f44f 6280 	mov.w	r2, #1024	; 0x400
  402af8:	601a      	str	r2, [r3, #0]
	}
}
  402afa:	f107 070c 	add.w	r7, r7, #12
  402afe:	46bd      	mov	sp, r7
  402b00:	bc80      	pop	{r7}
  402b02:	4770      	bx	lr

00402b04 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList * const pxList )
{
  402b04:	b480      	push	{r7}
  402b06:	b083      	sub	sp, #12
  402b08:	af00      	add	r7, sp, #0
  402b0a:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  402b0c:	687b      	ldr	r3, [r7, #4]
  402b0e:	f103 0208 	add.w	r2, r3, #8
  402b12:	687b      	ldr	r3, [r7, #4]
  402b14:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  402b16:	687b      	ldr	r3, [r7, #4]
  402b18:	f04f 32ff 	mov.w	r2, #4294967295
  402b1c:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  402b1e:	687b      	ldr	r3, [r7, #4]
  402b20:	f103 0208 	add.w	r2, r3, #8
  402b24:	687b      	ldr	r3, [r7, #4]
  402b26:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  402b28:	687b      	ldr	r3, [r7, #4]
  402b2a:	f103 0208 	add.w	r2, r3, #8
  402b2e:	687b      	ldr	r3, [r7, #4]
  402b30:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  402b32:	687b      	ldr	r3, [r7, #4]
  402b34:	f04f 0200 	mov.w	r2, #0
  402b38:	601a      	str	r2, [r3, #0]
}
  402b3a:	f107 070c 	add.w	r7, r7, #12
  402b3e:	46bd      	mov	sp, r7
  402b40:	bc80      	pop	{r7}
  402b42:	4770      	bx	lr

00402b44 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem * const pxItem )
{
  402b44:	b480      	push	{r7}
  402b46:	b083      	sub	sp, #12
  402b48:	af00      	add	r7, sp, #0
  402b4a:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  402b4c:	687b      	ldr	r3, [r7, #4]
  402b4e:	f04f 0200 	mov.w	r2, #0
  402b52:	611a      	str	r2, [r3, #16]
}
  402b54:	f107 070c 	add.w	r7, r7, #12
  402b58:	46bd      	mov	sp, r7
  402b5a:	bc80      	pop	{r7}
  402b5c:	4770      	bx	lr
  402b5e:	bf00      	nop

00402b60 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList * const pxList, xListItem * const pxNewListItem )
{
  402b60:	b480      	push	{r7}
  402b62:	b085      	sub	sp, #20
  402b64:	af00      	add	r7, sp, #0
  402b66:	6078      	str	r0, [r7, #4]
  402b68:	6039      	str	r1, [r7, #0]
xListItem * pxIndex;

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry. */
	pxIndex = pxList->pxIndex;
  402b6a:	687b      	ldr	r3, [r7, #4]
  402b6c:	685b      	ldr	r3, [r3, #4]
  402b6e:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex;
  402b70:	683b      	ldr	r3, [r7, #0]
  402b72:	68fa      	ldr	r2, [r7, #12]
  402b74:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  402b76:	68fb      	ldr	r3, [r7, #12]
  402b78:	689a      	ldr	r2, [r3, #8]
  402b7a:	683b      	ldr	r3, [r7, #0]
  402b7c:	609a      	str	r2, [r3, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
  402b7e:	68fb      	ldr	r3, [r7, #12]
  402b80:	689b      	ldr	r3, [r3, #8]
  402b82:	683a      	ldr	r2, [r7, #0]
  402b84:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
  402b86:	68fb      	ldr	r3, [r7, #12]
  402b88:	683a      	ldr	r2, [r7, #0]
  402b8a:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  402b8c:	683b      	ldr	r3, [r7, #0]
  402b8e:	687a      	ldr	r2, [r7, #4]
  402b90:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  402b92:	687b      	ldr	r3, [r7, #4]
  402b94:	681b      	ldr	r3, [r3, #0]
  402b96:	f103 0201 	add.w	r2, r3, #1
  402b9a:	687b      	ldr	r3, [r7, #4]
  402b9c:	601a      	str	r2, [r3, #0]
}
  402b9e:	f107 0714 	add.w	r7, r7, #20
  402ba2:	46bd      	mov	sp, r7
  402ba4:	bc80      	pop	{r7}
  402ba6:	4770      	bx	lr

00402ba8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList * const pxList, xListItem * const pxNewListItem )
{
  402ba8:	b480      	push	{r7}
  402baa:	b085      	sub	sp, #20
  402bac:	af00      	add	r7, sp, #0
  402bae:	6078      	str	r0, [r7, #4]
  402bb0:	6039      	str	r1, [r7, #0]
xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
  402bb2:	683b      	ldr	r3, [r7, #0]
  402bb4:	681b      	ldr	r3, [r3, #0]
  402bb6:	60bb      	str	r3, [r7, #8]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  402bb8:	68bb      	ldr	r3, [r7, #8]
  402bba:	f1b3 3fff 	cmp.w	r3, #4294967295
  402bbe:	d103      	bne.n	402bc8 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  402bc0:	687b      	ldr	r3, [r7, #4]
  402bc2:	691b      	ldr	r3, [r3, #16]
  402bc4:	60fb      	str	r3, [r7, #12]
  402bc6:	e00d      	b.n	402be4 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  402bc8:	687b      	ldr	r3, [r7, #4]
  402bca:	f103 0308 	add.w	r3, r3, #8
  402bce:	60fb      	str	r3, [r7, #12]
  402bd0:	e002      	b.n	402bd8 <vListInsert+0x30>
  402bd2:	68fb      	ldr	r3, [r7, #12]
  402bd4:	685b      	ldr	r3, [r3, #4]
  402bd6:	60fb      	str	r3, [r7, #12]
  402bd8:	68fb      	ldr	r3, [r7, #12]
  402bda:	685b      	ldr	r3, [r3, #4]
  402bdc:	681a      	ldr	r2, [r3, #0]
  402bde:	68bb      	ldr	r3, [r7, #8]
  402be0:	429a      	cmp	r2, r3
  402be2:	d9f6      	bls.n	402bd2 <vListInsert+0x2a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  402be4:	68fb      	ldr	r3, [r7, #12]
  402be6:	685a      	ldr	r2, [r3, #4]
  402be8:	683b      	ldr	r3, [r7, #0]
  402bea:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  402bec:	683b      	ldr	r3, [r7, #0]
  402bee:	685b      	ldr	r3, [r3, #4]
  402bf0:	683a      	ldr	r2, [r7, #0]
  402bf2:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
  402bf4:	683b      	ldr	r3, [r7, #0]
  402bf6:	68fa      	ldr	r2, [r7, #12]
  402bf8:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
  402bfa:	68fb      	ldr	r3, [r7, #12]
  402bfc:	683a      	ldr	r2, [r7, #0]
  402bfe:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  402c00:	683b      	ldr	r3, [r7, #0]
  402c02:	687a      	ldr	r2, [r7, #4]
  402c04:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  402c06:	687b      	ldr	r3, [r7, #4]
  402c08:	681b      	ldr	r3, [r3, #0]
  402c0a:	f103 0201 	add.w	r2, r3, #1
  402c0e:	687b      	ldr	r3, [r7, #4]
  402c10:	601a      	str	r2, [r3, #0]
}
  402c12:	f107 0714 	add.w	r7, r7, #20
  402c16:	46bd      	mov	sp, r7
  402c18:	bc80      	pop	{r7}
  402c1a:	4770      	bx	lr

00402c1c <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove )
{
  402c1c:	b480      	push	{r7}
  402c1e:	b085      	sub	sp, #20
  402c20:	af00      	add	r7, sp, #0
  402c22:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  402c24:	687b      	ldr	r3, [r7, #4]
  402c26:	685b      	ldr	r3, [r3, #4]
  402c28:	687a      	ldr	r2, [r7, #4]
  402c2a:	6892      	ldr	r2, [r2, #8]
  402c2c:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  402c2e:	687b      	ldr	r3, [r7, #4]
  402c30:	689b      	ldr	r3, [r3, #8]
  402c32:	687a      	ldr	r2, [r7, #4]
  402c34:	6852      	ldr	r2, [r2, #4]
  402c36:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  402c38:	687b      	ldr	r3, [r7, #4]
  402c3a:	691b      	ldr	r3, [r3, #16]
  402c3c:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  402c3e:	68fb      	ldr	r3, [r7, #12]
  402c40:	685a      	ldr	r2, [r3, #4]
  402c42:	687b      	ldr	r3, [r7, #4]
  402c44:	429a      	cmp	r2, r3
  402c46:	d103      	bne.n	402c50 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  402c48:	687b      	ldr	r3, [r7, #4]
  402c4a:	689a      	ldr	r2, [r3, #8]
  402c4c:	68fb      	ldr	r3, [r7, #12]
  402c4e:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  402c50:	687b      	ldr	r3, [r7, #4]
  402c52:	f04f 0200 	mov.w	r2, #0
  402c56:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
  402c58:	68fb      	ldr	r3, [r7, #12]
  402c5a:	681b      	ldr	r3, [r3, #0]
  402c5c:	f103 32ff 	add.w	r2, r3, #4294967295
  402c60:	68fb      	ldr	r3, [r7, #12]
  402c62:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  402c64:	68fb      	ldr	r3, [r7, #12]
  402c66:	681b      	ldr	r3, [r3, #0]
}
  402c68:	4618      	mov	r0, r3
  402c6a:	f107 0714 	add.w	r7, r7, #20
  402c6e:	46bd      	mov	sp, r7
  402c70:	bc80      	pop	{r7}
  402c72:	4770      	bx	lr

00402c74 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
  402c74:	b480      	push	{r7}
  402c76:	b085      	sub	sp, #20
  402c78:	af00      	add	r7, sp, #0
  402c7a:	60f8      	str	r0, [r7, #12]
  402c7c:	60b9      	str	r1, [r7, #8]
  402c7e:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
  402c80:	68fb      	ldr	r3, [r7, #12]
  402c82:	f1a3 0304 	sub.w	r3, r3, #4
  402c86:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
  402c88:	68fb      	ldr	r3, [r7, #12]
  402c8a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  402c8e:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  402c90:	68fb      	ldr	r3, [r7, #12]
  402c92:	f1a3 0304 	sub.w	r3, r3, #4
  402c96:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
  402c98:	68ba      	ldr	r2, [r7, #8]
  402c9a:	68fb      	ldr	r3, [r7, #12]
  402c9c:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  402c9e:	68fb      	ldr	r3, [r7, #12]
  402ca0:	f1a3 0304 	sub.w	r3, r3, #4
  402ca4:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) portTASK_RETURN_ADDRESS;	/* LR */
  402ca6:	f642 43d9 	movw	r3, #11481	; 0x2cd9
  402caa:	f2c0 0340 	movt	r3, #64	; 0x40
  402cae:	68fa      	ldr	r2, [r7, #12]
  402cb0:	6013      	str	r3, [r2, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
  402cb2:	68fb      	ldr	r3, [r7, #12]
  402cb4:	f1a3 0314 	sub.w	r3, r3, #20
  402cb8:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
  402cba:	687a      	ldr	r2, [r7, #4]
  402cbc:	68fb      	ldr	r3, [r7, #12]
  402cbe:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
  402cc0:	68fb      	ldr	r3, [r7, #12]
  402cc2:	f1a3 0320 	sub.w	r3, r3, #32
  402cc6:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
  402cc8:	68fb      	ldr	r3, [r7, #12]
}
  402cca:	4618      	mov	r0, r3
  402ccc:	f107 0714 	add.w	r7, r7, #20
  402cd0:	46bd      	mov	sp, r7
  402cd2:	bc80      	pop	{r7}
  402cd4:	4770      	bx	lr
  402cd6:	bf00      	nop

00402cd8 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
  402cd8:	b580      	push	{r7, lr}
  402cda:	af00      	add	r7, sp, #0
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
  402cdc:	f240 0314 	movw	r3, #20
  402ce0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402ce4:	681b      	ldr	r3, [r3, #0]
  402ce6:	f1b3 3fff 	cmp.w	r3, #4294967295
  402cea:	d005      	beq.n	402cf8 <prvTaskExitError+0x20>
  402cec:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  402cf0:	f2c0 0340 	movt	r3, #64	; 0x40
  402cf4:	4798      	blx	r3
  402cf6:	e7fe      	b.n	402cf6 <prvTaskExitError+0x1e>
	portDISABLE_INTERRUPTS();
  402cf8:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  402cfc:	f2c0 0340 	movt	r3, #64	; 0x40
  402d00:	4798      	blx	r3
	for( ;; );
  402d02:	e7fe      	b.n	402d02 <prvTaskExitError+0x2a>

00402d04 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
  402d04:	4b06      	ldr	r3, [pc, #24]	; (402d20 <pxCurrentTCBConst2>)
  402d06:	6819      	ldr	r1, [r3, #0]
  402d08:	6808      	ldr	r0, [r1, #0]
  402d0a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  402d0e:	f380 8809 	msr	PSP, r0
  402d12:	f04f 0000 	mov.w	r0, #0
  402d16:	f380 8811 	msr	BASEPRI, r0
  402d1a:	f04e 0e0d 	orr.w	lr, lr, #13
  402d1e:	4770      	bx	lr

00402d20 <pxCurrentTCBConst2>:
  402d20:	2000a550 	.word	0x2000a550

00402d24 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
  402d24:	4803      	ldr	r0, [pc, #12]	; (402d34 <prvPortStartFirstTask+0x10>)
  402d26:	6800      	ldr	r0, [r0, #0]
  402d28:	6800      	ldr	r0, [r0, #0]
  402d2a:	f380 8808 	msr	MSP, r0
  402d2e:	b662      	cpsie	i
  402d30:	df00      	svc	0
  402d32:	bf00      	nop
  402d34:	e000ed08 	.word	0xe000ed08

00402d38 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
  402d38:	b580      	push	{r7, lr}
  402d3a:	b084      	sub	sp, #16
  402d3c:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile unsigned long ulOriginalPriority;
		volatile char * const pcFirstUserPriorityRegister = ( volatile char * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
  402d3e:	f44f 4364 	mov.w	r3, #58368	; 0xe400
  402d42:	f2ce 0300 	movt	r3, #57344	; 0xe000
  402d46:	60fb      	str	r3, [r7, #12]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pcFirstUserPriorityRegister;
  402d48:	68fb      	ldr	r3, [r7, #12]
  402d4a:	781b      	ldrb	r3, [r3, #0]
  402d4c:	b2db      	uxtb	r3, r3
  402d4e:	60bb      	str	r3, [r7, #8]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pcFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  402d50:	68fb      	ldr	r3, [r7, #12]
  402d52:	f04f 02ff 	mov.w	r2, #255	; 0xff
  402d56:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pcFirstUserPriorityRegister;
  402d58:	68fb      	ldr	r3, [r7, #12]
  402d5a:	781b      	ldrb	r3, [r3, #0]
  402d5c:	b2db      	uxtb	r3, r3
  402d5e:	71fb      	strb	r3, [r7, #7]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
  402d60:	79fb      	ldrb	r3, [r7, #7]
  402d62:	b2db      	uxtb	r3, r3
  402d64:	f023 035f 	bic.w	r3, r3, #95	; 0x5f
  402d68:	b2da      	uxtb	r2, r3
  402d6a:	f24a 5348 	movw	r3, #42312	; 0xa548
  402d6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402d72:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
  402d74:	f24a 534c 	movw	r3, #42316	; 0xa54c
  402d78:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402d7c:	f04f 0207 	mov.w	r2, #7
  402d80:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  402d82:	e011      	b.n	402da8 <xPortStartScheduler+0x70>
		{
			ulMaxPRIGROUPValue--;
  402d84:	f24a 534c 	movw	r3, #42316	; 0xa54c
  402d88:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402d8c:	681b      	ldr	r3, [r3, #0]
  402d8e:	f103 32ff 	add.w	r2, r3, #4294967295
  402d92:	f24a 534c 	movw	r3, #42316	; 0xa54c
  402d96:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402d9a:	601a      	str	r2, [r3, #0]
			ucMaxPriorityValue <<= ( unsigned char ) 0x01;
  402d9c:	79fb      	ldrb	r3, [r7, #7]
  402d9e:	b2db      	uxtb	r3, r3
  402da0:	ea4f 0343 	mov.w	r3, r3, lsl #1
  402da4:	b2db      	uxtb	r3, r3
  402da6:	71fb      	strb	r3, [r7, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  402da8:	79fb      	ldrb	r3, [r7, #7]
  402daa:	b2db      	uxtb	r3, r3
  402dac:	b2db      	uxtb	r3, r3
  402dae:	b25b      	sxtb	r3, r3
  402db0:	2b00      	cmp	r3, #0
  402db2:	dbe7      	blt.n	402d84 <xPortStartScheduler+0x4c>
			ucMaxPriorityValue <<= ( unsigned char ) 0x01;
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
  402db4:	f24a 534c 	movw	r3, #42316	; 0xa54c
  402db8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402dbc:	681b      	ldr	r3, [r3, #0]
  402dbe:	ea4f 2203 	mov.w	r2, r3, lsl #8
  402dc2:	f24a 534c 	movw	r3, #42316	; 0xa54c
  402dc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402dca:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
  402dcc:	f24a 534c 	movw	r3, #42316	; 0xa54c
  402dd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402dd4:	681b      	ldr	r3, [r3, #0]
  402dd6:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  402dda:	f24a 534c 	movw	r3, #42316	; 0xa54c
  402dde:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402de2:	601a      	str	r2, [r3, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pcFirstUserPriorityRegister = ulOriginalPriority;
  402de4:	68bb      	ldr	r3, [r7, #8]
  402de6:	b2da      	uxtb	r2, r3
  402de8:	68fb      	ldr	r3, [r7, #12]
  402dea:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  402dec:	f64e 5320 	movw	r3, #60704	; 0xed20
  402df0:	f2ce 0300 	movt	r3, #57344	; 0xe000
  402df4:	f64e 5220 	movw	r2, #60704	; 0xed20
  402df8:	f2ce 0200 	movt	r2, #57344	; 0xe000
  402dfc:	6812      	ldr	r2, [r2, #0]
  402dfe:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
  402e02:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  402e04:	f64e 5320 	movw	r3, #60704	; 0xed20
  402e08:	f2ce 0300 	movt	r3, #57344	; 0xe000
  402e0c:	f64e 5220 	movw	r2, #60704	; 0xed20
  402e10:	f2ce 0200 	movt	r2, #57344	; 0xe000
  402e14:	6812      	ldr	r2, [r2, #0]
  402e16:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
  402e1a:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
  402e1c:	f642 7379 	movw	r3, #12153	; 0x2f79
  402e20:	f2c0 0340 	movt	r3, #64	; 0x40
  402e24:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  402e26:	f240 0314 	movw	r3, #20
  402e2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402e2e:	f04f 0200 	mov.w	r2, #0
  402e32:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
  402e34:	f642 5325 	movw	r3, #11557	; 0x2d25
  402e38:	f2c0 0340 	movt	r3, #64	; 0x40
  402e3c:	4798      	blx	r3

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
  402e3e:	f642 43d9 	movw	r3, #11481	; 0x2cd9
  402e42:	f2c0 0340 	movt	r3, #64	; 0x40
  402e46:	4798      	blx	r3

	/* Should not get here! */
	return 0;
  402e48:	f04f 0300 	mov.w	r3, #0
}
  402e4c:	4618      	mov	r0, r3
  402e4e:	f107 0710 	add.w	r7, r7, #16
  402e52:	46bd      	mov	sp, r7
  402e54:	bd80      	pop	{r7, pc}
  402e56:	bf00      	nop

00402e58 <vPortYield>:
	is nothing to return to.  */
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
  402e58:	b480      	push	{r7}
  402e5a:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  402e5c:	f64e 5304 	movw	r3, #60676	; 0xed04
  402e60:	f2ce 0300 	movt	r3, #57344	; 0xe000
  402e64:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402e68:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
  402e6a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
  402e6e:	f3bf 8f6f 	isb	sy
}
  402e72:	46bd      	mov	sp, r7
  402e74:	bc80      	pop	{r7}
  402e76:	4770      	bx	lr

00402e78 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
  402e78:	b580      	push	{r7, lr}
  402e7a:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
  402e7c:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  402e80:	f2c0 0340 	movt	r3, #64	; 0x40
  402e84:	4798      	blx	r3
	uxCriticalNesting++;
  402e86:	f240 0314 	movw	r3, #20
  402e8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402e8e:	681b      	ldr	r3, [r3, #0]
  402e90:	f103 0201 	add.w	r2, r3, #1
  402e94:	f240 0314 	movw	r3, #20
  402e98:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402e9c:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" );
  402e9e:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
  402ea2:	f3bf 8f6f 	isb	sy
}
  402ea6:	bd80      	pop	{r7, pc}

00402ea8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
  402ea8:	b580      	push	{r7, lr}
  402eaa:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
  402eac:	f240 0314 	movw	r3, #20
  402eb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402eb4:	681b      	ldr	r3, [r3, #0]
  402eb6:	f103 32ff 	add.w	r2, r3, #4294967295
  402eba:	f240 0314 	movw	r3, #20
  402ebe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402ec2:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
  402ec4:	f240 0314 	movw	r3, #20
  402ec8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402ecc:	681b      	ldr	r3, [r3, #0]
  402ece:	2b00      	cmp	r3, #0
  402ed0:	d106      	bne.n	402ee0 <vPortExitCritical+0x38>
	{
		portENABLE_INTERRUPTS();
  402ed2:	f04f 0000 	mov.w	r0, #0
  402ed6:	f642 63f9 	movw	r3, #12025	; 0x2ef9
  402eda:	f2c0 0340 	movt	r3, #64	; 0x40
  402ede:	4798      	blx	r3
	}
}
  402ee0:	bd80      	pop	{r7, pc}
  402ee2:	bf00      	nop

00402ee4 <ulPortSetInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
  402ee4:	f3ef 8011 	mrs	r0, BASEPRI
  402ee8:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  402eec:	f381 8811 	msr	BASEPRI, r1
  402ef0:	4770      	bx	lr
		:: "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "r0", "r1"	\
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
  402ef2:	f04f 0300 	mov.w	r3, #0
}
  402ef6:	4618      	mov	r0, r3

00402ef8 <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
  402ef8:	f380 8811 	msr	BASEPRI, r0
  402efc:	4770      	bx	lr
  402efe:	bf00      	nop

00402f00 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
  402f00:	f3ef 8009 	mrs	r0, PSP
  402f04:	4b0c      	ldr	r3, [pc, #48]	; (402f38 <pxCurrentTCBConst>)
  402f06:	681a      	ldr	r2, [r3, #0]
  402f08:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  402f0c:	6010      	str	r0, [r2, #0]
  402f0e:	e92d 4008 	stmdb	sp!, {r3, lr}
  402f12:	f04f 00a0 	mov.w	r0, #160	; 0xa0
  402f16:	f380 8811 	msr	BASEPRI, r0
  402f1a:	f001 ff39 	bl	404d90 <vTaskSwitchContext>
  402f1e:	f04f 0000 	mov.w	r0, #0
  402f22:	f380 8811 	msr	BASEPRI, r0
  402f26:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  402f2a:	6819      	ldr	r1, [r3, #0]
  402f2c:	6808      	ldr	r0, [r1, #0]
  402f2e:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  402f32:	f380 8809 	msr	PSP, r0
  402f36:	4770      	bx	lr

00402f38 <pxCurrentTCBConst>:
  402f38:	2000a550 	.word	0x2000a550

00402f3c <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
  402f3c:	b580      	push	{r7, lr}
  402f3e:	af00      	add	r7, sp, #0
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
  402f40:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  402f44:	f2c0 0340 	movt	r3, #64	; 0x40
  402f48:	4798      	blx	r3
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
  402f4a:	f644 330d 	movw	r3, #19213	; 0x4b0d
  402f4e:	f2c0 0340 	movt	r3, #64	; 0x40
  402f52:	4798      	blx	r3
  402f54:	4603      	mov	r3, r0
  402f56:	2b00      	cmp	r3, #0
  402f58:	d006      	beq.n	402f68 <SysTick_Handler+0x2c>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  402f5a:	f64e 5304 	movw	r3, #60676	; 0xed04
  402f5e:	f2ce 0300 	movt	r3, #57344	; 0xe000
  402f62:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402f66:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
  402f68:	f04f 0000 	mov.w	r0, #0
  402f6c:	f642 63f9 	movw	r3, #12025	; 0x2ef9
  402f70:	f2c0 0340 	movt	r3, #64	; 0x40
  402f74:	4798      	blx	r3
}
  402f76:	bd80      	pop	{r7, pc}

00402f78 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
  402f78:	b480      	push	{r7}
  402f7a:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
  402f7c:	f24e 0314 	movw	r3, #57364	; 0xe014
  402f80:	f2ce 0300 	movt	r3, #57344	; 0xe000
  402f84:	f240 0210 	movw	r2, #16
  402f88:	f2c2 0200 	movt	r2, #8192	; 0x2000
  402f8c:	6811      	ldr	r1, [r2, #0]
  402f8e:	f644 52d3 	movw	r2, #19923	; 0x4dd3
  402f92:	f2c1 0262 	movt	r2, #4194	; 0x1062
  402f96:	fba2 0201 	umull	r0, r2, r2, r1
  402f9a:	ea4f 1292 	mov.w	r2, r2, lsr #6
  402f9e:	f102 32ff 	add.w	r2, r2, #4294967295
  402fa2:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
  402fa4:	f24e 0310 	movw	r3, #57360	; 0xe010
  402fa8:	f2ce 0300 	movt	r3, #57344	; 0xe000
  402fac:	f04f 0207 	mov.w	r2, #7
  402fb0:	601a      	str	r2, [r3, #0]
}
  402fb2:	46bd      	mov	sp, r7
  402fb4:	bc80      	pop	{r7}
  402fb6:	4770      	bx	lr

00402fb8 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
  402fb8:	b590      	push	{r4, r7, lr}
  402fba:	b083      	sub	sp, #12
  402fbc:	af00      	add	r7, sp, #0
	unsigned long ulCurrentInterrupt;
	unsigned char ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
  402fbe:	f3ef 8405 	mrs	r4, IPSR
  402fc2:	607c      	str	r4, [r7, #4]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
  402fc4:	687b      	ldr	r3, [r7, #4]
  402fc6:	2b0f      	cmp	r3, #15
  402fc8:	d916      	bls.n	402ff8 <vPortValidateInterruptPriority+0x40>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
  402fca:	f249 63a0 	movw	r3, #38560	; 0x96a0
  402fce:	f2c0 0340 	movt	r3, #64	; 0x40
  402fd2:	681a      	ldr	r2, [r3, #0]
  402fd4:	687b      	ldr	r3, [r7, #4]
  402fd6:	18d3      	adds	r3, r2, r3
  402fd8:	781b      	ldrb	r3, [r3, #0]
  402fda:	70fb      	strb	r3, [r7, #3]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
  402fdc:	f24a 5348 	movw	r3, #42312	; 0xa548
  402fe0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402fe4:	781b      	ldrb	r3, [r3, #0]
  402fe6:	78fa      	ldrb	r2, [r7, #3]
  402fe8:	429a      	cmp	r2, r3
  402fea:	d205      	bcs.n	402ff8 <vPortValidateInterruptPriority+0x40>
  402fec:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  402ff0:	f2c0 0340 	movt	r3, #64	; 0x40
  402ff4:	4798      	blx	r3
  402ff6:	e7fe      	b.n	402ff6 <vPortValidateInterruptPriority+0x3e>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
  402ff8:	f64e 530c 	movw	r3, #60684	; 0xed0c
  402ffc:	f2ce 0300 	movt	r3, #57344	; 0xe000
  403000:	681b      	ldr	r3, [r3, #0]
  403002:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  403006:	f24a 534c 	movw	r3, #42316	; 0xa54c
  40300a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40300e:	681b      	ldr	r3, [r3, #0]
  403010:	429a      	cmp	r2, r3
  403012:	d905      	bls.n	403020 <vPortValidateInterruptPriority+0x68>
  403014:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403018:	f2c0 0340 	movt	r3, #64	; 0x40
  40301c:	4798      	blx	r3
  40301e:	e7fe      	b.n	40301e <vPortValidateInterruptPriority+0x66>
	}
  403020:	f107 070c 	add.w	r7, r7, #12
  403024:	46bd      	mov	sp, r7
  403026:	bd90      	pop	{r4, r7, pc}

00403028 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
  403028:	b580      	push	{r7, lr}
  40302a:	b084      	sub	sp, #16
  40302c:	af00      	add	r7, sp, #0
  40302e:	6078      	str	r0, [r7, #4]
  403030:	6039      	str	r1, [r7, #0]
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  403032:	687b      	ldr	r3, [r7, #4]
  403034:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
  403036:	68fb      	ldr	r3, [r7, #12]
  403038:	2b00      	cmp	r3, #0
  40303a:	d105      	bne.n	403048 <xQueueGenericReset+0x20>
  40303c:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403040:	f2c0 0340 	movt	r3, #64	; 0x40
  403044:	4798      	blx	r3
  403046:	e7fe      	b.n	403046 <xQueueGenericReset+0x1e>

	taskENTER_CRITICAL();
  403048:	f642 6379 	movw	r3, #11897	; 0x2e79
  40304c:	f2c0 0340 	movt	r3, #64	; 0x40
  403050:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  403052:	68fb      	ldr	r3, [r7, #12]
  403054:	681a      	ldr	r2, [r3, #0]
  403056:	68fb      	ldr	r3, [r7, #12]
  403058:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  40305a:	68f9      	ldr	r1, [r7, #12]
  40305c:	6c09      	ldr	r1, [r1, #64]	; 0x40
  40305e:	fb01 f303 	mul.w	r3, r1, r3
  403062:	18d2      	adds	r2, r2, r3
  403064:	68fb      	ldr	r3, [r7, #12]
  403066:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  403068:	68fb      	ldr	r3, [r7, #12]
  40306a:	f04f 0200 	mov.w	r2, #0
  40306e:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  403070:	68fb      	ldr	r3, [r7, #12]
  403072:	681a      	ldr	r2, [r3, #0]
  403074:	68fb      	ldr	r3, [r7, #12]
  403076:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
  403078:	68fb      	ldr	r3, [r7, #12]
  40307a:	681a      	ldr	r2, [r3, #0]
  40307c:	68fb      	ldr	r3, [r7, #12]
  40307e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  403080:	f103 33ff 	add.w	r3, r3, #4294967295
  403084:	68f9      	ldr	r1, [r7, #12]
  403086:	6c09      	ldr	r1, [r1, #64]	; 0x40
  403088:	fb01 f303 	mul.w	r3, r1, r3
  40308c:	18d2      	adds	r2, r2, r3
  40308e:	68fb      	ldr	r3, [r7, #12]
  403090:	60da      	str	r2, [r3, #12]
		pxQueue->xRxLock = queueUNLOCKED;
  403092:	68fb      	ldr	r3, [r7, #12]
  403094:	f04f 32ff 	mov.w	r2, #4294967295
  403098:	645a      	str	r2, [r3, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
  40309a:	68fb      	ldr	r3, [r7, #12]
  40309c:	f04f 32ff 	mov.w	r2, #4294967295
  4030a0:	649a      	str	r2, [r3, #72]	; 0x48

		if( xNewQueue == pdFALSE )
  4030a2:	683b      	ldr	r3, [r7, #0]
  4030a4:	2b00      	cmp	r3, #0
  4030a6:	d115      	bne.n	4030d4 <xQueueGenericReset+0xac>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4030a8:	68fb      	ldr	r3, [r7, #12]
  4030aa:	691b      	ldr	r3, [r3, #16]
  4030ac:	2b00      	cmp	r3, #0
  4030ae:	d023      	beq.n	4030f8 <xQueueGenericReset+0xd0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  4030b0:	68fb      	ldr	r3, [r7, #12]
  4030b2:	f103 0310 	add.w	r3, r3, #16
  4030b6:	4618      	mov	r0, r3
  4030b8:	f245 0375 	movw	r3, #20597	; 0x5075
  4030bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4030c0:	4798      	blx	r3
  4030c2:	4603      	mov	r3, r0
  4030c4:	2b01      	cmp	r3, #1
  4030c6:	d117      	bne.n	4030f8 <xQueueGenericReset+0xd0>
				{
					queueYIELD_IF_USING_PREEMPTION();
  4030c8:	f642 6359 	movw	r3, #11865	; 0x2e59
  4030cc:	f2c0 0340 	movt	r3, #64	; 0x40
  4030d0:	4798      	blx	r3
  4030d2:	e011      	b.n	4030f8 <xQueueGenericReset+0xd0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  4030d4:	68fb      	ldr	r3, [r7, #12]
  4030d6:	f103 0310 	add.w	r3, r3, #16
  4030da:	4618      	mov	r0, r3
  4030dc:	f642 3305 	movw	r3, #11013	; 0x2b05
  4030e0:	f2c0 0340 	movt	r3, #64	; 0x40
  4030e4:	4798      	blx	r3
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  4030e6:	68fb      	ldr	r3, [r7, #12]
  4030e8:	f103 0324 	add.w	r3, r3, #36	; 0x24
  4030ec:	4618      	mov	r0, r3
  4030ee:	f642 3305 	movw	r3, #11013	; 0x2b05
  4030f2:	f2c0 0340 	movt	r3, #64	; 0x40
  4030f6:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
  4030f8:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  4030fc:	f2c0 0340 	movt	r3, #64	; 0x40
  403100:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
  403102:	f04f 0301 	mov.w	r3, #1
}
  403106:	4618      	mov	r0, r3
  403108:	f107 0710 	add.w	r7, r7, #16
  40310c:	46bd      	mov	sp, r7
  40310e:	bd80      	pop	{r7, pc}

00403110 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
  403110:	b580      	push	{r7, lr}
  403112:	b088      	sub	sp, #32
  403114:	af00      	add	r7, sp, #0
  403116:	60f8      	str	r0, [r7, #12]
  403118:	60b9      	str	r1, [r7, #8]
  40311a:	4613      	mov	r3, r2
  40311c:	71fb      	strb	r3, [r7, #7]
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
  40311e:	f04f 0300 	mov.w	r3, #0
  403122:	61fb      	str	r3, [r7, #28]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  403124:	68fb      	ldr	r3, [r7, #12]
  403126:	2b00      	cmp	r3, #0
  403128:	d039      	beq.n	40319e <xQueueGenericCreate+0x8e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  40312a:	f04f 0050 	mov.w	r0, #80	; 0x50
  40312e:	f240 5345 	movw	r3, #1349	; 0x545
  403132:	f2c0 0340 	movt	r3, #64	; 0x40
  403136:	4798      	blx	r3
  403138:	61b8      	str	r0, [r7, #24]
		if( pxNewQueue != NULL )
  40313a:	69bb      	ldr	r3, [r7, #24]
  40313c:	2b00      	cmp	r3, #0
  40313e:	d02e      	beq.n	40319e <xQueueGenericCreate+0x8e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  403140:	68fb      	ldr	r3, [r7, #12]
  403142:	68ba      	ldr	r2, [r7, #8]
  403144:	fb02 f303 	mul.w	r3, r2, r3
  403148:	f103 0301 	add.w	r3, r3, #1
  40314c:	617b      	str	r3, [r7, #20]

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  40314e:	6978      	ldr	r0, [r7, #20]
  403150:	f240 5345 	movw	r3, #1349	; 0x545
  403154:	f2c0 0340 	movt	r3, #64	; 0x40
  403158:	4798      	blx	r3
  40315a:	4602      	mov	r2, r0
  40315c:	69bb      	ldr	r3, [r7, #24]
  40315e:	601a      	str	r2, [r3, #0]
			if( pxNewQueue->pcHead != NULL )
  403160:	69bb      	ldr	r3, [r7, #24]
  403162:	681b      	ldr	r3, [r3, #0]
  403164:	2b00      	cmp	r3, #0
  403166:	d014      	beq.n	403192 <xQueueGenericCreate+0x82>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
  403168:	69bb      	ldr	r3, [r7, #24]
  40316a:	68fa      	ldr	r2, [r7, #12]
  40316c:	63da      	str	r2, [r3, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
  40316e:	69bb      	ldr	r3, [r7, #24]
  403170:	68ba      	ldr	r2, [r7, #8]
  403172:	641a      	str	r2, [r3, #64]	; 0x40
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  403174:	69b8      	ldr	r0, [r7, #24]
  403176:	f04f 0101 	mov.w	r1, #1
  40317a:	f243 0329 	movw	r3, #12329	; 0x3029
  40317e:	f2c0 0340 	movt	r3, #64	; 0x40
  403182:	4798      	blx	r3
				}
				#endif /* configUSE_TRACE_FACILITY */

				#if( configUSE_QUEUE_SETS == 1 )
				{
					pxNewQueue->pxQueueSetContainer = NULL;
  403184:	69bb      	ldr	r3, [r7, #24]
  403186:	f04f 0200 	mov.w	r2, #0
  40318a:	64da      	str	r2, [r3, #76]	; 0x4c
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
  40318c:	69bb      	ldr	r3, [r7, #24]
  40318e:	61fb      	str	r3, [r7, #28]
  403190:	e005      	b.n	40319e <xQueueGenericCreate+0x8e>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
  403192:	69b8      	ldr	r0, [r7, #24]
  403194:	f240 63c5 	movw	r3, #1733	; 0x6c5
  403198:	f2c0 0340 	movt	r3, #64	; 0x40
  40319c:	4798      	blx	r3
			}
		}
	}

	configASSERT( xReturn );
  40319e:	69fb      	ldr	r3, [r7, #28]
  4031a0:	2b00      	cmp	r3, #0
  4031a2:	d105      	bne.n	4031b0 <xQueueGenericCreate+0xa0>
  4031a4:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4031a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4031ac:	4798      	blx	r3
  4031ae:	e7fe      	b.n	4031ae <xQueueGenericCreate+0x9e>

	return xReturn;
  4031b0:	69fb      	ldr	r3, [r7, #28]
}
  4031b2:	4618      	mov	r0, r3
  4031b4:	f107 0720 	add.w	r7, r7, #32
  4031b8:	46bd      	mov	sp, r7
  4031ba:	bd80      	pop	{r7, pc}

004031bc <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
  4031bc:	b590      	push	{r4, r7, lr}
  4031be:	b085      	sub	sp, #20
  4031c0:	af00      	add	r7, sp, #0
  4031c2:	4603      	mov	r3, r0
  4031c4:	71fb      	strb	r3, [r7, #7]
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  4031c6:	f04f 0050 	mov.w	r0, #80	; 0x50
  4031ca:	f240 5345 	movw	r3, #1349	; 0x545
  4031ce:	f2c0 0340 	movt	r3, #64	; 0x40
  4031d2:	4798      	blx	r3
  4031d4:	60f8      	str	r0, [r7, #12]
		if( pxNewQueue != NULL )
  4031d6:	68fb      	ldr	r3, [r7, #12]
  4031d8:	2b00      	cmp	r3, #0
  4031da:	d045      	beq.n	403268 <xQueueCreateMutex+0xac>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
  4031dc:	68fb      	ldr	r3, [r7, #12]
  4031de:	f04f 0200 	mov.w	r2, #0
  4031e2:	605a      	str	r2, [r3, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
  4031e4:	68fb      	ldr	r3, [r7, #12]
  4031e6:	f04f 0200 	mov.w	r2, #0
  4031ea:	601a      	str	r2, [r3, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
  4031ec:	68fb      	ldr	r3, [r7, #12]
  4031ee:	f04f 0200 	mov.w	r2, #0
  4031f2:	609a      	str	r2, [r3, #8]
			pxNewQueue->u.pcReadFrom = NULL;
  4031f4:	68fb      	ldr	r3, [r7, #12]
  4031f6:	f04f 0200 	mov.w	r2, #0
  4031fa:	60da      	str	r2, [r3, #12]

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  4031fc:	68fb      	ldr	r3, [r7, #12]
  4031fe:	f04f 0200 	mov.w	r2, #0
  403202:	639a      	str	r2, [r3, #56]	; 0x38
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
  403204:	68fb      	ldr	r3, [r7, #12]
  403206:	f04f 0201 	mov.w	r2, #1
  40320a:	63da      	str	r2, [r3, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
  40320c:	68fb      	ldr	r3, [r7, #12]
  40320e:	f04f 0200 	mov.w	r2, #0
  403212:	641a      	str	r2, [r3, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
  403214:	68fb      	ldr	r3, [r7, #12]
  403216:	f04f 32ff 	mov.w	r2, #4294967295
  40321a:	645a      	str	r2, [r3, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
  40321c:	68fb      	ldr	r3, [r7, #12]
  40321e:	f04f 32ff 	mov.w	r2, #4294967295
  403222:	649a      	str	r2, [r3, #72]	; 0x48
			}
			#endif

			#if ( configUSE_QUEUE_SETS == 1 )
			{
				pxNewQueue->pxQueueSetContainer = NULL;
  403224:	68fb      	ldr	r3, [r7, #12]
  403226:	f04f 0200 	mov.w	r2, #0
  40322a:	64da      	str	r2, [r3, #76]	; 0x4c
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
  40322c:	68fb      	ldr	r3, [r7, #12]
  40322e:	f103 0310 	add.w	r3, r3, #16
  403232:	4618      	mov	r0, r3
  403234:	f642 3305 	movw	r3, #11013	; 0x2b05
  403238:	f2c0 0340 	movt	r3, #64	; 0x40
  40323c:	4798      	blx	r3
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
  40323e:	68fb      	ldr	r3, [r7, #12]
  403240:	f103 0324 	add.w	r3, r3, #36	; 0x24
  403244:	4618      	mov	r0, r3
  403246:	f642 3305 	movw	r3, #11013	; 0x2b05
  40324a:	f2c0 0340 	movt	r3, #64	; 0x40
  40324e:	4798      	blx	r3

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
  403250:	68f8      	ldr	r0, [r7, #12]
  403252:	f04f 0100 	mov.w	r1, #0
  403256:	f04f 0200 	mov.w	r2, #0
  40325a:	f04f 0300 	mov.w	r3, #0
  40325e:	f243 34f1 	movw	r4, #13297	; 0x33f1
  403262:	f2c0 0440 	movt	r4, #64	; 0x40
  403266:	47a0      	blx	r4
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
  403268:	68fb      	ldr	r3, [r7, #12]
  40326a:	2b00      	cmp	r3, #0
  40326c:	d105      	bne.n	40327a <xQueueCreateMutex+0xbe>
  40326e:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403272:	f2c0 0340 	movt	r3, #64	; 0x40
  403276:	4798      	blx	r3
  403278:	e7fe      	b.n	403278 <xQueueCreateMutex+0xbc>
		return pxNewQueue;
  40327a:	68fb      	ldr	r3, [r7, #12]
	}
  40327c:	4618      	mov	r0, r3
  40327e:	f107 0714 	add.w	r7, r7, #20
  403282:	46bd      	mov	sp, r7
  403284:	bd90      	pop	{r4, r7, pc}
  403286:	bf00      	nop

00403288 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex )
	{
  403288:	b590      	push	{r4, r7, lr}
  40328a:	b085      	sub	sp, #20
  40328c:	af00      	add	r7, sp, #0
  40328e:	6078      	str	r0, [r7, #4]
	portBASE_TYPE xReturn;
	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
  403290:	687b      	ldr	r3, [r7, #4]
  403292:	60bb      	str	r3, [r7, #8]

		configASSERT( pxMutex );
  403294:	68bb      	ldr	r3, [r7, #8]
  403296:	2b00      	cmp	r3, #0
  403298:	d105      	bne.n	4032a6 <xQueueGiveMutexRecursive+0x1e>
  40329a:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  40329e:	f2c0 0340 	movt	r3, #64	; 0x40
  4032a2:	4798      	blx	r3
  4032a4:	e7fe      	b.n	4032a4 <xQueueGiveMutexRecursive+0x1c>
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as xTaskHandle is a typedef. */
  4032a6:	68bb      	ldr	r3, [r7, #8]
  4032a8:	685c      	ldr	r4, [r3, #4]
  4032aa:	f245 6345 	movw	r3, #22085	; 0x5645
  4032ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4032b2:	4798      	blx	r3
  4032b4:	4603      	mov	r3, r0
  4032b6:	429c      	cmp	r4, r3
  4032b8:	d119      	bne.n	4032ee <xQueueGiveMutexRecursive+0x66>
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.uxRecursiveCallCount )--;
  4032ba:	68bb      	ldr	r3, [r7, #8]
  4032bc:	68db      	ldr	r3, [r3, #12]
  4032be:	f103 32ff 	add.w	r2, r3, #4294967295
  4032c2:	68bb      	ldr	r3, [r7, #8]
  4032c4:	60da      	str	r2, [r3, #12]

			/* Have we unwound the call count? */
			if( pxMutex->u.uxRecursiveCallCount == ( unsigned portBASE_TYPE ) 0 )
  4032c6:	68bb      	ldr	r3, [r7, #8]
  4032c8:	68db      	ldr	r3, [r3, #12]
  4032ca:	2b00      	cmp	r3, #0
  4032cc:	d10b      	bne.n	4032e6 <xQueueGiveMutexRecursive+0x5e>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
  4032ce:	68b8      	ldr	r0, [r7, #8]
  4032d0:	f04f 0100 	mov.w	r1, #0
  4032d4:	f04f 0200 	mov.w	r2, #0
  4032d8:	f04f 0300 	mov.w	r3, #0
  4032dc:	f243 34f1 	movw	r4, #13297	; 0x33f1
  4032e0:	f2c0 0440 	movt	r4, #64	; 0x40
  4032e4:	47a0      	blx	r4
			}

			xReturn = pdPASS;
  4032e6:	f04f 0301 	mov.w	r3, #1
  4032ea:	60fb      	str	r3, [r7, #12]
  4032ec:	e002      	b.n	4032f4 <xQueueGiveMutexRecursive+0x6c>
		}
		else
		{
			/* We cannot give the mutex because we are not the holder. */
			xReturn = pdFAIL;
  4032ee:	f04f 0300 	mov.w	r3, #0
  4032f2:	60fb      	str	r3, [r7, #12]

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
  4032f4:	68fb      	ldr	r3, [r7, #12]
	}
  4032f6:	4618      	mov	r0, r3
  4032f8:	f107 0714 	add.w	r7, r7, #20
  4032fc:	46bd      	mov	sp, r7
  4032fe:	bd90      	pop	{r4, r7, pc}

00403300 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime )
	{
  403300:	b590      	push	{r4, r7, lr}
  403302:	b085      	sub	sp, #20
  403304:	af00      	add	r7, sp, #0
  403306:	6078      	str	r0, [r7, #4]
  403308:	6039      	str	r1, [r7, #0]
	portBASE_TYPE xReturn;
	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
  40330a:	687b      	ldr	r3, [r7, #4]
  40330c:	60bb      	str	r3, [r7, #8]

		configASSERT( pxMutex );
  40330e:	68bb      	ldr	r3, [r7, #8]
  403310:	2b00      	cmp	r3, #0
  403312:	d105      	bne.n	403320 <xQueueTakeMutexRecursive+0x20>
  403314:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403318:	f2c0 0340 	movt	r3, #64	; 0x40
  40331c:	4798      	blx	r3
  40331e:	e7fe      	b.n	40331e <xQueueTakeMutexRecursive+0x1e>
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
  403320:	68bb      	ldr	r3, [r7, #8]
  403322:	685c      	ldr	r4, [r3, #4]
  403324:	f245 6345 	movw	r3, #22085	; 0x5645
  403328:	f2c0 0340 	movt	r3, #64	; 0x40
  40332c:	4798      	blx	r3
  40332e:	4603      	mov	r3, r0
  403330:	429c      	cmp	r4, r3
  403332:	d109      	bne.n	403348 <xQueueTakeMutexRecursive+0x48>
		{
			( pxMutex->u.uxRecursiveCallCount )++;
  403334:	68bb      	ldr	r3, [r7, #8]
  403336:	68db      	ldr	r3, [r3, #12]
  403338:	f103 0201 	add.w	r2, r3, #1
  40333c:	68bb      	ldr	r3, [r7, #8]
  40333e:	60da      	str	r2, [r3, #12]
			xReturn = pdPASS;
  403340:	f04f 0301 	mov.w	r3, #1
  403344:	60fb      	str	r3, [r7, #12]
  403346:	e014      	b.n	403372 <xQueueTakeMutexRecursive+0x72>
		}
		else
		{
			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
  403348:	68b8      	ldr	r0, [r7, #8]
  40334a:	f04f 0100 	mov.w	r1, #0
  40334e:	683a      	ldr	r2, [r7, #0]
  403350:	f04f 0300 	mov.w	r3, #0
  403354:	f243 7469 	movw	r4, #14185	; 0x3769
  403358:	f2c0 0440 	movt	r4, #64	; 0x40
  40335c:	47a0      	blx	r4
  40335e:	60f8      	str	r0, [r7, #12]

			/* pdPASS will only be returned if we successfully obtained the mutex,
			we may have blocked to reach here. */
			if( xReturn == pdPASS )
  403360:	68fb      	ldr	r3, [r7, #12]
  403362:	2b01      	cmp	r3, #1
  403364:	d105      	bne.n	403372 <xQueueTakeMutexRecursive+0x72>
			{
				( pxMutex->u.uxRecursiveCallCount )++;
  403366:	68bb      	ldr	r3, [r7, #8]
  403368:	68db      	ldr	r3, [r3, #12]
  40336a:	f103 0201 	add.w	r2, r3, #1
  40336e:	68bb      	ldr	r3, [r7, #8]
  403370:	60da      	str	r2, [r3, #12]
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
  403372:	68fb      	ldr	r3, [r7, #12]
	}
  403374:	4618      	mov	r0, r3
  403376:	f107 0714 	add.w	r7, r7, #20
  40337a:	46bd      	mov	sp, r7
  40337c:	bd90      	pop	{r4, r7, pc}
  40337e:	bf00      	nop

00403380 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxMaxCount, unsigned portBASE_TYPE uxInitialCount )
	{
  403380:	b580      	push	{r7, lr}
  403382:	b084      	sub	sp, #16
  403384:	af00      	add	r7, sp, #0
  403386:	6078      	str	r0, [r7, #4]
  403388:	6039      	str	r1, [r7, #0]
	xQueueHandle xHandle;

		configASSERT( uxMaxCount != 0 );
  40338a:	687b      	ldr	r3, [r7, #4]
  40338c:	2b00      	cmp	r3, #0
  40338e:	d105      	bne.n	40339c <xQueueCreateCountingSemaphore+0x1c>
  403390:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403394:	f2c0 0340 	movt	r3, #64	; 0x40
  403398:	4798      	blx	r3
  40339a:	e7fe      	b.n	40339a <xQueueCreateCountingSemaphore+0x1a>
		configASSERT( uxInitialCount <= uxMaxCount );
  40339c:	683a      	ldr	r2, [r7, #0]
  40339e:	687b      	ldr	r3, [r7, #4]
  4033a0:	429a      	cmp	r2, r3
  4033a2:	d905      	bls.n	4033b0 <xQueueCreateCountingSemaphore+0x30>
  4033a4:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4033a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4033ac:	4798      	blx	r3
  4033ae:	e7fe      	b.n	4033ae <xQueueCreateCountingSemaphore+0x2e>

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
  4033b0:	6878      	ldr	r0, [r7, #4]
  4033b2:	f04f 0100 	mov.w	r1, #0
  4033b6:	f04f 0202 	mov.w	r2, #2
  4033ba:	f243 1311 	movw	r3, #12561	; 0x3111
  4033be:	f2c0 0340 	movt	r3, #64	; 0x40
  4033c2:	4798      	blx	r3
  4033c4:	60f8      	str	r0, [r7, #12]

		if( xHandle != NULL )
  4033c6:	68fb      	ldr	r3, [r7, #12]
  4033c8:	2b00      	cmp	r3, #0
  4033ca:	d002      	beq.n	4033d2 <xQueueCreateCountingSemaphore+0x52>
		{
			( ( xQUEUE * ) xHandle )->uxMessagesWaiting = uxInitialCount;
  4033cc:	68fb      	ldr	r3, [r7, #12]
  4033ce:	683a      	ldr	r2, [r7, #0]
  4033d0:	639a      	str	r2, [r3, #56]	; 0x38
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
  4033d2:	68fb      	ldr	r3, [r7, #12]
  4033d4:	2b00      	cmp	r3, #0
  4033d6:	d105      	bne.n	4033e4 <xQueueCreateCountingSemaphore+0x64>
  4033d8:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4033dc:	f2c0 0340 	movt	r3, #64	; 0x40
  4033e0:	4798      	blx	r3
  4033e2:	e7fe      	b.n	4033e2 <xQueueCreateCountingSemaphore+0x62>
		return xHandle;
  4033e4:	68fb      	ldr	r3, [r7, #12]
	}
  4033e6:	4618      	mov	r0, r3
  4033e8:	f107 0710 	add.w	r7, r7, #16
  4033ec:	46bd      	mov	sp, r7
  4033ee:	bd80      	pop	{r7, pc}

004033f0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  4033f0:	b580      	push	{r7, lr}
  4033f2:	b088      	sub	sp, #32
  4033f4:	af00      	add	r7, sp, #0
  4033f6:	60f8      	str	r0, [r7, #12]
  4033f8:	60b9      	str	r1, [r7, #8]
  4033fa:	607a      	str	r2, [r7, #4]
  4033fc:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  4033fe:	f04f 0300 	mov.w	r3, #0
  403402:	61fb      	str	r3, [r7, #28]
xTimeOutType xTimeOut;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  403404:	68fb      	ldr	r3, [r7, #12]
  403406:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
  403408:	69bb      	ldr	r3, [r7, #24]
  40340a:	2b00      	cmp	r3, #0
  40340c:	d105      	bne.n	40341a <xQueueGenericSend+0x2a>
  40340e:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403412:	f2c0 0340 	movt	r3, #64	; 0x40
  403416:	4798      	blx	r3
  403418:	e7fe      	b.n	403418 <xQueueGenericSend+0x28>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  40341a:	68bb      	ldr	r3, [r7, #8]
  40341c:	2b00      	cmp	r3, #0
  40341e:	d103      	bne.n	403428 <xQueueGenericSend+0x38>
  403420:	69bb      	ldr	r3, [r7, #24]
  403422:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  403424:	2b00      	cmp	r3, #0
  403426:	d102      	bne.n	40342e <xQueueGenericSend+0x3e>
  403428:	f04f 0301 	mov.w	r3, #1
  40342c:	e001      	b.n	403432 <xQueueGenericSend+0x42>
  40342e:	f04f 0300 	mov.w	r3, #0
  403432:	2b00      	cmp	r3, #0
  403434:	d105      	bne.n	403442 <xQueueGenericSend+0x52>
  403436:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  40343a:	f2c0 0340 	movt	r3, #64	; 0x40
  40343e:	4798      	blx	r3
  403440:	e7fe      	b.n	403440 <xQueueGenericSend+0x50>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  403442:	683b      	ldr	r3, [r7, #0]
  403444:	2b02      	cmp	r3, #2
  403446:	d103      	bne.n	403450 <xQueueGenericSend+0x60>
  403448:	69bb      	ldr	r3, [r7, #24]
  40344a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  40344c:	2b01      	cmp	r3, #1
  40344e:	d102      	bne.n	403456 <xQueueGenericSend+0x66>
  403450:	f04f 0301 	mov.w	r3, #1
  403454:	e001      	b.n	40345a <xQueueGenericSend+0x6a>
  403456:	f04f 0300 	mov.w	r3, #0
  40345a:	2b00      	cmp	r3, #0
  40345c:	d106      	bne.n	40346c <xQueueGenericSend+0x7c>
  40345e:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403462:	f2c0 0340 	movt	r3, #64	; 0x40
  403466:	4798      	blx	r3
  403468:	e7fe      	b.n	403468 <xQueueGenericSend+0x78>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
  40346a:	bf00      	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  40346c:	f642 6379 	movw	r3, #11897	; 0x2e79
  403470:	f2c0 0340 	movt	r3, #64	; 0x40
  403474:	4798      	blx	r3
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  403476:	69bb      	ldr	r3, [r7, #24]
  403478:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40347a:	69bb      	ldr	r3, [r7, #24]
  40347c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  40347e:	429a      	cmp	r2, r3
  403480:	d302      	bcc.n	403488 <xQueueGenericSend+0x98>
  403482:	683b      	ldr	r3, [r7, #0]
  403484:	2b02      	cmp	r3, #2
  403486:	d138      	bne.n	4034fa <xQueueGenericSend+0x10a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  403488:	69b8      	ldr	r0, [r7, #24]
  40348a:	68b9      	ldr	r1, [r7, #8]
  40348c:	683a      	ldr	r2, [r7, #0]
  40348e:	f643 23fd 	movw	r3, #15101	; 0x3afd
  403492:	f2c0 0340 	movt	r3, #64	; 0x40
  403496:	4798      	blx	r3

				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
  403498:	69bb      	ldr	r3, [r7, #24]
  40349a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  40349c:	2b00      	cmp	r3, #0
  40349e:	d00f      	beq.n	4034c0 <xQueueGenericSend+0xd0>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
  4034a0:	69b8      	ldr	r0, [r7, #24]
  4034a2:	6839      	ldr	r1, [r7, #0]
  4034a4:	f643 7381 	movw	r3, #16257	; 0x3f81
  4034a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4034ac:	4798      	blx	r3
  4034ae:	4603      	mov	r3, r0
  4034b0:	2b01      	cmp	r3, #1
  4034b2:	d11a      	bne.n	4034ea <xQueueGenericSend+0xfa>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock. A context switch is required. */
							queueYIELD_IF_USING_PREEMPTION();
  4034b4:	f642 6359 	movw	r3, #11865	; 0x2e59
  4034b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4034bc:	4798      	blx	r3
  4034be:	e014      	b.n	4034ea <xQueueGenericSend+0xfa>
					}
					else
					{
						/* If there was a task waiting for data to arrive on the
						queue then unblock it now. */
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4034c0:	69bb      	ldr	r3, [r7, #24]
  4034c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4034c4:	2b00      	cmp	r3, #0
  4034c6:	d010      	beq.n	4034ea <xQueueGenericSend+0xfa>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
  4034c8:	69bb      	ldr	r3, [r7, #24]
  4034ca:	f103 0324 	add.w	r3, r3, #36	; 0x24
  4034ce:	4618      	mov	r0, r3
  4034d0:	f245 0375 	movw	r3, #20597	; 0x5075
  4034d4:	f2c0 0340 	movt	r3, #64	; 0x40
  4034d8:	4798      	blx	r3
  4034da:	4603      	mov	r3, r0
  4034dc:	2b01      	cmp	r3, #1
  4034de:	d104      	bne.n	4034ea <xQueueGenericSend+0xfa>
							{
								/* The unblocked task has a priority higher than
								our own so yield immediately.  Yes it is ok to
								do this from within the critical section - the
								kernel takes care of that. */
								queueYIELD_IF_USING_PREEMPTION();
  4034e0:	f642 6359 	movw	r3, #11865	; 0x2e59
  4034e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4034e8:	4798      	blx	r3
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
  4034ea:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  4034ee:	f2c0 0340 	movt	r3, #64	; 0x40
  4034f2:	4798      	blx	r3

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
  4034f4:	f04f 0301 	mov.w	r3, #1
  4034f8:	e08e      	b.n	403618 <xQueueGenericSend+0x228>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  4034fa:	687b      	ldr	r3, [r7, #4]
  4034fc:	2b00      	cmp	r3, #0
  4034fe:	d107      	bne.n	403510 <xQueueGenericSend+0x120>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  403500:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  403504:	f2c0 0340 	movt	r3, #64	; 0x40
  403508:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  40350a:	f04f 0300 	mov.w	r3, #0
  40350e:	e083      	b.n	403618 <xQueueGenericSend+0x228>
				}
				else if( xEntryTimeSet == pdFALSE )
  403510:	69fb      	ldr	r3, [r7, #28]
  403512:	2b00      	cmp	r3, #0
  403514:	d10a      	bne.n	40352c <xQueueGenericSend+0x13c>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  403516:	f107 0310 	add.w	r3, r7, #16
  40351a:	4618      	mov	r0, r3
  40351c:	f245 1371 	movw	r3, #20849	; 0x5171
  403520:	f2c0 0340 	movt	r3, #64	; 0x40
  403524:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  403526:	f04f 0301 	mov.w	r3, #1
  40352a:	61fb      	str	r3, [r7, #28]
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
  40352c:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  403530:	f2c0 0340 	movt	r3, #64	; 0x40
  403534:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  403536:	f644 03f9 	movw	r3, #18681	; 0x48f9
  40353a:	f2c0 0340 	movt	r3, #64	; 0x40
  40353e:	4798      	blx	r3
		prvLockQueue( pxQueue );
  403540:	f642 6379 	movw	r3, #11897	; 0x2e79
  403544:	f2c0 0340 	movt	r3, #64	; 0x40
  403548:	4798      	blx	r3
  40354a:	69bb      	ldr	r3, [r7, #24]
  40354c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  40354e:	f1b3 3fff 	cmp.w	r3, #4294967295
  403552:	d103      	bne.n	40355c <xQueueGenericSend+0x16c>
  403554:	69bb      	ldr	r3, [r7, #24]
  403556:	f04f 0200 	mov.w	r2, #0
  40355a:	645a      	str	r2, [r3, #68]	; 0x44
  40355c:	69bb      	ldr	r3, [r7, #24]
  40355e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  403560:	f1b3 3fff 	cmp.w	r3, #4294967295
  403564:	d103      	bne.n	40356e <xQueueGenericSend+0x17e>
  403566:	69bb      	ldr	r3, [r7, #24]
  403568:	f04f 0200 	mov.w	r2, #0
  40356c:	649a      	str	r2, [r3, #72]	; 0x48
  40356e:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  403572:	f2c0 0340 	movt	r3, #64	; 0x40
  403576:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  403578:	f107 0210 	add.w	r2, r7, #16
  40357c:	f107 0304 	add.w	r3, r7, #4
  403580:	4610      	mov	r0, r2
  403582:	4619      	mov	r1, r3
  403584:	f245 13b1 	movw	r3, #20913	; 0x51b1
  403588:	f2c0 0340 	movt	r3, #64	; 0x40
  40358c:	4798      	blx	r3
  40358e:	4603      	mov	r3, r0
  403590:	2b00      	cmp	r3, #0
  403592:	d134      	bne.n	4035fe <xQueueGenericSend+0x20e>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  403594:	69b8      	ldr	r0, [r7, #24]
  403596:	f643 537d 	movw	r3, #15741	; 0x3d7d
  40359a:	f2c0 0340 	movt	r3, #64	; 0x40
  40359e:	4798      	blx	r3
  4035a0:	4603      	mov	r3, r0
  4035a2:	2b00      	cmp	r3, #0
  4035a4:	d01f      	beq.n	4035e6 <xQueueGenericSend+0x1f6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  4035a6:	69bb      	ldr	r3, [r7, #24]
  4035a8:	f103 0210 	add.w	r2, r3, #16
  4035ac:	687b      	ldr	r3, [r7, #4]
  4035ae:	4610      	mov	r0, r2
  4035b0:	4619      	mov	r1, r3
  4035b2:	f644 63f1 	movw	r3, #20209	; 0x4ef1
  4035b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4035ba:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  4035bc:	69b8      	ldr	r0, [r7, #24]
  4035be:	f643 4341 	movw	r3, #15425	; 0x3c41
  4035c2:	f2c0 0340 	movt	r3, #64	; 0x40
  4035c6:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  4035c8:	f644 131d 	movw	r3, #18717	; 0x491d
  4035cc:	f2c0 0340 	movt	r3, #64	; 0x40
  4035d0:	4798      	blx	r3
  4035d2:	4603      	mov	r3, r0
  4035d4:	2b00      	cmp	r3, #0
  4035d6:	f47f af48 	bne.w	40346a <xQueueGenericSend+0x7a>
				{
					portYIELD_WITHIN_API();
  4035da:	f642 6359 	movw	r3, #11865	; 0x2e59
  4035de:	f2c0 0340 	movt	r3, #64	; 0x40
  4035e2:	4798      	blx	r3
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
  4035e4:	e741      	b.n	40346a <xQueueGenericSend+0x7a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  4035e6:	69b8      	ldr	r0, [r7, #24]
  4035e8:	f643 4341 	movw	r3, #15425	; 0x3c41
  4035ec:	f2c0 0340 	movt	r3, #64	; 0x40
  4035f0:	4798      	blx	r3
				( void ) xTaskResumeAll();
  4035f2:	f644 131d 	movw	r3, #18717	; 0x491d
  4035f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4035fa:	4798      	blx	r3
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
  4035fc:	e735      	b.n	40346a <xQueueGenericSend+0x7a>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  4035fe:	69b8      	ldr	r0, [r7, #24]
  403600:	f643 4341 	movw	r3, #15425	; 0x3c41
  403604:	f2c0 0340 	movt	r3, #64	; 0x40
  403608:	4798      	blx	r3
			( void ) xTaskResumeAll();
  40360a:	f644 131d 	movw	r3, #18717	; 0x491d
  40360e:	f2c0 0340 	movt	r3, #64	; 0x40
  403612:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  403614:	f04f 0300 	mov.w	r3, #0
		}
	}
}
  403618:	4618      	mov	r0, r3
  40361a:	f107 0720 	add.w	r7, r7, #32
  40361e:	46bd      	mov	sp, r7
  403620:	bd80      	pop	{r7, pc}
  403622:	bf00      	nop

00403624 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
  403624:	b580      	push	{r7, lr}
  403626:	b088      	sub	sp, #32
  403628:	af00      	add	r7, sp, #0
  40362a:	60f8      	str	r0, [r7, #12]
  40362c:	60b9      	str	r1, [r7, #8]
  40362e:	607a      	str	r2, [r7, #4]
  403630:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  403632:	68fb      	ldr	r3, [r7, #12]
  403634:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
  403636:	69bb      	ldr	r3, [r7, #24]
  403638:	2b00      	cmp	r3, #0
  40363a:	d105      	bne.n	403648 <xQueueGenericSendFromISR+0x24>
  40363c:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403640:	f2c0 0340 	movt	r3, #64	; 0x40
  403644:	4798      	blx	r3
  403646:	e7fe      	b.n	403646 <xQueueGenericSendFromISR+0x22>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  403648:	68bb      	ldr	r3, [r7, #8]
  40364a:	2b00      	cmp	r3, #0
  40364c:	d103      	bne.n	403656 <xQueueGenericSendFromISR+0x32>
  40364e:	69bb      	ldr	r3, [r7, #24]
  403650:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  403652:	2b00      	cmp	r3, #0
  403654:	d102      	bne.n	40365c <xQueueGenericSendFromISR+0x38>
  403656:	f04f 0301 	mov.w	r3, #1
  40365a:	e001      	b.n	403660 <xQueueGenericSendFromISR+0x3c>
  40365c:	f04f 0300 	mov.w	r3, #0
  403660:	2b00      	cmp	r3, #0
  403662:	d105      	bne.n	403670 <xQueueGenericSendFromISR+0x4c>
  403664:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403668:	f2c0 0340 	movt	r3, #64	; 0x40
  40366c:	4798      	blx	r3
  40366e:	e7fe      	b.n	40366e <xQueueGenericSendFromISR+0x4a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  403670:	683b      	ldr	r3, [r7, #0]
  403672:	2b02      	cmp	r3, #2
  403674:	d103      	bne.n	40367e <xQueueGenericSendFromISR+0x5a>
  403676:	69bb      	ldr	r3, [r7, #24]
  403678:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  40367a:	2b01      	cmp	r3, #1
  40367c:	d102      	bne.n	403684 <xQueueGenericSendFromISR+0x60>
  40367e:	f04f 0301 	mov.w	r3, #1
  403682:	e001      	b.n	403688 <xQueueGenericSendFromISR+0x64>
  403684:	f04f 0300 	mov.w	r3, #0
  403688:	2b00      	cmp	r3, #0
  40368a:	d105      	bne.n	403698 <xQueueGenericSendFromISR+0x74>
  40368c:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403690:	f2c0 0340 	movt	r3, #64	; 0x40
  403694:	4798      	blx	r3
  403696:	e7fe      	b.n	403696 <xQueueGenericSendFromISR+0x72>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  403698:	f642 73b9 	movw	r3, #12217	; 0x2fb9
  40369c:	f2c0 0340 	movt	r3, #64	; 0x40
  4036a0:	4798      	blx	r3
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  4036a2:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4036a6:	f2c0 0340 	movt	r3, #64	; 0x40
  4036aa:	4798      	blx	r3
  4036ac:	6178      	str	r0, [r7, #20]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  4036ae:	69bb      	ldr	r3, [r7, #24]
  4036b0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  4036b2:	69bb      	ldr	r3, [r7, #24]
  4036b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  4036b6:	429a      	cmp	r2, r3
  4036b8:	d302      	bcc.n	4036c0 <xQueueGenericSendFromISR+0x9c>
  4036ba:	683b      	ldr	r3, [r7, #0]
  4036bc:	2b02      	cmp	r3, #2
  4036be:	d144      	bne.n	40374a <xQueueGenericSendFromISR+0x126>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  4036c0:	69b8      	ldr	r0, [r7, #24]
  4036c2:	68b9      	ldr	r1, [r7, #8]
  4036c4:	683a      	ldr	r2, [r7, #0]
  4036c6:	f643 23fd 	movw	r3, #15101	; 0x3afd
  4036ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4036ce:	4798      	blx	r3

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
  4036d0:	69bb      	ldr	r3, [r7, #24]
  4036d2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  4036d4:	f1b3 3fff 	cmp.w	r3, #4294967295
  4036d8:	d12d      	bne.n	403736 <xQueueGenericSendFromISR+0x112>
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
  4036da:	69bb      	ldr	r3, [r7, #24]
  4036dc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  4036de:	2b00      	cmp	r3, #0
  4036e0:	d011      	beq.n	403706 <xQueueGenericSendFromISR+0xe2>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
  4036e2:	69b8      	ldr	r0, [r7, #24]
  4036e4:	6839      	ldr	r1, [r7, #0]
  4036e6:	f643 7381 	movw	r3, #16257	; 0x3f81
  4036ea:	f2c0 0340 	movt	r3, #64	; 0x40
  4036ee:	4798      	blx	r3
  4036f0:	4603      	mov	r3, r0
  4036f2:	2b01      	cmp	r3, #1
  4036f4:	d125      	bne.n	403742 <xQueueGenericSendFromISR+0x11e>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  4036f6:	687b      	ldr	r3, [r7, #4]
  4036f8:	2b00      	cmp	r3, #0
  4036fa:	d022      	beq.n	403742 <xQueueGenericSendFromISR+0x11e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  4036fc:	687b      	ldr	r3, [r7, #4]
  4036fe:	f04f 0201 	mov.w	r2, #1
  403702:	601a      	str	r2, [r3, #0]
  403704:	e01d      	b.n	403742 <xQueueGenericSendFromISR+0x11e>
							}
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  403706:	69bb      	ldr	r3, [r7, #24]
  403708:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40370a:	2b00      	cmp	r3, #0
  40370c:	d019      	beq.n	403742 <xQueueGenericSendFromISR+0x11e>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  40370e:	69bb      	ldr	r3, [r7, #24]
  403710:	f103 0324 	add.w	r3, r3, #36	; 0x24
  403714:	4618      	mov	r0, r3
  403716:	f245 0375 	movw	r3, #20597	; 0x5075
  40371a:	f2c0 0340 	movt	r3, #64	; 0x40
  40371e:	4798      	blx	r3
  403720:	4603      	mov	r3, r0
  403722:	2b00      	cmp	r3, #0
  403724:	d00d      	beq.n	403742 <xQueueGenericSendFromISR+0x11e>
							{
								/* The task waiting has a higher priority so record that a
								context	switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
  403726:	687b      	ldr	r3, [r7, #4]
  403728:	2b00      	cmp	r3, #0
  40372a:	d00a      	beq.n	403742 <xQueueGenericSendFromISR+0x11e>
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
  40372c:	687b      	ldr	r3, [r7, #4]
  40372e:	f04f 0201 	mov.w	r2, #1
  403732:	601a      	str	r2, [r3, #0]
  403734:	e005      	b.n	403742 <xQueueGenericSendFromISR+0x11e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
  403736:	69bb      	ldr	r3, [r7, #24]
  403738:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  40373a:	f103 0201 	add.w	r2, r3, #1
  40373e:	69bb      	ldr	r3, [r7, #24]
  403740:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
  403742:	f04f 0301 	mov.w	r3, #1
  403746:	61fb      	str	r3, [r7, #28]
  403748:	e002      	b.n	403750 <xQueueGenericSendFromISR+0x12c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  40374a:	f04f 0300 	mov.w	r3, #0
  40374e:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  403750:	6978      	ldr	r0, [r7, #20]
  403752:	f642 63f9 	movw	r3, #12025	; 0x2ef9
  403756:	f2c0 0340 	movt	r3, #64	; 0x40
  40375a:	4798      	blx	r3

	return xReturn;
  40375c:	69fb      	ldr	r3, [r7, #28]
}
  40375e:	4618      	mov	r0, r3
  403760:	f107 0720 	add.w	r7, r7, #32
  403764:	46bd      	mov	sp, r7
  403766:	bd80      	pop	{r7, pc}

00403768 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  403768:	b580      	push	{r7, lr}
  40376a:	b08a      	sub	sp, #40	; 0x28
  40376c:	af00      	add	r7, sp, #0
  40376e:	60f8      	str	r0, [r7, #12]
  403770:	60b9      	str	r1, [r7, #8]
  403772:	607a      	str	r2, [r7, #4]
  403774:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  403776:	f04f 0300 	mov.w	r3, #0
  40377a:	627b      	str	r3, [r7, #36]	; 0x24
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  40377c:	68fb      	ldr	r3, [r7, #12]
  40377e:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
  403780:	6a3b      	ldr	r3, [r7, #32]
  403782:	2b00      	cmp	r3, #0
  403784:	d105      	bne.n	403792 <xQueueGenericReceive+0x2a>
  403786:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  40378a:	f2c0 0340 	movt	r3, #64	; 0x40
  40378e:	4798      	blx	r3
  403790:	e7fe      	b.n	403790 <xQueueGenericReceive+0x28>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  403792:	68bb      	ldr	r3, [r7, #8]
  403794:	2b00      	cmp	r3, #0
  403796:	d103      	bne.n	4037a0 <xQueueGenericReceive+0x38>
  403798:	6a3b      	ldr	r3, [r7, #32]
  40379a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40379c:	2b00      	cmp	r3, #0
  40379e:	d102      	bne.n	4037a6 <xQueueGenericReceive+0x3e>
  4037a0:	f04f 0301 	mov.w	r3, #1
  4037a4:	e001      	b.n	4037aa <xQueueGenericReceive+0x42>
  4037a6:	f04f 0300 	mov.w	r3, #0
  4037aa:	2b00      	cmp	r3, #0
  4037ac:	d106      	bne.n	4037bc <xQueueGenericReceive+0x54>
  4037ae:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4037b2:	f2c0 0340 	movt	r3, #64	; 0x40
  4037b6:	4798      	blx	r3
  4037b8:	e7fe      	b.n	4037b8 <xQueueGenericReceive+0x50>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
  4037ba:	bf00      	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  4037bc:	f642 6379 	movw	r3, #11897	; 0x2e79
  4037c0:	f2c0 0340 	movt	r3, #64	; 0x40
  4037c4:	4798      	blx	r3
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  4037c6:	6a3b      	ldr	r3, [r7, #32]
  4037c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  4037ca:	2b00      	cmp	r3, #0
  4037cc:	d054      	beq.n	403878 <xQueueGenericReceive+0x110>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
  4037ce:	6a3b      	ldr	r3, [r7, #32]
  4037d0:	68db      	ldr	r3, [r3, #12]
  4037d2:	61fb      	str	r3, [r7, #28]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  4037d4:	6a38      	ldr	r0, [r7, #32]
  4037d6:	68b9      	ldr	r1, [r7, #8]
  4037d8:	f643 33ed 	movw	r3, #15341	; 0x3bed
  4037dc:	f2c0 0340 	movt	r3, #64	; 0x40
  4037e0:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
  4037e2:	683b      	ldr	r3, [r7, #0]
  4037e4:	2b00      	cmp	r3, #0
  4037e6:	d127      	bne.n	403838 <xQueueGenericReceive+0xd0>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
  4037e8:	6a3b      	ldr	r3, [r7, #32]
  4037ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  4037ec:	f103 32ff 	add.w	r2, r3, #4294967295
  4037f0:	6a3b      	ldr	r3, [r7, #32]
  4037f2:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4037f4:	6a3b      	ldr	r3, [r7, #32]
  4037f6:	681b      	ldr	r3, [r3, #0]
  4037f8:	2b00      	cmp	r3, #0
  4037fa:	d107      	bne.n	40380c <xQueueGenericReceive+0xa4>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
  4037fc:	f245 6345 	movw	r3, #22085	; 0x5645
  403800:	f2c0 0340 	movt	r3, #64	; 0x40
  403804:	4798      	blx	r3
  403806:	4602      	mov	r2, r0
  403808:	6a3b      	ldr	r3, [r7, #32]
  40380a:	605a      	str	r2, [r3, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  40380c:	6a3b      	ldr	r3, [r7, #32]
  40380e:	691b      	ldr	r3, [r3, #16]
  403810:	2b00      	cmp	r3, #0
  403812:	d029      	beq.n	403868 <xQueueGenericReceive+0x100>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  403814:	6a3b      	ldr	r3, [r7, #32]
  403816:	f103 0310 	add.w	r3, r3, #16
  40381a:	4618      	mov	r0, r3
  40381c:	f245 0375 	movw	r3, #20597	; 0x5075
  403820:	f2c0 0340 	movt	r3, #64	; 0x40
  403824:	4798      	blx	r3
  403826:	4603      	mov	r3, r0
  403828:	2b01      	cmp	r3, #1
  40382a:	d11d      	bne.n	403868 <xQueueGenericReceive+0x100>
						{
							queueYIELD_IF_USING_PREEMPTION();
  40382c:	f642 6359 	movw	r3, #11865	; 0x2e59
  403830:	f2c0 0340 	movt	r3, #64	; 0x40
  403834:	4798      	blx	r3
  403836:	e017      	b.n	403868 <xQueueGenericReceive+0x100>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
  403838:	6a3b      	ldr	r3, [r7, #32]
  40383a:	69fa      	ldr	r2, [r7, #28]
  40383c:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  40383e:	6a3b      	ldr	r3, [r7, #32]
  403840:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  403842:	2b00      	cmp	r3, #0
  403844:	d010      	beq.n	403868 <xQueueGenericReceive+0x100>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  403846:	6a3b      	ldr	r3, [r7, #32]
  403848:	f103 0324 	add.w	r3, r3, #36	; 0x24
  40384c:	4618      	mov	r0, r3
  40384e:	f245 0375 	movw	r3, #20597	; 0x5075
  403852:	f2c0 0340 	movt	r3, #64	; 0x40
  403856:	4798      	blx	r3
  403858:	4603      	mov	r3, r0
  40385a:	2b00      	cmp	r3, #0
  40385c:	d004      	beq.n	403868 <xQueueGenericReceive+0x100>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
  40385e:	f642 6359 	movw	r3, #11865	; 0x2e59
  403862:	f2c0 0340 	movt	r3, #64	; 0x40
  403866:	4798      	blx	r3
						}
					}
				}

				taskEXIT_CRITICAL();
  403868:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  40386c:	f2c0 0340 	movt	r3, #64	; 0x40
  403870:	4798      	blx	r3
				return pdPASS;
  403872:	f04f 0301 	mov.w	r3, #1
  403876:	e0a4      	b.n	4039c2 <xQueueGenericReceive+0x25a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  403878:	687b      	ldr	r3, [r7, #4]
  40387a:	2b00      	cmp	r3, #0
  40387c:	d107      	bne.n	40388e <xQueueGenericReceive+0x126>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  40387e:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  403882:	f2c0 0340 	movt	r3, #64	; 0x40
  403886:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  403888:	f04f 0300 	mov.w	r3, #0
  40388c:	e099      	b.n	4039c2 <xQueueGenericReceive+0x25a>
				}
				else if( xEntryTimeSet == pdFALSE )
  40388e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403890:	2b00      	cmp	r3, #0
  403892:	d10a      	bne.n	4038aa <xQueueGenericReceive+0x142>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  403894:	f107 0314 	add.w	r3, r7, #20
  403898:	4618      	mov	r0, r3
  40389a:	f245 1371 	movw	r3, #20849	; 0x5171
  40389e:	f2c0 0340 	movt	r3, #64	; 0x40
  4038a2:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  4038a4:	f04f 0301 	mov.w	r3, #1
  4038a8:	627b      	str	r3, [r7, #36]	; 0x24
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
  4038aa:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  4038ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4038b2:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  4038b4:	f644 03f9 	movw	r3, #18681	; 0x48f9
  4038b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4038bc:	4798      	blx	r3
		prvLockQueue( pxQueue );
  4038be:	f642 6379 	movw	r3, #11897	; 0x2e79
  4038c2:	f2c0 0340 	movt	r3, #64	; 0x40
  4038c6:	4798      	blx	r3
  4038c8:	6a3b      	ldr	r3, [r7, #32]
  4038ca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  4038cc:	f1b3 3fff 	cmp.w	r3, #4294967295
  4038d0:	d103      	bne.n	4038da <xQueueGenericReceive+0x172>
  4038d2:	6a3b      	ldr	r3, [r7, #32]
  4038d4:	f04f 0200 	mov.w	r2, #0
  4038d8:	645a      	str	r2, [r3, #68]	; 0x44
  4038da:	6a3b      	ldr	r3, [r7, #32]
  4038dc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  4038de:	f1b3 3fff 	cmp.w	r3, #4294967295
  4038e2:	d103      	bne.n	4038ec <xQueueGenericReceive+0x184>
  4038e4:	6a3b      	ldr	r3, [r7, #32]
  4038e6:	f04f 0200 	mov.w	r2, #0
  4038ea:	649a      	str	r2, [r3, #72]	; 0x48
  4038ec:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  4038f0:	f2c0 0340 	movt	r3, #64	; 0x40
  4038f4:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  4038f6:	f107 0214 	add.w	r2, r7, #20
  4038fa:	f107 0304 	add.w	r3, r7, #4
  4038fe:	4610      	mov	r0, r2
  403900:	4619      	mov	r1, r3
  403902:	f245 13b1 	movw	r3, #20913	; 0x51b1
  403906:	f2c0 0340 	movt	r3, #64	; 0x40
  40390a:	4798      	blx	r3
  40390c:	4603      	mov	r3, r0
  40390e:	2b00      	cmp	r3, #0
  403910:	d14a      	bne.n	4039a8 <xQueueGenericReceive+0x240>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  403912:	6a38      	ldr	r0, [r7, #32]
  403914:	f643 533d 	movw	r3, #15677	; 0x3d3d
  403918:	f2c0 0340 	movt	r3, #64	; 0x40
  40391c:	4798      	blx	r3
  40391e:	4603      	mov	r3, r0
  403920:	2b00      	cmp	r3, #0
  403922:	d035      	beq.n	403990 <xQueueGenericReceive+0x228>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  403924:	6a3b      	ldr	r3, [r7, #32]
  403926:	681b      	ldr	r3, [r3, #0]
  403928:	2b00      	cmp	r3, #0
  40392a:	d111      	bne.n	403950 <xQueueGenericReceive+0x1e8>
					{
						portENTER_CRITICAL();
  40392c:	f642 6379 	movw	r3, #11897	; 0x2e79
  403930:	f2c0 0340 	movt	r3, #64	; 0x40
  403934:	4798      	blx	r3
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  403936:	6a3b      	ldr	r3, [r7, #32]
  403938:	685b      	ldr	r3, [r3, #4]
  40393a:	4618      	mov	r0, r3
  40393c:	f245 63ad 	movw	r3, #22189	; 0x56ad
  403940:	f2c0 0340 	movt	r3, #64	; 0x40
  403944:	4798      	blx	r3
						}
						portEXIT_CRITICAL();
  403946:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  40394a:	f2c0 0340 	movt	r3, #64	; 0x40
  40394e:	4798      	blx	r3
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  403950:	6a3b      	ldr	r3, [r7, #32]
  403952:	f103 0224 	add.w	r2, r3, #36	; 0x24
  403956:	687b      	ldr	r3, [r7, #4]
  403958:	4610      	mov	r0, r2
  40395a:	4619      	mov	r1, r3
  40395c:	f644 63f1 	movw	r3, #20209	; 0x4ef1
  403960:	f2c0 0340 	movt	r3, #64	; 0x40
  403964:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  403966:	6a38      	ldr	r0, [r7, #32]
  403968:	f643 4341 	movw	r3, #15425	; 0x3c41
  40396c:	f2c0 0340 	movt	r3, #64	; 0x40
  403970:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  403972:	f644 131d 	movw	r3, #18717	; 0x491d
  403976:	f2c0 0340 	movt	r3, #64	; 0x40
  40397a:	4798      	blx	r3
  40397c:	4603      	mov	r3, r0
  40397e:	2b00      	cmp	r3, #0
  403980:	f47f af1b 	bne.w	4037ba <xQueueGenericReceive+0x52>
				{
					portYIELD_WITHIN_API();
  403984:	f642 6359 	movw	r3, #11865	; 0x2e59
  403988:	f2c0 0340 	movt	r3, #64	; 0x40
  40398c:	4798      	blx	r3
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
  40398e:	e714      	b.n	4037ba <xQueueGenericReceive+0x52>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  403990:	6a38      	ldr	r0, [r7, #32]
  403992:	f643 4341 	movw	r3, #15425	; 0x3c41
  403996:	f2c0 0340 	movt	r3, #64	; 0x40
  40399a:	4798      	blx	r3
				( void ) xTaskResumeAll();
  40399c:	f644 131d 	movw	r3, #18717	; 0x491d
  4039a0:	f2c0 0340 	movt	r3, #64	; 0x40
  4039a4:	4798      	blx	r3
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
  4039a6:	e708      	b.n	4037ba <xQueueGenericReceive+0x52>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  4039a8:	6a38      	ldr	r0, [r7, #32]
  4039aa:	f643 4341 	movw	r3, #15425	; 0x3c41
  4039ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4039b2:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4039b4:	f644 131d 	movw	r3, #18717	; 0x491d
  4039b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4039bc:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
  4039be:	f04f 0300 	mov.w	r3, #0
		}
	}
}
  4039c2:	4618      	mov	r0, r3
  4039c4:	f107 0728 	add.w	r7, r7, #40	; 0x28
  4039c8:	46bd      	mov	sp, r7
  4039ca:	bd80      	pop	{r7, pc}

004039cc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
  4039cc:	b580      	push	{r7, lr}
  4039ce:	b088      	sub	sp, #32
  4039d0:	af00      	add	r7, sp, #0
  4039d2:	60f8      	str	r0, [r7, #12]
  4039d4:	60b9      	str	r1, [r7, #8]
  4039d6:	607a      	str	r2, [r7, #4]
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  4039d8:	68fb      	ldr	r3, [r7, #12]
  4039da:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
  4039dc:	69bb      	ldr	r3, [r7, #24]
  4039de:	2b00      	cmp	r3, #0
  4039e0:	d105      	bne.n	4039ee <xQueueReceiveFromISR+0x22>
  4039e2:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4039e6:	f2c0 0340 	movt	r3, #64	; 0x40
  4039ea:	4798      	blx	r3
  4039ec:	e7fe      	b.n	4039ec <xQueueReceiveFromISR+0x20>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  4039ee:	68bb      	ldr	r3, [r7, #8]
  4039f0:	2b00      	cmp	r3, #0
  4039f2:	d103      	bne.n	4039fc <xQueueReceiveFromISR+0x30>
  4039f4:	69bb      	ldr	r3, [r7, #24]
  4039f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4039f8:	2b00      	cmp	r3, #0
  4039fa:	d102      	bne.n	403a02 <xQueueReceiveFromISR+0x36>
  4039fc:	f04f 0301 	mov.w	r3, #1
  403a00:	e001      	b.n	403a06 <xQueueReceiveFromISR+0x3a>
  403a02:	f04f 0300 	mov.w	r3, #0
  403a06:	2b00      	cmp	r3, #0
  403a08:	d105      	bne.n	403a16 <xQueueReceiveFromISR+0x4a>
  403a0a:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403a0e:	f2c0 0340 	movt	r3, #64	; 0x40
  403a12:	4798      	blx	r3
  403a14:	e7fe      	b.n	403a14 <xQueueReceiveFromISR+0x48>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  403a16:	f642 73b9 	movw	r3, #12217	; 0x2fb9
  403a1a:	f2c0 0340 	movt	r3, #64	; 0x40
  403a1e:	4798      	blx	r3

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  403a20:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403a24:	f2c0 0340 	movt	r3, #64	; 0x40
  403a28:	4798      	blx	r3
  403a2a:	6178      	str	r0, [r7, #20]
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  403a2c:	69bb      	ldr	r3, [r7, #24]
  403a2e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  403a30:	2b00      	cmp	r3, #0
  403a32:	d033      	beq.n	403a9c <xQueueReceiveFromISR+0xd0>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
  403a34:	69b8      	ldr	r0, [r7, #24]
  403a36:	68b9      	ldr	r1, [r7, #8]
  403a38:	f643 33ed 	movw	r3, #15341	; 0x3bed
  403a3c:	f2c0 0340 	movt	r3, #64	; 0x40
  403a40:	4798      	blx	r3
			--( pxQueue->uxMessagesWaiting );
  403a42:	69bb      	ldr	r3, [r7, #24]
  403a44:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  403a46:	f103 32ff 	add.w	r2, r3, #4294967295
  403a4a:	69bb      	ldr	r3, [r7, #24]
  403a4c:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
  403a4e:	69bb      	ldr	r3, [r7, #24]
  403a50:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  403a52:	f1b3 3fff 	cmp.w	r3, #4294967295
  403a56:	d117      	bne.n	403a88 <xQueueReceiveFromISR+0xbc>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  403a58:	69bb      	ldr	r3, [r7, #24]
  403a5a:	691b      	ldr	r3, [r3, #16]
  403a5c:	2b00      	cmp	r3, #0
  403a5e:	d019      	beq.n	403a94 <xQueueReceiveFromISR+0xc8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  403a60:	69bb      	ldr	r3, [r7, #24]
  403a62:	f103 0310 	add.w	r3, r3, #16
  403a66:	4618      	mov	r0, r3
  403a68:	f245 0375 	movw	r3, #20597	; 0x5075
  403a6c:	f2c0 0340 	movt	r3, #64	; 0x40
  403a70:	4798      	blx	r3
  403a72:	4603      	mov	r3, r0
  403a74:	2b00      	cmp	r3, #0
  403a76:	d00d      	beq.n	403a94 <xQueueReceiveFromISR+0xc8>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
  403a78:	687b      	ldr	r3, [r7, #4]
  403a7a:	2b00      	cmp	r3, #0
  403a7c:	d00a      	beq.n	403a94 <xQueueReceiveFromISR+0xc8>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
  403a7e:	687b      	ldr	r3, [r7, #4]
  403a80:	f04f 0201 	mov.w	r2, #1
  403a84:	601a      	str	r2, [r3, #0]
  403a86:	e005      	b.n	403a94 <xQueueReceiveFromISR+0xc8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
  403a88:	69bb      	ldr	r3, [r7, #24]
  403a8a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  403a8c:	f103 0201 	add.w	r2, r3, #1
  403a90:	69bb      	ldr	r3, [r7, #24]
  403a92:	645a      	str	r2, [r3, #68]	; 0x44
			}

			xReturn = pdPASS;
  403a94:	f04f 0301 	mov.w	r3, #1
  403a98:	61fb      	str	r3, [r7, #28]
  403a9a:	e002      	b.n	403aa2 <xQueueReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
  403a9c:	f04f 0300 	mov.w	r3, #0
  403aa0:	61fb      	str	r3, [r7, #28]
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  403aa2:	6978      	ldr	r0, [r7, #20]
  403aa4:	f642 63f9 	movw	r3, #12025	; 0x2ef9
  403aa8:	f2c0 0340 	movt	r3, #64	; 0x40
  403aac:	4798      	blx	r3

	return xReturn;
  403aae:	69fb      	ldr	r3, [r7, #28]
}
  403ab0:	4618      	mov	r0, r3
  403ab2:	f107 0720 	add.w	r7, r7, #32
  403ab6:	46bd      	mov	sp, r7
  403ab8:	bd80      	pop	{r7, pc}
  403aba:	bf00      	nop

00403abc <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
{
  403abc:	b580      	push	{r7, lr}
  403abe:	b084      	sub	sp, #16
  403ac0:	af00      	add	r7, sp, #0
  403ac2:	6078      	str	r0, [r7, #4]
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );
  403ac4:	687b      	ldr	r3, [r7, #4]
  403ac6:	2b00      	cmp	r3, #0
  403ac8:	d105      	bne.n	403ad6 <uxQueueMessagesWaiting+0x1a>
  403aca:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403ace:	f2c0 0340 	movt	r3, #64	; 0x40
  403ad2:	4798      	blx	r3
  403ad4:	e7fe      	b.n	403ad4 <uxQueueMessagesWaiting+0x18>

	taskENTER_CRITICAL();
  403ad6:	f642 6379 	movw	r3, #11897	; 0x2e79
  403ada:	f2c0 0340 	movt	r3, #64	; 0x40
  403ade:	4798      	blx	r3
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
  403ae0:	687b      	ldr	r3, [r7, #4]
  403ae2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  403ae4:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
  403ae6:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  403aea:	f2c0 0340 	movt	r3, #64	; 0x40
  403aee:	4798      	blx	r3

	return uxReturn;
  403af0:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
  403af2:	4618      	mov	r0, r3
  403af4:	f107 0710 	add.w	r7, r7, #16
  403af8:	46bd      	mov	sp, r7
  403afa:	bd80      	pop	{r7, pc}

00403afc <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  403afc:	b580      	push	{r7, lr}
  403afe:	b084      	sub	sp, #16
  403b00:	af00      	add	r7, sp, #0
  403b02:	60f8      	str	r0, [r7, #12]
  403b04:	60b9      	str	r1, [r7, #8]
  403b06:	607a      	str	r2, [r7, #4]
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  403b08:	68fb      	ldr	r3, [r7, #12]
  403b0a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  403b0c:	2b00      	cmp	r3, #0
  403b0e:	d110      	bne.n	403b32 <prvCopyDataToQueue+0x36>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  403b10:	68fb      	ldr	r3, [r7, #12]
  403b12:	681b      	ldr	r3, [r3, #0]
  403b14:	2b00      	cmp	r3, #0
  403b16:	d15e      	bne.n	403bd6 <prvCopyDataToQueue+0xda>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  403b18:	68fb      	ldr	r3, [r7, #12]
  403b1a:	685b      	ldr	r3, [r3, #4]
  403b1c:	4618      	mov	r0, r3
  403b1e:	f245 73f5 	movw	r3, #22517	; 0x57f5
  403b22:	f2c0 0340 	movt	r3, #64	; 0x40
  403b26:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  403b28:	68fb      	ldr	r3, [r7, #12]
  403b2a:	f04f 0200 	mov.w	r2, #0
  403b2e:	605a      	str	r2, [r3, #4]
  403b30:	e051      	b.n	403bd6 <prvCopyDataToQueue+0xda>
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
  403b32:	687b      	ldr	r3, [r7, #4]
  403b34:	2b00      	cmp	r3, #0
  403b36:	d11d      	bne.n	403b74 <prvCopyDataToQueue+0x78>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
  403b38:	68fb      	ldr	r3, [r7, #12]
  403b3a:	689a      	ldr	r2, [r3, #8]
  403b3c:	68fb      	ldr	r3, [r7, #12]
  403b3e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  403b40:	4610      	mov	r0, r2
  403b42:	68b9      	ldr	r1, [r7, #8]
  403b44:	461a      	mov	r2, r3
  403b46:	f249 6347 	movw	r3, #38471	; 0x9647
  403b4a:	f2c0 0340 	movt	r3, #64	; 0x40
  403b4e:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  403b50:	68fb      	ldr	r3, [r7, #12]
  403b52:	689a      	ldr	r2, [r3, #8]
  403b54:	68fb      	ldr	r3, [r7, #12]
  403b56:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  403b58:	18d2      	adds	r2, r2, r3
  403b5a:	68fb      	ldr	r3, [r7, #12]
  403b5c:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  403b5e:	68fb      	ldr	r3, [r7, #12]
  403b60:	689a      	ldr	r2, [r3, #8]
  403b62:	68fb      	ldr	r3, [r7, #12]
  403b64:	685b      	ldr	r3, [r3, #4]
  403b66:	429a      	cmp	r2, r3
  403b68:	d335      	bcc.n	403bd6 <prvCopyDataToQueue+0xda>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  403b6a:	68fb      	ldr	r3, [r7, #12]
  403b6c:	681a      	ldr	r2, [r3, #0]
  403b6e:	68fb      	ldr	r3, [r7, #12]
  403b70:	609a      	str	r2, [r3, #8]
  403b72:	e030      	b.n	403bd6 <prvCopyDataToQueue+0xda>
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  403b74:	68fb      	ldr	r3, [r7, #12]
  403b76:	68da      	ldr	r2, [r3, #12]
  403b78:	68fb      	ldr	r3, [r7, #12]
  403b7a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  403b7c:	4610      	mov	r0, r2
  403b7e:	68b9      	ldr	r1, [r7, #8]
  403b80:	461a      	mov	r2, r3
  403b82:	f249 6347 	movw	r3, #38471	; 0x9647
  403b86:	f2c0 0340 	movt	r3, #64	; 0x40
  403b8a:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
  403b8c:	68fb      	ldr	r3, [r7, #12]
  403b8e:	68da      	ldr	r2, [r3, #12]
  403b90:	68fb      	ldr	r3, [r7, #12]
  403b92:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  403b94:	f1c3 0300 	rsb	r3, r3, #0
  403b98:	18d2      	adds	r2, r2, r3
  403b9a:	68fb      	ldr	r3, [r7, #12]
  403b9c:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  403b9e:	68fb      	ldr	r3, [r7, #12]
  403ba0:	68da      	ldr	r2, [r3, #12]
  403ba2:	68fb      	ldr	r3, [r7, #12]
  403ba4:	681b      	ldr	r3, [r3, #0]
  403ba6:	429a      	cmp	r2, r3
  403ba8:	d208      	bcs.n	403bbc <prvCopyDataToQueue+0xc0>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  403baa:	68fb      	ldr	r3, [r7, #12]
  403bac:	685a      	ldr	r2, [r3, #4]
  403bae:	68fb      	ldr	r3, [r7, #12]
  403bb0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  403bb2:	f1c3 0300 	rsb	r3, r3, #0
  403bb6:	18d2      	adds	r2, r2, r3
  403bb8:	68fb      	ldr	r3, [r7, #12]
  403bba:	60da      	str	r2, [r3, #12]
		}

		if( xPosition == queueOVERWRITE )
  403bbc:	687b      	ldr	r3, [r7, #4]
  403bbe:	2b02      	cmp	r3, #2
  403bc0:	d109      	bne.n	403bd6 <prvCopyDataToQueue+0xda>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  403bc2:	68fb      	ldr	r3, [r7, #12]
  403bc4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  403bc6:	2b00      	cmp	r3, #0
  403bc8:	d005      	beq.n	403bd6 <prvCopyDataToQueue+0xda>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
  403bca:	68fb      	ldr	r3, [r7, #12]
  403bcc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  403bce:	f103 32ff 	add.w	r2, r3, #4294967295
  403bd2:	68fb      	ldr	r3, [r7, #12]
  403bd4:	639a      	str	r2, [r3, #56]	; 0x38
			}
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403bd6:	68fb      	ldr	r3, [r7, #12]
  403bd8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  403bda:	f103 0201 	add.w	r2, r3, #1
  403bde:	68fb      	ldr	r3, [r7, #12]
  403be0:	639a      	str	r2, [r3, #56]	; 0x38
}
  403be2:	f107 0710 	add.w	r7, r7, #16
  403be6:	46bd      	mov	sp, r7
  403be8:	bd80      	pop	{r7, pc}
  403bea:	bf00      	nop

00403bec <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
{
  403bec:	b580      	push	{r7, lr}
  403bee:	b082      	sub	sp, #8
  403bf0:	af00      	add	r7, sp, #0
  403bf2:	6078      	str	r0, [r7, #4]
  403bf4:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  403bf6:	687b      	ldr	r3, [r7, #4]
  403bf8:	681b      	ldr	r3, [r3, #0]
  403bfa:	2b00      	cmp	r3, #0
  403bfc:	d01c      	beq.n	403c38 <prvCopyDataFromQueue+0x4c>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
  403bfe:	687b      	ldr	r3, [r7, #4]
  403c00:	68da      	ldr	r2, [r3, #12]
  403c02:	687b      	ldr	r3, [r7, #4]
  403c04:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  403c06:	18d2      	adds	r2, r2, r3
  403c08:	687b      	ldr	r3, [r7, #4]
  403c0a:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  403c0c:	687b      	ldr	r3, [r7, #4]
  403c0e:	68da      	ldr	r2, [r3, #12]
  403c10:	687b      	ldr	r3, [r7, #4]
  403c12:	685b      	ldr	r3, [r3, #4]
  403c14:	429a      	cmp	r2, r3
  403c16:	d303      	bcc.n	403c20 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
  403c18:	687b      	ldr	r3, [r7, #4]
  403c1a:	681a      	ldr	r2, [r3, #0]
  403c1c:	687b      	ldr	r3, [r7, #4]
  403c1e:	60da      	str	r2, [r3, #12]
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
  403c20:	687b      	ldr	r3, [r7, #4]
  403c22:	68da      	ldr	r2, [r3, #12]
  403c24:	687b      	ldr	r3, [r7, #4]
  403c26:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  403c28:	6838      	ldr	r0, [r7, #0]
  403c2a:	4611      	mov	r1, r2
  403c2c:	461a      	mov	r2, r3
  403c2e:	f249 6347 	movw	r3, #38471	; 0x9647
  403c32:	f2c0 0340 	movt	r3, #64	; 0x40
  403c36:	4798      	blx	r3
	}
}
  403c38:	f107 0708 	add.w	r7, r7, #8
  403c3c:	46bd      	mov	sp, r7
  403c3e:	bd80      	pop	{r7, pc}

00403c40 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
  403c40:	b580      	push	{r7, lr}
  403c42:	b082      	sub	sp, #8
  403c44:	af00      	add	r7, sp, #0
  403c46:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  403c48:	f642 6379 	movw	r3, #11897	; 0x2e79
  403c4c:	f2c0 0340 	movt	r3, #64	; 0x40
  403c50:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403c52:	e02f      	b.n	403cb4 <prvUnlockQueue+0x74>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			#if ( configUSE_QUEUE_SETS == 1 )
			{
				if( pxQueue->pxQueueSetContainer != NULL )
  403c54:	687b      	ldr	r3, [r7, #4]
  403c56:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  403c58:	2b00      	cmp	r3, #0
  403c5a:	d010      	beq.n	403c7e <prvUnlockQueue+0x3e>
				{
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
  403c5c:	6878      	ldr	r0, [r7, #4]
  403c5e:	f04f 0100 	mov.w	r1, #0
  403c62:	f643 7381 	movw	r3, #16257	; 0x3f81
  403c66:	f2c0 0340 	movt	r3, #64	; 0x40
  403c6a:	4798      	blx	r3
  403c6c:	4603      	mov	r3, r0
  403c6e:	2b01      	cmp	r3, #1
  403c70:	d11a      	bne.n	403ca8 <prvUnlockQueue+0x68>
					{
						/* The queue is a member of a queue set, and posting to
						the queue set caused a higher priority task to unblock.
						A context switch is required. */
						vTaskMissedYield();
  403c72:	f245 237d 	movw	r3, #21117	; 0x527d
  403c76:	f2c0 0340 	movt	r3, #64	; 0x40
  403c7a:	4798      	blx	r3
  403c7c:	e014      	b.n	403ca8 <prvUnlockQueue+0x68>
				}
				else
				{
					/* Tasks that are removed from the event list will get added to
					the pending ready list as the scheduler is still suspended. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  403c7e:	687b      	ldr	r3, [r7, #4]
  403c80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  403c82:	2b00      	cmp	r3, #0
  403c84:	d01b      	beq.n	403cbe <prvUnlockQueue+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  403c86:	687b      	ldr	r3, [r7, #4]
  403c88:	f103 0324 	add.w	r3, r3, #36	; 0x24
  403c8c:	4618      	mov	r0, r3
  403c8e:	f245 0375 	movw	r3, #20597	; 0x5075
  403c92:	f2c0 0340 	movt	r3, #64	; 0x40
  403c96:	4798      	blx	r3
  403c98:	4603      	mov	r3, r0
  403c9a:	2b00      	cmp	r3, #0
  403c9c:	d004      	beq.n	403ca8 <prvUnlockQueue+0x68>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							vTaskMissedYield();
  403c9e:	f245 237d 	movw	r3, #21117	; 0x527d
  403ca2:	f2c0 0340 	movt	r3, #64	; 0x40
  403ca6:	4798      	blx	r3
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
  403ca8:	687b      	ldr	r3, [r7, #4]
  403caa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  403cac:	f103 32ff 	add.w	r2, r3, #4294967295
  403cb0:	687b      	ldr	r3, [r7, #4]
  403cb2:	649a      	str	r2, [r3, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403cb4:	687b      	ldr	r3, [r7, #4]
  403cb6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  403cb8:	2b00      	cmp	r3, #0
  403cba:	dccb      	bgt.n	403c54 <prvUnlockQueue+0x14>
  403cbc:	e000      	b.n	403cc0 <prvUnlockQueue+0x80>
							vTaskMissedYield();
						}
					}
					else
					{
						break;
  403cbe:	bf00      	nop
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
  403cc0:	687b      	ldr	r3, [r7, #4]
  403cc2:	f04f 32ff 	mov.w	r2, #4294967295
  403cc6:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
  403cc8:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  403ccc:	f2c0 0340 	movt	r3, #64	; 0x40
  403cd0:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  403cd2:	f642 6379 	movw	r3, #11897	; 0x2e79
  403cd6:	f2c0 0340 	movt	r3, #64	; 0x40
  403cda:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  403cdc:	e01a      	b.n	403d14 <prvUnlockQueue+0xd4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  403cde:	687b      	ldr	r3, [r7, #4]
  403ce0:	691b      	ldr	r3, [r3, #16]
  403ce2:	2b00      	cmp	r3, #0
  403ce4:	d01b      	beq.n	403d1e <prvUnlockQueue+0xde>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  403ce6:	687b      	ldr	r3, [r7, #4]
  403ce8:	f103 0310 	add.w	r3, r3, #16
  403cec:	4618      	mov	r0, r3
  403cee:	f245 0375 	movw	r3, #20597	; 0x5075
  403cf2:	f2c0 0340 	movt	r3, #64	; 0x40
  403cf6:	4798      	blx	r3
  403cf8:	4603      	mov	r3, r0
  403cfa:	2b00      	cmp	r3, #0
  403cfc:	d004      	beq.n	403d08 <prvUnlockQueue+0xc8>
				{
					vTaskMissedYield();
  403cfe:	f245 237d 	movw	r3, #21117	; 0x527d
  403d02:	f2c0 0340 	movt	r3, #64	; 0x40
  403d06:	4798      	blx	r3
				}

				--( pxQueue->xRxLock );
  403d08:	687b      	ldr	r3, [r7, #4]
  403d0a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  403d0c:	f103 32ff 	add.w	r2, r3, #4294967295
  403d10:	687b      	ldr	r3, [r7, #4]
  403d12:	645a      	str	r2, [r3, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  403d14:	687b      	ldr	r3, [r7, #4]
  403d16:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  403d18:	2b00      	cmp	r3, #0
  403d1a:	dce0      	bgt.n	403cde <prvUnlockQueue+0x9e>
  403d1c:	e000      	b.n	403d20 <prvUnlockQueue+0xe0>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
  403d1e:	bf00      	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
  403d20:	687b      	ldr	r3, [r7, #4]
  403d22:	f04f 32ff 	mov.w	r2, #4294967295
  403d26:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  403d28:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  403d2c:	f2c0 0340 	movt	r3, #64	; 0x40
  403d30:	4798      	blx	r3
}
  403d32:	f107 0708 	add.w	r7, r7, #8
  403d36:	46bd      	mov	sp, r7
  403d38:	bd80      	pop	{r7, pc}
  403d3a:	bf00      	nop

00403d3c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
  403d3c:	b580      	push	{r7, lr}
  403d3e:	b084      	sub	sp, #16
  403d40:	af00      	add	r7, sp, #0
  403d42:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  403d44:	f642 6379 	movw	r3, #11897	; 0x2e79
  403d48:	f2c0 0340 	movt	r3, #64	; 0x40
  403d4c:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
  403d4e:	687b      	ldr	r3, [r7, #4]
  403d50:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  403d52:	2b00      	cmp	r3, #0
  403d54:	d103      	bne.n	403d5e <prvIsQueueEmpty+0x22>
		{
			xReturn = pdTRUE;
  403d56:	f04f 0301 	mov.w	r3, #1
  403d5a:	60fb      	str	r3, [r7, #12]
  403d5c:	e002      	b.n	403d64 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
  403d5e:	f04f 0300 	mov.w	r3, #0
  403d62:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  403d64:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  403d68:	f2c0 0340 	movt	r3, #64	; 0x40
  403d6c:	4798      	blx	r3

	return xReturn;
  403d6e:	68fb      	ldr	r3, [r7, #12]
}
  403d70:	4618      	mov	r0, r3
  403d72:	f107 0710 	add.w	r7, r7, #16
  403d76:	46bd      	mov	sp, r7
  403d78:	bd80      	pop	{r7, pc}
  403d7a:	bf00      	nop

00403d7c <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
  403d7c:	b580      	push	{r7, lr}
  403d7e:	b084      	sub	sp, #16
  403d80:	af00      	add	r7, sp, #0
  403d82:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  403d84:	f642 6379 	movw	r3, #11897	; 0x2e79
  403d88:	f2c0 0340 	movt	r3, #64	; 0x40
  403d8c:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  403d8e:	687b      	ldr	r3, [r7, #4]
  403d90:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  403d92:	687b      	ldr	r3, [r7, #4]
  403d94:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  403d96:	429a      	cmp	r2, r3
  403d98:	d103      	bne.n	403da2 <prvIsQueueFull+0x26>
		{
			xReturn = pdTRUE;
  403d9a:	f04f 0301 	mov.w	r3, #1
  403d9e:	60fb      	str	r3, [r7, #12]
  403da0:	e002      	b.n	403da8 <prvIsQueueFull+0x2c>
		}
		else
		{
			xReturn = pdFALSE;
  403da2:	f04f 0300 	mov.w	r3, #0
  403da6:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  403da8:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  403dac:	f2c0 0340 	movt	r3, #64	; 0x40
  403db0:	4798      	blx	r3

	return xReturn;
  403db2:	68fb      	ldr	r3, [r7, #12]
}
  403db4:	4618      	mov	r0, r3
  403db6:	f107 0710 	add.w	r7, r7, #16
  403dba:	46bd      	mov	sp, r7
  403dbc:	bd80      	pop	{r7, pc}
  403dbe:	bf00      	nop

00403dc0 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
	{
  403dc0:	b580      	push	{r7, lr}
  403dc2:	b084      	sub	sp, #16
  403dc4:	af00      	add	r7, sp, #0
  403dc6:	6078      	str	r0, [r7, #4]
  403dc8:	6039      	str	r1, [r7, #0]
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  403dca:	687b      	ldr	r3, [r7, #4]
  403dcc:	60fb      	str	r3, [r7, #12]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
  403dce:	f642 6379 	movw	r3, #11897	; 0x2e79
  403dd2:	f2c0 0340 	movt	r3, #64	; 0x40
  403dd6:	4798      	blx	r3
  403dd8:	68fb      	ldr	r3, [r7, #12]
  403dda:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  403ddc:	f1b3 3fff 	cmp.w	r3, #4294967295
  403de0:	d103      	bne.n	403dea <vQueueWaitForMessageRestricted+0x2a>
  403de2:	68fb      	ldr	r3, [r7, #12]
  403de4:	f04f 0200 	mov.w	r2, #0
  403de8:	645a      	str	r2, [r3, #68]	; 0x44
  403dea:	68fb      	ldr	r3, [r7, #12]
  403dec:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  403dee:	f1b3 3fff 	cmp.w	r3, #4294967295
  403df2:	d103      	bne.n	403dfc <vQueueWaitForMessageRestricted+0x3c>
  403df4:	68fb      	ldr	r3, [r7, #12]
  403df6:	f04f 0200 	mov.w	r2, #0
  403dfa:	649a      	str	r2, [r3, #72]	; 0x48
  403dfc:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  403e00:	f2c0 0340 	movt	r3, #64	; 0x40
  403e04:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
  403e06:	68fb      	ldr	r3, [r7, #12]
  403e08:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  403e0a:	2b00      	cmp	r3, #0
  403e0c:	d109      	bne.n	403e22 <vQueueWaitForMessageRestricted+0x62>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  403e0e:	68fb      	ldr	r3, [r7, #12]
  403e10:	f103 0324 	add.w	r3, r3, #36	; 0x24
  403e14:	4618      	mov	r0, r3
  403e16:	6839      	ldr	r1, [r7, #0]
  403e18:	f644 73c9 	movw	r3, #20425	; 0x4fc9
  403e1c:	f2c0 0340 	movt	r3, #64	; 0x40
  403e20:	4798      	blx	r3
		}
		prvUnlockQueue( pxQueue );
  403e22:	68f8      	ldr	r0, [r7, #12]
  403e24:	f643 4341 	movw	r3, #15425	; 0x3c41
  403e28:	f2c0 0340 	movt	r3, #64	; 0x40
  403e2c:	4798      	blx	r3
	}
  403e2e:	f107 0710 	add.w	r7, r7, #16
  403e32:	46bd      	mov	sp, r7
  403e34:	bd80      	pop	{r7, pc}
  403e36:	bf00      	nop

00403e38 <xQueueCreateSet>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	xQueueSetHandle xQueueCreateSet( unsigned portBASE_TYPE uxEventQueueLength )
	{
  403e38:	b580      	push	{r7, lr}
  403e3a:	b084      	sub	sp, #16
  403e3c:	af00      	add	r7, sp, #0
  403e3e:	6078      	str	r0, [r7, #4]
	xQueueSetHandle pxQueue;

		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( xQUEUE * ), queueQUEUE_TYPE_SET );
  403e40:	6878      	ldr	r0, [r7, #4]
  403e42:	f04f 0104 	mov.w	r1, #4
  403e46:	f04f 0200 	mov.w	r2, #0
  403e4a:	f243 1311 	movw	r3, #12561	; 0x3111
  403e4e:	f2c0 0340 	movt	r3, #64	; 0x40
  403e52:	4798      	blx	r3
  403e54:	60f8      	str	r0, [r7, #12]

		return pxQueue;
  403e56:	68fb      	ldr	r3, [r7, #12]
	}
  403e58:	4618      	mov	r0, r3
  403e5a:	f107 0710 	add.w	r7, r7, #16
  403e5e:	46bd      	mov	sp, r7
  403e60:	bd80      	pop	{r7, pc}
  403e62:	bf00      	nop

00403e64 <xQueueAddToSet>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	portBASE_TYPE xQueueAddToSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet )
	{
  403e64:	b580      	push	{r7, lr}
  403e66:	b084      	sub	sp, #16
  403e68:	af00      	add	r7, sp, #0
  403e6a:	6078      	str	r0, [r7, #4]
  403e6c:	6039      	str	r1, [r7, #0]
	portBASE_TYPE xReturn;

		if( ( ( xQUEUE * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
  403e6e:	687b      	ldr	r3, [r7, #4]
  403e70:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  403e72:	2b00      	cmp	r3, #0
  403e74:	d003      	beq.n	403e7e <xQueueAddToSet+0x1a>
		{
			/* Cannot add a queue/semaphore to more than one queue set. */
			xReturn = pdFAIL;
  403e76:	f04f 0300 	mov.w	r3, #0
  403e7a:	60fb      	str	r3, [r7, #12]
  403e7c:	e017      	b.n	403eae <xQueueAddToSet+0x4a>
		}
		else if( ( ( xQUEUE * ) xQueueOrSemaphore )->uxMessagesWaiting != ( unsigned portBASE_TYPE ) 0 )
  403e7e:	687b      	ldr	r3, [r7, #4]
  403e80:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  403e82:	2b00      	cmp	r3, #0
  403e84:	d003      	beq.n	403e8e <xQueueAddToSet+0x2a>
		{
			/* Cannot add a queue/semaphore to a queue set if there are already
			items in the queue/semaphore. */
			xReturn = pdFAIL;
  403e86:	f04f 0300 	mov.w	r3, #0
  403e8a:	60fb      	str	r3, [r7, #12]
  403e8c:	e00f      	b.n	403eae <xQueueAddToSet+0x4a>
		}
		else
		{
			taskENTER_CRITICAL();
  403e8e:	f642 6379 	movw	r3, #11897	; 0x2e79
  403e92:	f2c0 0340 	movt	r3, #64	; 0x40
  403e96:	4798      	blx	r3
			{
				( ( xQUEUE * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
  403e98:	687b      	ldr	r3, [r7, #4]
  403e9a:	683a      	ldr	r2, [r7, #0]
  403e9c:	64da      	str	r2, [r3, #76]	; 0x4c
			}
			taskEXIT_CRITICAL();
  403e9e:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  403ea2:	f2c0 0340 	movt	r3, #64	; 0x40
  403ea6:	4798      	blx	r3
			xReturn = pdPASS;
  403ea8:	f04f 0301 	mov.w	r3, #1
  403eac:	60fb      	str	r3, [r7, #12]
		}

		return xReturn;
  403eae:	68fb      	ldr	r3, [r7, #12]
	}
  403eb0:	4618      	mov	r0, r3
  403eb2:	f107 0710 	add.w	r7, r7, #16
  403eb6:	46bd      	mov	sp, r7
  403eb8:	bd80      	pop	{r7, pc}
  403eba:	bf00      	nop

00403ebc <xQueueRemoveFromSet>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	portBASE_TYPE xQueueRemoveFromSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet )
	{
  403ebc:	b580      	push	{r7, lr}
  403ebe:	b084      	sub	sp, #16
  403ec0:	af00      	add	r7, sp, #0
  403ec2:	6078      	str	r0, [r7, #4]
  403ec4:	6039      	str	r1, [r7, #0]
	portBASE_TYPE xReturn;
	xQUEUE * const pxQueueOrSemaphore = ( xQUEUE * ) xQueueOrSemaphore;
  403ec6:	687b      	ldr	r3, [r7, #4]
  403ec8:	60bb      	str	r3, [r7, #8]

		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
  403eca:	68bb      	ldr	r3, [r7, #8]
  403ecc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  403ece:	683b      	ldr	r3, [r7, #0]
  403ed0:	429a      	cmp	r2, r3
  403ed2:	d003      	beq.n	403edc <xQueueRemoveFromSet+0x20>
		{
			/* The queue was not a member of the set. */
			xReturn = pdFAIL;
  403ed4:	f04f 0300 	mov.w	r3, #0
  403ed8:	60fb      	str	r3, [r7, #12]
  403eda:	e018      	b.n	403f0e <xQueueRemoveFromSet+0x52>
		}
		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( unsigned portBASE_TYPE ) 0 )
  403edc:	68bb      	ldr	r3, [r7, #8]
  403ede:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  403ee0:	2b00      	cmp	r3, #0
  403ee2:	d003      	beq.n	403eec <xQueueRemoveFromSet+0x30>
		{
			/* It is dangerous to remove a queue from a set when the queue is
			not empty because the queue set will still hold pending events for
			the queue. */
			xReturn = pdFAIL;
  403ee4:	f04f 0300 	mov.w	r3, #0
  403ee8:	60fb      	str	r3, [r7, #12]
  403eea:	e010      	b.n	403f0e <xQueueRemoveFromSet+0x52>
		}
		else
		{
			taskENTER_CRITICAL();
  403eec:	f642 6379 	movw	r3, #11897	; 0x2e79
  403ef0:	f2c0 0340 	movt	r3, #64	; 0x40
  403ef4:	4798      	blx	r3
			{
				/* The queue is no longer contained in the set. */
				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
  403ef6:	68bb      	ldr	r3, [r7, #8]
  403ef8:	f04f 0200 	mov.w	r2, #0
  403efc:	64da      	str	r2, [r3, #76]	; 0x4c
			}
			taskEXIT_CRITICAL();
  403efe:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  403f02:	f2c0 0340 	movt	r3, #64	; 0x40
  403f06:	4798      	blx	r3
			xReturn = pdPASS;
  403f08:	f04f 0301 	mov.w	r3, #1
  403f0c:	60fb      	str	r3, [r7, #12]
		}

		return xReturn;
  403f0e:	68fb      	ldr	r3, [r7, #12]
	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
  403f10:	4618      	mov	r0, r3
  403f12:	f107 0710 	add.w	r7, r7, #16
  403f16:	46bd      	mov	sp, r7
  403f18:	bd80      	pop	{r7, pc}
  403f1a:	bf00      	nop

00403f1c <xQueueSelectFromSet>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	xQueueSetMemberHandle xQueueSelectFromSet( xQueueSetHandle xQueueSet, portTickType xBlockTimeTicks )
	{
  403f1c:	b590      	push	{r4, r7, lr}
  403f1e:	b085      	sub	sp, #20
  403f20:	af00      	add	r7, sp, #0
  403f22:	6078      	str	r0, [r7, #4]
  403f24:	6039      	str	r1, [r7, #0]
	xQueueSetMemberHandle xReturn = NULL;
  403f26:	f04f 0300 	mov.w	r3, #0
  403f2a:	60fb      	str	r3, [r7, #12]

		( void ) xQueueGenericReceive( ( xQueueHandle ) xQueueSet, &xReturn, xBlockTimeTicks, pdFALSE ); /*lint !e961 Casting from one typedef to another is not redundant. */
  403f2c:	f107 030c 	add.w	r3, r7, #12
  403f30:	6878      	ldr	r0, [r7, #4]
  403f32:	4619      	mov	r1, r3
  403f34:	683a      	ldr	r2, [r7, #0]
  403f36:	f04f 0300 	mov.w	r3, #0
  403f3a:	f243 7469 	movw	r4, #14185	; 0x3769
  403f3e:	f2c0 0440 	movt	r4, #64	; 0x40
  403f42:	47a0      	blx	r4
		return xReturn;
  403f44:	68fb      	ldr	r3, [r7, #12]
	}
  403f46:	4618      	mov	r0, r3
  403f48:	f107 0714 	add.w	r7, r7, #20
  403f4c:	46bd      	mov	sp, r7
  403f4e:	bd90      	pop	{r4, r7, pc}

00403f50 <xQueueSelectFromSetFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	xQueueSetMemberHandle xQueueSelectFromSetFromISR( xQueueSetHandle xQueueSet )
	{
  403f50:	b580      	push	{r7, lr}
  403f52:	b084      	sub	sp, #16
  403f54:	af00      	add	r7, sp, #0
  403f56:	6078      	str	r0, [r7, #4]
	xQueueSetMemberHandle xReturn = NULL;
  403f58:	f04f 0300 	mov.w	r3, #0
  403f5c:	60fb      	str	r3, [r7, #12]

		( void ) xQueueReceiveFromISR( ( xQueueHandle ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
  403f5e:	f107 030c 	add.w	r3, r7, #12
  403f62:	6878      	ldr	r0, [r7, #4]
  403f64:	4619      	mov	r1, r3
  403f66:	f04f 0200 	mov.w	r2, #0
  403f6a:	f643 13cd 	movw	r3, #14797	; 0x39cd
  403f6e:	f2c0 0340 	movt	r3, #64	; 0x40
  403f72:	4798      	blx	r3
		return xReturn;
  403f74:	68fb      	ldr	r3, [r7, #12]
	}
  403f76:	4618      	mov	r0, r3
  403f78:	f107 0710 	add.w	r7, r7, #16
  403f7c:	46bd      	mov	sp, r7
  403f7e:	bd80      	pop	{r7, pc}

00403f80 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static portBASE_TYPE prvNotifyQueueSetContainer( const xQUEUE * const pxQueue, portBASE_TYPE xCopyPosition )
	{
  403f80:	b580      	push	{r7, lr}
  403f82:	b084      	sub	sp, #16
  403f84:	af00      	add	r7, sp, #0
  403f86:	6078      	str	r0, [r7, #4]
  403f88:	6039      	str	r1, [r7, #0]
	xQUEUE *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
  403f8a:	687b      	ldr	r3, [r7, #4]
  403f8c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  403f8e:	60bb      	str	r3, [r7, #8]
	portBASE_TYPE xReturn = pdFALSE;
  403f90:	f04f 0300 	mov.w	r3, #0
  403f94:	60fb      	str	r3, [r7, #12]

		configASSERT( pxQueueSetContainer );
  403f96:	68bb      	ldr	r3, [r7, #8]
  403f98:	2b00      	cmp	r3, #0
  403f9a:	d105      	bne.n	403fa8 <prvNotifyQueueSetContainer+0x28>
  403f9c:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403fa0:	f2c0 0340 	movt	r3, #64	; 0x40
  403fa4:	4798      	blx	r3
  403fa6:	e7fe      	b.n	403fa6 <prvNotifyQueueSetContainer+0x26>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
  403fa8:	68bb      	ldr	r3, [r7, #8]
  403faa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  403fac:	68bb      	ldr	r3, [r7, #8]
  403fae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  403fb0:	429a      	cmp	r2, r3
  403fb2:	d305      	bcc.n	403fc0 <prvNotifyQueueSetContainer+0x40>
  403fb4:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  403fb8:	f2c0 0340 	movt	r3, #64	; 0x40
  403fbc:	4798      	blx	r3
  403fbe:	e7fe      	b.n	403fbe <prvNotifyQueueSetContainer+0x3e>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
  403fc0:	68bb      	ldr	r3, [r7, #8]
  403fc2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  403fc4:	68bb      	ldr	r3, [r7, #8]
  403fc6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  403fc8:	429a      	cmp	r2, r3
  403fca:	d21c      	bcs.n	404006 <prvNotifyQueueSetContainer+0x86>
		{
			traceQUEUE_SEND( pxQueueSetContainer );
			/* The data copies is the handle of the queue that contains data. */
			prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
  403fcc:	f107 0304 	add.w	r3, r7, #4
  403fd0:	68b8      	ldr	r0, [r7, #8]
  403fd2:	4619      	mov	r1, r3
  403fd4:	683a      	ldr	r2, [r7, #0]
  403fd6:	f643 23fd 	movw	r3, #15101	; 0x3afd
  403fda:	f2c0 0340 	movt	r3, #64	; 0x40
  403fde:	4798      	blx	r3
			if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
  403fe0:	68bb      	ldr	r3, [r7, #8]
  403fe2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  403fe4:	2b00      	cmp	r3, #0
  403fe6:	d00e      	beq.n	404006 <prvNotifyQueueSetContainer+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
  403fe8:	68bb      	ldr	r3, [r7, #8]
  403fea:	f103 0324 	add.w	r3, r3, #36	; 0x24
  403fee:	4618      	mov	r0, r3
  403ff0:	f245 0375 	movw	r3, #20597	; 0x5075
  403ff4:	f2c0 0340 	movt	r3, #64	; 0x40
  403ff8:	4798      	blx	r3
  403ffa:	4603      	mov	r3, r0
  403ffc:	2b00      	cmp	r3, #0
  403ffe:	d002      	beq.n	404006 <prvNotifyQueueSetContainer+0x86>
				{
					/* The task waiting has a higher priority */
					xReturn = pdTRUE;
  404000:	f04f 0301 	mov.w	r3, #1
  404004:	60fb      	str	r3, [r7, #12]
				}
			}
		}

		return xReturn;
  404006:	68fb      	ldr	r3, [r7, #12]
	}
  404008:	4618      	mov	r0, r3
  40400a:	f107 0710 	add.w	r7, r7, #16
  40400e:	46bd      	mov	sp, r7
  404010:	bd80      	pop	{r7, pc}
  404012:	bf00      	nop

00404014 <xTaskGenericCreate>:
	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
  404014:	b590      	push	{r4, r7, lr}
  404016:	b08b      	sub	sp, #44	; 0x2c
  404018:	af02      	add	r7, sp, #8
  40401a:	60f8      	str	r0, [r7, #12]
  40401c:	60b9      	str	r1, [r7, #8]
  40401e:	603b      	str	r3, [r7, #0]
  404020:	4613      	mov	r3, r2
  404022:	80fb      	strh	r3, [r7, #6]
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
  404024:	68fb      	ldr	r3, [r7, #12]
  404026:	2b00      	cmp	r3, #0
  404028:	d105      	bne.n	404036 <xTaskGenericCreate+0x22>
  40402a:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  40402e:	f2c0 0340 	movt	r3, #64	; 0x40
  404032:	4798      	blx	r3
  404034:	e7fe      	b.n	404034 <xTaskGenericCreate+0x20>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
  404036:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  404038:	2b04      	cmp	r3, #4
  40403a:	d905      	bls.n	404048 <xTaskGenericCreate+0x34>
  40403c:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  404040:	f2c0 0340 	movt	r3, #64	; 0x40
  404044:	4798      	blx	r3
  404046:	e7fe      	b.n	404046 <xTaskGenericCreate+0x32>

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
  404048:	88fb      	ldrh	r3, [r7, #6]
  40404a:	4618      	mov	r0, r3
  40404c:	6bb9      	ldr	r1, [r7, #56]	; 0x38
  40404e:	f245 5391 	movw	r3, #21905	; 0x5591
  404052:	f2c0 0340 	movt	r3, #64	; 0x40
  404056:	4798      	blx	r3
  404058:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
  40405a:	69bb      	ldr	r3, [r7, #24]
  40405c:	2b00      	cmp	r3, #0
  40405e:	f000 80b2 	beq.w	4041c6 <xTaskGenericCreate+0x1b2>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
  404062:	69bb      	ldr	r3, [r7, #24]
  404064:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  404066:	88fb      	ldrh	r3, [r7, #6]
  404068:	f103 33ff 	add.w	r3, r3, #4294967295
  40406c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404070:	18d3      	adds	r3, r2, r3
  404072:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
  404074:	697b      	ldr	r3, [r7, #20]
  404076:	f023 0307 	bic.w	r3, r3, #7
  40407a:	617b      	str	r3, [r7, #20]

			/* Check the alignment of the calculated top of stack is correct. */
			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
  40407c:	697b      	ldr	r3, [r7, #20]
  40407e:	f003 0307 	and.w	r3, r3, #7
  404082:	2b00      	cmp	r3, #0
  404084:	d005      	beq.n	404092 <xTaskGenericCreate+0x7e>
  404086:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  40408a:	f2c0 0340 	movt	r3, #64	; 0x40
  40408e:	4798      	blx	r3
  404090:	e7fe      	b.n	404090 <xTaskGenericCreate+0x7c>
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
  404092:	88fb      	ldrh	r3, [r7, #6]
  404094:	9300      	str	r3, [sp, #0]
  404096:	69b8      	ldr	r0, [r7, #24]
  404098:	68b9      	ldr	r1, [r7, #8]
  40409a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40409c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40409e:	f245 24c5 	movw	r4, #21189	; 0x52c5
  4040a2:	f2c0 0440 	movt	r4, #64	; 0x40
  4040a6:	47a0      	blx	r4
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  4040a8:	6978      	ldr	r0, [r7, #20]
  4040aa:	68f9      	ldr	r1, [r7, #12]
  4040ac:	683a      	ldr	r2, [r7, #0]
  4040ae:	f642 4375 	movw	r3, #11381	; 0x2c75
  4040b2:	f2c0 0340 	movt	r3, #64	; 0x40
  4040b6:	4798      	blx	r3
  4040b8:	4602      	mov	r2, r0
  4040ba:	69bb      	ldr	r3, [r7, #24]
  4040bc:	601a      	str	r2, [r3, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
  4040be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  4040c0:	2b00      	cmp	r3, #0
  4040c2:	d002      	beq.n	4040ca <xTaskGenericCreate+0xb6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
  4040c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  4040c6:	69ba      	ldr	r2, [r7, #24]
  4040c8:	601a      	str	r2, [r3, #0]
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
  4040ca:	f642 6379 	movw	r3, #11897	; 0x2e79
  4040ce:	f2c0 0340 	movt	r3, #64	; 0x40
  4040d2:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
  4040d4:	f24a 6328 	movw	r3, #42536	; 0xa628
  4040d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4040dc:	681b      	ldr	r3, [r3, #0]
  4040de:	f103 0201 	add.w	r2, r3, #1
  4040e2:	f24a 6328 	movw	r3, #42536	; 0xa628
  4040e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4040ea:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
  4040ec:	f24a 5350 	movw	r3, #42320	; 0xa550
  4040f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4040f4:	681b      	ldr	r3, [r3, #0]
  4040f6:	2b00      	cmp	r3, #0
  4040f8:	d112      	bne.n	404120 <xTaskGenericCreate+0x10c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
  4040fa:	f24a 5350 	movw	r3, #42320	; 0xa550
  4040fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404102:	69ba      	ldr	r2, [r7, #24]
  404104:	601a      	str	r2, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
  404106:	f24a 6328 	movw	r3, #42536	; 0xa628
  40410a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40410e:	681b      	ldr	r3, [r3, #0]
  404110:	2b01      	cmp	r3, #1
  404112:	d11b      	bne.n	40414c <xTaskGenericCreate+0x138>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
  404114:	f245 3371 	movw	r3, #21361	; 0x5371
  404118:	f2c0 0340 	movt	r3, #64	; 0x40
  40411c:	4798      	blx	r3
  40411e:	e015      	b.n	40414c <xTaskGenericCreate+0x138>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
  404120:	f24a 6334 	movw	r3, #42548	; 0xa634
  404124:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404128:	681b      	ldr	r3, [r3, #0]
  40412a:	2b00      	cmp	r3, #0
  40412c:	d10e      	bne.n	40414c <xTaskGenericCreate+0x138>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
  40412e:	f24a 5350 	movw	r3, #42320	; 0xa550
  404132:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404136:	681b      	ldr	r3, [r3, #0]
  404138:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40413a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40413c:	429a      	cmp	r2, r3
  40413e:	d805      	bhi.n	40414c <xTaskGenericCreate+0x138>
					{
						pxCurrentTCB = pxNewTCB;
  404140:	f24a 5350 	movw	r3, #42320	; 0xa550
  404144:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404148:	69ba      	ldr	r2, [r7, #24]
  40414a:	601a      	str	r2, [r3, #0]
					}
				}
			}

			uxTaskNumber++;
  40414c:	f24a 6348 	movw	r3, #42568	; 0xa648
  404150:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404154:	681b      	ldr	r3, [r3, #0]
  404156:	f103 0201 	add.w	r2, r3, #1
  40415a:	f24a 6348 	movw	r3, #42568	; 0xa648
  40415e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404162:	601a      	str	r2, [r3, #0]
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
  404164:	69bb      	ldr	r3, [r7, #24]
  404166:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  404168:	f04f 0201 	mov.w	r2, #1
  40416c:	fa02 f203 	lsl.w	r2, r2, r3
  404170:	f24a 6330 	movw	r3, #42544	; 0xa630
  404174:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404178:	681b      	ldr	r3, [r3, #0]
  40417a:	431a      	orrs	r2, r3
  40417c:	f24a 6330 	movw	r3, #42544	; 0xa630
  404180:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404184:	601a      	str	r2, [r3, #0]
  404186:	69bb      	ldr	r3, [r7, #24]
  404188:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40418a:	4613      	mov	r3, r2
  40418c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404190:	189b      	adds	r3, r3, r2
  404192:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404196:	f24a 5254 	movw	r2, #42324	; 0xa554
  40419a:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40419e:	189a      	adds	r2, r3, r2
  4041a0:	69bb      	ldr	r3, [r7, #24]
  4041a2:	f103 0304 	add.w	r3, r3, #4
  4041a6:	4610      	mov	r0, r2
  4041a8:	4619      	mov	r1, r3
  4041aa:	f642 3361 	movw	r3, #11105	; 0x2b61
  4041ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4041b2:	4798      	blx	r3

			xReturn = pdPASS;
  4041b4:	f04f 0301 	mov.w	r3, #1
  4041b8:	61fb      	str	r3, [r7, #28]
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
  4041ba:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  4041be:	f2c0 0340 	movt	r3, #64	; 0x40
  4041c2:	4798      	blx	r3
  4041c4:	e002      	b.n	4041cc <xTaskGenericCreate+0x1b8>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  4041c6:	f04f 33ff 	mov.w	r3, #4294967295
  4041ca:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
  4041cc:	69fb      	ldr	r3, [r7, #28]
  4041ce:	2b01      	cmp	r3, #1
  4041d0:	d114      	bne.n	4041fc <xTaskGenericCreate+0x1e8>
	{
		if( xSchedulerRunning != pdFALSE )
  4041d2:	f24a 6334 	movw	r3, #42548	; 0xa634
  4041d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4041da:	681b      	ldr	r3, [r3, #0]
  4041dc:	2b00      	cmp	r3, #0
  4041de:	d00d      	beq.n	4041fc <xTaskGenericCreate+0x1e8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
  4041e0:	f24a 5350 	movw	r3, #42320	; 0xa550
  4041e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4041e8:	681b      	ldr	r3, [r3, #0]
  4041ea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4041ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4041ee:	429a      	cmp	r2, r3
  4041f0:	d204      	bcs.n	4041fc <xTaskGenericCreate+0x1e8>
			{
				taskYIELD_IF_USING_PREEMPTION();
  4041f2:	f642 6359 	movw	r3, #11865	; 0x2e59
  4041f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4041fa:	4798      	blx	r3
			}
		}
	}

	return xReturn;
  4041fc:	69fb      	ldr	r3, [r7, #28]
}
  4041fe:	4618      	mov	r0, r3
  404200:	f107 0724 	add.w	r7, r7, #36	; 0x24
  404204:	46bd      	mov	sp, r7
  404206:	bd90      	pop	{r4, r7, pc}

00404208 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
  404208:	b580      	push	{r7, lr}
  40420a:	b084      	sub	sp, #16
  40420c:	af00      	add	r7, sp, #0
  40420e:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
  404210:	f642 6379 	movw	r3, #11897	; 0x2e79
  404214:	f2c0 0340 	movt	r3, #64	; 0x40
  404218:	4798      	blx	r3
		{
			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
  40421a:	687b      	ldr	r3, [r7, #4]
  40421c:	2b00      	cmp	r3, #0
  40421e:	d105      	bne.n	40422c <vTaskDelete+0x24>
  404220:	f24a 5350 	movw	r3, #42320	; 0xa550
  404224:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404228:	681b      	ldr	r3, [r3, #0]
  40422a:	e000      	b.n	40422e <vTaskDelete+0x26>
  40422c:	687b      	ldr	r3, [r7, #4]
  40422e:	60fb      	str	r3, [r7, #12]

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  404230:	68fb      	ldr	r3, [r7, #12]
  404232:	f103 0304 	add.w	r3, r3, #4
  404236:	4618      	mov	r0, r3
  404238:	f642 431d 	movw	r3, #11293	; 0x2c1d
  40423c:	f2c0 0340 	movt	r3, #64	; 0x40
  404240:	4798      	blx	r3
  404242:	4603      	mov	r3, r0
  404244:	2b00      	cmp	r3, #0
  404246:	d122      	bne.n	40428e <vTaskDelete+0x86>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  404248:	68fb      	ldr	r3, [r7, #12]
  40424a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  40424c:	f24a 5254 	movw	r2, #42324	; 0xa554
  404250:	f2c2 0200 	movt	r2, #8192	; 0x2000
  404254:	460b      	mov	r3, r1
  404256:	ea4f 0383 	mov.w	r3, r3, lsl #2
  40425a:	185b      	adds	r3, r3, r1
  40425c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404260:	18d3      	adds	r3, r2, r3
  404262:	681b      	ldr	r3, [r3, #0]
  404264:	2b00      	cmp	r3, #0
  404266:	d112      	bne.n	40428e <vTaskDelete+0x86>
  404268:	68fb      	ldr	r3, [r7, #12]
  40426a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40426c:	f04f 0201 	mov.w	r2, #1
  404270:	fa02 f303 	lsl.w	r3, r2, r3
  404274:	ea6f 0203 	mvn.w	r2, r3
  404278:	f24a 6330 	movw	r3, #42544	; 0xa630
  40427c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404280:	681b      	ldr	r3, [r3, #0]
  404282:	401a      	ands	r2, r3
  404284:	f24a 6330 	movw	r3, #42544	; 0xa630
  404288:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40428c:	601a      	str	r2, [r3, #0]
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  40428e:	68fb      	ldr	r3, [r7, #12]
  404290:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  404292:	2b00      	cmp	r3, #0
  404294:	d008      	beq.n	4042a8 <vTaskDelete+0xa0>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  404296:	68fb      	ldr	r3, [r7, #12]
  404298:	f103 0318 	add.w	r3, r3, #24
  40429c:	4618      	mov	r0, r3
  40429e:	f642 431d 	movw	r3, #11293	; 0x2c1d
  4042a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4042a6:	4798      	blx	r3
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
  4042a8:	68fb      	ldr	r3, [r7, #12]
  4042aa:	f103 0304 	add.w	r3, r3, #4
  4042ae:	f24a 50fc 	movw	r0, #42492	; 0xa5fc
  4042b2:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4042b6:	4619      	mov	r1, r3
  4042b8:	f642 3361 	movw	r3, #11105	; 0x2b61
  4042bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4042c0:	4798      	blx	r3

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
  4042c2:	f24a 6310 	movw	r3, #42512	; 0xa610
  4042c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4042ca:	681b      	ldr	r3, [r3, #0]
  4042cc:	f103 0201 	add.w	r2, r3, #1
  4042d0:	f24a 6310 	movw	r3, #42512	; 0xa610
  4042d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4042d8:	601a      	str	r2, [r3, #0]

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
  4042da:	f24a 6348 	movw	r3, #42568	; 0xa648
  4042de:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4042e2:	681b      	ldr	r3, [r3, #0]
  4042e4:	f103 0201 	add.w	r2, r3, #1
  4042e8:	f24a 6348 	movw	r3, #42568	; 0xa648
  4042ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4042f0:	601a      	str	r2, [r3, #0]

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
  4042f2:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  4042f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4042fa:	4798      	blx	r3

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
  4042fc:	f24a 6334 	movw	r3, #42548	; 0xa634
  404300:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404304:	681b      	ldr	r3, [r3, #0]
  404306:	2b00      	cmp	r3, #0
  404308:	d00c      	beq.n	404324 <vTaskDelete+0x11c>
		{
			if( pxTCB == pxCurrentTCB )
  40430a:	f24a 5350 	movw	r3, #42320	; 0xa550
  40430e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404312:	681b      	ldr	r3, [r3, #0]
  404314:	68fa      	ldr	r2, [r7, #12]
  404316:	429a      	cmp	r2, r3
  404318:	d104      	bne.n	404324 <vTaskDelete+0x11c>
			{
				portYIELD_WITHIN_API();
  40431a:	f642 6359 	movw	r3, #11865	; 0x2e59
  40431e:	f2c0 0340 	movt	r3, #64	; 0x40
  404322:	4798      	blx	r3
			}
		}
	}
  404324:	f107 0710 	add.w	r7, r7, #16
  404328:	46bd      	mov	sp, r7
  40432a:	bd80      	pop	{r7, pc}

0040432c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
  40432c:	b580      	push	{r7, lr}
  40432e:	b084      	sub	sp, #16
  404330:	af00      	add	r7, sp, #0
  404332:	6078      	str	r0, [r7, #4]
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  404334:	f04f 0300 	mov.w	r3, #0
  404338:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
  40433a:	687b      	ldr	r3, [r7, #4]
  40433c:	2b00      	cmp	r3, #0
  40433e:	d03f      	beq.n	4043c0 <vTaskDelay+0x94>
		{
			vTaskSuspendAll();
  404340:	f644 03f9 	movw	r3, #18681	; 0x48f9
  404344:	f2c0 0340 	movt	r3, #64	; 0x40
  404348:	4798      	blx	r3
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
  40434a:	f24a 632c 	movw	r3, #42540	; 0xa62c
  40434e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404352:	681a      	ldr	r2, [r3, #0]
  404354:	687b      	ldr	r3, [r7, #4]
  404356:	18d3      	adds	r3, r2, r3
  404358:	60bb      	str	r3, [r7, #8]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  40435a:	f24a 5350 	movw	r3, #42320	; 0xa550
  40435e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404362:	681b      	ldr	r3, [r3, #0]
  404364:	f103 0304 	add.w	r3, r3, #4
  404368:	4618      	mov	r0, r3
  40436a:	f642 431d 	movw	r3, #11293	; 0x2c1d
  40436e:	f2c0 0340 	movt	r3, #64	; 0x40
  404372:	4798      	blx	r3
  404374:	4603      	mov	r3, r0
  404376:	2b00      	cmp	r3, #0
  404378:	d116      	bne.n	4043a8 <vTaskDelay+0x7c>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  40437a:	f24a 5350 	movw	r3, #42320	; 0xa550
  40437e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404382:	681b      	ldr	r3, [r3, #0]
  404384:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  404386:	f04f 0201 	mov.w	r2, #1
  40438a:	fa02 f303 	lsl.w	r3, r2, r3
  40438e:	ea6f 0203 	mvn.w	r2, r3
  404392:	f24a 6330 	movw	r3, #42544	; 0xa630
  404396:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40439a:	681b      	ldr	r3, [r3, #0]
  40439c:	401a      	ands	r2, r3
  40439e:	f24a 6330 	movw	r3, #42544	; 0xa630
  4043a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4043a6:	601a      	str	r2, [r3, #0]
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
  4043a8:	68b8      	ldr	r0, [r7, #8]
  4043aa:	f245 43f9 	movw	r3, #21753	; 0x54f9
  4043ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4043b2:	4798      	blx	r3
			}
			xAlreadyYielded = xTaskResumeAll();
  4043b4:	f644 131d 	movw	r3, #18717	; 0x491d
  4043b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4043bc:	4798      	blx	r3
  4043be:	60f8      	str	r0, [r7, #12]
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  4043c0:	68fb      	ldr	r3, [r7, #12]
  4043c2:	2b00      	cmp	r3, #0
  4043c4:	d104      	bne.n	4043d0 <vTaskDelay+0xa4>
		{
			portYIELD_WITHIN_API();
  4043c6:	f642 6359 	movw	r3, #11865	; 0x2e59
  4043ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4043ce:	4798      	blx	r3
		}
	}
  4043d0:	f107 0710 	add.w	r7, r7, #16
  4043d4:	46bd      	mov	sp, r7
  4043d6:	bd80      	pop	{r7, pc}

004043d8 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
	{
  4043d8:	b580      	push	{r7, lr}
  4043da:	b084      	sub	sp, #16
  4043dc:	af00      	add	r7, sp, #0
  4043de:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
  4043e0:	f642 6379 	movw	r3, #11897	; 0x2e79
  4043e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4043e8:	4798      	blx	r3
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
  4043ea:	687b      	ldr	r3, [r7, #4]
  4043ec:	2b00      	cmp	r3, #0
  4043ee:	d105      	bne.n	4043fc <uxTaskPriorityGet+0x24>
  4043f0:	f24a 5350 	movw	r3, #42320	; 0xa550
  4043f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4043f8:	681b      	ldr	r3, [r3, #0]
  4043fa:	e000      	b.n	4043fe <uxTaskPriorityGet+0x26>
  4043fc:	687b      	ldr	r3, [r7, #4]
  4043fe:	60fb      	str	r3, [r7, #12]
			uxReturn = pxTCB->uxPriority;
  404400:	68fb      	ldr	r3, [r7, #12]
  404402:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  404404:	60bb      	str	r3, [r7, #8]
		}
		taskEXIT_CRITICAL();
  404406:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  40440a:	f2c0 0340 	movt	r3, #64	; 0x40
  40440e:	4798      	blx	r3

		return uxReturn;
  404410:	68bb      	ldr	r3, [r7, #8]
	}
  404412:	4618      	mov	r0, r3
  404414:	f107 0710 	add.w	r7, r7, #16
  404418:	46bd      	mov	sp, r7
  40441a:	bd80      	pop	{r7, pc}

0040441c <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
	{
  40441c:	b580      	push	{r7, lr}
  40441e:	b086      	sub	sp, #24
  404420:	af00      	add	r7, sp, #0
  404422:	6078      	str	r0, [r7, #4]
  404424:	6039      	str	r1, [r7, #0]
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
	portBASE_TYPE xYieldRequired = pdFALSE;
  404426:	f04f 0300 	mov.w	r3, #0
  40442a:	617b      	str	r3, [r7, #20]

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
  40442c:	683b      	ldr	r3, [r7, #0]
  40442e:	2b04      	cmp	r3, #4
  404430:	d905      	bls.n	40443e <vTaskPrioritySet+0x22>
  404432:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  404436:	f2c0 0340 	movt	r3, #64	; 0x40
  40443a:	4798      	blx	r3
  40443c:	e7fe      	b.n	40443c <vTaskPrioritySet+0x20>

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
  40443e:	683b      	ldr	r3, [r7, #0]
  404440:	2b04      	cmp	r3, #4
  404442:	d902      	bls.n	40444a <vTaskPrioritySet+0x2e>
		{
			uxNewPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
  404444:	f04f 0304 	mov.w	r3, #4
  404448:	603b      	str	r3, [r7, #0]
		}

		taskENTER_CRITICAL();
  40444a:	f642 6379 	movw	r3, #11897	; 0x2e79
  40444e:	f2c0 0340 	movt	r3, #64	; 0x40
  404452:	4798      	blx	r3
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
  404454:	687b      	ldr	r3, [r7, #4]
  404456:	2b00      	cmp	r3, #0
  404458:	d105      	bne.n	404466 <vTaskPrioritySet+0x4a>
  40445a:	f24a 5350 	movw	r3, #42320	; 0xa550
  40445e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404462:	681b      	ldr	r3, [r3, #0]
  404464:	e000      	b.n	404468 <vTaskPrioritySet+0x4c>
  404466:	687b      	ldr	r3, [r7, #4]
  404468:	613b      	str	r3, [r7, #16]

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
  40446a:	693b      	ldr	r3, [r7, #16]
  40446c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40446e:	60fb      	str	r3, [r7, #12]
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
  404470:	68fa      	ldr	r2, [r7, #12]
  404472:	683b      	ldr	r3, [r7, #0]
  404474:	429a      	cmp	r2, r3
  404476:	f000 809d 	beq.w	4045b4 <vTaskPrioritySet+0x198>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
  40447a:	683a      	ldr	r2, [r7, #0]
  40447c:	68fb      	ldr	r3, [r7, #12]
  40447e:	429a      	cmp	r2, r3
  404480:	d914      	bls.n	4044ac <vTaskPrioritySet+0x90>
				{
					if( pxTCB != pxCurrentTCB )
  404482:	f24a 5350 	movw	r3, #42320	; 0xa550
  404486:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40448a:	681b      	ldr	r3, [r3, #0]
  40448c:	693a      	ldr	r2, [r7, #16]
  40448e:	429a      	cmp	r2, r3
  404490:	d017      	beq.n	4044c2 <vTaskPrioritySet+0xa6>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
  404492:	f24a 5350 	movw	r3, #42320	; 0xa550
  404496:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40449a:	681b      	ldr	r3, [r3, #0]
  40449c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40449e:	683b      	ldr	r3, [r7, #0]
  4044a0:	429a      	cmp	r2, r3
  4044a2:	d80e      	bhi.n	4044c2 <vTaskPrioritySet+0xa6>
						{
							xYieldRequired = pdTRUE;
  4044a4:	f04f 0301 	mov.w	r3, #1
  4044a8:	617b      	str	r3, [r7, #20]
  4044aa:	e00a      	b.n	4044c2 <vTaskPrioritySet+0xa6>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
  4044ac:	f24a 5350 	movw	r3, #42320	; 0xa550
  4044b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4044b4:	681b      	ldr	r3, [r3, #0]
  4044b6:	693a      	ldr	r2, [r7, #16]
  4044b8:	429a      	cmp	r2, r3
  4044ba:	d102      	bne.n	4044c2 <vTaskPrioritySet+0xa6>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
  4044bc:	f04f 0301 	mov.w	r3, #1
  4044c0:	617b      	str	r3, [r7, #20]
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
  4044c2:	693b      	ldr	r3, [r7, #16]
  4044c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4044c6:	60bb      	str	r3, [r7, #8]

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
  4044c8:	693b      	ldr	r3, [r7, #16]
  4044ca:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  4044cc:	693b      	ldr	r3, [r7, #16]
  4044ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4044d0:	429a      	cmp	r2, r3
  4044d2:	d102      	bne.n	4044da <vTaskPrioritySet+0xbe>
					{
						pxTCB->uxPriority = uxNewPriority;
  4044d4:	693b      	ldr	r3, [r7, #16]
  4044d6:	683a      	ldr	r2, [r7, #0]
  4044d8:	62da      	str	r2, [r3, #44]	; 0x2c
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
  4044da:	693b      	ldr	r3, [r7, #16]
  4044dc:	683a      	ldr	r2, [r7, #0]
  4044de:	641a      	str	r2, [r3, #64]	; 0x40
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  4044e0:	683b      	ldr	r3, [r7, #0]
  4044e2:	f1c3 0205 	rsb	r2, r3, #5
  4044e6:	693b      	ldr	r3, [r7, #16]
  4044e8:	619a      	str	r2, [r3, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
  4044ea:	693b      	ldr	r3, [r7, #16]
  4044ec:	6959      	ldr	r1, [r3, #20]
  4044ee:	68ba      	ldr	r2, [r7, #8]
  4044f0:	4613      	mov	r3, r2
  4044f2:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4044f6:	189b      	adds	r3, r3, r2
  4044f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4044fc:	f24a 5254 	movw	r2, #42324	; 0xa554
  404500:	f2c2 0200 	movt	r2, #8192	; 0x2000
  404504:	189b      	adds	r3, r3, r2
  404506:	4299      	cmp	r1, r3
  404508:	d102      	bne.n	404510 <vTaskPrioritySet+0xf4>
  40450a:	f04f 0301 	mov.w	r3, #1
  40450e:	e001      	b.n	404514 <vTaskPrioritySet+0xf8>
  404510:	f04f 0300 	mov.w	r3, #0
  404514:	2b00      	cmp	r3, #0
  404516:	d045      	beq.n	4045a4 <vTaskPrioritySet+0x188>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  404518:	693b      	ldr	r3, [r7, #16]
  40451a:	f103 0304 	add.w	r3, r3, #4
  40451e:	4618      	mov	r0, r3
  404520:	f642 431d 	movw	r3, #11293	; 0x2c1d
  404524:	f2c0 0340 	movt	r3, #64	; 0x40
  404528:	4798      	blx	r3
  40452a:	4603      	mov	r3, r0
  40452c:	2b00      	cmp	r3, #0
  40452e:	d111      	bne.n	404554 <vTaskPrioritySet+0x138>
					{
						/* It is known that the task is in its ready list so
						there is no need to check again and the port level
						reset macro can be called directly. */
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
  404530:	68bb      	ldr	r3, [r7, #8]
  404532:	f04f 0201 	mov.w	r2, #1
  404536:	fa02 f303 	lsl.w	r3, r2, r3
  40453a:	ea6f 0203 	mvn.w	r2, r3
  40453e:	f24a 6330 	movw	r3, #42544	; 0xa630
  404542:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404546:	681b      	ldr	r3, [r3, #0]
  404548:	401a      	ands	r2, r3
  40454a:	f24a 6330 	movw	r3, #42544	; 0xa630
  40454e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404552:	601a      	str	r2, [r3, #0]
					}
					prvAddTaskToReadyList( pxTCB );
  404554:	693b      	ldr	r3, [r7, #16]
  404556:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  404558:	f04f 0201 	mov.w	r2, #1
  40455c:	fa02 f203 	lsl.w	r2, r2, r3
  404560:	f24a 6330 	movw	r3, #42544	; 0xa630
  404564:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404568:	681b      	ldr	r3, [r3, #0]
  40456a:	431a      	orrs	r2, r3
  40456c:	f24a 6330 	movw	r3, #42544	; 0xa630
  404570:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404574:	601a      	str	r2, [r3, #0]
  404576:	693b      	ldr	r3, [r7, #16]
  404578:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40457a:	4613      	mov	r3, r2
  40457c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404580:	189b      	adds	r3, r3, r2
  404582:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404586:	f24a 5254 	movw	r2, #42324	; 0xa554
  40458a:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40458e:	189a      	adds	r2, r3, r2
  404590:	693b      	ldr	r3, [r7, #16]
  404592:	f103 0304 	add.w	r3, r3, #4
  404596:	4610      	mov	r0, r2
  404598:	4619      	mov	r1, r3
  40459a:	f642 3361 	movw	r3, #11105	; 0x2b61
  40459e:	f2c0 0340 	movt	r3, #64	; 0x40
  4045a2:	4798      	blx	r3
				}

				if( xYieldRequired == pdTRUE )
  4045a4:	697b      	ldr	r3, [r7, #20]
  4045a6:	2b01      	cmp	r3, #1
  4045a8:	d104      	bne.n	4045b4 <vTaskPrioritySet+0x198>
				{
					taskYIELD_IF_USING_PREEMPTION();
  4045aa:	f642 6359 	movw	r3, #11865	; 0x2e59
  4045ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4045b2:	4798      	blx	r3
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
  4045b4:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  4045b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4045bc:	4798      	blx	r3
	}
  4045be:	f107 0718 	add.w	r7, r7, #24
  4045c2:	46bd      	mov	sp, r7
  4045c4:	bd80      	pop	{r7, pc}
  4045c6:	bf00      	nop

004045c8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle xTaskToSuspend )
	{
  4045c8:	b580      	push	{r7, lr}
  4045ca:	b084      	sub	sp, #16
  4045cc:	af00      	add	r7, sp, #0
  4045ce:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
  4045d0:	f642 6379 	movw	r3, #11897	; 0x2e79
  4045d4:	f2c0 0340 	movt	r3, #64	; 0x40
  4045d8:	4798      	blx	r3
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
  4045da:	687b      	ldr	r3, [r7, #4]
  4045dc:	2b00      	cmp	r3, #0
  4045de:	d105      	bne.n	4045ec <vTaskSuspend+0x24>
  4045e0:	f24a 5350 	movw	r3, #42320	; 0xa550
  4045e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4045e8:	681b      	ldr	r3, [r3, #0]
  4045ea:	e000      	b.n	4045ee <vTaskSuspend+0x26>
  4045ec:	687b      	ldr	r3, [r7, #4]
  4045ee:	60fb      	str	r3, [r7, #12]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  4045f0:	68fb      	ldr	r3, [r7, #12]
  4045f2:	f103 0304 	add.w	r3, r3, #4
  4045f6:	4618      	mov	r0, r3
  4045f8:	f642 431d 	movw	r3, #11293	; 0x2c1d
  4045fc:	f2c0 0340 	movt	r3, #64	; 0x40
  404600:	4798      	blx	r3
  404602:	4603      	mov	r3, r0
  404604:	2b00      	cmp	r3, #0
  404606:	d122      	bne.n	40464e <vTaskSuspend+0x86>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  404608:	68fb      	ldr	r3, [r7, #12]
  40460a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  40460c:	f24a 5254 	movw	r2, #42324	; 0xa554
  404610:	f2c2 0200 	movt	r2, #8192	; 0x2000
  404614:	460b      	mov	r3, r1
  404616:	ea4f 0383 	mov.w	r3, r3, lsl #2
  40461a:	185b      	adds	r3, r3, r1
  40461c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404620:	18d3      	adds	r3, r2, r3
  404622:	681b      	ldr	r3, [r3, #0]
  404624:	2b00      	cmp	r3, #0
  404626:	d112      	bne.n	40464e <vTaskSuspend+0x86>
  404628:	68fb      	ldr	r3, [r7, #12]
  40462a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40462c:	f04f 0201 	mov.w	r2, #1
  404630:	fa02 f303 	lsl.w	r3, r2, r3
  404634:	ea6f 0203 	mvn.w	r2, r3
  404638:	f24a 6330 	movw	r3, #42544	; 0xa630
  40463c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404640:	681b      	ldr	r3, [r3, #0]
  404642:	401a      	ands	r2, r3
  404644:	f24a 6330 	movw	r3, #42544	; 0xa630
  404648:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40464c:	601a      	str	r2, [r3, #0]
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  40464e:	68fb      	ldr	r3, [r7, #12]
  404650:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  404652:	2b00      	cmp	r3, #0
  404654:	d008      	beq.n	404668 <vTaskSuspend+0xa0>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  404656:	68fb      	ldr	r3, [r7, #12]
  404658:	f103 0318 	add.w	r3, r3, #24
  40465c:	4618      	mov	r0, r3
  40465e:	f642 431d 	movw	r3, #11293	; 0x2c1d
  404662:	f2c0 0340 	movt	r3, #64	; 0x40
  404666:	4798      	blx	r3
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
  404668:	68fb      	ldr	r3, [r7, #12]
  40466a:	f103 0304 	add.w	r3, r3, #4
  40466e:	f24a 6014 	movw	r0, #42516	; 0xa614
  404672:	f2c2 0000 	movt	r0, #8192	; 0x2000
  404676:	4619      	mov	r1, r3
  404678:	f642 3361 	movw	r3, #11105	; 0x2b61
  40467c:	f2c0 0340 	movt	r3, #64	; 0x40
  404680:	4798      	blx	r3
		}
		taskEXIT_CRITICAL();
  404682:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  404686:	f2c0 0340 	movt	r3, #64	; 0x40
  40468a:	4798      	blx	r3

		if( pxTCB == pxCurrentTCB )
  40468c:	f24a 5350 	movw	r3, #42320	; 0xa550
  404690:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404694:	681b      	ldr	r3, [r3, #0]
  404696:	68fa      	ldr	r2, [r7, #12]
  404698:	429a      	cmp	r2, r3
  40469a:	d125      	bne.n	4046e8 <vTaskSuspend+0x120>
		{
			if( xSchedulerRunning != pdFALSE )
  40469c:	f24a 6334 	movw	r3, #42548	; 0xa634
  4046a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4046a4:	681b      	ldr	r3, [r3, #0]
  4046a6:	2b00      	cmp	r3, #0
  4046a8:	d005      	beq.n	4046b6 <vTaskSuspend+0xee>
			{
				/* The current task has just been suspended. */
				portYIELD_WITHIN_API();
  4046aa:	f642 6359 	movw	r3, #11865	; 0x2e59
  4046ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4046b2:	4798      	blx	r3
  4046b4:	e018      	b.n	4046e8 <vTaskSuspend+0x120>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
  4046b6:	f24a 6314 	movw	r3, #42516	; 0xa614
  4046ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4046be:	681a      	ldr	r2, [r3, #0]
  4046c0:	f24a 6328 	movw	r3, #42536	; 0xa628
  4046c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4046c8:	681b      	ldr	r3, [r3, #0]
  4046ca:	429a      	cmp	r2, r3
  4046cc:	d107      	bne.n	4046de <vTaskSuspend+0x116>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
  4046ce:	f24a 5350 	movw	r3, #42320	; 0xa550
  4046d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4046d6:	f04f 0200 	mov.w	r2, #0
  4046da:	601a      	str	r2, [r3, #0]
  4046dc:	e004      	b.n	4046e8 <vTaskSuspend+0x120>
				}
				else
				{
					vTaskSwitchContext();
  4046de:	f644 5391 	movw	r3, #19857	; 0x4d91
  4046e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4046e6:	4798      	blx	r3
				}
			}
		}
	}
  4046e8:	f107 0710 	add.w	r7, r7, #16
  4046ec:	46bd      	mov	sp, r7
  4046ee:	bd80      	pop	{r7, pc}

004046f0 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
  4046f0:	b580      	push	{r7, lr}
  4046f2:	b084      	sub	sp, #16
  4046f4:	af00      	add	r7, sp, #0
  4046f6:	6078      	str	r0, [r7, #4]
	portBASE_TYPE xReturn = pdFALSE;
  4046f8:	f04f 0300 	mov.w	r3, #0
  4046fc:	60fb      	str	r3, [r7, #12]
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
  4046fe:	687b      	ldr	r3, [r7, #4]
  404700:	60bb      	str	r3, [r7, #8]

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
  404702:	687b      	ldr	r3, [r7, #4]
  404704:	2b00      	cmp	r3, #0
  404706:	d105      	bne.n	404714 <xTaskIsTaskSuspended+0x24>
  404708:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  40470c:	f2c0 0340 	movt	r3, #64	; 0x40
  404710:	4798      	blx	r3
  404712:	e7fe      	b.n	404712 <xTaskIsTaskSuspended+0x22>

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
  404714:	68bb      	ldr	r3, [r7, #8]
  404716:	695a      	ldr	r2, [r3, #20]
  404718:	f24a 6314 	movw	r3, #42516	; 0xa614
  40471c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404720:	429a      	cmp	r2, r3
  404722:	d102      	bne.n	40472a <xTaskIsTaskSuspended+0x3a>
  404724:	f04f 0301 	mov.w	r3, #1
  404728:	e001      	b.n	40472e <xTaskIsTaskSuspended+0x3e>
  40472a:	f04f 0300 	mov.w	r3, #0
  40472e:	2b00      	cmp	r3, #0
  404730:	d015      	beq.n	40475e <xTaskIsTaskSuspended+0x6e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
  404732:	68bb      	ldr	r3, [r7, #8]
  404734:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  404736:	f24a 53e8 	movw	r3, #42472	; 0xa5e8
  40473a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40473e:	429a      	cmp	r2, r3
  404740:	d00d      	beq.n	40475e <xTaskIsTaskSuspended+0x6e>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
  404742:	68bb      	ldr	r3, [r7, #8]
  404744:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  404746:	2b00      	cmp	r3, #0
  404748:	d102      	bne.n	404750 <xTaskIsTaskSuspended+0x60>
  40474a:	f04f 0301 	mov.w	r3, #1
  40474e:	e001      	b.n	404754 <xTaskIsTaskSuspended+0x64>
  404750:	f04f 0300 	mov.w	r3, #0
  404754:	2b00      	cmp	r3, #0
  404756:	d002      	beq.n	40475e <xTaskIsTaskSuspended+0x6e>
				{
					xReturn = pdTRUE;
  404758:	f04f 0301 	mov.w	r3, #1
  40475c:	60fb      	str	r3, [r7, #12]
				}
			}
		}

		return xReturn;
  40475e:	68fb      	ldr	r3, [r7, #12]
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
  404760:	4618      	mov	r0, r3
  404762:	f107 0710 	add.w	r7, r7, #16
  404766:	46bd      	mov	sp, r7
  404768:	bd80      	pop	{r7, pc}
  40476a:	bf00      	nop

0040476c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle xTaskToResume )
	{
  40476c:	b580      	push	{r7, lr}
  40476e:	b084      	sub	sp, #16
  404770:	af00      	add	r7, sp, #0
  404772:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
  404774:	687b      	ldr	r3, [r7, #4]
  404776:	60fb      	str	r3, [r7, #12]

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
  404778:	687b      	ldr	r3, [r7, #4]
  40477a:	2b00      	cmp	r3, #0
  40477c:	d105      	bne.n	40478a <vTaskResume+0x1e>
  40477e:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  404782:	f2c0 0340 	movt	r3, #64	; 0x40
  404786:	4798      	blx	r3
  404788:	e7fe      	b.n	404788 <vTaskResume+0x1c>

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
  40478a:	68fb      	ldr	r3, [r7, #12]
  40478c:	2b00      	cmp	r3, #0
  40478e:	d05a      	beq.n	404846 <vTaskResume+0xda>
  404790:	f24a 5350 	movw	r3, #42320	; 0xa550
  404794:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404798:	681b      	ldr	r3, [r3, #0]
  40479a:	68fa      	ldr	r2, [r7, #12]
  40479c:	429a      	cmp	r2, r3
  40479e:	d052      	beq.n	404846 <vTaskResume+0xda>
		{
			taskENTER_CRITICAL();
  4047a0:	f642 6379 	movw	r3, #11897	; 0x2e79
  4047a4:	f2c0 0340 	movt	r3, #64	; 0x40
  4047a8:	4798      	blx	r3
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
  4047aa:	68f8      	ldr	r0, [r7, #12]
  4047ac:	f244 63f1 	movw	r3, #18161	; 0x46f1
  4047b0:	f2c0 0340 	movt	r3, #64	; 0x40
  4047b4:	4798      	blx	r3
  4047b6:	4603      	mov	r3, r0
  4047b8:	2b01      	cmp	r3, #1
  4047ba:	d13f      	bne.n	40483c <vTaskResume+0xd0>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
  4047bc:	68fb      	ldr	r3, [r7, #12]
  4047be:	f103 0304 	add.w	r3, r3, #4
  4047c2:	4618      	mov	r0, r3
  4047c4:	f642 431d 	movw	r3, #11293	; 0x2c1d
  4047c8:	f2c0 0340 	movt	r3, #64	; 0x40
  4047cc:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
  4047ce:	68fb      	ldr	r3, [r7, #12]
  4047d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4047d2:	f04f 0201 	mov.w	r2, #1
  4047d6:	fa02 f203 	lsl.w	r2, r2, r3
  4047da:	f24a 6330 	movw	r3, #42544	; 0xa630
  4047de:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4047e2:	681b      	ldr	r3, [r3, #0]
  4047e4:	431a      	orrs	r2, r3
  4047e6:	f24a 6330 	movw	r3, #42544	; 0xa630
  4047ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4047ee:	601a      	str	r2, [r3, #0]
  4047f0:	68fb      	ldr	r3, [r7, #12]
  4047f2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4047f4:	4613      	mov	r3, r2
  4047f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4047fa:	189b      	adds	r3, r3, r2
  4047fc:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404800:	f24a 5254 	movw	r2, #42324	; 0xa554
  404804:	f2c2 0200 	movt	r2, #8192	; 0x2000
  404808:	189a      	adds	r2, r3, r2
  40480a:	68fb      	ldr	r3, [r7, #12]
  40480c:	f103 0304 	add.w	r3, r3, #4
  404810:	4610      	mov	r0, r2
  404812:	4619      	mov	r1, r3
  404814:	f642 3361 	movw	r3, #11105	; 0x2b61
  404818:	f2c0 0340 	movt	r3, #64	; 0x40
  40481c:	4798      	blx	r3

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  40481e:	68fb      	ldr	r3, [r7, #12]
  404820:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  404822:	f24a 5350 	movw	r3, #42320	; 0xa550
  404826:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40482a:	681b      	ldr	r3, [r3, #0]
  40482c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40482e:	429a      	cmp	r2, r3
  404830:	d304      	bcc.n	40483c <vTaskResume+0xd0>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
  404832:	f642 6359 	movw	r3, #11865	; 0x2e59
  404836:	f2c0 0340 	movt	r3, #64	; 0x40
  40483a:	4798      	blx	r3
					}
				}
			}
			taskEXIT_CRITICAL();
  40483c:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  404840:	f2c0 0340 	movt	r3, #64	; 0x40
  404844:	4798      	blx	r3
		}
	}
  404846:	f107 0710 	add.w	r7, r7, #16
  40484a:	46bd      	mov	sp, r7
  40484c:	bd80      	pop	{r7, pc}
  40484e:	bf00      	nop

00404850 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
  404850:	b590      	push	{r4, r7, lr}
  404852:	b087      	sub	sp, #28
  404854:	af04      	add	r7, sp, #16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
  404856:	f04f 0300 	mov.w	r3, #0
  40485a:	9300      	str	r3, [sp, #0]
  40485c:	f04f 0300 	mov.w	r3, #0
  404860:	9301      	str	r3, [sp, #4]
  404862:	f04f 0300 	mov.w	r3, #0
  404866:	9302      	str	r3, [sp, #8]
  404868:	f04f 0300 	mov.w	r3, #0
  40486c:	9303      	str	r3, [sp, #12]
  40486e:	f245 2095 	movw	r0, #21141	; 0x5295
  404872:	f2c0 0040 	movt	r0, #64	; 0x40
  404876:	f249 61a4 	movw	r1, #38564	; 0x96a4
  40487a:	f2c0 0140 	movt	r1, #64	; 0x40
  40487e:	f04f 0282 	mov.w	r2, #130	; 0x82
  404882:	f04f 0300 	mov.w	r3, #0
  404886:	f244 0415 	movw	r4, #16405	; 0x4015
  40488a:	f2c0 0440 	movt	r4, #64	; 0x40
  40488e:	47a0      	blx	r4
  404890:	6078      	str	r0, [r7, #4]
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
  404892:	687b      	ldr	r3, [r7, #4]
  404894:	2b01      	cmp	r3, #1
  404896:	d105      	bne.n	4048a4 <vTaskStartScheduler+0x54>
		{
			xReturn = xTimerCreateTimerTask();
  404898:	f645 03dd 	movw	r3, #22749	; 0x58dd
  40489c:	f2c0 0340 	movt	r3, #64	; 0x40
  4048a0:	4798      	blx	r3
  4048a2:	6078      	str	r0, [r7, #4]
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
  4048a4:	687b      	ldr	r3, [r7, #4]
  4048a6:	2b01      	cmp	r3, #1
  4048a8:	d118      	bne.n	4048dc <vTaskStartScheduler+0x8c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
  4048aa:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4048ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4048b2:	4798      	blx	r3
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
  4048b4:	f24a 6334 	movw	r3, #42548	; 0xa634
  4048b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4048bc:	f04f 0201 	mov.w	r2, #1
  4048c0:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
  4048c2:	f24a 632c 	movw	r3, #42540	; 0xa62c
  4048c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4048ca:	f04f 0200 	mov.w	r2, #0
  4048ce:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  4048d0:	f642 5339 	movw	r3, #11577	; 0x2d39
  4048d4:	f2c0 0340 	movt	r3, #64	; 0x40
  4048d8:	4798      	blx	r3
  4048da:	e008      	b.n	4048ee <vTaskStartScheduler+0x9e>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
  4048dc:	687b      	ldr	r3, [r7, #4]
  4048de:	2b00      	cmp	r3, #0
  4048e0:	d105      	bne.n	4048ee <vTaskStartScheduler+0x9e>
  4048e2:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4048e6:	f2c0 0340 	movt	r3, #64	; 0x40
  4048ea:	4798      	blx	r3
  4048ec:	e7fe      	b.n	4048ec <vTaskStartScheduler+0x9c>
	}
}
  4048ee:	f107 070c 	add.w	r7, r7, #12
  4048f2:	46bd      	mov	sp, r7
  4048f4:	bd90      	pop	{r4, r7, pc}
  4048f6:	bf00      	nop

004048f8 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
  4048f8:	b480      	push	{r7}
  4048fa:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  4048fc:	f24a 6338 	movw	r3, #42552	; 0xa638
  404900:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404904:	681b      	ldr	r3, [r3, #0]
  404906:	f103 0201 	add.w	r2, r3, #1
  40490a:	f24a 6338 	movw	r3, #42552	; 0xa638
  40490e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404912:	601a      	str	r2, [r3, #0]
}
  404914:	46bd      	mov	sp, r7
  404916:	bc80      	pop	{r7}
  404918:	4770      	bx	lr
  40491a:	bf00      	nop

0040491c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
  40491c:	b580      	push	{r7, lr}
  40491e:	b082      	sub	sp, #8
  404920:	af00      	add	r7, sp, #0
tskTCB *pxTCB;
portBASE_TYPE xAlreadyYielded = pdFALSE;
  404922:	f04f 0300 	mov.w	r3, #0
  404926:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
  404928:	f24a 6338 	movw	r3, #42552	; 0xa638
  40492c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404930:	681b      	ldr	r3, [r3, #0]
  404932:	2b00      	cmp	r3, #0
  404934:	d105      	bne.n	404942 <xTaskResumeAll+0x26>
  404936:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  40493a:	f2c0 0340 	movt	r3, #64	; 0x40
  40493e:	4798      	blx	r3
  404940:	e7fe      	b.n	404940 <xTaskResumeAll+0x24>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  404942:	f642 6379 	movw	r3, #11897	; 0x2e79
  404946:	f2c0 0340 	movt	r3, #64	; 0x40
  40494a:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  40494c:	f24a 6338 	movw	r3, #42552	; 0xa638
  404950:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404954:	681b      	ldr	r3, [r3, #0]
  404956:	f103 32ff 	add.w	r2, r3, #4294967295
  40495a:	f24a 6338 	movw	r3, #42552	; 0xa638
  40495e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404962:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  404964:	f24a 6338 	movw	r3, #42552	; 0xa638
  404968:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40496c:	681b      	ldr	r3, [r3, #0]
  40496e:	2b00      	cmp	r3, #0
  404970:	f040 809b 	bne.w	404aaa <xTaskResumeAll+0x18e>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
  404974:	f24a 6328 	movw	r3, #42536	; 0xa628
  404978:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40497c:	681b      	ldr	r3, [r3, #0]
  40497e:	2b00      	cmp	r3, #0
  404980:	f000 8093 	beq.w	404aaa <xTaskResumeAll+0x18e>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  404984:	e051      	b.n	404a2a <xTaskResumeAll+0x10e>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
  404986:	f24a 53e8 	movw	r3, #42472	; 0xa5e8
  40498a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40498e:	68db      	ldr	r3, [r3, #12]
  404990:	68db      	ldr	r3, [r3, #12]
  404992:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  404994:	683b      	ldr	r3, [r7, #0]
  404996:	f103 0318 	add.w	r3, r3, #24
  40499a:	4618      	mov	r0, r3
  40499c:	f642 431d 	movw	r3, #11293	; 0x2c1d
  4049a0:	f2c0 0340 	movt	r3, #64	; 0x40
  4049a4:	4798      	blx	r3
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
  4049a6:	683b      	ldr	r3, [r7, #0]
  4049a8:	f103 0304 	add.w	r3, r3, #4
  4049ac:	4618      	mov	r0, r3
  4049ae:	f642 431d 	movw	r3, #11293	; 0x2c1d
  4049b2:	f2c0 0340 	movt	r3, #64	; 0x40
  4049b6:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
  4049b8:	683b      	ldr	r3, [r7, #0]
  4049ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4049bc:	f04f 0201 	mov.w	r2, #1
  4049c0:	fa02 f203 	lsl.w	r2, r2, r3
  4049c4:	f24a 6330 	movw	r3, #42544	; 0xa630
  4049c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4049cc:	681b      	ldr	r3, [r3, #0]
  4049ce:	431a      	orrs	r2, r3
  4049d0:	f24a 6330 	movw	r3, #42544	; 0xa630
  4049d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4049d8:	601a      	str	r2, [r3, #0]
  4049da:	683b      	ldr	r3, [r7, #0]
  4049dc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4049de:	4613      	mov	r3, r2
  4049e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4049e4:	189b      	adds	r3, r3, r2
  4049e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4049ea:	f24a 5254 	movw	r2, #42324	; 0xa554
  4049ee:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4049f2:	189a      	adds	r2, r3, r2
  4049f4:	683b      	ldr	r3, [r7, #0]
  4049f6:	f103 0304 	add.w	r3, r3, #4
  4049fa:	4610      	mov	r0, r2
  4049fc:	4619      	mov	r1, r3
  4049fe:	f642 3361 	movw	r3, #11105	; 0x2b61
  404a02:	f2c0 0340 	movt	r3, #64	; 0x40
  404a06:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  404a08:	683b      	ldr	r3, [r7, #0]
  404a0a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  404a0c:	f24a 5350 	movw	r3, #42320	; 0xa550
  404a10:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404a14:	681b      	ldr	r3, [r3, #0]
  404a16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  404a18:	429a      	cmp	r2, r3
  404a1a:	d306      	bcc.n	404a2a <xTaskResumeAll+0x10e>
					{
						xYieldPending = pdTRUE;
  404a1c:	f24a 6340 	movw	r3, #42560	; 0xa640
  404a20:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404a24:	f04f 0201 	mov.w	r2, #1
  404a28:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  404a2a:	f24a 53e8 	movw	r3, #42472	; 0xa5e8
  404a2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404a32:	681b      	ldr	r3, [r3, #0]
  404a34:	2b00      	cmp	r3, #0
  404a36:	d1a6      	bne.n	404986 <xTaskResumeAll+0x6a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
  404a38:	f24a 633c 	movw	r3, #42556	; 0xa63c
  404a3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404a40:	681b      	ldr	r3, [r3, #0]
  404a42:	2b00      	cmp	r3, #0
  404a44:	d022      	beq.n	404a8c <xTaskResumeAll+0x170>
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
  404a46:	e01a      	b.n	404a7e <xTaskResumeAll+0x162>
					{
						if( xTaskIncrementTick() != pdFALSE )
  404a48:	f644 330d 	movw	r3, #19213	; 0x4b0d
  404a4c:	f2c0 0340 	movt	r3, #64	; 0x40
  404a50:	4798      	blx	r3
  404a52:	4603      	mov	r3, r0
  404a54:	2b00      	cmp	r3, #0
  404a56:	d006      	beq.n	404a66 <xTaskResumeAll+0x14a>
						{
							xYieldPending = pdTRUE;
  404a58:	f24a 6340 	movw	r3, #42560	; 0xa640
  404a5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404a60:	f04f 0201 	mov.w	r2, #1
  404a64:	601a      	str	r2, [r3, #0]
						}
						--uxPendedTicks;
  404a66:	f24a 633c 	movw	r3, #42556	; 0xa63c
  404a6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404a6e:	681b      	ldr	r3, [r3, #0]
  404a70:	f103 32ff 	add.w	r2, r3, #4294967295
  404a74:	f24a 633c 	movw	r3, #42556	; 0xa63c
  404a78:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404a7c:	601a      	str	r2, [r3, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
  404a7e:	f24a 633c 	movw	r3, #42556	; 0xa63c
  404a82:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404a86:	681b      	ldr	r3, [r3, #0]
  404a88:	2b00      	cmp	r3, #0
  404a8a:	d1dd      	bne.n	404a48 <xTaskResumeAll+0x12c>
						}
						--uxPendedTicks;
					}
				}

				if( xYieldPending == pdTRUE )
  404a8c:	f24a 6340 	movw	r3, #42560	; 0xa640
  404a90:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404a94:	681b      	ldr	r3, [r3, #0]
  404a96:	2b01      	cmp	r3, #1
  404a98:	d107      	bne.n	404aaa <xTaskResumeAll+0x18e>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
  404a9a:	f04f 0301 	mov.w	r3, #1
  404a9e:	607b      	str	r3, [r7, #4]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
  404aa0:	f642 6359 	movw	r3, #11865	; 0x2e59
  404aa4:	f2c0 0340 	movt	r3, #64	; 0x40
  404aa8:	4798      	blx	r3
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  404aaa:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  404aae:	f2c0 0340 	movt	r3, #64	; 0x40
  404ab2:	4798      	blx	r3

	return xAlreadyYielded;
  404ab4:	687b      	ldr	r3, [r7, #4]
}
  404ab6:	4618      	mov	r0, r3
  404ab8:	f107 0708 	add.w	r7, r7, #8
  404abc:	46bd      	mov	sp, r7
  404abe:	bd80      	pop	{r7, pc}

00404ac0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCount( void )
{
  404ac0:	b580      	push	{r7, lr}
  404ac2:	b082      	sub	sp, #8
  404ac4:	af00      	add	r7, sp, #0
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
  404ac6:	f642 6379 	movw	r3, #11897	; 0x2e79
  404aca:	f2c0 0340 	movt	r3, #64	; 0x40
  404ace:	4798      	blx	r3
	{
		xTicks = xTickCount;
  404ad0:	f24a 632c 	movw	r3, #42540	; 0xa62c
  404ad4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404ad8:	681b      	ldr	r3, [r3, #0]
  404ada:	607b      	str	r3, [r7, #4]
	}
	taskEXIT_CRITICAL();
  404adc:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  404ae0:	f2c0 0340 	movt	r3, #64	; 0x40
  404ae4:	4798      	blx	r3

	return xTicks;
  404ae6:	687b      	ldr	r3, [r7, #4]
}
  404ae8:	4618      	mov	r0, r3
  404aea:	f107 0708 	add.w	r7, r7, #8
  404aee:	46bd      	mov	sp, r7
  404af0:	bd80      	pop	{r7, pc}
  404af2:	bf00      	nop

00404af4 <uxTaskGetNumberOfTasks>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
  404af4:	b480      	push	{r7}
  404af6:	af00      	add	r7, sp, #0
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
  404af8:	f24a 6328 	movw	r3, #42536	; 0xa628
  404afc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404b00:	681b      	ldr	r3, [r3, #0]
}
  404b02:	4618      	mov	r0, r3
  404b04:	46bd      	mov	sp, r7
  404b06:	bc80      	pop	{r7}
  404b08:	4770      	bx	lr
  404b0a:	bf00      	nop

00404b0c <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

portBASE_TYPE xTaskIncrementTick( void )
{
  404b0c:	b580      	push	{r7, lr}
  404b0e:	b086      	sub	sp, #24
  404b10:	af00      	add	r7, sp, #0
tskTCB * pxTCB;
portTickType xItemValue;
portBASE_TYPE xSwitchRequired = pdFALSE;
  404b12:	f04f 0300 	mov.w	r3, #0
  404b16:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  404b18:	f24a 6338 	movw	r3, #42552	; 0xa638
  404b1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404b20:	681b      	ldr	r3, [r3, #0]
  404b22:	2b00      	cmp	r3, #0
  404b24:	f040 8112 	bne.w	404d4c <xTaskIncrementTick+0x240>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
  404b28:	f24a 632c 	movw	r3, #42540	; 0xa62c
  404b2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404b30:	681b      	ldr	r3, [r3, #0]
  404b32:	f103 0201 	add.w	r2, r3, #1
  404b36:	f24a 632c 	movw	r3, #42540	; 0xa62c
  404b3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404b3e:	601a      	str	r2, [r3, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
  404b40:	f24a 632c 	movw	r3, #42540	; 0xa62c
  404b44:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404b48:	681b      	ldr	r3, [r3, #0]
  404b4a:	613b      	str	r3, [r7, #16]

			if( xConstTickCount == ( portTickType ) 0U )
  404b4c:	693b      	ldr	r3, [r7, #16]
  404b4e:	2b00      	cmp	r3, #0
  404b50:	d155      	bne.n	404bfe <xTaskIncrementTick+0xf2>
			{
				taskSWITCH_DELAYED_LISTS();
  404b52:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  404b56:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404b5a:	681b      	ldr	r3, [r3, #0]
  404b5c:	681b      	ldr	r3, [r3, #0]
  404b5e:	2b00      	cmp	r3, #0
  404b60:	d005      	beq.n	404b6e <xTaskIncrementTick+0x62>
  404b62:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  404b66:	f2c0 0340 	movt	r3, #64	; 0x40
  404b6a:	4798      	blx	r3
  404b6c:	e7fe      	b.n	404b6c <xTaskIncrementTick+0x60>
  404b6e:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  404b72:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404b76:	681b      	ldr	r3, [r3, #0]
  404b78:	60fb      	str	r3, [r7, #12]
  404b7a:	f24a 53e4 	movw	r3, #42468	; 0xa5e4
  404b7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404b82:	681a      	ldr	r2, [r3, #0]
  404b84:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  404b88:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404b8c:	601a      	str	r2, [r3, #0]
  404b8e:	f24a 53e4 	movw	r3, #42468	; 0xa5e4
  404b92:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404b96:	68fa      	ldr	r2, [r7, #12]
  404b98:	601a      	str	r2, [r3, #0]
  404b9a:	f24a 6344 	movw	r3, #42564	; 0xa644
  404b9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404ba2:	681b      	ldr	r3, [r3, #0]
  404ba4:	f103 0201 	add.w	r2, r3, #1
  404ba8:	f24a 6344 	movw	r3, #42564	; 0xa644
  404bac:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404bb0:	601a      	str	r2, [r3, #0]
  404bb2:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  404bb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404bba:	681b      	ldr	r3, [r3, #0]
  404bbc:	681b      	ldr	r3, [r3, #0]
  404bbe:	2b00      	cmp	r3, #0
  404bc0:	d102      	bne.n	404bc8 <xTaskIncrementTick+0xbc>
  404bc2:	f04f 0301 	mov.w	r3, #1
  404bc6:	e001      	b.n	404bcc <xTaskIncrementTick+0xc0>
  404bc8:	f04f 0300 	mov.w	r3, #0
  404bcc:	2b00      	cmp	r3, #0
  404bce:	d007      	beq.n	404be0 <xTaskIncrementTick+0xd4>
  404bd0:	f240 0318 	movw	r3, #24
  404bd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404bd8:	f04f 32ff 	mov.w	r2, #4294967295
  404bdc:	601a      	str	r2, [r3, #0]
  404bde:	e00e      	b.n	404bfe <xTaskIncrementTick+0xf2>
  404be0:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  404be4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404be8:	681b      	ldr	r3, [r3, #0]
  404bea:	68db      	ldr	r3, [r3, #12]
  404bec:	68db      	ldr	r3, [r3, #12]
  404bee:	60bb      	str	r3, [r7, #8]
  404bf0:	68bb      	ldr	r3, [r7, #8]
  404bf2:	685a      	ldr	r2, [r3, #4]
  404bf4:	f240 0318 	movw	r3, #24
  404bf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404bfc:	601a      	str	r2, [r3, #0]

			/* See if this tick has made a timeout expire.  Tasks are stored in the
			queue in the order of their wake time - meaning once one tasks has been
			found whose block time has not expired there is no need not look any
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
  404bfe:	f240 0318 	movw	r3, #24
  404c02:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404c06:	681b      	ldr	r3, [r3, #0]
  404c08:	693a      	ldr	r2, [r7, #16]
  404c0a:	429a      	cmp	r2, r3
  404c0c:	d37a      	bcc.n	404d04 <xTaskIncrementTick+0x1f8>
  404c0e:	e000      	b.n	404c12 <xTaskIncrementTick+0x106>
								xSwitchRequired = pdTRUE;
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
  404c10:	bf00      	nop
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  404c12:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  404c16:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404c1a:	681b      	ldr	r3, [r3, #0]
  404c1c:	681b      	ldr	r3, [r3, #0]
  404c1e:	2b00      	cmp	r3, #0
  404c20:	d102      	bne.n	404c28 <xTaskIncrementTick+0x11c>
  404c22:	f04f 0301 	mov.w	r3, #1
  404c26:	e001      	b.n	404c2c <xTaskIncrementTick+0x120>
  404c28:	f04f 0300 	mov.w	r3, #0
  404c2c:	2b00      	cmp	r3, #0
  404c2e:	d007      	beq.n	404c40 <xTaskIncrementTick+0x134>
					{
						/* The delayed list is empty.  Set xNextTaskUnblockTime to
						the	maximum possible value so it is extremely unlikely that
						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
  404c30:	f240 0318 	movw	r3, #24
  404c34:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404c38:	f04f 32ff 	mov.w	r2, #4294967295
  404c3c:	601a      	str	r2, [r3, #0]
						break;
  404c3e:	e061      	b.n	404d04 <xTaskIncrementTick+0x1f8>
					{
						/* The delayed list is not empty, get the value of the item
						at the head of the delayed list.  This is the time at which
						the task at the head of the delayed list must be removed
						from the Blocked state. */
						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  404c40:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  404c44:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404c48:	681b      	ldr	r3, [r3, #0]
  404c4a:	68db      	ldr	r3, [r3, #12]
  404c4c:	68db      	ldr	r3, [r3, #12]
  404c4e:	60bb      	str	r3, [r7, #8]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  404c50:	68bb      	ldr	r3, [r7, #8]
  404c52:	685b      	ldr	r3, [r3, #4]
  404c54:	607b      	str	r3, [r7, #4]

						if( xConstTickCount < xItemValue )
  404c56:	693a      	ldr	r2, [r7, #16]
  404c58:	687b      	ldr	r3, [r7, #4]
  404c5a:	429a      	cmp	r2, r3
  404c5c:	d206      	bcs.n	404c6c <xTaskIncrementTick+0x160>
						{
							/* It is not time to unblock this item yet, but the item
							value is the time at which the task at the head of the
							blocked list must be removed from the Blocked state -
							so record the item value in xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
  404c5e:	f240 0318 	movw	r3, #24
  404c62:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404c66:	687a      	ldr	r2, [r7, #4]
  404c68:	601a      	str	r2, [r3, #0]
							break;
  404c6a:	e04b      	b.n	404d04 <xTaskIncrementTick+0x1f8>
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
  404c6c:	68bb      	ldr	r3, [r7, #8]
  404c6e:	f103 0304 	add.w	r3, r3, #4
  404c72:	4618      	mov	r0, r3
  404c74:	f642 431d 	movw	r3, #11293	; 0x2c1d
  404c78:	f2c0 0340 	movt	r3, #64	; 0x40
  404c7c:	4798      	blx	r3

						/* Is the task waiting on an event also?  If so remove it
						from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  404c7e:	68bb      	ldr	r3, [r7, #8]
  404c80:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  404c82:	2b00      	cmp	r3, #0
  404c84:	d008      	beq.n	404c98 <xTaskIncrementTick+0x18c>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  404c86:	68bb      	ldr	r3, [r7, #8]
  404c88:	f103 0318 	add.w	r3, r3, #24
  404c8c:	4618      	mov	r0, r3
  404c8e:	f642 431d 	movw	r3, #11293	; 0x2c1d
  404c92:	f2c0 0340 	movt	r3, #64	; 0x40
  404c96:	4798      	blx	r3
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
  404c98:	68bb      	ldr	r3, [r7, #8]
  404c9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  404c9c:	f04f 0201 	mov.w	r2, #1
  404ca0:	fa02 f203 	lsl.w	r2, r2, r3
  404ca4:	f24a 6330 	movw	r3, #42544	; 0xa630
  404ca8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404cac:	681b      	ldr	r3, [r3, #0]
  404cae:	431a      	orrs	r2, r3
  404cb0:	f24a 6330 	movw	r3, #42544	; 0xa630
  404cb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404cb8:	601a      	str	r2, [r3, #0]
  404cba:	68bb      	ldr	r3, [r7, #8]
  404cbc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  404cbe:	4613      	mov	r3, r2
  404cc0:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404cc4:	189b      	adds	r3, r3, r2
  404cc6:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404cca:	f24a 5254 	movw	r2, #42324	; 0xa554
  404cce:	f2c2 0200 	movt	r2, #8192	; 0x2000
  404cd2:	189a      	adds	r2, r3, r2
  404cd4:	68bb      	ldr	r3, [r7, #8]
  404cd6:	f103 0304 	add.w	r3, r3, #4
  404cda:	4610      	mov	r0, r2
  404cdc:	4619      	mov	r1, r3
  404cde:	f642 3361 	movw	r3, #11105	; 0x2b61
  404ce2:	f2c0 0340 	movt	r3, #64	; 0x40
  404ce6:	4798      	blx	r3
						{
							/* Preemption is on, but a context switch should only
							be performed if the unblocked task has a priority that
							is equal to or higher than the currently executing
							task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  404ce8:	68bb      	ldr	r3, [r7, #8]
  404cea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  404cec:	f24a 5350 	movw	r3, #42320	; 0xa550
  404cf0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404cf4:	681b      	ldr	r3, [r3, #0]
  404cf6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  404cf8:	429a      	cmp	r2, r3
  404cfa:	d389      	bcc.n	404c10 <xTaskIncrementTick+0x104>
							{
								xSwitchRequired = pdTRUE;
  404cfc:	f04f 0301 	mov.w	r3, #1
  404d00:	617b      	str	r3, [r7, #20]
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
  404d02:	e785      	b.n	404c10 <xTaskIncrementTick+0x104>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  404d04:	f24a 5350 	movw	r3, #42320	; 0xa550
  404d08:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404d0c:	681b      	ldr	r3, [r3, #0]
  404d0e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  404d10:	f24a 5254 	movw	r2, #42324	; 0xa554
  404d14:	f2c2 0200 	movt	r2, #8192	; 0x2000
  404d18:	460b      	mov	r3, r1
  404d1a:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404d1e:	185b      	adds	r3, r3, r1
  404d20:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404d24:	18d3      	adds	r3, r2, r3
  404d26:	681b      	ldr	r3, [r3, #0]
  404d28:	2b01      	cmp	r3, #1
  404d2a:	d902      	bls.n	404d32 <xTaskIncrementTick+0x226>
			{
				xSwitchRequired = pdTRUE;
  404d2c:	f04f 0301 	mov.w	r3, #1
  404d30:	617b      	str	r3, [r7, #20]

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( unsigned portBASE_TYPE ) 0U )
  404d32:	f24a 633c 	movw	r3, #42556	; 0xa63c
  404d36:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404d3a:	681b      	ldr	r3, [r3, #0]
  404d3c:	2b00      	cmp	r3, #0
  404d3e:	d116      	bne.n	404d6e <xTaskIncrementTick+0x262>
			{
				vApplicationTickHook();
  404d40:	f249 1369 	movw	r3, #37225	; 0x9169
  404d44:	f2c0 0340 	movt	r3, #64	; 0x40
  404d48:	4798      	blx	r3
  404d4a:	e010      	b.n	404d6e <xTaskIncrementTick+0x262>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
  404d4c:	f24a 633c 	movw	r3, #42556	; 0xa63c
  404d50:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404d54:	681b      	ldr	r3, [r3, #0]
  404d56:	f103 0201 	add.w	r2, r3, #1
  404d5a:	f24a 633c 	movw	r3, #42556	; 0xa63c
  404d5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404d62:	601a      	str	r2, [r3, #0]

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
  404d64:	f249 1369 	movw	r3, #37225	; 0x9169
  404d68:	f2c0 0340 	movt	r3, #64	; 0x40
  404d6c:	4798      	blx	r3
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
  404d6e:	f24a 6340 	movw	r3, #42560	; 0xa640
  404d72:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404d76:	681b      	ldr	r3, [r3, #0]
  404d78:	2b00      	cmp	r3, #0
  404d7a:	d002      	beq.n	404d82 <xTaskIncrementTick+0x276>
		{
			xSwitchRequired = pdTRUE;
  404d7c:	f04f 0301 	mov.w	r3, #1
  404d80:	617b      	str	r3, [r7, #20]
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
  404d82:	697b      	ldr	r3, [r7, #20]
}
  404d84:	4618      	mov	r0, r3
  404d86:	f107 0718 	add.w	r7, r7, #24
  404d8a:	46bd      	mov	sp, r7
  404d8c:	bd80      	pop	{r7, pc}
  404d8e:	bf00      	nop

00404d90 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  404d90:	b590      	push	{r4, r7, lr}
  404d92:	b085      	sub	sp, #20
  404d94:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  404d96:	f24a 6338 	movw	r3, #42552	; 0xa638
  404d9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404d9e:	681b      	ldr	r3, [r3, #0]
  404da0:	2b00      	cmp	r3, #0
  404da2:	d007      	beq.n	404db4 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
  404da4:	f24a 6340 	movw	r3, #42560	; 0xa640
  404da8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404dac:	f04f 0201 	mov.w	r2, #1
  404db0:	601a      	str	r2, [r3, #0]
  404db2:	e098      	b.n	404ee6 <vTaskSwitchContext+0x156>
	}
	else
	{
		xYieldPending = pdFALSE;
  404db4:	f24a 6340 	movw	r3, #42560	; 0xa640
  404db8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404dbc:	f04f 0200 	mov.w	r2, #0
  404dc0:	601a      	str	r2, [r3, #0]
				}
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
  404dc2:	f24a 5350 	movw	r3, #42320	; 0xa550
  404dc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404dca:	681b      	ldr	r3, [r3, #0]
  404dcc:	681a      	ldr	r2, [r3, #0]
  404dce:	f24a 5350 	movw	r3, #42320	; 0xa550
  404dd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404dd6:	681b      	ldr	r3, [r3, #0]
  404dd8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  404dda:	429a      	cmp	r2, r3
  404ddc:	d812      	bhi.n	404e04 <vTaskSwitchContext+0x74>
  404dde:	f24a 5350 	movw	r3, #42320	; 0xa550
  404de2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404de6:	681a      	ldr	r2, [r3, #0]
  404de8:	f24a 5350 	movw	r3, #42320	; 0xa550
  404dec:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404df0:	681b      	ldr	r3, [r3, #0]
  404df2:	f103 0334 	add.w	r3, r3, #52	; 0x34
  404df6:	4610      	mov	r0, r2
  404df8:	4619      	mov	r1, r3
  404dfa:	f249 1351 	movw	r3, #37201	; 0x9151
  404dfe:	f2c0 0340 	movt	r3, #64	; 0x40
  404e02:	4798      	blx	r3
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
  404e04:	f24a 5350 	movw	r3, #42320	; 0xa550
  404e08:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404e0c:	681b      	ldr	r3, [r3, #0]
  404e0e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  404e10:	4618      	mov	r0, r3
  404e12:	f249 61ac 	movw	r1, #38572	; 0x96ac
  404e16:	f2c0 0140 	movt	r1, #64	; 0x40
  404e1a:	f04f 0214 	mov.w	r2, #20
  404e1e:	f249 6329 	movw	r3, #38441	; 0x9629
  404e22:	f2c0 0340 	movt	r3, #64	; 0x40
  404e26:	4798      	blx	r3
  404e28:	4603      	mov	r3, r0
  404e2a:	2b00      	cmp	r3, #0
  404e2c:	d012      	beq.n	404e54 <vTaskSwitchContext+0xc4>
  404e2e:	f24a 5350 	movw	r3, #42320	; 0xa550
  404e32:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404e36:	681a      	ldr	r2, [r3, #0]
  404e38:	f24a 5350 	movw	r3, #42320	; 0xa550
  404e3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404e40:	681b      	ldr	r3, [r3, #0]
  404e42:	f103 0334 	add.w	r3, r3, #52	; 0x34
  404e46:	4610      	mov	r0, r2
  404e48:	4619      	mov	r1, r3
  404e4a:	f249 1351 	movw	r3, #37201	; 0x9151
  404e4e:	f2c0 0340 	movt	r3, #64	; 0x40
  404e52:	4798      	blx	r3

		taskSELECT_HIGHEST_PRIORITY_TASK();
  404e54:	f24a 6330 	movw	r3, #42544	; 0xa630
  404e58:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404e5c:	681b      	ldr	r3, [r3, #0]
  404e5e:	607b      	str	r3, [r7, #4]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline unsigned char ucPortCountLeadingZeros( unsigned long ulBitmap )
	{
	unsigned char ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
  404e60:	687b      	ldr	r3, [r7, #4]
  404e62:	fab3 f483 	clz	r4, r3
  404e66:	70fc      	strb	r4, [r7, #3]
		return ucReturn;
  404e68:	78fb      	ldrb	r3, [r7, #3]
  404e6a:	f1c3 031f 	rsb	r3, r3, #31
  404e6e:	60fb      	str	r3, [r7, #12]
  404e70:	f24a 5254 	movw	r2, #42324	; 0xa554
  404e74:	f2c2 0200 	movt	r2, #8192	; 0x2000
  404e78:	68f9      	ldr	r1, [r7, #12]
  404e7a:	460b      	mov	r3, r1
  404e7c:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404e80:	185b      	adds	r3, r3, r1
  404e82:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404e86:	18d3      	adds	r3, r2, r3
  404e88:	681b      	ldr	r3, [r3, #0]
  404e8a:	2b00      	cmp	r3, #0
  404e8c:	d105      	bne.n	404e9a <vTaskSwitchContext+0x10a>
  404e8e:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  404e92:	f2c0 0340 	movt	r3, #64	; 0x40
  404e96:	4798      	blx	r3
  404e98:	e7fe      	b.n	404e98 <vTaskSwitchContext+0x108>
  404e9a:	68fa      	ldr	r2, [r7, #12]
  404e9c:	4613      	mov	r3, r2
  404e9e:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404ea2:	189b      	adds	r3, r3, r2
  404ea4:	ea4f 0383 	mov.w	r3, r3, lsl #2
  404ea8:	f24a 5254 	movw	r2, #42324	; 0xa554
  404eac:	f2c2 0200 	movt	r2, #8192	; 0x2000
  404eb0:	189b      	adds	r3, r3, r2
  404eb2:	60bb      	str	r3, [r7, #8]
  404eb4:	68bb      	ldr	r3, [r7, #8]
  404eb6:	685b      	ldr	r3, [r3, #4]
  404eb8:	685a      	ldr	r2, [r3, #4]
  404eba:	68bb      	ldr	r3, [r7, #8]
  404ebc:	605a      	str	r2, [r3, #4]
  404ebe:	68bb      	ldr	r3, [r7, #8]
  404ec0:	685a      	ldr	r2, [r3, #4]
  404ec2:	68bb      	ldr	r3, [r7, #8]
  404ec4:	f103 0308 	add.w	r3, r3, #8
  404ec8:	429a      	cmp	r2, r3
  404eca:	d104      	bne.n	404ed6 <vTaskSwitchContext+0x146>
  404ecc:	68bb      	ldr	r3, [r7, #8]
  404ece:	685b      	ldr	r3, [r3, #4]
  404ed0:	685a      	ldr	r2, [r3, #4]
  404ed2:	68bb      	ldr	r3, [r7, #8]
  404ed4:	605a      	str	r2, [r3, #4]
  404ed6:	68bb      	ldr	r3, [r7, #8]
  404ed8:	685b      	ldr	r3, [r3, #4]
  404eda:	68da      	ldr	r2, [r3, #12]
  404edc:	f24a 5350 	movw	r3, #42320	; 0xa550
  404ee0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404ee4:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  404ee6:	f107 0714 	add.w	r7, r7, #20
  404eea:	46bd      	mov	sp, r7
  404eec:	bd90      	pop	{r4, r7, pc}
  404eee:	bf00      	nop

00404ef0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
{
  404ef0:	b580      	push	{r7, lr}
  404ef2:	b084      	sub	sp, #16
  404ef4:	af00      	add	r7, sp, #0
  404ef6:	6078      	str	r0, [r7, #4]
  404ef8:	6039      	str	r1, [r7, #0]
portTickType xTimeToWake;

	configASSERT( pxEventList );
  404efa:	687b      	ldr	r3, [r7, #4]
  404efc:	2b00      	cmp	r3, #0
  404efe:	d105      	bne.n	404f0c <vTaskPlaceOnEventList+0x1c>
  404f00:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  404f04:	f2c0 0340 	movt	r3, #64	; 0x40
  404f08:	4798      	blx	r3
  404f0a:	e7fe      	b.n	404f0a <vTaskPlaceOnEventList+0x1a>
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  404f0c:	f24a 5350 	movw	r3, #42320	; 0xa550
  404f10:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404f14:	681b      	ldr	r3, [r3, #0]
  404f16:	f103 0318 	add.w	r3, r3, #24
  404f1a:	6878      	ldr	r0, [r7, #4]
  404f1c:	4619      	mov	r1, r3
  404f1e:	f642 33a9 	movw	r3, #11177	; 0x2ba9
  404f22:	f2c0 0340 	movt	r3, #64	; 0x40
  404f26:	4798      	blx	r3

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  404f28:	f24a 5350 	movw	r3, #42320	; 0xa550
  404f2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404f30:	681b      	ldr	r3, [r3, #0]
  404f32:	f103 0304 	add.w	r3, r3, #4
  404f36:	4618      	mov	r0, r3
  404f38:	f642 431d 	movw	r3, #11293	; 0x2c1d
  404f3c:	f2c0 0340 	movt	r3, #64	; 0x40
  404f40:	4798      	blx	r3
  404f42:	4603      	mov	r3, r0
  404f44:	2b00      	cmp	r3, #0
  404f46:	d116      	bne.n	404f76 <vTaskPlaceOnEventList+0x86>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  404f48:	f24a 5350 	movw	r3, #42320	; 0xa550
  404f4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404f50:	681b      	ldr	r3, [r3, #0]
  404f52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  404f54:	f04f 0201 	mov.w	r2, #1
  404f58:	fa02 f303 	lsl.w	r3, r2, r3
  404f5c:	ea6f 0203 	mvn.w	r2, r3
  404f60:	f24a 6330 	movw	r3, #42544	; 0xa630
  404f64:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404f68:	681b      	ldr	r3, [r3, #0]
  404f6a:	401a      	ands	r2, r3
  404f6c:	f24a 6330 	movw	r3, #42544	; 0xa630
  404f70:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404f74:	601a      	str	r2, [r3, #0]
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
  404f76:	683b      	ldr	r3, [r7, #0]
  404f78:	f1b3 3fff 	cmp.w	r3, #4294967295
  404f7c:	d111      	bne.n	404fa2 <vTaskPlaceOnEventList+0xb2>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
  404f7e:	f24a 5350 	movw	r3, #42320	; 0xa550
  404f82:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404f86:	681b      	ldr	r3, [r3, #0]
  404f88:	f103 0304 	add.w	r3, r3, #4
  404f8c:	f24a 6014 	movw	r0, #42516	; 0xa614
  404f90:	f2c2 0000 	movt	r0, #8192	; 0x2000
  404f94:	4619      	mov	r1, r3
  404f96:	f642 3361 	movw	r3, #11105	; 0x2b61
  404f9a:	f2c0 0340 	movt	r3, #64	; 0x40
  404f9e:	4798      	blx	r3
  404fa0:	e00d      	b.n	404fbe <vTaskPlaceOnEventList+0xce>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  404fa2:	f24a 632c 	movw	r3, #42540	; 0xa62c
  404fa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404faa:	681a      	ldr	r2, [r3, #0]
  404fac:	683b      	ldr	r3, [r7, #0]
  404fae:	18d3      	adds	r3, r2, r3
  404fb0:	60fb      	str	r3, [r7, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  404fb2:	68f8      	ldr	r0, [r7, #12]
  404fb4:	f245 43f9 	movw	r3, #21753	; 0x54f9
  404fb8:	f2c0 0340 	movt	r3, #64	; 0x40
  404fbc:	4798      	blx	r3
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  404fbe:	f107 0710 	add.w	r7, r7, #16
  404fc2:	46bd      	mov	sp, r7
  404fc4:	bd80      	pop	{r7, pc}
  404fc6:	bf00      	nop

00404fc8 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait )
	{
  404fc8:	b580      	push	{r7, lr}
  404fca:	b084      	sub	sp, #16
  404fcc:	af00      	add	r7, sp, #0
  404fce:	6078      	str	r0, [r7, #4]
  404fd0:	6039      	str	r1, [r7, #0]
	portTickType xTimeToWake;

		configASSERT( pxEventList );
  404fd2:	687b      	ldr	r3, [r7, #4]
  404fd4:	2b00      	cmp	r3, #0
  404fd6:	d105      	bne.n	404fe4 <vTaskPlaceOnEventListRestricted+0x1c>
  404fd8:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  404fdc:	f2c0 0340 	movt	r3, #64	; 0x40
  404fe0:	4798      	blx	r3
  404fe2:	e7fe      	b.n	404fe2 <vTaskPlaceOnEventListRestricted+0x1a>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  404fe4:	f24a 5350 	movw	r3, #42320	; 0xa550
  404fe8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404fec:	681b      	ldr	r3, [r3, #0]
  404fee:	f103 0318 	add.w	r3, r3, #24
  404ff2:	6878      	ldr	r0, [r7, #4]
  404ff4:	4619      	mov	r1, r3
  404ff6:	f642 3361 	movw	r3, #11105	; 0x2b61
  404ffa:	f2c0 0340 	movt	r3, #64	; 0x40
  404ffe:	4798      	blx	r3

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  405000:	f24a 5350 	movw	r3, #42320	; 0xa550
  405004:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405008:	681b      	ldr	r3, [r3, #0]
  40500a:	f103 0304 	add.w	r3, r3, #4
  40500e:	4618      	mov	r0, r3
  405010:	f642 431d 	movw	r3, #11293	; 0x2c1d
  405014:	f2c0 0340 	movt	r3, #64	; 0x40
  405018:	4798      	blx	r3
  40501a:	4603      	mov	r3, r0
  40501c:	2b00      	cmp	r3, #0
  40501e:	d116      	bne.n	40504e <vTaskPlaceOnEventListRestricted+0x86>
		{
			/* The current task must be in a ready list, so there is no need to
			check, and the port reset macro can be called directly. */
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  405020:	f24a 5350 	movw	r3, #42320	; 0xa550
  405024:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405028:	681b      	ldr	r3, [r3, #0]
  40502a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40502c:	f04f 0201 	mov.w	r2, #1
  405030:	fa02 f303 	lsl.w	r3, r2, r3
  405034:	ea6f 0203 	mvn.w	r2, r3
  405038:	f24a 6330 	movw	r3, #42544	; 0xa630
  40503c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405040:	681b      	ldr	r3, [r3, #0]
  405042:	401a      	ands	r2, r3
  405044:	f24a 6330 	movw	r3, #42544	; 0xa630
  405048:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40504c:	601a      	str	r2, [r3, #0]
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
  40504e:	f24a 632c 	movw	r3, #42540	; 0xa62c
  405052:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405056:	681a      	ldr	r2, [r3, #0]
  405058:	683b      	ldr	r3, [r7, #0]
  40505a:	18d3      	adds	r3, r2, r3
  40505c:	60fb      	str	r3, [r7, #12]

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
  40505e:	68f8      	ldr	r0, [r7, #12]
  405060:	f245 43f9 	movw	r3, #21753	; 0x54f9
  405064:	f2c0 0340 	movt	r3, #64	; 0x40
  405068:	4798      	blx	r3
	}
  40506a:	f107 0710 	add.w	r7, r7, #16
  40506e:	46bd      	mov	sp, r7
  405070:	bd80      	pop	{r7, pc}
  405072:	bf00      	nop

00405074 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
  405074:	b580      	push	{r7, lr}
  405076:	b084      	sub	sp, #16
  405078:	af00      	add	r7, sp, #0
  40507a:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  40507c:	687b      	ldr	r3, [r7, #4]
  40507e:	68db      	ldr	r3, [r3, #12]
  405080:	68db      	ldr	r3, [r3, #12]
  405082:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
  405084:	68bb      	ldr	r3, [r7, #8]
  405086:	2b00      	cmp	r3, #0
  405088:	d105      	bne.n	405096 <xTaskRemoveFromEventList+0x22>
  40508a:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  40508e:	f2c0 0340 	movt	r3, #64	; 0x40
  405092:	4798      	blx	r3
  405094:	e7fe      	b.n	405094 <xTaskRemoveFromEventList+0x20>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  405096:	68bb      	ldr	r3, [r7, #8]
  405098:	f103 0318 	add.w	r3, r3, #24
  40509c:	4618      	mov	r0, r3
  40509e:	f642 431d 	movw	r3, #11293	; 0x2c1d
  4050a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4050a6:	4798      	blx	r3

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4050a8:	f24a 6338 	movw	r3, #42552	; 0xa638
  4050ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4050b0:	681b      	ldr	r3, [r3, #0]
  4050b2:	2b00      	cmp	r3, #0
  4050b4:	d131      	bne.n	40511a <xTaskRemoveFromEventList+0xa6>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  4050b6:	68bb      	ldr	r3, [r7, #8]
  4050b8:	f103 0304 	add.w	r3, r3, #4
  4050bc:	4618      	mov	r0, r3
  4050be:	f642 431d 	movw	r3, #11293	; 0x2c1d
  4050c2:	f2c0 0340 	movt	r3, #64	; 0x40
  4050c6:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
  4050c8:	68bb      	ldr	r3, [r7, #8]
  4050ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4050cc:	f04f 0201 	mov.w	r2, #1
  4050d0:	fa02 f203 	lsl.w	r2, r2, r3
  4050d4:	f24a 6330 	movw	r3, #42544	; 0xa630
  4050d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4050dc:	681b      	ldr	r3, [r3, #0]
  4050de:	431a      	orrs	r2, r3
  4050e0:	f24a 6330 	movw	r3, #42544	; 0xa630
  4050e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4050e8:	601a      	str	r2, [r3, #0]
  4050ea:	68bb      	ldr	r3, [r7, #8]
  4050ec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4050ee:	4613      	mov	r3, r2
  4050f0:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4050f4:	189b      	adds	r3, r3, r2
  4050f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4050fa:	f24a 5254 	movw	r2, #42324	; 0xa554
  4050fe:	f2c2 0200 	movt	r2, #8192	; 0x2000
  405102:	189a      	adds	r2, r3, r2
  405104:	68bb      	ldr	r3, [r7, #8]
  405106:	f103 0304 	add.w	r3, r3, #4
  40510a:	4610      	mov	r0, r2
  40510c:	4619      	mov	r1, r3
  40510e:	f642 3361 	movw	r3, #11105	; 0x2b61
  405112:	f2c0 0340 	movt	r3, #64	; 0x40
  405116:	4798      	blx	r3
  405118:	e00c      	b.n	405134 <xTaskRemoveFromEventList+0xc0>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  40511a:	68bb      	ldr	r3, [r7, #8]
  40511c:	f103 0318 	add.w	r3, r3, #24
  405120:	f24a 50e8 	movw	r0, #42472	; 0xa5e8
  405124:	f2c2 0000 	movt	r0, #8192	; 0x2000
  405128:	4619      	mov	r1, r3
  40512a:	f642 3361 	movw	r3, #11105	; 0x2b61
  40512e:	f2c0 0340 	movt	r3, #64	; 0x40
  405132:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  405134:	68bb      	ldr	r3, [r7, #8]
  405136:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  405138:	f24a 5350 	movw	r3, #42320	; 0xa550
  40513c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405140:	681b      	ldr	r3, [r3, #0]
  405142:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  405144:	429a      	cmp	r2, r3
  405146:	d30a      	bcc.n	40515e <xTaskRemoveFromEventList+0xea>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
  405148:	f04f 0301 	mov.w	r3, #1
  40514c:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
  40514e:	f24a 6340 	movw	r3, #42560	; 0xa640
  405152:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405156:	f04f 0201 	mov.w	r2, #1
  40515a:	601a      	str	r2, [r3, #0]
  40515c:	e002      	b.n	405164 <xTaskRemoveFromEventList+0xf0>
	}
	else
	{
		xReturn = pdFALSE;
  40515e:	f04f 0300 	mov.w	r3, #0
  405162:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
  405164:	68fb      	ldr	r3, [r7, #12]
}
  405166:	4618      	mov	r0, r3
  405168:	f107 0710 	add.w	r7, r7, #16
  40516c:	46bd      	mov	sp, r7
  40516e:	bd80      	pop	{r7, pc}

00405170 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
  405170:	b580      	push	{r7, lr}
  405172:	b082      	sub	sp, #8
  405174:	af00      	add	r7, sp, #0
  405176:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
  405178:	687b      	ldr	r3, [r7, #4]
  40517a:	2b00      	cmp	r3, #0
  40517c:	d105      	bne.n	40518a <vTaskSetTimeOutState+0x1a>
  40517e:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  405182:	f2c0 0340 	movt	r3, #64	; 0x40
  405186:	4798      	blx	r3
  405188:	e7fe      	b.n	405188 <vTaskSetTimeOutState+0x18>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  40518a:	f24a 6344 	movw	r3, #42564	; 0xa644
  40518e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405192:	681a      	ldr	r2, [r3, #0]
  405194:	687b      	ldr	r3, [r7, #4]
  405196:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  405198:	f24a 632c 	movw	r3, #42540	; 0xa62c
  40519c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4051a0:	681a      	ldr	r2, [r3, #0]
  4051a2:	687b      	ldr	r3, [r7, #4]
  4051a4:	605a      	str	r2, [r3, #4]
}
  4051a6:	f107 0708 	add.w	r7, r7, #8
  4051aa:	46bd      	mov	sp, r7
  4051ac:	bd80      	pop	{r7, pc}
  4051ae:	bf00      	nop

004051b0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  4051b0:	b580      	push	{r7, lr}
  4051b2:	b084      	sub	sp, #16
  4051b4:	af00      	add	r7, sp, #0
  4051b6:	6078      	str	r0, [r7, #4]
  4051b8:	6039      	str	r1, [r7, #0]
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
  4051ba:	687b      	ldr	r3, [r7, #4]
  4051bc:	2b00      	cmp	r3, #0
  4051be:	d105      	bne.n	4051cc <xTaskCheckForTimeOut+0x1c>
  4051c0:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4051c4:	f2c0 0340 	movt	r3, #64	; 0x40
  4051c8:	4798      	blx	r3
  4051ca:	e7fe      	b.n	4051ca <xTaskCheckForTimeOut+0x1a>
	configASSERT( pxTicksToWait );
  4051cc:	683b      	ldr	r3, [r7, #0]
  4051ce:	2b00      	cmp	r3, #0
  4051d0:	d105      	bne.n	4051de <xTaskCheckForTimeOut+0x2e>
  4051d2:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4051d6:	f2c0 0340 	movt	r3, #64	; 0x40
  4051da:	4798      	blx	r3
  4051dc:	e7fe      	b.n	4051dc <xTaskCheckForTimeOut+0x2c>

	taskENTER_CRITICAL();
  4051de:	f642 6379 	movw	r3, #11897	; 0x2e79
  4051e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4051e6:	4798      	blx	r3
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const portTickType xConstTickCount = xTickCount;
  4051e8:	f24a 632c 	movw	r3, #42540	; 0xa62c
  4051ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4051f0:	681b      	ldr	r3, [r3, #0]
  4051f2:	60bb      	str	r3, [r7, #8]

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
  4051f4:	683b      	ldr	r3, [r7, #0]
  4051f6:	681b      	ldr	r3, [r3, #0]
  4051f8:	f1b3 3fff 	cmp.w	r3, #4294967295
  4051fc:	d103      	bne.n	405206 <xTaskCheckForTimeOut+0x56>
			{
				xReturn = pdFALSE;
  4051fe:	f04f 0300 	mov.w	r3, #0
  405202:	60fb      	str	r3, [r7, #12]
  405204:	e02f      	b.n	405266 <xTaskCheckForTimeOut+0xb6>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  405206:	687b      	ldr	r3, [r7, #4]
  405208:	681a      	ldr	r2, [r3, #0]
  40520a:	f24a 6344 	movw	r3, #42564	; 0xa644
  40520e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405212:	681b      	ldr	r3, [r3, #0]
  405214:	429a      	cmp	r2, r3
  405216:	d008      	beq.n	40522a <xTaskCheckForTimeOut+0x7a>
  405218:	687b      	ldr	r3, [r7, #4]
  40521a:	685a      	ldr	r2, [r3, #4]
  40521c:	68bb      	ldr	r3, [r7, #8]
  40521e:	429a      	cmp	r2, r3
  405220:	d803      	bhi.n	40522a <xTaskCheckForTimeOut+0x7a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
  405222:	f04f 0301 	mov.w	r3, #1
  405226:	60fb      	str	r3, [r7, #12]
  405228:	e01d      	b.n	405266 <xTaskCheckForTimeOut+0xb6>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
  40522a:	687b      	ldr	r3, [r7, #4]
  40522c:	685b      	ldr	r3, [r3, #4]
  40522e:	68ba      	ldr	r2, [r7, #8]
  405230:	1ad2      	subs	r2, r2, r3
  405232:	683b      	ldr	r3, [r7, #0]
  405234:	681b      	ldr	r3, [r3, #0]
  405236:	429a      	cmp	r2, r3
  405238:	d212      	bcs.n	405260 <xTaskCheckForTimeOut+0xb0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
  40523a:	683b      	ldr	r3, [r7, #0]
  40523c:	681a      	ldr	r2, [r3, #0]
  40523e:	687b      	ldr	r3, [r7, #4]
  405240:	6859      	ldr	r1, [r3, #4]
  405242:	68bb      	ldr	r3, [r7, #8]
  405244:	1acb      	subs	r3, r1, r3
  405246:	18d2      	adds	r2, r2, r3
  405248:	683b      	ldr	r3, [r7, #0]
  40524a:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
  40524c:	6878      	ldr	r0, [r7, #4]
  40524e:	f245 1371 	movw	r3, #20849	; 0x5171
  405252:	f2c0 0340 	movt	r3, #64	; 0x40
  405256:	4798      	blx	r3
			xReturn = pdFALSE;
  405258:	f04f 0300 	mov.w	r3, #0
  40525c:	60fb      	str	r3, [r7, #12]
  40525e:	e002      	b.n	405266 <xTaskCheckForTimeOut+0xb6>
		}
		else
		{
			xReturn = pdTRUE;
  405260:	f04f 0301 	mov.w	r3, #1
  405264:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  405266:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  40526a:	f2c0 0340 	movt	r3, #64	; 0x40
  40526e:	4798      	blx	r3

	return xReturn;
  405270:	68fb      	ldr	r3, [r7, #12]
}
  405272:	4618      	mov	r0, r3
  405274:	f107 0710 	add.w	r7, r7, #16
  405278:	46bd      	mov	sp, r7
  40527a:	bd80      	pop	{r7, pc}

0040527c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
  40527c:	b480      	push	{r7}
  40527e:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
  405280:	f24a 6340 	movw	r3, #42560	; 0xa640
  405284:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405288:	f04f 0201 	mov.w	r2, #1
  40528c:	601a      	str	r2, [r3, #0]
}
  40528e:	46bd      	mov	sp, r7
  405290:	bc80      	pop	{r7}
  405292:	4770      	bx	lr

00405294 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  405294:	b580      	push	{r7, lr}
  405296:	b082      	sub	sp, #8
  405298:	af00      	add	r7, sp, #0
  40529a:	6078      	str	r0, [r7, #4]
  40529c:	e000      	b.n	4052a0 <prvIdleTask+0xc>
				}
				( void ) xTaskResumeAll();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
  40529e:	bf00      	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
  4052a0:	f245 4339 	movw	r3, #21561	; 0x5439
  4052a4:	f2c0 0340 	movt	r3, #64	; 0x40
  4052a8:	4798      	blx	r3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  4052aa:	f24a 5354 	movw	r3, #42324	; 0xa554
  4052ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4052b2:	681b      	ldr	r3, [r3, #0]
  4052b4:	2b01      	cmp	r3, #1
  4052b6:	d9f2      	bls.n	40529e <prvIdleTask+0xa>
			{
				taskYIELD();
  4052b8:	f642 6359 	movw	r3, #11865	; 0x2e59
  4052bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4052c0:	4798      	blx	r3
				}
				( void ) xTaskResumeAll();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
  4052c2:	e7ec      	b.n	40529e <prvIdleTask+0xa>

004052c4 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
  4052c4:	b580      	push	{r7, lr}
  4052c6:	b086      	sub	sp, #24
  4052c8:	af00      	add	r7, sp, #0
  4052ca:	60f8      	str	r0, [r7, #12]
  4052cc:	60b9      	str	r1, [r7, #8]
  4052ce:	607a      	str	r2, [r7, #4]
  4052d0:	603b      	str	r3, [r7, #0]
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
  4052d2:	f04f 0300 	mov.w	r3, #0
  4052d6:	617b      	str	r3, [r7, #20]
  4052d8:	e013      	b.n	405302 <prvInitialiseTCBVariables+0x3e>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
  4052da:	68ba      	ldr	r2, [r7, #8]
  4052dc:	697b      	ldr	r3, [r7, #20]
  4052de:	18d3      	adds	r3, r2, r3
  4052e0:	781a      	ldrb	r2, [r3, #0]
  4052e2:	68f9      	ldr	r1, [r7, #12]
  4052e4:	697b      	ldr	r3, [r7, #20]
  4052e6:	18cb      	adds	r3, r1, r3
  4052e8:	f103 0330 	add.w	r3, r3, #48	; 0x30
  4052ec:	711a      	strb	r2, [r3, #4]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
  4052ee:	68ba      	ldr	r2, [r7, #8]
  4052f0:	697b      	ldr	r3, [r7, #20]
  4052f2:	18d3      	adds	r3, r2, r3
  4052f4:	781b      	ldrb	r3, [r3, #0]
  4052f6:	2b00      	cmp	r3, #0
  4052f8:	d007      	beq.n	40530a <prvInitialiseTCBVariables+0x46>
static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
  4052fa:	697b      	ldr	r3, [r7, #20]
  4052fc:	f103 0301 	add.w	r3, r3, #1
  405300:	617b      	str	r3, [r7, #20]
  405302:	697b      	ldr	r3, [r7, #20]
  405304:	2b09      	cmp	r3, #9
  405306:	d9e8      	bls.n	4052da <prvInitialiseTCBVariables+0x16>
  405308:	e000      	b.n	40530c <prvInitialiseTCBVariables+0x48>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
  40530a:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
  40530c:	68fb      	ldr	r3, [r7, #12]
  40530e:	f04f 0200 	mov.w	r2, #0
  405312:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
  405316:	687b      	ldr	r3, [r7, #4]
  405318:	2b04      	cmp	r3, #4
  40531a:	d902      	bls.n	405322 <prvInitialiseTCBVariables+0x5e>
	{
		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
  40531c:	f04f 0304 	mov.w	r3, #4
  405320:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
  405322:	68fb      	ldr	r3, [r7, #12]
  405324:	687a      	ldr	r2, [r7, #4]
  405326:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
  405328:	68fb      	ldr	r3, [r7, #12]
  40532a:	687a      	ldr	r2, [r7, #4]
  40532c:	641a      	str	r2, [r3, #64]	; 0x40
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  40532e:	68fb      	ldr	r3, [r7, #12]
  405330:	f103 0304 	add.w	r3, r3, #4
  405334:	4618      	mov	r0, r3
  405336:	f642 3345 	movw	r3, #11077	; 0x2b45
  40533a:	f2c0 0340 	movt	r3, #64	; 0x40
  40533e:	4798      	blx	r3
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
  405340:	68fb      	ldr	r3, [r7, #12]
  405342:	f103 0318 	add.w	r3, r3, #24
  405346:	4618      	mov	r0, r3
  405348:	f642 3345 	movw	r3, #11077	; 0x2b45
  40534c:	f2c0 0340 	movt	r3, #64	; 0x40
  405350:	4798      	blx	r3

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
  405352:	68fb      	ldr	r3, [r7, #12]
  405354:	68fa      	ldr	r2, [r7, #12]
  405356:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  405358:	687b      	ldr	r3, [r7, #4]
  40535a:	f1c3 0205 	rsb	r2, r3, #5
  40535e:	68fb      	ldr	r3, [r7, #12]
  405360:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
  405362:	68fb      	ldr	r3, [r7, #12]
  405364:	68fa      	ldr	r2, [r7, #12]
  405366:	625a      	str	r2, [r3, #36]	; 0x24
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
  405368:	f107 0718 	add.w	r7, r7, #24
  40536c:	46bd      	mov	sp, r7
  40536e:	bd80      	pop	{r7, pc}

00405370 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
  405370:	b580      	push	{r7, lr}
  405372:	b082      	sub	sp, #8
  405374:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
  405376:	f04f 0300 	mov.w	r3, #0
  40537a:	607b      	str	r3, [r7, #4]
  40537c:	e015      	b.n	4053aa <prvInitialiseTaskLists+0x3a>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  40537e:	687a      	ldr	r2, [r7, #4]
  405380:	4613      	mov	r3, r2
  405382:	ea4f 0383 	mov.w	r3, r3, lsl #2
  405386:	189b      	adds	r3, r3, r2
  405388:	ea4f 0383 	mov.w	r3, r3, lsl #2
  40538c:	f24a 5254 	movw	r2, #42324	; 0xa554
  405390:	f2c2 0200 	movt	r2, #8192	; 0x2000
  405394:	189b      	adds	r3, r3, r2
  405396:	4618      	mov	r0, r3
  405398:	f642 3305 	movw	r3, #11013	; 0x2b05
  40539c:	f2c0 0340 	movt	r3, #64	; 0x40
  4053a0:	4798      	blx	r3

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
  4053a2:	687b      	ldr	r3, [r7, #4]
  4053a4:	f103 0301 	add.w	r3, r3, #1
  4053a8:	607b      	str	r3, [r7, #4]
  4053aa:	687b      	ldr	r3, [r7, #4]
  4053ac:	2b04      	cmp	r3, #4
  4053ae:	d9e6      	bls.n	40537e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
  4053b0:	f24a 50b8 	movw	r0, #42424	; 0xa5b8
  4053b4:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4053b8:	f642 3305 	movw	r3, #11013	; 0x2b05
  4053bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4053c0:	4798      	blx	r3
	vListInitialise( &xDelayedTaskList2 );
  4053c2:	f24a 50cc 	movw	r0, #42444	; 0xa5cc
  4053c6:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4053ca:	f642 3305 	movw	r3, #11013	; 0x2b05
  4053ce:	f2c0 0340 	movt	r3, #64	; 0x40
  4053d2:	4798      	blx	r3
	vListInitialise( &xPendingReadyList );
  4053d4:	f24a 50e8 	movw	r0, #42472	; 0xa5e8
  4053d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4053dc:	f642 3305 	movw	r3, #11013	; 0x2b05
  4053e0:	f2c0 0340 	movt	r3, #64	; 0x40
  4053e4:	4798      	blx	r3

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
  4053e6:	f24a 50fc 	movw	r0, #42492	; 0xa5fc
  4053ea:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4053ee:	f642 3305 	movw	r3, #11013	; 0x2b05
  4053f2:	f2c0 0340 	movt	r3, #64	; 0x40
  4053f6:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
  4053f8:	f24a 6014 	movw	r0, #42516	; 0xa614
  4053fc:	f2c2 0000 	movt	r0, #8192	; 0x2000
  405400:	f642 3305 	movw	r3, #11013	; 0x2b05
  405404:	f2c0 0340 	movt	r3, #64	; 0x40
  405408:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  40540a:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  40540e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405412:	f24a 52b8 	movw	r2, #42424	; 0xa5b8
  405416:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40541a:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  40541c:	f24a 53e4 	movw	r3, #42468	; 0xa5e4
  405420:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405424:	f24a 52cc 	movw	r2, #42444	; 0xa5cc
  405428:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40542c:	601a      	str	r2, [r3, #0]
}
  40542e:	f107 0708 	add.w	r7, r7, #8
  405432:	46bd      	mov	sp, r7
  405434:	bd80      	pop	{r7, pc}
  405436:	bf00      	nop

00405438 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
  405438:	b580      	push	{r7, lr}
  40543a:	b082      	sub	sp, #8
  40543c:	af00      	add	r7, sp, #0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  40543e:	e04f      	b.n	4054e0 <prvCheckTasksWaitingTermination+0xa8>
		{
			vTaskSuspendAll();
  405440:	f644 03f9 	movw	r3, #18681	; 0x48f9
  405444:	f2c0 0340 	movt	r3, #64	; 0x40
  405448:	4798      	blx	r3
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  40544a:	f24a 53fc 	movw	r3, #42492	; 0xa5fc
  40544e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405452:	681b      	ldr	r3, [r3, #0]
  405454:	2b00      	cmp	r3, #0
  405456:	bf14      	ite	ne
  405458:	2300      	movne	r3, #0
  40545a:	2301      	moveq	r3, #1
  40545c:	b2db      	uxtb	r3, r3
  40545e:	607b      	str	r3, [r7, #4]
			( void ) xTaskResumeAll();
  405460:	f644 131d 	movw	r3, #18717	; 0x491d
  405464:	f2c0 0340 	movt	r3, #64	; 0x40
  405468:	4798      	blx	r3

			if( xListIsEmpty == pdFALSE )
  40546a:	687b      	ldr	r3, [r7, #4]
  40546c:	2b00      	cmp	r3, #0
  40546e:	d137      	bne.n	4054e0 <prvCheckTasksWaitingTermination+0xa8>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
  405470:	f642 6379 	movw	r3, #11897	; 0x2e79
  405474:	f2c0 0340 	movt	r3, #64	; 0x40
  405478:	4798      	blx	r3
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
  40547a:	f24a 53fc 	movw	r3, #42492	; 0xa5fc
  40547e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405482:	68db      	ldr	r3, [r3, #12]
  405484:	68db      	ldr	r3, [r3, #12]
  405486:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
  405488:	683b      	ldr	r3, [r7, #0]
  40548a:	f103 0304 	add.w	r3, r3, #4
  40548e:	4618      	mov	r0, r3
  405490:	f642 431d 	movw	r3, #11293	; 0x2c1d
  405494:	f2c0 0340 	movt	r3, #64	; 0x40
  405498:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
  40549a:	f24a 6328 	movw	r3, #42536	; 0xa628
  40549e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4054a2:	681b      	ldr	r3, [r3, #0]
  4054a4:	f103 32ff 	add.w	r2, r3, #4294967295
  4054a8:	f24a 6328 	movw	r3, #42536	; 0xa628
  4054ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4054b0:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
  4054b2:	f24a 6310 	movw	r3, #42512	; 0xa610
  4054b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4054ba:	681b      	ldr	r3, [r3, #0]
  4054bc:	f103 32ff 	add.w	r2, r3, #4294967295
  4054c0:	f24a 6310 	movw	r3, #42512	; 0xa610
  4054c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4054c8:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
  4054ca:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  4054ce:	f2c0 0340 	movt	r3, #64	; 0x40
  4054d2:	4798      	blx	r3

				prvDeleteTCB( pxTCB );
  4054d4:	6838      	ldr	r0, [r7, #0]
  4054d6:	f245 6319 	movw	r3, #22041	; 0x5619
  4054da:	f2c0 0340 	movt	r3, #64	; 0x40
  4054de:	4798      	blx	r3
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  4054e0:	f24a 6310 	movw	r3, #42512	; 0xa610
  4054e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4054e8:	681b      	ldr	r3, [r3, #0]
  4054ea:	2b00      	cmp	r3, #0
  4054ec:	d1a8      	bne.n	405440 <prvCheckTasksWaitingTermination+0x8>
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif /* vTaskDelete */
}
  4054ee:	f107 0708 	add.w	r7, r7, #8
  4054f2:	46bd      	mov	sp, r7
  4054f4:	bd80      	pop	{r7, pc}
  4054f6:	bf00      	nop

004054f8 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  4054f8:	b580      	push	{r7, lr}
  4054fa:	b082      	sub	sp, #8
  4054fc:	af00      	add	r7, sp, #0
  4054fe:	6078      	str	r0, [r7, #4]
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  405500:	f24a 5350 	movw	r3, #42320	; 0xa550
  405504:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405508:	681b      	ldr	r3, [r3, #0]
  40550a:	687a      	ldr	r2, [r7, #4]
  40550c:	605a      	str	r2, [r3, #4]

	if( xTimeToWake < xTickCount )
  40550e:	f24a 632c 	movw	r3, #42540	; 0xa62c
  405512:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405516:	681b      	ldr	r3, [r3, #0]
  405518:	687a      	ldr	r2, [r7, #4]
  40551a:	429a      	cmp	r2, r3
  40551c:	d213      	bcs.n	405546 <prvAddCurrentTaskToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
  40551e:	f24a 53e4 	movw	r3, #42468	; 0xa5e4
  405522:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405526:	681a      	ldr	r2, [r3, #0]
  405528:	f24a 5350 	movw	r3, #42320	; 0xa550
  40552c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405530:	681b      	ldr	r3, [r3, #0]
  405532:	f103 0304 	add.w	r3, r3, #4
  405536:	4610      	mov	r0, r2
  405538:	4619      	mov	r1, r3
  40553a:	f642 33a9 	movw	r3, #11177	; 0x2ba9
  40553e:	f2c0 0340 	movt	r3, #64	; 0x40
  405542:	4798      	blx	r3
  405544:	e020      	b.n	405588 <prvAddCurrentTaskToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
  405546:	f24a 53e0 	movw	r3, #42464	; 0xa5e0
  40554a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40554e:	681a      	ldr	r2, [r3, #0]
  405550:	f24a 5350 	movw	r3, #42320	; 0xa550
  405554:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405558:	681b      	ldr	r3, [r3, #0]
  40555a:	f103 0304 	add.w	r3, r3, #4
  40555e:	4610      	mov	r0, r2
  405560:	4619      	mov	r1, r3
  405562:	f642 33a9 	movw	r3, #11177	; 0x2ba9
  405566:	f2c0 0340 	movt	r3, #64	; 0x40
  40556a:	4798      	blx	r3

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
  40556c:	f240 0318 	movw	r3, #24
  405570:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405574:	681b      	ldr	r3, [r3, #0]
  405576:	687a      	ldr	r2, [r7, #4]
  405578:	429a      	cmp	r2, r3
  40557a:	d205      	bcs.n	405588 <prvAddCurrentTaskToDelayedList+0x90>
		{
			xNextTaskUnblockTime = xTimeToWake;
  40557c:	f240 0318 	movw	r3, #24
  405580:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405584:	687a      	ldr	r2, [r7, #4]
  405586:	601a      	str	r2, [r3, #0]
		}
	}
}
  405588:	f107 0708 	add.w	r7, r7, #8
  40558c:	46bd      	mov	sp, r7
  40558e:	bd80      	pop	{r7, pc}

00405590 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
  405590:	b580      	push	{r7, lr}
  405592:	b084      	sub	sp, #16
  405594:	af00      	add	r7, sp, #0
  405596:	4603      	mov	r3, r0
  405598:	6039      	str	r1, [r7, #0]
  40559a:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
  40559c:	f04f 0044 	mov.w	r0, #68	; 0x44
  4055a0:	f240 5345 	movw	r3, #1349	; 0x545
  4055a4:	f2c0 0340 	movt	r3, #64	; 0x40
  4055a8:	4798      	blx	r3
  4055aa:	60f8      	str	r0, [r7, #12]

	if( pxNewTCB != NULL )
  4055ac:	68fb      	ldr	r3, [r7, #12]
  4055ae:	2b00      	cmp	r3, #0
  4055b0:	d02c      	beq.n	40560c <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  4055b2:	683b      	ldr	r3, [r7, #0]
  4055b4:	2b00      	cmp	r3, #0
  4055b6:	d10a      	bne.n	4055ce <prvAllocateTCBAndStack+0x3e>
  4055b8:	88fb      	ldrh	r3, [r7, #6]
  4055ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4055be:	4618      	mov	r0, r3
  4055c0:	f240 5345 	movw	r3, #1349	; 0x545
  4055c4:	f2c0 0340 	movt	r3, #64	; 0x40
  4055c8:	4798      	blx	r3
  4055ca:	4603      	mov	r3, r0
  4055cc:	e000      	b.n	4055d0 <prvAllocateTCBAndStack+0x40>
  4055ce:	683b      	ldr	r3, [r7, #0]
  4055d0:	68fa      	ldr	r2, [r7, #12]
  4055d2:	6313      	str	r3, [r2, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
  4055d4:	68fb      	ldr	r3, [r7, #12]
  4055d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4055d8:	2b00      	cmp	r3, #0
  4055da:	d109      	bne.n	4055f0 <prvAllocateTCBAndStack+0x60>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
  4055dc:	68f8      	ldr	r0, [r7, #12]
  4055de:	f240 63c5 	movw	r3, #1733	; 0x6c5
  4055e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4055e6:	4798      	blx	r3
			pxNewTCB = NULL;
  4055e8:	f04f 0300 	mov.w	r3, #0
  4055ec:	60fb      	str	r3, [r7, #12]
  4055ee:	e00d      	b.n	40560c <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
  4055f0:	68fb      	ldr	r3, [r7, #12]
  4055f2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  4055f4:	88fb      	ldrh	r3, [r7, #6]
  4055f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4055fa:	4610      	mov	r0, r2
  4055fc:	f04f 01a5 	mov.w	r1, #165	; 0xa5
  405600:	461a      	mov	r2, r3
  405602:	f249 6359 	movw	r3, #38489	; 0x9659
  405606:	f2c0 0340 	movt	r3, #64	; 0x40
  40560a:	4798      	blx	r3
		}
	}

	return pxNewTCB;
  40560c:	68fb      	ldr	r3, [r7, #12]
}
  40560e:	4618      	mov	r0, r3
  405610:	f107 0710 	add.w	r7, r7, #16
  405614:	46bd      	mov	sp, r7
  405616:	bd80      	pop	{r7, pc}

00405618 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
  405618:	b580      	push	{r7, lr}
  40561a:	b082      	sub	sp, #8
  40561c:	af00      	add	r7, sp, #0
  40561e:	6078      	str	r0, [r7, #4]
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
  405620:	687b      	ldr	r3, [r7, #4]
  405622:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405624:	4618      	mov	r0, r3
  405626:	f240 63c5 	movw	r3, #1733	; 0x6c5
  40562a:	f2c0 0340 	movt	r3, #64	; 0x40
  40562e:	4798      	blx	r3
		vPortFree( pxTCB );
  405630:	6878      	ldr	r0, [r7, #4]
  405632:	f240 63c5 	movw	r3, #1733	; 0x6c5
  405636:	f2c0 0340 	movt	r3, #64	; 0x40
  40563a:	4798      	blx	r3
	}
  40563c:	f107 0708 	add.w	r7, r7, #8
  405640:	46bd      	mov	sp, r7
  405642:	bd80      	pop	{r7, pc}

00405644 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
  405644:	b480      	push	{r7}
  405646:	b083      	sub	sp, #12
  405648:	af00      	add	r7, sp, #0
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  40564a:	f24a 5350 	movw	r3, #42320	; 0xa550
  40564e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405652:	681b      	ldr	r3, [r3, #0]
  405654:	607b      	str	r3, [r7, #4]

		return xReturn;
  405656:	687b      	ldr	r3, [r7, #4]
	}
  405658:	4618      	mov	r0, r3
  40565a:	f107 070c 	add.w	r7, r7, #12
  40565e:	46bd      	mov	sp, r7
  405660:	bc80      	pop	{r7}
  405662:	4770      	bx	lr

00405664 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
  405664:	b480      	push	{r7}
  405666:	b083      	sub	sp, #12
  405668:	af00      	add	r7, sp, #0
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
  40566a:	f24a 6334 	movw	r3, #42548	; 0xa634
  40566e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405672:	681b      	ldr	r3, [r3, #0]
  405674:	2b00      	cmp	r3, #0
  405676:	d103      	bne.n	405680 <xTaskGetSchedulerState+0x1c>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
  405678:	f04f 0300 	mov.w	r3, #0
  40567c:	607b      	str	r3, [r7, #4]
  40567e:	e00d      	b.n	40569c <xTaskGetSchedulerState+0x38>
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  405680:	f24a 6338 	movw	r3, #42552	; 0xa638
  405684:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405688:	681b      	ldr	r3, [r3, #0]
  40568a:	2b00      	cmp	r3, #0
  40568c:	d103      	bne.n	405696 <xTaskGetSchedulerState+0x32>
			{
				xReturn = taskSCHEDULER_RUNNING;
  40568e:	f04f 0301 	mov.w	r3, #1
  405692:	607b      	str	r3, [r7, #4]
  405694:	e002      	b.n	40569c <xTaskGetSchedulerState+0x38>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
  405696:	f04f 0302 	mov.w	r3, #2
  40569a:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
  40569c:	687b      	ldr	r3, [r7, #4]
	}
  40569e:	4618      	mov	r0, r3
  4056a0:	f107 070c 	add.w	r7, r7, #12
  4056a4:	46bd      	mov	sp, r7
  4056a6:	bc80      	pop	{r7}
  4056a8:	4770      	bx	lr
  4056aa:	bf00      	nop

004056ac <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle const pxMutexHolder )
	{
  4056ac:	b580      	push	{r7, lr}
  4056ae:	b084      	sub	sp, #16
  4056b0:	af00      	add	r7, sp, #0
  4056b2:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
  4056b4:	687b      	ldr	r3, [r7, #4]
  4056b6:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
  4056b8:	687b      	ldr	r3, [r7, #4]
  4056ba:	2b00      	cmp	r3, #0
  4056bc:	f000 8095 	beq.w	4057ea <vTaskPriorityInherit+0x13e>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  4056c0:	68fb      	ldr	r3, [r7, #12]
  4056c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4056c4:	f24a 5350 	movw	r3, #42320	; 0xa550
  4056c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4056cc:	681b      	ldr	r3, [r3, #0]
  4056ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4056d0:	429a      	cmp	r2, r3
  4056d2:	f080 808a 	bcs.w	4057ea <vTaskPriorityInherit+0x13e>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  4056d6:	f24a 5350 	movw	r3, #42320	; 0xa550
  4056da:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4056de:	681b      	ldr	r3, [r3, #0]
  4056e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4056e2:	f1c3 0205 	rsb	r2, r3, #5
  4056e6:	68fb      	ldr	r3, [r7, #12]
  4056e8:	619a      	str	r2, [r3, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
  4056ea:	68fb      	ldr	r3, [r7, #12]
  4056ec:	6959      	ldr	r1, [r3, #20]
  4056ee:	68fb      	ldr	r3, [r7, #12]
  4056f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4056f2:	4613      	mov	r3, r2
  4056f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4056f8:	189b      	adds	r3, r3, r2
  4056fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4056fe:	f24a 5254 	movw	r2, #42324	; 0xa554
  405702:	f2c2 0200 	movt	r2, #8192	; 0x2000
  405706:	189b      	adds	r3, r3, r2
  405708:	4299      	cmp	r1, r3
  40570a:	d102      	bne.n	405712 <vTaskPriorityInherit+0x66>
  40570c:	f04f 0301 	mov.w	r3, #1
  405710:	e001      	b.n	405716 <vTaskPriorityInherit+0x6a>
  405712:	f04f 0300 	mov.w	r3, #0
  405716:	2b00      	cmp	r3, #0
  405718:	d05f      	beq.n	4057da <vTaskPriorityInherit+0x12e>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  40571a:	68fb      	ldr	r3, [r7, #12]
  40571c:	f103 0304 	add.w	r3, r3, #4
  405720:	4618      	mov	r0, r3
  405722:	f642 431d 	movw	r3, #11293	; 0x2c1d
  405726:	f2c0 0340 	movt	r3, #64	; 0x40
  40572a:	4798      	blx	r3
  40572c:	4603      	mov	r3, r0
  40572e:	2b00      	cmp	r3, #0
  405730:	d122      	bne.n	405778 <vTaskPriorityInherit+0xcc>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  405732:	68fb      	ldr	r3, [r7, #12]
  405734:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  405736:	f24a 5254 	movw	r2, #42324	; 0xa554
  40573a:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40573e:	460b      	mov	r3, r1
  405740:	ea4f 0383 	mov.w	r3, r3, lsl #2
  405744:	185b      	adds	r3, r3, r1
  405746:	ea4f 0383 	mov.w	r3, r3, lsl #2
  40574a:	18d3      	adds	r3, r2, r3
  40574c:	681b      	ldr	r3, [r3, #0]
  40574e:	2b00      	cmp	r3, #0
  405750:	d112      	bne.n	405778 <vTaskPriorityInherit+0xcc>
  405752:	68fb      	ldr	r3, [r7, #12]
  405754:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  405756:	f04f 0201 	mov.w	r2, #1
  40575a:	fa02 f303 	lsl.w	r3, r2, r3
  40575e:	ea6f 0203 	mvn.w	r2, r3
  405762:	f24a 6330 	movw	r3, #42544	; 0xa630
  405766:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40576a:	681b      	ldr	r3, [r3, #0]
  40576c:	401a      	ands	r2, r3
  40576e:	f24a 6330 	movw	r3, #42544	; 0xa630
  405772:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405776:	601a      	str	r2, [r3, #0]
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  405778:	f24a 5350 	movw	r3, #42320	; 0xa550
  40577c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405780:	681b      	ldr	r3, [r3, #0]
  405782:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  405784:	68fb      	ldr	r3, [r7, #12]
  405786:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
  405788:	68fb      	ldr	r3, [r7, #12]
  40578a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40578c:	f04f 0201 	mov.w	r2, #1
  405790:	fa02 f203 	lsl.w	r2, r2, r3
  405794:	f24a 6330 	movw	r3, #42544	; 0xa630
  405798:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40579c:	681b      	ldr	r3, [r3, #0]
  40579e:	431a      	orrs	r2, r3
  4057a0:	f24a 6330 	movw	r3, #42544	; 0xa630
  4057a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4057a8:	601a      	str	r2, [r3, #0]
  4057aa:	68fb      	ldr	r3, [r7, #12]
  4057ac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4057ae:	4613      	mov	r3, r2
  4057b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4057b4:	189b      	adds	r3, r3, r2
  4057b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4057ba:	f24a 5254 	movw	r2, #42324	; 0xa554
  4057be:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4057c2:	189a      	adds	r2, r3, r2
  4057c4:	68fb      	ldr	r3, [r7, #12]
  4057c6:	f103 0304 	add.w	r3, r3, #4
  4057ca:	4610      	mov	r0, r2
  4057cc:	4619      	mov	r1, r3
  4057ce:	f642 3361 	movw	r3, #11105	; 0x2b61
  4057d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4057d6:	4798      	blx	r3
  4057d8:	e007      	b.n	4057ea <vTaskPriorityInherit+0x13e>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4057da:	f24a 5350 	movw	r3, #42320	; 0xa550
  4057de:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4057e2:	681b      	ldr	r3, [r3, #0]
  4057e4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4057e6:	68fb      	ldr	r3, [r7, #12]
  4057e8:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
  4057ea:	f107 0710 	add.w	r7, r7, #16
  4057ee:	46bd      	mov	sp, r7
  4057f0:	bd80      	pop	{r7, pc}
  4057f2:	bf00      	nop

004057f4 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder )
	{
  4057f4:	b580      	push	{r7, lr}
  4057f6:	b084      	sub	sp, #16
  4057f8:	af00      	add	r7, sp, #0
  4057fa:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
  4057fc:	687b      	ldr	r3, [r7, #4]
  4057fe:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
  405800:	687b      	ldr	r3, [r7, #4]
  405802:	2b00      	cmp	r3, #0
  405804:	d066      	beq.n	4058d4 <vTaskPriorityDisinherit+0xe0>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  405806:	68fb      	ldr	r3, [r7, #12]
  405808:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40580a:	68fb      	ldr	r3, [r7, #12]
  40580c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40580e:	429a      	cmp	r2, r3
  405810:	d060      	beq.n	4058d4 <vTaskPriorityDisinherit+0xe0>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
  405812:	68fb      	ldr	r3, [r7, #12]
  405814:	f103 0304 	add.w	r3, r3, #4
  405818:	4618      	mov	r0, r3
  40581a:	f642 431d 	movw	r3, #11293	; 0x2c1d
  40581e:	f2c0 0340 	movt	r3, #64	; 0x40
  405822:	4798      	blx	r3
  405824:	4603      	mov	r3, r0
  405826:	2b00      	cmp	r3, #0
  405828:	d122      	bne.n	405870 <vTaskPriorityDisinherit+0x7c>
				{
					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  40582a:	68fb      	ldr	r3, [r7, #12]
  40582c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  40582e:	f24a 5254 	movw	r2, #42324	; 0xa554
  405832:	f2c2 0200 	movt	r2, #8192	; 0x2000
  405836:	460b      	mov	r3, r1
  405838:	ea4f 0383 	mov.w	r3, r3, lsl #2
  40583c:	185b      	adds	r3, r3, r1
  40583e:	ea4f 0383 	mov.w	r3, r3, lsl #2
  405842:	18d3      	adds	r3, r2, r3
  405844:	681b      	ldr	r3, [r3, #0]
  405846:	2b00      	cmp	r3, #0
  405848:	d112      	bne.n	405870 <vTaskPriorityDisinherit+0x7c>
  40584a:	68fb      	ldr	r3, [r7, #12]
  40584c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40584e:	f04f 0201 	mov.w	r2, #1
  405852:	fa02 f303 	lsl.w	r3, r2, r3
  405856:	ea6f 0203 	mvn.w	r2, r3
  40585a:	f24a 6330 	movw	r3, #42544	; 0xa630
  40585e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405862:	681b      	ldr	r3, [r3, #0]
  405864:	401a      	ands	r2, r3
  405866:	f24a 6330 	movw	r3, #42544	; 0xa630
  40586a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40586e:	601a      	str	r2, [r3, #0]
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  405870:	68fb      	ldr	r3, [r7, #12]
  405872:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  405874:	68fb      	ldr	r3, [r7, #12]
  405876:	62da      	str	r2, [r3, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  405878:	68fb      	ldr	r3, [r7, #12]
  40587a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40587c:	f1c3 0205 	rsb	r2, r3, #5
  405880:	68fb      	ldr	r3, [r7, #12]
  405882:	619a      	str	r2, [r3, #24]
				prvAddTaskToReadyList( pxTCB );
  405884:	68fb      	ldr	r3, [r7, #12]
  405886:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  405888:	f04f 0201 	mov.w	r2, #1
  40588c:	fa02 f203 	lsl.w	r2, r2, r3
  405890:	f24a 6330 	movw	r3, #42544	; 0xa630
  405894:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405898:	681b      	ldr	r3, [r3, #0]
  40589a:	431a      	orrs	r2, r3
  40589c:	f24a 6330 	movw	r3, #42544	; 0xa630
  4058a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4058a4:	601a      	str	r2, [r3, #0]
  4058a6:	68fb      	ldr	r3, [r7, #12]
  4058a8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4058aa:	4613      	mov	r3, r2
  4058ac:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4058b0:	189b      	adds	r3, r3, r2
  4058b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4058b6:	f24a 5254 	movw	r2, #42324	; 0xa554
  4058ba:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4058be:	189a      	adds	r2, r3, r2
  4058c0:	68fb      	ldr	r3, [r7, #12]
  4058c2:	f103 0304 	add.w	r3, r3, #4
  4058c6:	4610      	mov	r0, r2
  4058c8:	4619      	mov	r1, r3
  4058ca:	f642 3361 	movw	r3, #11105	; 0x2b61
  4058ce:	f2c0 0340 	movt	r3, #64	; 0x40
  4058d2:	4798      	blx	r3
			}
		}
	}
  4058d4:	f107 0710 	add.w	r7, r7, #16
  4058d8:	46bd      	mov	sp, r7
  4058da:	bd80      	pop	{r7, pc}

004058dc <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
  4058dc:	b590      	push	{r4, r7, lr}
  4058de:	b087      	sub	sp, #28
  4058e0:	af04      	add	r7, sp, #16
portBASE_TYPE xReturn = pdFAIL;
  4058e2:	f04f 0300 	mov.w	r3, #0
  4058e6:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
  4058e8:	f645 73b1 	movw	r3, #24497	; 0x5fb1
  4058ec:	f2c0 0340 	movt	r3, #64	; 0x40
  4058f0:	4798      	blx	r3

	if( xTimerQueue != NULL )
  4058f2:	f24a 637c 	movw	r3, #42620	; 0xa67c
  4058f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4058fa:	681b      	ldr	r3, [r3, #0]
  4058fc:	2b00      	cmp	r3, #0
  4058fe:	d01d      	beq.n	40593c <xTimerCreateTimerTask+0x60>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
  405900:	f04f 0302 	mov.w	r3, #2
  405904:	9300      	str	r3, [sp, #0]
  405906:	f04f 0300 	mov.w	r3, #0
  40590a:	9301      	str	r3, [sp, #4]
  40590c:	f04f 0300 	mov.w	r3, #0
  405910:	9302      	str	r3, [sp, #8]
  405912:	f04f 0300 	mov.w	r3, #0
  405916:	9303      	str	r3, [sp, #12]
  405918:	f645 3041 	movw	r0, #23361	; 0x5b41
  40591c:	f2c0 0040 	movt	r0, #64	; 0x40
  405920:	f249 61c0 	movw	r1, #38592	; 0x96c0
  405924:	f2c0 0140 	movt	r1, #64	; 0x40
  405928:	f44f 7282 	mov.w	r2, #260	; 0x104
  40592c:	f04f 0300 	mov.w	r3, #0
  405930:	f244 0415 	movw	r4, #16405	; 0x4015
  405934:	f2c0 0440 	movt	r4, #64	; 0x40
  405938:	47a0      	blx	r4
  40593a:	6078      	str	r0, [r7, #4]
		}
		#endif
	}

	configASSERT( xReturn );
  40593c:	687b      	ldr	r3, [r7, #4]
  40593e:	2b00      	cmp	r3, #0
  405940:	d105      	bne.n	40594e <xTimerCreateTimerTask+0x72>
  405942:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  405946:	f2c0 0340 	movt	r3, #64	; 0x40
  40594a:	4798      	blx	r3
  40594c:	e7fe      	b.n	40594c <xTimerCreateTimerTask+0x70>
	return xReturn;
  40594e:	687b      	ldr	r3, [r7, #4]
}
  405950:	4618      	mov	r0, r3
  405952:	f107 070c 	add.w	r7, r7, #12
  405956:	46bd      	mov	sp, r7
  405958:	bd90      	pop	{r4, r7, pc}
  40595a:	bf00      	nop

0040595c <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char * const pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
  40595c:	b580      	push	{r7, lr}
  40595e:	b086      	sub	sp, #24
  405960:	af00      	add	r7, sp, #0
  405962:	60f8      	str	r0, [r7, #12]
  405964:	60b9      	str	r1, [r7, #8]
  405966:	607a      	str	r2, [r7, #4]
  405968:	603b      	str	r3, [r7, #0]
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
  40596a:	68bb      	ldr	r3, [r7, #8]
  40596c:	2b00      	cmp	r3, #0
  40596e:	d103      	bne.n	405978 <xTimerCreate+0x1c>
	{
		pxNewTimer = NULL;
  405970:	f04f 0300 	mov.w	r3, #0
  405974:	617b      	str	r3, [r7, #20]
  405976:	e027      	b.n	4059c8 <xTimerCreate+0x6c>
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
  405978:	f04f 0028 	mov.w	r0, #40	; 0x28
  40597c:	f240 5345 	movw	r3, #1349	; 0x545
  405980:	f2c0 0340 	movt	r3, #64	; 0x40
  405984:	4798      	blx	r3
  405986:	6178      	str	r0, [r7, #20]
		if( pxNewTimer != NULL )
  405988:	697b      	ldr	r3, [r7, #20]
  40598a:	2b00      	cmp	r3, #0
  40598c:	d01c      	beq.n	4059c8 <xTimerCreate+0x6c>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
  40598e:	f645 73b1 	movw	r3, #24497	; 0x5fb1
  405992:	f2c0 0340 	movt	r3, #64	; 0x40
  405996:	4798      	blx	r3

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
  405998:	697b      	ldr	r3, [r7, #20]
  40599a:	68fa      	ldr	r2, [r7, #12]
  40599c:	601a      	str	r2, [r3, #0]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
  40599e:	697b      	ldr	r3, [r7, #20]
  4059a0:	68ba      	ldr	r2, [r7, #8]
  4059a2:	619a      	str	r2, [r3, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
  4059a4:	697b      	ldr	r3, [r7, #20]
  4059a6:	687a      	ldr	r2, [r7, #4]
  4059a8:	61da      	str	r2, [r3, #28]
			pxNewTimer->pvTimerID = pvTimerID;
  4059aa:	697b      	ldr	r3, [r7, #20]
  4059ac:	683a      	ldr	r2, [r7, #0]
  4059ae:	621a      	str	r2, [r3, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
  4059b0:	697b      	ldr	r3, [r7, #20]
  4059b2:	6a3a      	ldr	r2, [r7, #32]
  4059b4:	625a      	str	r2, [r3, #36]	; 0x24
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
  4059b6:	697b      	ldr	r3, [r7, #20]
  4059b8:	f103 0304 	add.w	r3, r3, #4
  4059bc:	4618      	mov	r0, r3
  4059be:	f642 3345 	movw	r3, #11077	; 0x2b45
  4059c2:	f2c0 0340 	movt	r3, #64	; 0x40
  4059c6:	4798      	blx	r3
			traceTIMER_CREATE_FAILED();
		}
	}

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
  4059c8:	68bb      	ldr	r3, [r7, #8]
  4059ca:	2b00      	cmp	r3, #0
  4059cc:	d105      	bne.n	4059da <xTimerCreate+0x7e>
  4059ce:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4059d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4059d6:	4798      	blx	r3
  4059d8:	e7fe      	b.n	4059d8 <xTimerCreate+0x7c>

	return ( xTimerHandle ) pxNewTimer;
  4059da:	697b      	ldr	r3, [r7, #20]
}
  4059dc:	4618      	mov	r0, r3
  4059de:	f107 0718 	add.w	r7, r7, #24
  4059e2:	46bd      	mov	sp, r7
  4059e4:	bd80      	pop	{r7, pc}
  4059e6:	bf00      	nop

004059e8 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
  4059e8:	b590      	push	{r4, r7, lr}
  4059ea:	b089      	sub	sp, #36	; 0x24
  4059ec:	af00      	add	r7, sp, #0
  4059ee:	60f8      	str	r0, [r7, #12]
  4059f0:	60b9      	str	r1, [r7, #8]
  4059f2:	607a      	str	r2, [r7, #4]
  4059f4:	603b      	str	r3, [r7, #0]
portBASE_TYPE xReturn = pdFAIL;
  4059f6:	f04f 0300 	mov.w	r3, #0
  4059fa:	61fb      	str	r3, [r7, #28]
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
  4059fc:	f24a 637c 	movw	r3, #42620	; 0xa67c
  405a00:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405a04:	681b      	ldr	r3, [r3, #0]
  405a06:	2b00      	cmp	r3, #0
  405a08:	d049      	beq.n	405a9e <xTimerGenericCommand+0xb6>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
  405a0a:	68bb      	ldr	r3, [r7, #8]
  405a0c:	613b      	str	r3, [r7, #16]
		xMessage.xMessageValue = xOptionalValue;
  405a0e:	687b      	ldr	r3, [r7, #4]
  405a10:	617b      	str	r3, [r7, #20]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
  405a12:	68fb      	ldr	r3, [r7, #12]
  405a14:	61bb      	str	r3, [r7, #24]

		if( pxHigherPriorityTaskWoken == NULL )
  405a16:	683b      	ldr	r3, [r7, #0]
  405a18:	2b00      	cmp	r3, #0
  405a1a:	d12e      	bne.n	405a7a <xTimerGenericCommand+0x92>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  405a1c:	f245 6365 	movw	r3, #22117	; 0x5665
  405a20:	f2c0 0340 	movt	r3, #64	; 0x40
  405a24:	4798      	blx	r3
  405a26:	4603      	mov	r3, r0
  405a28:	2b01      	cmp	r3, #1
  405a2a:	d112      	bne.n	405a52 <xTimerGenericCommand+0x6a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
  405a2c:	f24a 637c 	movw	r3, #42620	; 0xa67c
  405a30:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405a34:	681a      	ldr	r2, [r3, #0]
  405a36:	f107 0310 	add.w	r3, r7, #16
  405a3a:	4610      	mov	r0, r2
  405a3c:	4619      	mov	r1, r3
  405a3e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  405a40:	f04f 0300 	mov.w	r3, #0
  405a44:	f243 34f1 	movw	r4, #13297	; 0x33f1
  405a48:	f2c0 0440 	movt	r4, #64	; 0x40
  405a4c:	47a0      	blx	r4
  405a4e:	61f8      	str	r0, [r7, #28]
  405a50:	e025      	b.n	405a9e <xTimerGenericCommand+0xb6>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  405a52:	f24a 637c 	movw	r3, #42620	; 0xa67c
  405a56:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405a5a:	681a      	ldr	r2, [r3, #0]
  405a5c:	f107 0310 	add.w	r3, r7, #16
  405a60:	4610      	mov	r0, r2
  405a62:	4619      	mov	r1, r3
  405a64:	f04f 0200 	mov.w	r2, #0
  405a68:	f04f 0300 	mov.w	r3, #0
  405a6c:	f243 34f1 	movw	r4, #13297	; 0x33f1
  405a70:	f2c0 0440 	movt	r4, #64	; 0x40
  405a74:	47a0      	blx	r4
  405a76:	61f8      	str	r0, [r7, #28]
  405a78:	e011      	b.n	405a9e <xTimerGenericCommand+0xb6>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  405a7a:	f24a 637c 	movw	r3, #42620	; 0xa67c
  405a7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405a82:	681a      	ldr	r2, [r3, #0]
  405a84:	f107 0310 	add.w	r3, r7, #16
  405a88:	4610      	mov	r0, r2
  405a8a:	4619      	mov	r1, r3
  405a8c:	683a      	ldr	r2, [r7, #0]
  405a8e:	f04f 0300 	mov.w	r3, #0
  405a92:	f243 6425 	movw	r4, #13861	; 0x3625
  405a96:	f2c0 0440 	movt	r4, #64	; 0x40
  405a9a:	47a0      	blx	r4
  405a9c:	61f8      	str	r0, [r7, #28]
		}

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
  405a9e:	69fb      	ldr	r3, [r7, #28]
}
  405aa0:	4618      	mov	r0, r3
  405aa2:	f107 0724 	add.w	r7, r7, #36	; 0x24
  405aa6:	46bd      	mov	sp, r7
  405aa8:	bd90      	pop	{r4, r7, pc}
  405aaa:	bf00      	nop

00405aac <prvProcessExpiredTimer>:

#endif
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
{
  405aac:	b590      	push	{r4, r7, lr}
  405aae:	b087      	sub	sp, #28
  405ab0:	af02      	add	r7, sp, #8
  405ab2:	6078      	str	r0, [r7, #4]
  405ab4:	6039      	str	r1, [r7, #0]
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  405ab6:	f24a 6374 	movw	r3, #42612	; 0xa674
  405aba:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405abe:	681b      	ldr	r3, [r3, #0]
  405ac0:	68db      	ldr	r3, [r3, #12]
  405ac2:	68db      	ldr	r3, [r3, #12]
  405ac4:	60fb      	str	r3, [r7, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  405ac6:	68fb      	ldr	r3, [r7, #12]
  405ac8:	f103 0304 	add.w	r3, r3, #4
  405acc:	4618      	mov	r0, r3
  405ace:	f642 431d 	movw	r3, #11293	; 0x2c1d
  405ad2:	f2c0 0340 	movt	r3, #64	; 0x40
  405ad6:	4798      	blx	r3
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  405ad8:	68fb      	ldr	r3, [r7, #12]
  405ada:	69db      	ldr	r3, [r3, #28]
  405adc:	2b01      	cmp	r3, #1
  405ade:	d127      	bne.n	405b30 <prvProcessExpiredTimer+0x84>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
  405ae0:	68fb      	ldr	r3, [r7, #12]
  405ae2:	699a      	ldr	r2, [r3, #24]
  405ae4:	687b      	ldr	r3, [r7, #4]
  405ae6:	18d3      	adds	r3, r2, r3
  405ae8:	68f8      	ldr	r0, [r7, #12]
  405aea:	4619      	mov	r1, r3
  405aec:	683a      	ldr	r2, [r7, #0]
  405aee:	687b      	ldr	r3, [r7, #4]
  405af0:	f645 44d5 	movw	r4, #23765	; 0x5cd5
  405af4:	f2c0 0440 	movt	r4, #64	; 0x40
  405af8:	47a0      	blx	r4
  405afa:	4603      	mov	r3, r0
  405afc:	2b01      	cmp	r3, #1
  405afe:	d117      	bne.n	405b30 <prvProcessExpiredTimer+0x84>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  405b00:	f04f 0300 	mov.w	r3, #0
  405b04:	9300      	str	r3, [sp, #0]
  405b06:	68f8      	ldr	r0, [r7, #12]
  405b08:	f04f 0100 	mov.w	r1, #0
  405b0c:	687a      	ldr	r2, [r7, #4]
  405b0e:	f04f 0300 	mov.w	r3, #0
  405b12:	f645 14e9 	movw	r4, #23017	; 0x59e9
  405b16:	f2c0 0440 	movt	r4, #64	; 0x40
  405b1a:	47a0      	blx	r4
  405b1c:	60b8      	str	r0, [r7, #8]
			configASSERT( xResult );
  405b1e:	68bb      	ldr	r3, [r7, #8]
  405b20:	2b00      	cmp	r3, #0
  405b22:	d105      	bne.n	405b30 <prvProcessExpiredTimer+0x84>
  405b24:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  405b28:	f2c0 0340 	movt	r3, #64	; 0x40
  405b2c:	4798      	blx	r3
  405b2e:	e7fe      	b.n	405b2e <prvProcessExpiredTimer+0x82>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  405b30:	68fb      	ldr	r3, [r7, #12]
  405b32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  405b34:	68f8      	ldr	r0, [r7, #12]
  405b36:	4798      	blx	r3
}
  405b38:	f107 0714 	add.w	r7, r7, #20
  405b3c:	46bd      	mov	sp, r7
  405b3e:	bd90      	pop	{r4, r7, pc}

00405b40 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
  405b40:	b580      	push	{r7, lr}
  405b42:	b084      	sub	sp, #16
  405b44:	af00      	add	r7, sp, #0
  405b46:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
  405b48:	f107 0308 	add.w	r3, r7, #8
  405b4c:	4618      	mov	r0, r3
  405b4e:	f645 431d 	movw	r3, #23581	; 0x5c1d
  405b52:	f2c0 0340 	movt	r3, #64	; 0x40
  405b56:	4798      	blx	r3
  405b58:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
  405b5a:	68bb      	ldr	r3, [r7, #8]
  405b5c:	68f8      	ldr	r0, [r7, #12]
  405b5e:	4619      	mov	r1, r3
  405b60:	f645 3379 	movw	r3, #23417	; 0x5b79
  405b64:	f2c0 0340 	movt	r3, #64	; 0x40
  405b68:	4798      	blx	r3

		/* Empty the command queue. */
		prvProcessReceivedCommands();
  405b6a:	f645 5375 	movw	r3, #23925	; 0x5d75
  405b6e:	f2c0 0340 	movt	r3, #64	; 0x40
  405b72:	4798      	blx	r3
	}
  405b74:	e7e8      	b.n	405b48 <prvTimerTask+0x8>
  405b76:	bf00      	nop

00405b78 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
  405b78:	b580      	push	{r7, lr}
  405b7a:	b084      	sub	sp, #16
  405b7c:	af00      	add	r7, sp, #0
  405b7e:	6078      	str	r0, [r7, #4]
  405b80:	6039      	str	r1, [r7, #0]
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  405b82:	f644 03f9 	movw	r3, #18681	; 0x48f9
  405b86:	f2c0 0340 	movt	r3, #64	; 0x40
  405b8a:	4798      	blx	r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  405b8c:	f107 0308 	add.w	r3, r7, #8
  405b90:	4618      	mov	r0, r3
  405b92:	f645 4371 	movw	r3, #23665	; 0x5c71
  405b96:	f2c0 0340 	movt	r3, #64	; 0x40
  405b9a:	4798      	blx	r3
  405b9c:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
  405b9e:	68bb      	ldr	r3, [r7, #8]
  405ba0:	2b00      	cmp	r3, #0
  405ba2:	d130      	bne.n	405c06 <prvProcessTimerOrBlockTask+0x8e>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  405ba4:	683b      	ldr	r3, [r7, #0]
  405ba6:	2b00      	cmp	r3, #0
  405ba8:	d110      	bne.n	405bcc <prvProcessTimerOrBlockTask+0x54>
  405baa:	687a      	ldr	r2, [r7, #4]
  405bac:	68fb      	ldr	r3, [r7, #12]
  405bae:	429a      	cmp	r2, r3
  405bb0:	d80c      	bhi.n	405bcc <prvProcessTimerOrBlockTask+0x54>
			{
				( void ) xTaskResumeAll();
  405bb2:	f644 131d 	movw	r3, #18717	; 0x491d
  405bb6:	f2c0 0340 	movt	r3, #64	; 0x40
  405bba:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
  405bbc:	6878      	ldr	r0, [r7, #4]
  405bbe:	68f9      	ldr	r1, [r7, #12]
  405bc0:	f645 23ad 	movw	r3, #23213	; 0x5aad
  405bc4:	f2c0 0340 	movt	r3, #64	; 0x40
  405bc8:	4798      	blx	r3
  405bca:	e023      	b.n	405c14 <prvProcessTimerOrBlockTask+0x9c>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
  405bcc:	f24a 637c 	movw	r3, #42620	; 0xa67c
  405bd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405bd4:	681a      	ldr	r2, [r3, #0]
  405bd6:	6879      	ldr	r1, [r7, #4]
  405bd8:	68fb      	ldr	r3, [r7, #12]
  405bda:	1acb      	subs	r3, r1, r3
  405bdc:	4610      	mov	r0, r2
  405bde:	4619      	mov	r1, r3
  405be0:	f643 53c1 	movw	r3, #15809	; 0x3dc1
  405be4:	f2c0 0340 	movt	r3, #64	; 0x40
  405be8:	4798      	blx	r3

				if( xTaskResumeAll() == pdFALSE )
  405bea:	f644 131d 	movw	r3, #18717	; 0x491d
  405bee:	f2c0 0340 	movt	r3, #64	; 0x40
  405bf2:	4798      	blx	r3
  405bf4:	4603      	mov	r3, r0
  405bf6:	2b00      	cmp	r3, #0
  405bf8:	d10b      	bne.n	405c12 <prvProcessTimerOrBlockTask+0x9a>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
  405bfa:	f642 6359 	movw	r3, #11865	; 0x2e59
  405bfe:	f2c0 0340 	movt	r3, #64	; 0x40
  405c02:	4798      	blx	r3
  405c04:	e005      	b.n	405c12 <prvProcessTimerOrBlockTask+0x9a>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
  405c06:	f644 131d 	movw	r3, #18717	; 0x491d
  405c0a:	f2c0 0340 	movt	r3, #64	; 0x40
  405c0e:	4798      	blx	r3
  405c10:	e000      	b.n	405c14 <prvProcessTimerOrBlockTask+0x9c>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
  405c12:	bf00      	nop
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
  405c14:	f107 0710 	add.w	r7, r7, #16
  405c18:	46bd      	mov	sp, r7
  405c1a:	bd80      	pop	{r7, pc}

00405c1c <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
{
  405c1c:	b480      	push	{r7}
  405c1e:	b085      	sub	sp, #20
  405c20:	af00      	add	r7, sp, #0
  405c22:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  405c24:	f24a 6374 	movw	r3, #42612	; 0xa674
  405c28:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405c2c:	681b      	ldr	r3, [r3, #0]
  405c2e:	681b      	ldr	r3, [r3, #0]
  405c30:	2b00      	cmp	r3, #0
  405c32:	bf14      	ite	ne
  405c34:	2300      	movne	r3, #0
  405c36:	2301      	moveq	r3, #1
  405c38:	b2db      	uxtb	r3, r3
  405c3a:	461a      	mov	r2, r3
  405c3c:	687b      	ldr	r3, [r7, #4]
  405c3e:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
  405c40:	687b      	ldr	r3, [r7, #4]
  405c42:	681b      	ldr	r3, [r3, #0]
  405c44:	2b00      	cmp	r3, #0
  405c46:	d108      	bne.n	405c5a <prvGetNextExpireTime+0x3e>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  405c48:	f24a 6374 	movw	r3, #42612	; 0xa674
  405c4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405c50:	681b      	ldr	r3, [r3, #0]
  405c52:	68db      	ldr	r3, [r3, #12]
  405c54:	681b      	ldr	r3, [r3, #0]
  405c56:	60fb      	str	r3, [r7, #12]
  405c58:	e002      	b.n	405c60 <prvGetNextExpireTime+0x44>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
  405c5a:	f04f 0300 	mov.w	r3, #0
  405c5e:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
  405c60:	68fb      	ldr	r3, [r7, #12]
}
  405c62:	4618      	mov	r0, r3
  405c64:	f107 0714 	add.w	r7, r7, #20
  405c68:	46bd      	mov	sp, r7
  405c6a:	bc80      	pop	{r7}
  405c6c:	4770      	bx	lr
  405c6e:	bf00      	nop

00405c70 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
  405c70:	b580      	push	{r7, lr}
  405c72:	b084      	sub	sp, #16
  405c74:	af00      	add	r7, sp, #0
  405c76:	6078      	str	r0, [r7, #4]
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
  405c78:	f644 23c1 	movw	r3, #19137	; 0x4ac1
  405c7c:	f2c0 0340 	movt	r3, #64	; 0x40
  405c80:	4798      	blx	r3
  405c82:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
  405c84:	f24a 6380 	movw	r3, #42624	; 0xa680
  405c88:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405c8c:	681b      	ldr	r3, [r3, #0]
  405c8e:	68fa      	ldr	r2, [r7, #12]
  405c90:	429a      	cmp	r2, r3
  405c92:	d20f      	bcs.n	405cb4 <prvSampleTimeNow+0x44>
	{
		prvSwitchTimerLists( xLastTime );
  405c94:	f24a 6380 	movw	r3, #42624	; 0xa680
  405c98:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405c9c:	681b      	ldr	r3, [r3, #0]
  405c9e:	4618      	mov	r0, r3
  405ca0:	f645 63b1 	movw	r3, #24241	; 0x5eb1
  405ca4:	f2c0 0340 	movt	r3, #64	; 0x40
  405ca8:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
  405caa:	687b      	ldr	r3, [r7, #4]
  405cac:	f04f 0201 	mov.w	r2, #1
  405cb0:	601a      	str	r2, [r3, #0]
  405cb2:	e003      	b.n	405cbc <prvSampleTimeNow+0x4c>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
  405cb4:	687b      	ldr	r3, [r7, #4]
  405cb6:	f04f 0200 	mov.w	r2, #0
  405cba:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
  405cbc:	f24a 6380 	movw	r3, #42624	; 0xa680
  405cc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405cc4:	68fa      	ldr	r2, [r7, #12]
  405cc6:	601a      	str	r2, [r3, #0]

	return xTimeNow;
  405cc8:	68fb      	ldr	r3, [r7, #12]
}
  405cca:	4618      	mov	r0, r3
  405ccc:	f107 0710 	add.w	r7, r7, #16
  405cd0:	46bd      	mov	sp, r7
  405cd2:	bd80      	pop	{r7, pc}

00405cd4 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
  405cd4:	b580      	push	{r7, lr}
  405cd6:	b086      	sub	sp, #24
  405cd8:	af00      	add	r7, sp, #0
  405cda:	60f8      	str	r0, [r7, #12]
  405cdc:	60b9      	str	r1, [r7, #8]
  405cde:	607a      	str	r2, [r7, #4]
  405ce0:	603b      	str	r3, [r7, #0]
portBASE_TYPE xProcessTimerNow = pdFALSE;
  405ce2:	f04f 0300 	mov.w	r3, #0
  405ce6:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  405ce8:	68fb      	ldr	r3, [r7, #12]
  405cea:	68ba      	ldr	r2, [r7, #8]
  405cec:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  405cee:	68fb      	ldr	r3, [r7, #12]
  405cf0:	68fa      	ldr	r2, [r7, #12]
  405cf2:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
  405cf4:	68ba      	ldr	r2, [r7, #8]
  405cf6:	687b      	ldr	r3, [r7, #4]
  405cf8:	429a      	cmp	r2, r3
  405cfa:	d81a      	bhi.n	405d32 <prvInsertTimerInActiveList+0x5e>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
  405cfc:	687a      	ldr	r2, [r7, #4]
  405cfe:	683b      	ldr	r3, [r7, #0]
  405d00:	1ad2      	subs	r2, r2, r3
  405d02:	68fb      	ldr	r3, [r7, #12]
  405d04:	699b      	ldr	r3, [r3, #24]
  405d06:	429a      	cmp	r2, r3
  405d08:	d303      	bcc.n	405d12 <prvInsertTimerInActiveList+0x3e>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  405d0a:	f04f 0301 	mov.w	r3, #1
  405d0e:	617b      	str	r3, [r7, #20]
  405d10:	e02a      	b.n	405d68 <prvInsertTimerInActiveList+0x94>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  405d12:	f24a 6378 	movw	r3, #42616	; 0xa678
  405d16:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405d1a:	681a      	ldr	r2, [r3, #0]
  405d1c:	68fb      	ldr	r3, [r7, #12]
  405d1e:	f103 0304 	add.w	r3, r3, #4
  405d22:	4610      	mov	r0, r2
  405d24:	4619      	mov	r1, r3
  405d26:	f642 33a9 	movw	r3, #11177	; 0x2ba9
  405d2a:	f2c0 0340 	movt	r3, #64	; 0x40
  405d2e:	4798      	blx	r3
  405d30:	e01a      	b.n	405d68 <prvInsertTimerInActiveList+0x94>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  405d32:	687a      	ldr	r2, [r7, #4]
  405d34:	683b      	ldr	r3, [r7, #0]
  405d36:	429a      	cmp	r2, r3
  405d38:	d207      	bcs.n	405d4a <prvInsertTimerInActiveList+0x76>
  405d3a:	68ba      	ldr	r2, [r7, #8]
  405d3c:	683b      	ldr	r3, [r7, #0]
  405d3e:	429a      	cmp	r2, r3
  405d40:	d303      	bcc.n	405d4a <prvInsertTimerInActiveList+0x76>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
  405d42:	f04f 0301 	mov.w	r3, #1
  405d46:	617b      	str	r3, [r7, #20]
  405d48:	e00e      	b.n	405d68 <prvInsertTimerInActiveList+0x94>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  405d4a:	f24a 6374 	movw	r3, #42612	; 0xa674
  405d4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405d52:	681a      	ldr	r2, [r3, #0]
  405d54:	68fb      	ldr	r3, [r7, #12]
  405d56:	f103 0304 	add.w	r3, r3, #4
  405d5a:	4610      	mov	r0, r2
  405d5c:	4619      	mov	r1, r3
  405d5e:	f642 33a9 	movw	r3, #11177	; 0x2ba9
  405d62:	f2c0 0340 	movt	r3, #64	; 0x40
  405d66:	4798      	blx	r3
		}
	}

	return xProcessTimerNow;
  405d68:	697b      	ldr	r3, [r7, #20]
}
  405d6a:	4618      	mov	r0, r3
  405d6c:	f107 0718 	add.w	r7, r7, #24
  405d70:	46bd      	mov	sp, r7
  405d72:	bd80      	pop	{r7, pc}

00405d74 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
  405d74:	b590      	push	{r4, r7, lr}
  405d76:	b08b      	sub	sp, #44	; 0x2c
  405d78:	af02      	add	r7, sp, #8
xTIMER_MESSAGE xMessage;
xTIMER *pxTimer;
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  405d7a:	e07e      	b.n	405e7a <prvProcessReceivedCommands+0x106>
	{
		pxTimer = xMessage.pxTimer;
  405d7c:	693b      	ldr	r3, [r7, #16]
  405d7e:	61fb      	str	r3, [r7, #28]

		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
  405d80:	69fb      	ldr	r3, [r7, #28]
  405d82:	695b      	ldr	r3, [r3, #20]
  405d84:	2b00      	cmp	r3, #0
  405d86:	d008      	beq.n	405d9a <prvProcessReceivedCommands+0x26>
		{
			/* The timer is in a list, remove it. */
			( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  405d88:	69fb      	ldr	r3, [r7, #28]
  405d8a:	f103 0304 	add.w	r3, r3, #4
  405d8e:	4618      	mov	r0, r3
  405d90:	f642 431d 	movw	r3, #11293	; 0x2c1d
  405d94:	f2c0 0340 	movt	r3, #64	; 0x40
  405d98:	4798      	blx	r3
		it must be present in the function call.  prvSampleTimeNow() must be 
		called after the message is received from xTimerQueue so there is no 
		possibility of a higher priority task adding a message to the message
		queue with a time that is ahead of the timer daemon task (because it
		pre-empted the timer daemon task after the xTimeNow value was set). */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  405d9a:	f107 0304 	add.w	r3, r7, #4
  405d9e:	4618      	mov	r0, r3
  405da0:	f645 4371 	movw	r3, #23665	; 0x5c71
  405da4:	f2c0 0340 	movt	r3, #64	; 0x40
  405da8:	4798      	blx	r3
  405daa:	61b8      	str	r0, [r7, #24]

		switch( xMessage.xMessageID )
  405dac:	68bb      	ldr	r3, [r7, #8]
  405dae:	2b03      	cmp	r3, #3
  405db0:	d860      	bhi.n	405e74 <prvProcessReceivedCommands+0x100>
  405db2:	a201      	add	r2, pc, #4	; (adr r2, 405db8 <prvProcessReceivedCommands+0x44>)
  405db4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  405db8:	00405dc9 	.word	0x00405dc9
  405dbc:	00405e75 	.word	0x00405e75
  405dc0:	00405e31 	.word	0x00405e31
  405dc4:	00405e67 	.word	0x00405e67
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
  405dc8:	68fa      	ldr	r2, [r7, #12]
  405dca:	69fb      	ldr	r3, [r7, #28]
  405dcc:	699b      	ldr	r3, [r3, #24]
  405dce:	18d2      	adds	r2, r2, r3
  405dd0:	68fb      	ldr	r3, [r7, #12]
  405dd2:	69f8      	ldr	r0, [r7, #28]
  405dd4:	4611      	mov	r1, r2
  405dd6:	69ba      	ldr	r2, [r7, #24]
  405dd8:	f645 44d5 	movw	r4, #23765	; 0x5cd5
  405ddc:	f2c0 0440 	movt	r4, #64	; 0x40
  405de0:	47a0      	blx	r4
  405de2:	4603      	mov	r3, r0
  405de4:	2b01      	cmp	r3, #1
  405de6:	d147      	bne.n	405e78 <prvProcessReceivedCommands+0x104>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  405de8:	69fb      	ldr	r3, [r7, #28]
  405dea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  405dec:	69f8      	ldr	r0, [r7, #28]
  405dee:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  405df0:	69fb      	ldr	r3, [r7, #28]
  405df2:	69db      	ldr	r3, [r3, #28]
  405df4:	2b01      	cmp	r3, #1
  405df6:	d13f      	bne.n	405e78 <prvProcessReceivedCommands+0x104>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  405df8:	68fa      	ldr	r2, [r7, #12]
  405dfa:	69fb      	ldr	r3, [r7, #28]
  405dfc:	699b      	ldr	r3, [r3, #24]
  405dfe:	18d3      	adds	r3, r2, r3
  405e00:	f04f 0200 	mov.w	r2, #0
  405e04:	9200      	str	r2, [sp, #0]
  405e06:	69f8      	ldr	r0, [r7, #28]
  405e08:	f04f 0100 	mov.w	r1, #0
  405e0c:	461a      	mov	r2, r3
  405e0e:	f04f 0300 	mov.w	r3, #0
  405e12:	f645 14e9 	movw	r4, #23017	; 0x59e9
  405e16:	f2c0 0440 	movt	r4, #64	; 0x40
  405e1a:	47a0      	blx	r4
  405e1c:	6178      	str	r0, [r7, #20]
						configASSERT( xResult );
  405e1e:	697b      	ldr	r3, [r7, #20]
  405e20:	2b00      	cmp	r3, #0
  405e22:	d129      	bne.n	405e78 <prvProcessReceivedCommands+0x104>
  405e24:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  405e28:	f2c0 0340 	movt	r3, #64	; 0x40
  405e2c:	4798      	blx	r3
  405e2e:	e7fe      	b.n	405e2e <prvProcessReceivedCommands+0xba>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
  405e30:	68fa      	ldr	r2, [r7, #12]
  405e32:	69fb      	ldr	r3, [r7, #28]
  405e34:	619a      	str	r2, [r3, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  405e36:	69fb      	ldr	r3, [r7, #28]
  405e38:	699b      	ldr	r3, [r3, #24]
  405e3a:	2b00      	cmp	r3, #0
  405e3c:	d105      	bne.n	405e4a <prvProcessReceivedCommands+0xd6>
  405e3e:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  405e42:	f2c0 0340 	movt	r3, #64	; 0x40
  405e46:	4798      	blx	r3
  405e48:	e7fe      	b.n	405e48 <prvProcessReceivedCommands+0xd4>
				longer or shorter than the old one.  The command time is 
				therefore set to the current time, and as the period cannot be
				zero the next expiry time can only be in the future, meaning
				(unlike for the xTimerStart() case above) there is no fail case
				that needs to be handled here. */
				( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  405e4a:	69fb      	ldr	r3, [r7, #28]
  405e4c:	699a      	ldr	r2, [r3, #24]
  405e4e:	69bb      	ldr	r3, [r7, #24]
  405e50:	18d3      	adds	r3, r2, r3
  405e52:	69f8      	ldr	r0, [r7, #28]
  405e54:	4619      	mov	r1, r3
  405e56:	69ba      	ldr	r2, [r7, #24]
  405e58:	69bb      	ldr	r3, [r7, #24]
  405e5a:	f645 44d5 	movw	r4, #23765	; 0x5cd5
  405e5e:	f2c0 0440 	movt	r4, #64	; 0x40
  405e62:	47a0      	blx	r4
				break;
  405e64:	e009      	b.n	405e7a <prvProcessReceivedCommands+0x106>

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
  405e66:	69f8      	ldr	r0, [r7, #28]
  405e68:	f240 63c5 	movw	r3, #1733	; 0x6c5
  405e6c:	f2c0 0340 	movt	r3, #64	; 0x40
  405e70:	4798      	blx	r3
				break;
  405e72:	e002      	b.n	405e7a <prvProcessReceivedCommands+0x106>

			default	:
				/* Don't expect to get here. */
				break;
  405e74:	bf00      	nop
  405e76:	e000      	b.n	405e7a <prvProcessReceivedCommands+0x106>
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
						configASSERT( xResult );
						( void ) xResult;
					}
				}
				break;
  405e78:	bf00      	nop
xTIMER_MESSAGE xMessage;
xTIMER *pxTimer;
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  405e7a:	f24a 637c 	movw	r3, #42620	; 0xa67c
  405e7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405e82:	681a      	ldr	r2, [r3, #0]
  405e84:	f107 0308 	add.w	r3, r7, #8
  405e88:	4610      	mov	r0, r2
  405e8a:	4619      	mov	r1, r3
  405e8c:	f04f 0200 	mov.w	r2, #0
  405e90:	f04f 0300 	mov.w	r3, #0
  405e94:	f243 7469 	movw	r4, #14185	; 0x3769
  405e98:	f2c0 0440 	movt	r4, #64	; 0x40
  405e9c:	47a0      	blx	r4
  405e9e:	4603      	mov	r3, r0
  405ea0:	2b00      	cmp	r3, #0
  405ea2:	f47f af6b 	bne.w	405d7c <prvProcessReceivedCommands+0x8>
			default	:
				/* Don't expect to get here. */
				break;
		}
	}
}
  405ea6:	f107 0724 	add.w	r7, r7, #36	; 0x24
  405eaa:	46bd      	mov	sp, r7
  405eac:	bd90      	pop	{r4, r7, pc}
  405eae:	bf00      	nop

00405eb0 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
{
  405eb0:	b590      	push	{r4, r7, lr}
  405eb2:	b08b      	sub	sp, #44	; 0x2c
  405eb4:	af02      	add	r7, sp, #8
  405eb6:	6078      	str	r0, [r7, #4]

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  405eb8:	e057      	b.n	405f6a <prvSwitchTimerLists+0xba>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  405eba:	f24a 6374 	movw	r3, #42612	; 0xa674
  405ebe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405ec2:	681b      	ldr	r3, [r3, #0]
  405ec4:	68db      	ldr	r3, [r3, #12]
  405ec6:	681b      	ldr	r3, [r3, #0]
  405ec8:	61fb      	str	r3, [r7, #28]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  405eca:	f24a 6374 	movw	r3, #42612	; 0xa674
  405ece:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405ed2:	681b      	ldr	r3, [r3, #0]
  405ed4:	68db      	ldr	r3, [r3, #12]
  405ed6:	68db      	ldr	r3, [r3, #12]
  405ed8:	61bb      	str	r3, [r7, #24]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  405eda:	69bb      	ldr	r3, [r7, #24]
  405edc:	f103 0304 	add.w	r3, r3, #4
  405ee0:	4618      	mov	r0, r3
  405ee2:	f642 431d 	movw	r3, #11293	; 0x2c1d
  405ee6:	f2c0 0340 	movt	r3, #64	; 0x40
  405eea:	4798      	blx	r3

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  405eec:	69bb      	ldr	r3, [r7, #24]
  405eee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  405ef0:	69b8      	ldr	r0, [r7, #24]
  405ef2:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  405ef4:	69bb      	ldr	r3, [r7, #24]
  405ef6:	69db      	ldr	r3, [r3, #28]
  405ef8:	2b01      	cmp	r3, #1
  405efa:	d136      	bne.n	405f6a <prvSwitchTimerLists+0xba>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  405efc:	69bb      	ldr	r3, [r7, #24]
  405efe:	699a      	ldr	r2, [r3, #24]
  405f00:	69fb      	ldr	r3, [r7, #28]
  405f02:	18d3      	adds	r3, r2, r3
  405f04:	617b      	str	r3, [r7, #20]
			if( xReloadTime > xNextExpireTime )
  405f06:	697a      	ldr	r2, [r7, #20]
  405f08:	69fb      	ldr	r3, [r7, #28]
  405f0a:	429a      	cmp	r2, r3
  405f0c:	d915      	bls.n	405f3a <prvSwitchTimerLists+0x8a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  405f0e:	69bb      	ldr	r3, [r7, #24]
  405f10:	697a      	ldr	r2, [r7, #20]
  405f12:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  405f14:	69bb      	ldr	r3, [r7, #24]
  405f16:	69ba      	ldr	r2, [r7, #24]
  405f18:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  405f1a:	f24a 6374 	movw	r3, #42612	; 0xa674
  405f1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405f22:	681a      	ldr	r2, [r3, #0]
  405f24:	69bb      	ldr	r3, [r7, #24]
  405f26:	f103 0304 	add.w	r3, r3, #4
  405f2a:	4610      	mov	r0, r2
  405f2c:	4619      	mov	r1, r3
  405f2e:	f642 33a9 	movw	r3, #11177	; 0x2ba9
  405f32:	f2c0 0340 	movt	r3, #64	; 0x40
  405f36:	4798      	blx	r3
  405f38:	e017      	b.n	405f6a <prvSwitchTimerLists+0xba>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  405f3a:	f04f 0300 	mov.w	r3, #0
  405f3e:	9300      	str	r3, [sp, #0]
  405f40:	69b8      	ldr	r0, [r7, #24]
  405f42:	f04f 0100 	mov.w	r1, #0
  405f46:	69fa      	ldr	r2, [r7, #28]
  405f48:	f04f 0300 	mov.w	r3, #0
  405f4c:	f645 14e9 	movw	r4, #23017	; 0x59e9
  405f50:	f2c0 0440 	movt	r4, #64	; 0x40
  405f54:	47a0      	blx	r4
  405f56:	6138      	str	r0, [r7, #16]
				configASSERT( xResult );
  405f58:	693b      	ldr	r3, [r7, #16]
  405f5a:	2b00      	cmp	r3, #0
  405f5c:	d105      	bne.n	405f6a <prvSwitchTimerLists+0xba>
  405f5e:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  405f62:	f2c0 0340 	movt	r3, #64	; 0x40
  405f66:	4798      	blx	r3
  405f68:	e7fe      	b.n	405f68 <prvSwitchTimerLists+0xb8>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  405f6a:	f24a 6374 	movw	r3, #42612	; 0xa674
  405f6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405f72:	681b      	ldr	r3, [r3, #0]
  405f74:	681b      	ldr	r3, [r3, #0]
  405f76:	2b00      	cmp	r3, #0
  405f78:	d19f      	bne.n	405eba <prvSwitchTimerLists+0xa>
				( void ) xResult;
			}
		}
	}

	pxTemp = pxCurrentTimerList;
  405f7a:	f24a 6374 	movw	r3, #42612	; 0xa674
  405f7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405f82:	681b      	ldr	r3, [r3, #0]
  405f84:	60fb      	str	r3, [r7, #12]
	pxCurrentTimerList = pxOverflowTimerList;
  405f86:	f24a 6378 	movw	r3, #42616	; 0xa678
  405f8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405f8e:	681a      	ldr	r2, [r3, #0]
  405f90:	f24a 6374 	movw	r3, #42612	; 0xa674
  405f94:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405f98:	601a      	str	r2, [r3, #0]
	pxOverflowTimerList = pxTemp;
  405f9a:	f24a 6378 	movw	r3, #42616	; 0xa678
  405f9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405fa2:	68fa      	ldr	r2, [r7, #12]
  405fa4:	601a      	str	r2, [r3, #0]
}
  405fa6:	f107 0724 	add.w	r7, r7, #36	; 0x24
  405faa:	46bd      	mov	sp, r7
  405fac:	bd90      	pop	{r4, r7, pc}
  405fae:	bf00      	nop

00405fb0 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  405fb0:	b580      	push	{r7, lr}
  405fb2:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  405fb4:	f642 6379 	movw	r3, #11897	; 0x2e79
  405fb8:	f2c0 0340 	movt	r3, #64	; 0x40
  405fbc:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
  405fbe:	f24a 637c 	movw	r3, #42620	; 0xa67c
  405fc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405fc6:	681b      	ldr	r3, [r3, #0]
  405fc8:	2b00      	cmp	r3, #0
  405fca:	d134      	bne.n	406036 <prvCheckForValidListAndQueue+0x86>
		{
			vListInitialise( &xActiveTimerList1 );
  405fcc:	f24a 604c 	movw	r0, #42572	; 0xa64c
  405fd0:	f2c2 0000 	movt	r0, #8192	; 0x2000
  405fd4:	f642 3305 	movw	r3, #11013	; 0x2b05
  405fd8:	f2c0 0340 	movt	r3, #64	; 0x40
  405fdc:	4798      	blx	r3
			vListInitialise( &xActiveTimerList2 );
  405fde:	f24a 6060 	movw	r0, #42592	; 0xa660
  405fe2:	f2c2 0000 	movt	r0, #8192	; 0x2000
  405fe6:	f642 3305 	movw	r3, #11013	; 0x2b05
  405fea:	f2c0 0340 	movt	r3, #64	; 0x40
  405fee:	4798      	blx	r3
			pxCurrentTimerList = &xActiveTimerList1;
  405ff0:	f24a 6374 	movw	r3, #42612	; 0xa674
  405ff4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  405ff8:	f24a 624c 	movw	r2, #42572	; 0xa64c
  405ffc:	f2c2 0200 	movt	r2, #8192	; 0x2000
  406000:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
  406002:	f24a 6378 	movw	r3, #42616	; 0xa678
  406006:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40600a:	f24a 6260 	movw	r2, #42592	; 0xa660
  40600e:	f2c2 0200 	movt	r2, #8192	; 0x2000
  406012:	601a      	str	r2, [r3, #0]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
  406014:	f04f 0005 	mov.w	r0, #5
  406018:	f04f 010c 	mov.w	r1, #12
  40601c:	f04f 0200 	mov.w	r2, #0
  406020:	f243 1311 	movw	r3, #12561	; 0x3111
  406024:	f2c0 0340 	movt	r3, #64	; 0x40
  406028:	4798      	blx	r3
  40602a:	4602      	mov	r2, r0
  40602c:	f24a 637c 	movw	r3, #42620	; 0xa67c
  406030:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406034:	601a      	str	r2, [r3, #0]
		}
	}
	taskEXIT_CRITICAL();
  406036:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  40603a:	f2c0 0340 	movt	r3, #64	; 0x40
  40603e:	4798      	blx	r3
}
  406040:	bd80      	pop	{r7, pc}
  406042:	bf00      	nop

00406044 <pvTimerGetTimerID>:
	return xTimerIsInActiveList;
}
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( xTimerHandle xTimer )
{
  406044:	b480      	push	{r7}
  406046:	b085      	sub	sp, #20
  406048:	af00      	add	r7, sp, #0
  40604a:	6078      	str	r0, [r7, #4]
xTIMER *pxTimer = ( xTIMER * ) xTimer;
  40604c:	687b      	ldr	r3, [r7, #4]
  40604e:	60fb      	str	r3, [r7, #12]

	return pxTimer->pvTimerID;
  406050:	68fb      	ldr	r3, [r7, #12]
  406052:	6a1b      	ldr	r3, [r3, #32]
}
  406054:	4618      	mov	r0, r3
  406056:	f107 0714 	add.w	r7, r7, #20
  40605a:	46bd      	mov	sp, r7
  40605c:	bc80      	pop	{r7}
  40605e:	4770      	bx	lr

00406060 <vStartBlockingQueueTasks>:
static volatile short sBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( unsigned short ) 0, ( unsigned short ) 0, ( unsigned short ) 0 };

/*-----------------------------------------------------------*/

void vStartBlockingQueueTasks( unsigned portBASE_TYPE uxPriority )
{
  406060:	b590      	push	{r4, r7, lr}
  406062:	b091      	sub	sp, #68	; 0x44
  406064:	af04      	add	r7, sp, #16
  406066:	6078      	str	r0, [r7, #4]
xBlockingQueueParameters *pxQueueParameters1, *pxQueueParameters2;
xBlockingQueueParameters *pxQueueParameters3, *pxQueueParameters4;
xBlockingQueueParameters *pxQueueParameters5, *pxQueueParameters6;
const unsigned portBASE_TYPE uxQueueSize1 = 1, uxQueueSize5 = 5;
  406068:	f04f 0301 	mov.w	r3, #1
  40606c:	62fb      	str	r3, [r7, #44]	; 0x2c
  40606e:	f04f 0305 	mov.w	r3, #5
  406072:	62bb      	str	r3, [r7, #40]	; 0x28
const portTickType xBlockTime = ( portTickType ) 1000 / portTICK_RATE_MS;
  406074:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  406078:	627b      	str	r3, [r7, #36]	; 0x24
const portTickType xDontBlock = ( portTickType ) 0;
  40607a:	f04f 0300 	mov.w	r3, #0
  40607e:	623b      	str	r3, [r7, #32]

	/* Create the first two tasks as described at the top of the file. */

	/* First create the structure used to pass parameters to the consumer tasks. */
	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
  406080:	f04f 000c 	mov.w	r0, #12
  406084:	f240 5345 	movw	r3, #1349	; 0x545
  406088:	f2c0 0340 	movt	r3, #64	; 0x40
  40608c:	4798      	blx	r3
  40608e:	61f8      	str	r0, [r7, #28]

	/* Create the queue used by the first two tasks to pass the incrementing number.
	Pass a pointer to the queue in the parameter structure. */
	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
  406090:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  406092:	f04f 0102 	mov.w	r1, #2
  406096:	f04f 0200 	mov.w	r2, #0
  40609a:	f243 1311 	movw	r3, #12561	; 0x3111
  40609e:	f2c0 0340 	movt	r3, #64	; 0x40
  4060a2:	4798      	blx	r3
  4060a4:	4602      	mov	r2, r0
  4060a6:	69fb      	ldr	r3, [r7, #28]
  4060a8:	601a      	str	r2, [r3, #0]

	/* The consumer is created first so gets a block time as described above. */
	pxQueueParameters1->xBlockTime = xBlockTime;
  4060aa:	69fb      	ldr	r3, [r7, #28]
  4060ac:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4060ae:	605a      	str	r2, [r3, #4]

	/* Pass in the variable that this task is going to increment so we can check it
	is still running. */
	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
  4060b0:	69fa      	ldr	r2, [r7, #28]
  4060b2:	f24a 6384 	movw	r3, #42628	; 0xa684
  4060b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4060ba:	6093      	str	r3, [r2, #8]

	/* Create the structure used to pass parameters to the producer task. */
	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
  4060bc:	f04f 000c 	mov.w	r0, #12
  4060c0:	f240 5345 	movw	r3, #1349	; 0x545
  4060c4:	f2c0 0340 	movt	r3, #64	; 0x40
  4060c8:	4798      	blx	r3
  4060ca:	61b8      	str	r0, [r7, #24]

	/* Pass the queue to this task also, using the parameter structure. */
	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;
  4060cc:	69fb      	ldr	r3, [r7, #28]
  4060ce:	681a      	ldr	r2, [r3, #0]
  4060d0:	69bb      	ldr	r3, [r7, #24]
  4060d2:	601a      	str	r2, [r3, #0]

	/* The producer is not going to block - as soon as it posts the consumer will
	wake and remove the item so the producer should always have room to post. */
	pxQueueParameters2->xBlockTime = xDontBlock;
  4060d4:	69bb      	ldr	r3, [r7, #24]
  4060d6:	6a3a      	ldr	r2, [r7, #32]
  4060d8:	605a      	str	r2, [r3, #4]

	/* Pass in the variable that this task is going to increment so we can check
	it is still running. */
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );
  4060da:	69ba      	ldr	r2, [r7, #24]
  4060dc:	f24a 638c 	movw	r3, #42636	; 0xa68c
  4060e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4060e4:	6093      	str	r3, [r2, #8]


	/* Note the producer has a lower priority than the consumer when the tasks are
	spawned. */
	xTaskCreate( vBlockingQueueConsumer, ( signed char * ) "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
  4060e6:	687b      	ldr	r3, [r7, #4]
  4060e8:	9300      	str	r3, [sp, #0]
  4060ea:	f04f 0300 	mov.w	r3, #0
  4060ee:	9301      	str	r3, [sp, #4]
  4060f0:	f04f 0300 	mov.w	r3, #0
  4060f4:	9302      	str	r3, [sp, #8]
  4060f6:	f04f 0300 	mov.w	r3, #0
  4060fa:	9303      	str	r3, [sp, #12]
  4060fc:	f246 306d 	movw	r0, #25453	; 0x636d
  406100:	f2c0 0040 	movt	r0, #64	; 0x40
  406104:	f249 61c8 	movw	r1, #38600	; 0x96c8
  406108:	f2c0 0140 	movt	r1, #64	; 0x40
  40610c:	f04f 0282 	mov.w	r2, #130	; 0x82
  406110:	69fb      	ldr	r3, [r7, #28]
  406112:	f244 0415 	movw	r4, #16405	; 0x4015
  406116:	f2c0 0440 	movt	r4, #64	; 0x40
  40611a:	47a0      	blx	r4
	xTaskCreate( vBlockingQueueProducer, ( signed char * ) "QProdB2", blckqSTACK_SIZE, ( void * ) pxQueueParameters2, tskIDLE_PRIORITY, NULL );
  40611c:	f04f 0300 	mov.w	r3, #0
  406120:	9300      	str	r3, [sp, #0]
  406122:	f04f 0300 	mov.w	r3, #0
  406126:	9301      	str	r3, [sp, #4]
  406128:	f04f 0300 	mov.w	r3, #0
  40612c:	9302      	str	r3, [sp, #8]
  40612e:	f04f 0300 	mov.w	r3, #0
  406132:	9303      	str	r3, [sp, #12]
  406134:	f246 3001 	movw	r0, #25345	; 0x6301
  406138:	f2c0 0040 	movt	r0, #64	; 0x40
  40613c:	f249 61d0 	movw	r1, #38608	; 0x96d0
  406140:	f2c0 0140 	movt	r1, #64	; 0x40
  406144:	f04f 0282 	mov.w	r2, #130	; 0x82
  406148:	69bb      	ldr	r3, [r7, #24]
  40614a:	f244 0415 	movw	r4, #16405	; 0x4015
  40614e:	f2c0 0440 	movt	r4, #64	; 0x40
  406152:	47a0      	blx	r4


	/* Create the second two tasks as described at the top of the file.   This uses
	the same mechanism but reverses the task priorities. */

	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
  406154:	f04f 000c 	mov.w	r0, #12
  406158:	f240 5345 	movw	r3, #1349	; 0x545
  40615c:	f2c0 0340 	movt	r3, #64	; 0x40
  406160:	4798      	blx	r3
  406162:	6178      	str	r0, [r7, #20]
	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
  406164:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  406166:	f04f 0102 	mov.w	r1, #2
  40616a:	f04f 0200 	mov.w	r2, #0
  40616e:	f243 1311 	movw	r3, #12561	; 0x3111
  406172:	f2c0 0340 	movt	r3, #64	; 0x40
  406176:	4798      	blx	r3
  406178:	4602      	mov	r2, r0
  40617a:	697b      	ldr	r3, [r7, #20]
  40617c:	601a      	str	r2, [r3, #0]
	pxQueueParameters3->xBlockTime = xDontBlock;
  40617e:	697b      	ldr	r3, [r7, #20]
  406180:	6a3a      	ldr	r2, [r7, #32]
  406182:	605a      	str	r2, [r3, #4]
	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );
  406184:	697b      	ldr	r3, [r7, #20]
  406186:	4a5a      	ldr	r2, [pc, #360]	; (4062f0 <vStartBlockingQueueTasks+0x290>)
  406188:	609a      	str	r2, [r3, #8]

	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
  40618a:	f04f 000c 	mov.w	r0, #12
  40618e:	f240 5345 	movw	r3, #1349	; 0x545
  406192:	f2c0 0340 	movt	r3, #64	; 0x40
  406196:	4798      	blx	r3
  406198:	6138      	str	r0, [r7, #16]
	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
  40619a:	697b      	ldr	r3, [r7, #20]
  40619c:	681a      	ldr	r2, [r3, #0]
  40619e:	693b      	ldr	r3, [r7, #16]
  4061a0:	601a      	str	r2, [r3, #0]
	pxQueueParameters4->xBlockTime = xBlockTime;
  4061a2:	693b      	ldr	r3, [r7, #16]
  4061a4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4061a6:	605a      	str	r2, [r3, #4]
	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );
  4061a8:	693b      	ldr	r3, [r7, #16]
  4061aa:	4a52      	ldr	r2, [pc, #328]	; (4062f4 <vStartBlockingQueueTasks+0x294>)
  4061ac:	609a      	str	r2, [r3, #8]

	xTaskCreate( vBlockingQueueConsumer, ( signed char * ) "QConsB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
  4061ae:	f04f 0300 	mov.w	r3, #0
  4061b2:	9300      	str	r3, [sp, #0]
  4061b4:	f04f 0300 	mov.w	r3, #0
  4061b8:	9301      	str	r3, [sp, #4]
  4061ba:	f04f 0300 	mov.w	r3, #0
  4061be:	9302      	str	r3, [sp, #8]
  4061c0:	f04f 0300 	mov.w	r3, #0
  4061c4:	9303      	str	r3, [sp, #12]
  4061c6:	f246 306d 	movw	r0, #25453	; 0x636d
  4061ca:	f2c0 0040 	movt	r0, #64	; 0x40
  4061ce:	f249 61d8 	movw	r1, #38616	; 0x96d8
  4061d2:	f2c0 0140 	movt	r1, #64	; 0x40
  4061d6:	f04f 0282 	mov.w	r2, #130	; 0x82
  4061da:	697b      	ldr	r3, [r7, #20]
  4061dc:	f244 0415 	movw	r4, #16405	; 0x4015
  4061e0:	f2c0 0440 	movt	r4, #64	; 0x40
  4061e4:	47a0      	blx	r4
	xTaskCreate( vBlockingQueueProducer, ( signed char * ) "QProdB4", blckqSTACK_SIZE, ( void * ) pxQueueParameters4, uxPriority, NULL );
  4061e6:	687b      	ldr	r3, [r7, #4]
  4061e8:	9300      	str	r3, [sp, #0]
  4061ea:	f04f 0300 	mov.w	r3, #0
  4061ee:	9301      	str	r3, [sp, #4]
  4061f0:	f04f 0300 	mov.w	r3, #0
  4061f4:	9302      	str	r3, [sp, #8]
  4061f6:	f04f 0300 	mov.w	r3, #0
  4061fa:	9303      	str	r3, [sp, #12]
  4061fc:	f246 3001 	movw	r0, #25345	; 0x6301
  406200:	f2c0 0040 	movt	r0, #64	; 0x40
  406204:	f249 61e0 	movw	r1, #38624	; 0x96e0
  406208:	f2c0 0140 	movt	r1, #64	; 0x40
  40620c:	f04f 0282 	mov.w	r2, #130	; 0x82
  406210:	693b      	ldr	r3, [r7, #16]
  406212:	f244 0415 	movw	r4, #16405	; 0x4015
  406216:	f2c0 0440 	movt	r4, #64	; 0x40
  40621a:	47a0      	blx	r4



	/* Create the last two tasks as described above.  The mechanism is again just
	the same.  This time both parameter structures are given a block time. */
	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
  40621c:	f04f 000c 	mov.w	r0, #12
  406220:	f240 5345 	movw	r3, #1349	; 0x545
  406224:	f2c0 0340 	movt	r3, #64	; 0x40
  406228:	4798      	blx	r3
  40622a:	60f8      	str	r0, [r7, #12]
	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
  40622c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  40622e:	f04f 0102 	mov.w	r1, #2
  406232:	f04f 0200 	mov.w	r2, #0
  406236:	f243 1311 	movw	r3, #12561	; 0x3111
  40623a:	f2c0 0340 	movt	r3, #64	; 0x40
  40623e:	4798      	blx	r3
  406240:	4602      	mov	r2, r0
  406242:	68fb      	ldr	r3, [r7, #12]
  406244:	601a      	str	r2, [r3, #0]
	pxQueueParameters5->xBlockTime = xBlockTime;
  406246:	68fb      	ldr	r3, [r7, #12]
  406248:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40624a:	605a      	str	r2, [r3, #4]
	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );
  40624c:	68fb      	ldr	r3, [r7, #12]
  40624e:	4a2a      	ldr	r2, [pc, #168]	; (4062f8 <vStartBlockingQueueTasks+0x298>)
  406250:	609a      	str	r2, [r3, #8]

	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
  406252:	f04f 000c 	mov.w	r0, #12
  406256:	f240 5345 	movw	r3, #1349	; 0x545
  40625a:	f2c0 0340 	movt	r3, #64	; 0x40
  40625e:	4798      	blx	r3
  406260:	60b8      	str	r0, [r7, #8]
	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
  406262:	68fb      	ldr	r3, [r7, #12]
  406264:	681a      	ldr	r2, [r3, #0]
  406266:	68bb      	ldr	r3, [r7, #8]
  406268:	601a      	str	r2, [r3, #0]
	pxQueueParameters6->xBlockTime = xBlockTime;
  40626a:	68bb      	ldr	r3, [r7, #8]
  40626c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40626e:	605a      	str	r2, [r3, #4]
	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );
  406270:	68bb      	ldr	r3, [r7, #8]
  406272:	4a22      	ldr	r2, [pc, #136]	; (4062fc <vStartBlockingQueueTasks+0x29c>)
  406274:	609a      	str	r2, [r3, #8]

	xTaskCreate( vBlockingQueueProducer, ( signed char * ) "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
  406276:	f04f 0300 	mov.w	r3, #0
  40627a:	9300      	str	r3, [sp, #0]
  40627c:	f04f 0300 	mov.w	r3, #0
  406280:	9301      	str	r3, [sp, #4]
  406282:	f04f 0300 	mov.w	r3, #0
  406286:	9302      	str	r3, [sp, #8]
  406288:	f04f 0300 	mov.w	r3, #0
  40628c:	9303      	str	r3, [sp, #12]
  40628e:	f246 3001 	movw	r0, #25345	; 0x6301
  406292:	f2c0 0040 	movt	r0, #64	; 0x40
  406296:	f249 61e8 	movw	r1, #38632	; 0x96e8
  40629a:	f2c0 0140 	movt	r1, #64	; 0x40
  40629e:	f04f 0282 	mov.w	r2, #130	; 0x82
  4062a2:	68fb      	ldr	r3, [r7, #12]
  4062a4:	f244 0415 	movw	r4, #16405	; 0x4015
  4062a8:	f2c0 0440 	movt	r4, #64	; 0x40
  4062ac:	47a0      	blx	r4
	xTaskCreate( vBlockingQueueConsumer, ( signed char * ) "QConsB6", blckqSTACK_SIZE, ( void * ) pxQueueParameters6, tskIDLE_PRIORITY, NULL );
  4062ae:	f04f 0300 	mov.w	r3, #0
  4062b2:	9300      	str	r3, [sp, #0]
  4062b4:	f04f 0300 	mov.w	r3, #0
  4062b8:	9301      	str	r3, [sp, #4]
  4062ba:	f04f 0300 	mov.w	r3, #0
  4062be:	9302      	str	r3, [sp, #8]
  4062c0:	f04f 0300 	mov.w	r3, #0
  4062c4:	9303      	str	r3, [sp, #12]
  4062c6:	f246 306d 	movw	r0, #25453	; 0x636d
  4062ca:	f2c0 0040 	movt	r0, #64	; 0x40
  4062ce:	f249 61f0 	movw	r1, #38640	; 0x96f0
  4062d2:	f2c0 0140 	movt	r1, #64	; 0x40
  4062d6:	f04f 0282 	mov.w	r2, #130	; 0x82
  4062da:	68bb      	ldr	r3, [r7, #8]
  4062dc:	f244 0415 	movw	r4, #16405	; 0x4015
  4062e0:	f2c0 0440 	movt	r4, #64	; 0x40
  4062e4:	47a0      	blx	r4
}
  4062e6:	f107 0734 	add.w	r7, r7, #52	; 0x34
  4062ea:	46bd      	mov	sp, r7
  4062ec:	bd90      	pop	{r4, r7, pc}
  4062ee:	bf00      	nop
  4062f0:	2000a68e 	.word	0x2000a68e
  4062f4:	2000a686 	.word	0x2000a686
  4062f8:	2000a690 	.word	0x2000a690
  4062fc:	2000a688 	.word	0x2000a688

00406300 <vBlockingQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueProducer, pvParameters )
{
  406300:	b590      	push	{r4, r7, lr}
  406302:	b087      	sub	sp, #28
  406304:	af00      	add	r7, sp, #0
  406306:	6078      	str	r0, [r7, #4]
unsigned short usValue = 0;
  406308:	f04f 0300 	mov.w	r3, #0
  40630c:	81fb      	strh	r3, [r7, #14]
xBlockingQueueParameters *pxQueueParameters;
short sErrorEverOccurred = pdFALSE;
  40630e:	f04f 0300 	mov.w	r3, #0
  406312:	82fb      	strh	r3, [r7, #22]

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
  406314:	687b      	ldr	r3, [r7, #4]
  406316:	613b      	str	r3, [r7, #16]

	for( ;; )
	{
		if( xQueueSend( pxQueueParameters->xQueue, ( void * ) &usValue, pxQueueParameters->xBlockTime ) != pdPASS )
  406318:	693b      	ldr	r3, [r7, #16]
  40631a:	6819      	ldr	r1, [r3, #0]
  40631c:	693b      	ldr	r3, [r7, #16]
  40631e:	685b      	ldr	r3, [r3, #4]
  406320:	f107 020e 	add.w	r2, r7, #14
  406324:	4608      	mov	r0, r1
  406326:	4611      	mov	r1, r2
  406328:	461a      	mov	r2, r3
  40632a:	f04f 0300 	mov.w	r3, #0
  40632e:	f243 34f1 	movw	r4, #13297	; 0x33f1
  406332:	f2c0 0440 	movt	r4, #64	; 0x40
  406336:	47a0      	blx	r4
  406338:	4603      	mov	r3, r0
  40633a:	2b01      	cmp	r3, #1
  40633c:	d003      	beq.n	406346 <vBlockingQueueProducer+0x46>
		{
			sErrorEverOccurred = pdTRUE;
  40633e:	f04f 0301 	mov.w	r3, #1
  406342:	82fb      	strh	r3, [r7, #22]

			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}
	}
  406344:	e7e8      	b.n	406318 <vBlockingQueueProducer+0x18>
		}
		else
		{
			/* We have successfully posted a message, so increment the variable
			used to check we are still running. */
			if( sErrorEverOccurred == pdFALSE )
  406346:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
  40634a:	2b00      	cmp	r3, #0
  40634c:	d107      	bne.n	40635e <vBlockingQueueProducer+0x5e>
			{
				( *pxQueueParameters->psCheckVariable )++;
  40634e:	693b      	ldr	r3, [r7, #16]
  406350:	689b      	ldr	r3, [r3, #8]
  406352:	881a      	ldrh	r2, [r3, #0]
  406354:	b292      	uxth	r2, r2
  406356:	f102 0201 	add.w	r2, r2, #1
  40635a:	b292      	uxth	r2, r2
  40635c:	801a      	strh	r2, [r3, #0]
			}

			/* Increment the variable we are going to post next time round.  The
			consumer will expect the numbers to	follow in numerical order. */
			++usValue;
  40635e:	89fb      	ldrh	r3, [r7, #14]
  406360:	f103 0301 	add.w	r3, r3, #1
  406364:	b29b      	uxth	r3, r3
  406366:	81fb      	strh	r3, [r7, #14]

			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}
	}
  406368:	e7d6      	b.n	406318 <vBlockingQueueProducer+0x18>
  40636a:	bf00      	nop

0040636c <vBlockingQueueConsumer>:
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueConsumer, pvParameters )
{
  40636c:	b590      	push	{r4, r7, lr}
  40636e:	b087      	sub	sp, #28
  406370:	af00      	add	r7, sp, #0
  406372:	6078      	str	r0, [r7, #4]
unsigned short usData, usExpectedValue = 0;
  406374:	f04f 0300 	mov.w	r3, #0
  406378:	82fb      	strh	r3, [r7, #22]
xBlockingQueueParameters *pxQueueParameters;
short sErrorEverOccurred = pdFALSE;
  40637a:	f04f 0300 	mov.w	r3, #0
  40637e:	82bb      	strh	r3, [r7, #20]

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
  406380:	687b      	ldr	r3, [r7, #4]
  406382:	613b      	str	r3, [r7, #16]
  406384:	e000      	b.n	406388 <vBlockingQueueConsumer+0x1c>
					taskYIELD();
				}
			}
			#endif
		}
	}
  406386:	bf00      	nop

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;

	for( ;; )
	{
		if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS )
  406388:	693b      	ldr	r3, [r7, #16]
  40638a:	6819      	ldr	r1, [r3, #0]
  40638c:	693b      	ldr	r3, [r7, #16]
  40638e:	685b      	ldr	r3, [r3, #4]
  406390:	f107 020e 	add.w	r2, r7, #14
  406394:	4608      	mov	r0, r1
  406396:	4611      	mov	r1, r2
  406398:	461a      	mov	r2, r3
  40639a:	f04f 0300 	mov.w	r3, #0
  40639e:	f243 7469 	movw	r4, #14185	; 0x3769
  4063a2:	f2c0 0440 	movt	r4, #64	; 0x40
  4063a6:	47a0      	blx	r4
  4063a8:	4603      	mov	r3, r0
  4063aa:	2b01      	cmp	r3, #1
  4063ac:	d1eb      	bne.n	406386 <vBlockingQueueConsumer+0x1a>
		{
			if( usData != usExpectedValue )
  4063ae:	89fb      	ldrh	r3, [r7, #14]
  4063b0:	8afa      	ldrh	r2, [r7, #22]
  4063b2:	429a      	cmp	r2, r3
  4063b4:	d005      	beq.n	4063c2 <vBlockingQueueConsumer+0x56>
			{
				/* Catch-up. */
				usExpectedValue = usData;
  4063b6:	89fb      	ldrh	r3, [r7, #14]
  4063b8:	82fb      	strh	r3, [r7, #22]

				sErrorEverOccurred = pdTRUE;
  4063ba:	f04f 0301 	mov.w	r3, #1
  4063be:	82bb      	strh	r3, [r7, #20]
					taskYIELD();
				}
			}
			#endif
		}
	}
  4063c0:	e7e1      	b.n	406386 <vBlockingQueueConsumer+0x1a>
			}
			else
			{
				/* We have successfully received a message, so increment the
				variable used to check we are still running. */
				if( sErrorEverOccurred == pdFALSE )
  4063c2:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
  4063c6:	2b00      	cmp	r3, #0
  4063c8:	d107      	bne.n	4063da <vBlockingQueueConsumer+0x6e>
				{
					( *pxQueueParameters->psCheckVariable )++;
  4063ca:	693b      	ldr	r3, [r7, #16]
  4063cc:	689b      	ldr	r3, [r3, #8]
  4063ce:	881a      	ldrh	r2, [r3, #0]
  4063d0:	b292      	uxth	r2, r2
  4063d2:	f102 0201 	add.w	r2, r2, #1
  4063d6:	b292      	uxth	r2, r2
  4063d8:	801a      	strh	r2, [r3, #0]
				}

				/* Increment the value we expect to remove from the queue next time
				round. */
				++usExpectedValue;
  4063da:	8afb      	ldrh	r3, [r7, #22]
  4063dc:	f103 0301 	add.w	r3, r3, #1
  4063e0:	82fb      	strh	r3, [r7, #22]
					taskYIELD();
				}
			}
			#endif
		}
	}
  4063e2:	e7d0      	b.n	406386 <vBlockingQueueConsumer+0x1a>

004063e4 <xAreBlockingQueuesStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreBlockingQueuesStillRunning( void )
{
  4063e4:	b480      	push	{r7}
  4063e6:	b083      	sub	sp, #12
  4063e8:	af00      	add	r7, sp, #0
static short sLastBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( unsigned short ) 0, ( unsigned short ) 0, ( unsigned short ) 0 };
static short sLastBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( unsigned short ) 0, ( unsigned short ) 0, ( unsigned short ) 0 };
portBASE_TYPE xReturn = pdPASS, xTasks;
  4063ea:	f04f 0301 	mov.w	r3, #1
  4063ee:	607b      	str	r3, [r7, #4]
	changed or not.

	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
  4063f0:	f04f 0300 	mov.w	r3, #0
  4063f4:	603b      	str	r3, [r7, #0]
  4063f6:	e04d      	b.n	406494 <xAreBlockingQueuesStillRunning+0xb0>
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
  4063f8:	f24a 6384 	movw	r3, #42628	; 0xa684
  4063fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406400:	683a      	ldr	r2, [r7, #0]
  406402:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
  406406:	b29a      	uxth	r2, r3
  406408:	f24a 6394 	movw	r3, #42644	; 0xa694
  40640c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406410:	6839      	ldr	r1, [r7, #0]
  406412:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
  406416:	b212      	sxth	r2, r2
  406418:	b21b      	sxth	r3, r3
  40641a:	429a      	cmp	r2, r3
  40641c:	d102      	bne.n	406424 <xAreBlockingQueuesStillRunning+0x40>
		{
			xReturn = pdFALSE;
  40641e:	f04f 0300 	mov.w	r3, #0
  406422:	607b      	str	r3, [r7, #4]
		}
		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
  406424:	f24a 6384 	movw	r3, #42628	; 0xa684
  406428:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40642c:	683a      	ldr	r2, [r7, #0]
  40642e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
  406432:	b299      	uxth	r1, r3
  406434:	f24a 6394 	movw	r3, #42644	; 0xa694
  406438:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40643c:	683a      	ldr	r2, [r7, #0]
  40643e:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]


		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
  406442:	f24a 638c 	movw	r3, #42636	; 0xa68c
  406446:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40644a:	683a      	ldr	r2, [r7, #0]
  40644c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
  406450:	b29a      	uxth	r2, r3
  406452:	f24a 639c 	movw	r3, #42652	; 0xa69c
  406456:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40645a:	6839      	ldr	r1, [r7, #0]
  40645c:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
  406460:	b212      	sxth	r2, r2
  406462:	b21b      	sxth	r3, r3
  406464:	429a      	cmp	r2, r3
  406466:	d102      	bne.n	40646e <xAreBlockingQueuesStillRunning+0x8a>
		{
			xReturn = pdFALSE;
  406468:	f04f 0300 	mov.w	r3, #0
  40646c:	607b      	str	r3, [r7, #4]
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
  40646e:	f24a 638c 	movw	r3, #42636	; 0xa68c
  406472:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406476:	683a      	ldr	r2, [r7, #0]
  406478:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
  40647c:	b299      	uxth	r1, r3
  40647e:	f24a 639c 	movw	r3, #42652	; 0xa69c
  406482:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406486:	683a      	ldr	r2, [r7, #0]
  406488:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
	changed or not.

	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
  40648c:	683b      	ldr	r3, [r7, #0]
  40648e:	f103 0301 	add.w	r3, r3, #1
  406492:	603b      	str	r3, [r7, #0]
  406494:	683b      	ldr	r3, [r7, #0]
  406496:	2b02      	cmp	r3, #2
  406498:	ddae      	ble.n	4063f8 <xAreBlockingQueuesStillRunning+0x14>
			xReturn = pdFALSE;
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
	}

	return xReturn;
  40649a:	687b      	ldr	r3, [r7, #4]
}
  40649c:	4618      	mov	r0, r3
  40649e:	f107 070c 	add.w	r7, r7, #12
  4064a2:	46bd      	mov	sp, r7
  4064a4:	bc80      	pop	{r7}
  4064a6:	4770      	bx	lr

004064a8 <vCreateBlockTimeTasks>:
static void vSecondaryBlockTimeTestTask( void *pvParameters );

/*-----------------------------------------------------------*/

void vCreateBlockTimeTasks( void )
{
  4064a8:	b590      	push	{r4, r7, lr}
  4064aa:	b085      	sub	sp, #20
  4064ac:	af04      	add	r7, sp, #16
	/* Create the queue on which the two tasks block. */
    xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
  4064ae:	f04f 0005 	mov.w	r0, #5
  4064b2:	f04f 0104 	mov.w	r1, #4
  4064b6:	f04f 0200 	mov.w	r2, #0
  4064ba:	f243 1311 	movw	r3, #12561	; 0x3111
  4064be:	f2c0 0340 	movt	r3, #64	; 0x40
  4064c2:	4798      	blx	r3
  4064c4:	4602      	mov	r2, r0
  4064c6:	f24a 63a4 	movw	r3, #42660	; 0xa6a4
  4064ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4064ce:	601a      	str	r2, [r3, #0]
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
	defined to be less than 1. */
	vQueueAddToRegistry( xTestQueue, ( signed char * ) "Block_Time_Queue" );

	/* Create the two test tasks. */
	xTaskCreate( vPrimaryBlockTimeTestTask, ( signed char * )"BTest1", configMINIMAL_STACK_SIZE, NULL, bktPRIMARY_PRIORITY, NULL );
  4064d0:	f04f 0302 	mov.w	r3, #2
  4064d4:	9300      	str	r3, [sp, #0]
  4064d6:	f04f 0300 	mov.w	r3, #0
  4064da:	9301      	str	r3, [sp, #4]
  4064dc:	f04f 0300 	mov.w	r3, #0
  4064e0:	9302      	str	r3, [sp, #8]
  4064e2:	f04f 0300 	mov.w	r3, #0
  4064e6:	9303      	str	r3, [sp, #12]
  4064e8:	f246 5051 	movw	r0, #25937	; 0x6551
  4064ec:	f2c0 0040 	movt	r0, #64	; 0x40
  4064f0:	f249 61f8 	movw	r1, #38648	; 0x96f8
  4064f4:	f2c0 0140 	movt	r1, #64	; 0x40
  4064f8:	f04f 0282 	mov.w	r2, #130	; 0x82
  4064fc:	f04f 0300 	mov.w	r3, #0
  406500:	f244 0415 	movw	r4, #16405	; 0x4015
  406504:	f2c0 0440 	movt	r4, #64	; 0x40
  406508:	47a0      	blx	r4
	xTaskCreate( vSecondaryBlockTimeTestTask, ( signed char * )"BTest2", configMINIMAL_STACK_SIZE, NULL, bktSECONDARY_PRIORITY, &xSecondary );
  40650a:	f04f 0301 	mov.w	r3, #1
  40650e:	9300      	str	r3, [sp, #0]
  406510:	f24a 63a8 	movw	r3, #42664	; 0xa6a8
  406514:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406518:	9301      	str	r3, [sp, #4]
  40651a:	f04f 0300 	mov.w	r3, #0
  40651e:	9302      	str	r3, [sp, #8]
  406520:	f04f 0300 	mov.w	r3, #0
  406524:	9303      	str	r3, [sp, #12]
  406526:	f646 2055 	movw	r0, #27221	; 0x6a55
  40652a:	f2c0 0040 	movt	r0, #64	; 0x40
  40652e:	f249 7100 	movw	r1, #38656	; 0x9700
  406532:	f2c0 0140 	movt	r1, #64	; 0x40
  406536:	f04f 0282 	mov.w	r2, #130	; 0x82
  40653a:	f04f 0300 	mov.w	r3, #0
  40653e:	f244 0415 	movw	r4, #16405	; 0x4015
  406542:	f2c0 0440 	movt	r4, #64	; 0x40
  406546:	47a0      	blx	r4
}
  406548:	f107 0704 	add.w	r7, r7, #4
  40654c:	46bd      	mov	sp, r7
  40654e:	bd90      	pop	{r4, r7, pc}

00406550 <vPrimaryBlockTimeTestTask>:
/*-----------------------------------------------------------*/

static void vPrimaryBlockTimeTestTask( void *pvParameters )
{
  406550:	b590      	push	{r4, r7, lr}
  406552:	b089      	sub	sp, #36	; 0x24
  406554:	af00      	add	r7, sp, #0
  406556:	6078      	str	r0, [r7, #4]
	{
		/*********************************************************************
        Test 1

        Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
  406558:	f04f 0300 	mov.w	r3, #0
  40655c:	613b      	str	r3, [r7, #16]
  40655e:	e04b      	b.n	4065f8 <vPrimaryBlockTimeTestTask+0xa8>
		{
			/* The queue is empty. Attempt to read from the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = ( portTickType ) ( bktPRIMARY_BLOCK_TIME << xItem );
  406560:	693b      	ldr	r3, [r7, #16]
  406562:	f04f 020a 	mov.w	r2, #10
  406566:	fa02 f303 	lsl.w	r3, r2, r3
  40656a:	61fb      	str	r3, [r7, #28]

			xTimeWhenBlocking = xTaskGetTickCount();
  40656c:	f644 23c1 	movw	r3, #19137	; 0x4ac1
  406570:	f2c0 0340 	movt	r3, #64	; 0x40
  406574:	4798      	blx	r3
  406576:	61b8      	str	r0, [r7, #24]

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
  406578:	f24a 63a4 	movw	r3, #42660	; 0xa6a4
  40657c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406580:	681a      	ldr	r2, [r3, #0]
  406582:	f107 030c 	add.w	r3, r7, #12
  406586:	4610      	mov	r0, r2
  406588:	4619      	mov	r1, r3
  40658a:	69fa      	ldr	r2, [r7, #28]
  40658c:	f04f 0300 	mov.w	r3, #0
  406590:	f243 7469 	movw	r4, #14185	; 0x3769
  406594:	f2c0 0440 	movt	r4, #64	; 0x40
  406598:	47a0      	blx	r4
  40659a:	4603      	mov	r3, r0
  40659c:	2b00      	cmp	r3, #0
  40659e:	d006      	beq.n	4065ae <vPrimaryBlockTimeTestTask+0x5e>
			{
				xErrorOccurred = pdTRUE;
  4065a0:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  4065a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4065a8:	f04f 0201 	mov.w	r2, #1
  4065ac:	601a      	str	r2, [r3, #0]
			}

			/* How long were we blocked for? */
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
  4065ae:	f644 23c1 	movw	r3, #19137	; 0x4ac1
  4065b2:	f2c0 0340 	movt	r3, #64	; 0x40
  4065b6:	4798      	blx	r3
  4065b8:	4602      	mov	r2, r0
  4065ba:	69bb      	ldr	r3, [r7, #24]
  4065bc:	1ad3      	subs	r3, r2, r3
  4065be:	617b      	str	r3, [r7, #20]

			if( xBlockedTime < xTimeToBlock )
  4065c0:	697a      	ldr	r2, [r7, #20]
  4065c2:	69fb      	ldr	r3, [r7, #28]
  4065c4:	429a      	cmp	r2, r3
  4065c6:	d206      	bcs.n	4065d6 <vPrimaryBlockTimeTestTask+0x86>
			{
				/* Should not have blocked for less than we requested. */
				xErrorOccurred = pdTRUE;
  4065c8:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  4065cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4065d0:	f04f 0201 	mov.w	r2, #1
  4065d4:	601a      	str	r2, [r3, #0]
			}

			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
  4065d6:	69fb      	ldr	r3, [r7, #28]
  4065d8:	f103 020f 	add.w	r2, r3, #15
  4065dc:	697b      	ldr	r3, [r7, #20]
  4065de:	429a      	cmp	r2, r3
  4065e0:	d206      	bcs.n	4065f0 <vPrimaryBlockTimeTestTask+0xa0>
			{
				/* Should not have blocked for longer than we requested,
				although we would not necessarily run as soon as we were
				unblocked so a margin is allowed. */
				xErrorOccurred = pdTRUE;
  4065e2:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  4065e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4065ea:	f04f 0201 	mov.w	r2, #1
  4065ee:	601a      	str	r2, [r3, #0]
	{
		/*********************************************************************
        Test 1

        Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
  4065f0:	693b      	ldr	r3, [r7, #16]
  4065f2:	f103 0301 	add.w	r3, r3, #1
  4065f6:	613b      	str	r3, [r7, #16]
  4065f8:	693b      	ldr	r3, [r7, #16]
  4065fa:	2b04      	cmp	r3, #4
  4065fc:	ddb0      	ble.n	406560 <vPrimaryBlockTimeTestTask+0x10>
        Test 2

        Simple block time wakeup test on queue sends.

		First fill the queue.  It should be empty so all sends should pass. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
  4065fe:	f04f 0300 	mov.w	r3, #0
  406602:	613b      	str	r3, [r7, #16]
  406604:	e01f      	b.n	406646 <vPrimaryBlockTimeTestTask+0xf6>
		{
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
  406606:	f24a 63a4 	movw	r3, #42660	; 0xa6a4
  40660a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40660e:	681a      	ldr	r2, [r3, #0]
  406610:	f107 0310 	add.w	r3, r7, #16
  406614:	4610      	mov	r0, r2
  406616:	4619      	mov	r1, r3
  406618:	f04f 0200 	mov.w	r2, #0
  40661c:	f04f 0300 	mov.w	r3, #0
  406620:	f243 34f1 	movw	r4, #13297	; 0x33f1
  406624:	f2c0 0440 	movt	r4, #64	; 0x40
  406628:	47a0      	blx	r4
  40662a:	4603      	mov	r3, r0
  40662c:	2b01      	cmp	r3, #1
  40662e:	d006      	beq.n	40663e <vPrimaryBlockTimeTestTask+0xee>
			{
				xErrorOccurred = pdTRUE;
  406630:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406634:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406638:	f04f 0201 	mov.w	r2, #1
  40663c:	601a      	str	r2, [r3, #0]
        Test 2

        Simple block time wakeup test on queue sends.

		First fill the queue.  It should be empty so all sends should pass. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
  40663e:	693b      	ldr	r3, [r7, #16]
  406640:	f103 0301 	add.w	r3, r3, #1
  406644:	613b      	str	r3, [r7, #16]
  406646:	693b      	ldr	r3, [r7, #16]
  406648:	2b04      	cmp	r3, #4
  40664a:	dddc      	ble.n	406606 <vPrimaryBlockTimeTestTask+0xb6>
			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
  40664c:	f04f 0300 	mov.w	r3, #0
  406650:	613b      	str	r3, [r7, #16]
  406652:	e04b      	b.n	4066ec <vPrimaryBlockTimeTestTask+0x19c>
		{
			/* The queue is full. Attempt to write to the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = ( portTickType ) ( bktPRIMARY_BLOCK_TIME << xItem );
  406654:	693b      	ldr	r3, [r7, #16]
  406656:	f04f 020a 	mov.w	r2, #10
  40665a:	fa02 f303 	lsl.w	r3, r2, r3
  40665e:	61fb      	str	r3, [r7, #28]

			xTimeWhenBlocking = xTaskGetTickCount();
  406660:	f644 23c1 	movw	r3, #19137	; 0x4ac1
  406664:	f2c0 0340 	movt	r3, #64	; 0x40
  406668:	4798      	blx	r3
  40666a:	61b8      	str	r0, [r7, #24]

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
  40666c:	f24a 63a4 	movw	r3, #42660	; 0xa6a4
  406670:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406674:	681a      	ldr	r2, [r3, #0]
  406676:	f107 0310 	add.w	r3, r7, #16
  40667a:	4610      	mov	r0, r2
  40667c:	4619      	mov	r1, r3
  40667e:	69fa      	ldr	r2, [r7, #28]
  406680:	f04f 0300 	mov.w	r3, #0
  406684:	f243 34f1 	movw	r4, #13297	; 0x33f1
  406688:	f2c0 0440 	movt	r4, #64	; 0x40
  40668c:	47a0      	blx	r4
  40668e:	4603      	mov	r3, r0
  406690:	2b00      	cmp	r3, #0
  406692:	d006      	beq.n	4066a2 <vPrimaryBlockTimeTestTask+0x152>
			{
				xErrorOccurred = pdTRUE;
  406694:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406698:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40669c:	f04f 0201 	mov.w	r2, #1
  4066a0:	601a      	str	r2, [r3, #0]
			}

			/* How long were we blocked for? */
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
  4066a2:	f644 23c1 	movw	r3, #19137	; 0x4ac1
  4066a6:	f2c0 0340 	movt	r3, #64	; 0x40
  4066aa:	4798      	blx	r3
  4066ac:	4602      	mov	r2, r0
  4066ae:	69bb      	ldr	r3, [r7, #24]
  4066b0:	1ad3      	subs	r3, r2, r3
  4066b2:	617b      	str	r3, [r7, #20]

			if( xBlockedTime < xTimeToBlock )
  4066b4:	697a      	ldr	r2, [r7, #20]
  4066b6:	69fb      	ldr	r3, [r7, #28]
  4066b8:	429a      	cmp	r2, r3
  4066ba:	d206      	bcs.n	4066ca <vPrimaryBlockTimeTestTask+0x17a>
			{
				/* Should not have blocked for less than we requested. */
				xErrorOccurred = pdTRUE;
  4066bc:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  4066c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4066c4:	f04f 0201 	mov.w	r2, #1
  4066c8:	601a      	str	r2, [r3, #0]
			}

			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
  4066ca:	69fb      	ldr	r3, [r7, #28]
  4066cc:	f103 020f 	add.w	r2, r3, #15
  4066d0:	697b      	ldr	r3, [r7, #20]
  4066d2:	429a      	cmp	r2, r3
  4066d4:	d206      	bcs.n	4066e4 <vPrimaryBlockTimeTestTask+0x194>
			{
				/* Should not have blocked for longer than we requested,
				although we would not necessarily run as soon as we were
				unblocked so a margin is allowed. */
				xErrorOccurred = pdTRUE;
  4066d6:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  4066da:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4066de:	f04f 0201 	mov.w	r2, #1
  4066e2:	601a      	str	r2, [r3, #0]
			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
  4066e4:	693b      	ldr	r3, [r7, #16]
  4066e6:	f103 0301 	add.w	r3, r3, #1
  4066ea:	613b      	str	r3, [r7, #16]
  4066ec:	693b      	ldr	r3, [r7, #16]
  4066ee:	2b04      	cmp	r3, #4
  4066f0:	ddb0      	ble.n	406654 <vPrimaryBlockTimeTestTask+0x104>
		recognise that its block time has not expired and return to block for
		the remains of its block time.

		Wake the other task so it blocks attempting to post to the already
		full queue. */
		xRunIndicator = 0;
  4066f2:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  4066f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4066fa:	f04f 0200 	mov.w	r2, #0
  4066fe:	601a      	str	r2, [r3, #0]
		vTaskResume( xSecondary );
  406700:	f24a 63a8 	movw	r3, #42664	; 0xa6a8
  406704:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406708:	681b      	ldr	r3, [r3, #0]
  40670a:	4618      	mov	r0, r3
  40670c:	f244 736d 	movw	r3, #18285	; 0x476d
  406710:	f2c0 0340 	movt	r3, #64	; 0x40
  406714:	4798      	blx	r3

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
  406716:	e006      	b.n	406726 <vPrimaryBlockTimeTestTask+0x1d6>
		{
			/* The other task has not yet executed. */
			vTaskDelay( bktSHORT_WAIT );
  406718:	f04f 0014 	mov.w	r0, #20
  40671c:	f244 332d 	movw	r3, #17197	; 0x432d
  406720:	f2c0 0340 	movt	r3, #64	; 0x40
  406724:	4798      	blx	r3
		full queue. */
		xRunIndicator = 0;
		vTaskResume( xSecondary );

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
  406726:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  40672a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40672e:	681b      	ldr	r3, [r3, #0]
  406730:	2b55      	cmp	r3, #85	; 0x55
  406732:	d1f1      	bne.n	406718 <vPrimaryBlockTimeTestTask+0x1c8>
		{
			/* The other task has not yet executed. */
			vTaskDelay( bktSHORT_WAIT );
		}
		/* Make sure the other task is blocked on the queue. */
		vTaskDelay( bktSHORT_WAIT );
  406734:	f04f 0014 	mov.w	r0, #20
  406738:	f244 332d 	movw	r3, #17197	; 0x432d
  40673c:	f2c0 0340 	movt	r3, #64	; 0x40
  406740:	4798      	blx	r3
		xRunIndicator = 0;
  406742:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  406746:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40674a:	f04f 0200 	mov.w	r2, #0
  40674e:	601a      	str	r2, [r3, #0]

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
  406750:	f04f 0300 	mov.w	r3, #0
  406754:	613b      	str	r3, [r7, #16]
  406756:	e071      	b.n	40683c <vPrimaryBlockTimeTestTask+0x2ec>
		{
			/* Now when we make space on the queue the other task should wake
			but not execute as this task has higher priority. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
  406758:	f24a 63a4 	movw	r3, #42660	; 0xa6a4
  40675c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406760:	681a      	ldr	r2, [r3, #0]
  406762:	f107 030c 	add.w	r3, r7, #12
  406766:	4610      	mov	r0, r2
  406768:	4619      	mov	r1, r3
  40676a:	f04f 0200 	mov.w	r2, #0
  40676e:	f04f 0300 	mov.w	r3, #0
  406772:	f243 7469 	movw	r4, #14185	; 0x3769
  406776:	f2c0 0440 	movt	r4, #64	; 0x40
  40677a:	47a0      	blx	r4
  40677c:	4603      	mov	r3, r0
  40677e:	2b01      	cmp	r3, #1
  406780:	d006      	beq.n	406790 <vPrimaryBlockTimeTestTask+0x240>
			{
				xErrorOccurred = pdTRUE;
  406782:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406786:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40678a:	f04f 0201 	mov.w	r2, #1
  40678e:	601a      	str	r2, [r3, #0]
			}

			/* Now fill the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			full ourselves, and the other task have set xRunIndicator. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
  406790:	f24a 63a4 	movw	r3, #42660	; 0xa6a4
  406794:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406798:	681a      	ldr	r2, [r3, #0]
  40679a:	f107 0310 	add.w	r3, r7, #16
  40679e:	4610      	mov	r0, r2
  4067a0:	4619      	mov	r1, r3
  4067a2:	f04f 0200 	mov.w	r2, #0
  4067a6:	f04f 0300 	mov.w	r3, #0
  4067aa:	f243 34f1 	movw	r4, #13297	; 0x33f1
  4067ae:	f2c0 0440 	movt	r4, #64	; 0x40
  4067b2:	47a0      	blx	r4
  4067b4:	4603      	mov	r3, r0
  4067b6:	2b01      	cmp	r3, #1
  4067b8:	d006      	beq.n	4067c8 <vPrimaryBlockTimeTestTask+0x278>
			{
				xErrorOccurred = pdTRUE;
  4067ba:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  4067be:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4067c2:	f04f 0201 	mov.w	r2, #1
  4067c6:	601a      	str	r2, [r3, #0]
			}

			if( xRunIndicator == bktRUN_INDICATOR )
  4067c8:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  4067cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4067d0:	681b      	ldr	r3, [r3, #0]
  4067d2:	2b55      	cmp	r3, #85	; 0x55
  4067d4:	d106      	bne.n	4067e4 <vPrimaryBlockTimeTestTask+0x294>
			{
				/* The other task should not have executed. */
				xErrorOccurred = pdTRUE;
  4067d6:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  4067da:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4067de:	f04f 0201 	mov.w	r2, #1
  4067e2:	601a      	str	r2, [r3, #0]
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
  4067e4:	f24a 63a8 	movw	r3, #42664	; 0xa6a8
  4067e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4067ec:	681b      	ldr	r3, [r3, #0]
  4067ee:	4618      	mov	r0, r3
  4067f0:	f04f 0104 	mov.w	r1, #4
  4067f4:	f244 431d 	movw	r3, #17437	; 0x441d
  4067f8:	f2c0 0340 	movt	r3, #64	; 0x40
  4067fc:	4798      	blx	r3

			/* The other task should now have re-blocked without exiting the
			queue function. */
			if( xRunIndicator == bktRUN_INDICATOR )
  4067fe:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  406802:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406806:	681b      	ldr	r3, [r3, #0]
  406808:	2b55      	cmp	r3, #85	; 0x55
  40680a:	d106      	bne.n	40681a <vPrimaryBlockTimeTestTask+0x2ca>
			{
				/* The other task should not have executed outside of the
				queue function. */
				xErrorOccurred = pdTRUE;
  40680c:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406810:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406814:	f04f 0201 	mov.w	r2, #1
  406818:	601a      	str	r2, [r3, #0]
			}

			/* Set the priority back down. */
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
  40681a:	f24a 63a8 	movw	r3, #42664	; 0xa6a8
  40681e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406822:	681b      	ldr	r3, [r3, #0]
  406824:	4618      	mov	r0, r3
  406826:	f04f 0101 	mov.w	r1, #1
  40682a:	f244 431d 	movw	r3, #17437	; 0x441d
  40682e:	f2c0 0340 	movt	r3, #64	; 0x40
  406832:	4798      	blx	r3
		}
		/* Make sure the other task is blocked on the queue. */
		vTaskDelay( bktSHORT_WAIT );
		xRunIndicator = 0;

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
  406834:	693b      	ldr	r3, [r7, #16]
  406836:	f103 0301 	add.w	r3, r3, #1
  40683a:	613b      	str	r3, [r7, #16]
  40683c:	693b      	ldr	r3, [r7, #16]
  40683e:	2b04      	cmp	r3, #4
  406840:	dd8a      	ble.n	406758 <vPrimaryBlockTimeTestTask+0x208>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
  406842:	e006      	b.n	406852 <vPrimaryBlockTimeTestTask+0x302>
		{
			vTaskDelay( bktSHORT_WAIT );
  406844:	f04f 0014 	mov.w	r0, #20
  406848:	f244 332d 	movw	r3, #17197	; 0x432d
  40684c:	f2c0 0340 	movt	r3, #64	; 0x40
  406850:	4798      	blx	r3
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
  406852:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  406856:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40685a:	681b      	ldr	r3, [r3, #0]
  40685c:	2b55      	cmp	r3, #85	; 0x55
  40685e:	d1f1      	bne.n	406844 <vPrimaryBlockTimeTestTask+0x2f4>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
  406860:	f04f 0014 	mov.w	r0, #20
  406864:	f244 332d 	movw	r3, #17197	; 0x432d
  406868:	f2c0 0340 	movt	r3, #64	; 0x40
  40686c:	4798      	blx	r3
		xRunIndicator = 0;
  40686e:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  406872:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406876:	f04f 0200 	mov.w	r2, #0
  40687a:	601a      	str	r2, [r3, #0]

		As per test 3 - but with the send and receive the other way around.
		The other task blocks attempting to read from the queue.

		Empty the queue.  We should find that it is full. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
  40687c:	f04f 0300 	mov.w	r3, #0
  406880:	613b      	str	r3, [r7, #16]
  406882:	e01f      	b.n	4068c4 <vPrimaryBlockTimeTestTask+0x374>
		{
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
  406884:	f24a 63a4 	movw	r3, #42660	; 0xa6a4
  406888:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40688c:	681a      	ldr	r2, [r3, #0]
  40688e:	f107 030c 	add.w	r3, r7, #12
  406892:	4610      	mov	r0, r2
  406894:	4619      	mov	r1, r3
  406896:	f04f 0200 	mov.w	r2, #0
  40689a:	f04f 0300 	mov.w	r3, #0
  40689e:	f243 7469 	movw	r4, #14185	; 0x3769
  4068a2:	f2c0 0440 	movt	r4, #64	; 0x40
  4068a6:	47a0      	blx	r4
  4068a8:	4603      	mov	r3, r0
  4068aa:	2b01      	cmp	r3, #1
  4068ac:	d006      	beq.n	4068bc <vPrimaryBlockTimeTestTask+0x36c>
			{
				xErrorOccurred = pdTRUE;
  4068ae:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  4068b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4068b6:	f04f 0201 	mov.w	r2, #1
  4068ba:	601a      	str	r2, [r3, #0]

		As per test 3 - but with the send and receive the other way around.
		The other task blocks attempting to read from the queue.

		Empty the queue.  We should find that it is full. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
  4068bc:	693b      	ldr	r3, [r7, #16]
  4068be:	f103 0301 	add.w	r3, r3, #1
  4068c2:	613b      	str	r3, [r7, #16]
  4068c4:	693b      	ldr	r3, [r7, #16]
  4068c6:	2b04      	cmp	r3, #4
  4068c8:	dddc      	ble.n	406884 <vPrimaryBlockTimeTestTask+0x334>
			}
		}

		/* Wake the other task so it blocks attempting to read from  the
		already	empty queue. */
		vTaskResume( xSecondary );
  4068ca:	f24a 63a8 	movw	r3, #42664	; 0xa6a8
  4068ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4068d2:	681b      	ldr	r3, [r3, #0]
  4068d4:	4618      	mov	r0, r3
  4068d6:	f244 736d 	movw	r3, #18285	; 0x476d
  4068da:	f2c0 0340 	movt	r3, #64	; 0x40
  4068de:	4798      	blx	r3

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
  4068e0:	e006      	b.n	4068f0 <vPrimaryBlockTimeTestTask+0x3a0>
		{
			vTaskDelay( bktSHORT_WAIT );
  4068e2:	f04f 0014 	mov.w	r0, #20
  4068e6:	f244 332d 	movw	r3, #17197	; 0x432d
  4068ea:	f2c0 0340 	movt	r3, #64	; 0x40
  4068ee:	4798      	blx	r3
		/* Wake the other task so it blocks attempting to read from  the
		already	empty queue. */
		vTaskResume( xSecondary );

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
  4068f0:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  4068f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4068f8:	681b      	ldr	r3, [r3, #0]
  4068fa:	2b55      	cmp	r3, #85	; 0x55
  4068fc:	d1f1      	bne.n	4068e2 <vPrimaryBlockTimeTestTask+0x392>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
  4068fe:	f04f 0014 	mov.w	r0, #20
  406902:	f244 332d 	movw	r3, #17197	; 0x432d
  406906:	f2c0 0340 	movt	r3, #64	; 0x40
  40690a:	4798      	blx	r3
		xRunIndicator = 0;
  40690c:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  406910:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406914:	f04f 0200 	mov.w	r2, #0
  406918:	601a      	str	r2, [r3, #0]

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
  40691a:	f04f 0300 	mov.w	r3, #0
  40691e:	613b      	str	r3, [r7, #16]
  406920:	e071      	b.n	406a06 <vPrimaryBlockTimeTestTask+0x4b6>
		{
			/* Now when we place an item on the queue the other task should
			wake but not execute as this task has higher priority. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
  406922:	f24a 63a4 	movw	r3, #42660	; 0xa6a4
  406926:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40692a:	681a      	ldr	r2, [r3, #0]
  40692c:	f107 0310 	add.w	r3, r7, #16
  406930:	4610      	mov	r0, r2
  406932:	4619      	mov	r1, r3
  406934:	f04f 0200 	mov.w	r2, #0
  406938:	f04f 0300 	mov.w	r3, #0
  40693c:	f243 34f1 	movw	r4, #13297	; 0x33f1
  406940:	f2c0 0440 	movt	r4, #64	; 0x40
  406944:	47a0      	blx	r4
  406946:	4603      	mov	r3, r0
  406948:	2b01      	cmp	r3, #1
  40694a:	d006      	beq.n	40695a <vPrimaryBlockTimeTestTask+0x40a>
			{
				xErrorOccurred = pdTRUE;
  40694c:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406950:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406954:	f04f 0201 	mov.w	r2, #1
  406958:	601a      	str	r2, [r3, #0]
			}

			/* Now empty the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			empty ourselves, and the other task would be suspended. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
  40695a:	f24a 63a4 	movw	r3, #42660	; 0xa6a4
  40695e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406962:	681a      	ldr	r2, [r3, #0]
  406964:	f107 030c 	add.w	r3, r7, #12
  406968:	4610      	mov	r0, r2
  40696a:	4619      	mov	r1, r3
  40696c:	f04f 0200 	mov.w	r2, #0
  406970:	f04f 0300 	mov.w	r3, #0
  406974:	f243 7469 	movw	r4, #14185	; 0x3769
  406978:	f2c0 0440 	movt	r4, #64	; 0x40
  40697c:	47a0      	blx	r4
  40697e:	4603      	mov	r3, r0
  406980:	2b01      	cmp	r3, #1
  406982:	d006      	beq.n	406992 <vPrimaryBlockTimeTestTask+0x442>
			{
				xErrorOccurred = pdTRUE;
  406984:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406988:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40698c:	f04f 0201 	mov.w	r2, #1
  406990:	601a      	str	r2, [r3, #0]
			}

			if( xRunIndicator == bktRUN_INDICATOR )
  406992:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  406996:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40699a:	681b      	ldr	r3, [r3, #0]
  40699c:	2b55      	cmp	r3, #85	; 0x55
  40699e:	d106      	bne.n	4069ae <vPrimaryBlockTimeTestTask+0x45e>
			{
				/* The other task should not have executed. */
				xErrorOccurred = pdTRUE;
  4069a0:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  4069a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4069a8:	f04f 0201 	mov.w	r2, #1
  4069ac:	601a      	str	r2, [r3, #0]
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
  4069ae:	f24a 63a8 	movw	r3, #42664	; 0xa6a8
  4069b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4069b6:	681b      	ldr	r3, [r3, #0]
  4069b8:	4618      	mov	r0, r3
  4069ba:	f04f 0104 	mov.w	r1, #4
  4069be:	f244 431d 	movw	r3, #17437	; 0x441d
  4069c2:	f2c0 0340 	movt	r3, #64	; 0x40
  4069c6:	4798      	blx	r3

			/* The other task should now have re-blocked without exiting the
			queue function. */
			if( xRunIndicator == bktRUN_INDICATOR )
  4069c8:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  4069cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4069d0:	681b      	ldr	r3, [r3, #0]
  4069d2:	2b55      	cmp	r3, #85	; 0x55
  4069d4:	d106      	bne.n	4069e4 <vPrimaryBlockTimeTestTask+0x494>
			{
				/* The other task should not have executed outside of the
				queue function. */
				xErrorOccurred = pdTRUE;
  4069d6:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  4069da:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4069de:	f04f 0201 	mov.w	r2, #1
  4069e2:	601a      	str	r2, [r3, #0]
			}
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
  4069e4:	f24a 63a8 	movw	r3, #42664	; 0xa6a8
  4069e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4069ec:	681b      	ldr	r3, [r3, #0]
  4069ee:	4618      	mov	r0, r3
  4069f0:	f04f 0101 	mov.w	r1, #1
  4069f4:	f244 431d 	movw	r3, #17437	; 0x441d
  4069f8:	f2c0 0340 	movt	r3, #64	; 0x40
  4069fc:	4798      	blx	r3
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
		xRunIndicator = 0;

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
  4069fe:	693b      	ldr	r3, [r7, #16]
  406a00:	f103 0301 	add.w	r3, r3, #1
  406a04:	613b      	str	r3, [r7, #16]
  406a06:	693b      	ldr	r3, [r7, #16]
  406a08:	2b04      	cmp	r3, #4
  406a0a:	dd8a      	ble.n	406922 <vPrimaryBlockTimeTestTask+0x3d2>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
  406a0c:	e006      	b.n	406a1c <vPrimaryBlockTimeTestTask+0x4cc>
		{
			vTaskDelay( bktSHORT_WAIT );
  406a0e:	f04f 0014 	mov.w	r0, #20
  406a12:	f244 332d 	movw	r3, #17197	; 0x432d
  406a16:	f2c0 0340 	movt	r3, #64	; 0x40
  406a1a:	4798      	blx	r3
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
  406a1c:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  406a20:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406a24:	681b      	ldr	r3, [r3, #0]
  406a26:	2b55      	cmp	r3, #85	; 0x55
  406a28:	d1f1      	bne.n	406a0e <vPrimaryBlockTimeTestTask+0x4be>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
  406a2a:	f04f 0014 	mov.w	r0, #20
  406a2e:	f244 332d 	movw	r3, #17197	; 0x432d
  406a32:	f2c0 0340 	movt	r3, #64	; 0x40
  406a36:	4798      	blx	r3

		xPrimaryCycles++;
  406a38:	f24a 63ac 	movw	r3, #42668	; 0xa6ac
  406a3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406a40:	681b      	ldr	r3, [r3, #0]
  406a42:	f103 0201 	add.w	r2, r3, #1
  406a46:	f24a 63ac 	movw	r3, #42668	; 0xa6ac
  406a4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406a4e:	601a      	str	r2, [r3, #0]
	}
  406a50:	e582      	b.n	406558 <vPrimaryBlockTimeTestTask+0x8>
  406a52:	bf00      	nop

00406a54 <vSecondaryBlockTimeTestTask>:
}
/*-----------------------------------------------------------*/

static void vSecondaryBlockTimeTestTask( void *pvParameters )
{
  406a54:	b590      	push	{r4, r7, lr}
  406a56:	b087      	sub	sp, #28
  406a58:	af00      	add	r7, sp, #0
  406a5a:	6078      	str	r0, [r7, #4]
	{
		/*********************************************************************
        Test 1 and 2

		This task does does not participate in these tests. */
		vTaskSuspend( NULL );
  406a5c:	f04f 0000 	mov.w	r0, #0
  406a60:	f244 53c9 	movw	r3, #17865	; 0x45c9
  406a64:	f2c0 0340 	movt	r3, #64	; 0x40
  406a68:	4798      	blx	r3
        Test 3

		The first thing we do is attempt to read from the queue.  It should be
		full so we block.  Note the time before we block so we can check the
		wake time is as per that expected. */
		xTimeWhenBlocking = xTaskGetTickCount();
  406a6a:	f644 23c1 	movw	r3, #19137	; 0x4ac1
  406a6e:	f2c0 0340 	movt	r3, #64	; 0x40
  406a72:	4798      	blx	r3
  406a74:	6178      	str	r0, [r7, #20]

		/* We should unblock after bktTIME_TO_BLOCK having not sent
		anything to the queue. */
		xData = 0;
  406a76:	f04f 0300 	mov.w	r3, #0
  406a7a:	60fb      	str	r3, [r7, #12]
		xRunIndicator = bktRUN_INDICATOR;
  406a7c:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  406a80:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406a84:	f04f 0255 	mov.w	r2, #85	; 0x55
  406a88:	601a      	str	r2, [r3, #0]
		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
  406a8a:	f24a 63a4 	movw	r3, #42660	; 0xa6a4
  406a8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406a92:	681a      	ldr	r2, [r3, #0]
  406a94:	f107 030c 	add.w	r3, r7, #12
  406a98:	4610      	mov	r0, r2
  406a9a:	4619      	mov	r1, r3
  406a9c:	f04f 02af 	mov.w	r2, #175	; 0xaf
  406aa0:	f04f 0300 	mov.w	r3, #0
  406aa4:	f243 34f1 	movw	r4, #13297	; 0x33f1
  406aa8:	f2c0 0440 	movt	r4, #64	; 0x40
  406aac:	47a0      	blx	r4
  406aae:	4603      	mov	r3, r0
  406ab0:	2b00      	cmp	r3, #0
  406ab2:	d006      	beq.n	406ac2 <vSecondaryBlockTimeTestTask+0x6e>
		{
			xErrorOccurred = pdTRUE;
  406ab4:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406ab8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406abc:	f04f 0201 	mov.w	r2, #1
  406ac0:	601a      	str	r2, [r3, #0]
		}

		/* How long were we inside the send function? */
		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
  406ac2:	f644 23c1 	movw	r3, #19137	; 0x4ac1
  406ac6:	f2c0 0340 	movt	r3, #64	; 0x40
  406aca:	4798      	blx	r3
  406acc:	4602      	mov	r2, r0
  406ace:	697b      	ldr	r3, [r7, #20]
  406ad0:	1ad3      	subs	r3, r2, r3
  406ad2:	613b      	str	r3, [r7, #16]

		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
		if( xBlockedTime < bktTIME_TO_BLOCK )
  406ad4:	693b      	ldr	r3, [r7, #16]
  406ad6:	2bae      	cmp	r3, #174	; 0xae
  406ad8:	d806      	bhi.n	406ae8 <vSecondaryBlockTimeTestTask+0x94>
		{
			xErrorOccurred = pdTRUE;
  406ada:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406ade:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406ae2:	f04f 0201 	mov.w	r2, #1
  406ae6:	601a      	str	r2, [r3, #0]
		}

		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
		either.  A margin is permitted as we would not necessarily run as
		soon as we unblocked. */
		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
  406ae8:	693b      	ldr	r3, [r7, #16]
  406aea:	2bbe      	cmp	r3, #190	; 0xbe
  406aec:	d906      	bls.n	406afc <vSecondaryBlockTimeTestTask+0xa8>
		{
			xErrorOccurred = pdTRUE;
  406aee:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406af2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406af6:	f04f 0201 	mov.w	r2, #1
  406afa:	601a      	str	r2, [r3, #0]
		}

		/* Suspend ready for test 3. */
		xRunIndicator = bktRUN_INDICATOR;
  406afc:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  406b00:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406b04:	f04f 0255 	mov.w	r2, #85	; 0x55
  406b08:	601a      	str	r2, [r3, #0]
		vTaskSuspend( NULL );
  406b0a:	f04f 0000 	mov.w	r0, #0
  406b0e:	f244 53c9 	movw	r3, #17865	; 0x45c9
  406b12:	f2c0 0340 	movt	r3, #64	; 0x40
  406b16:	4798      	blx	r3

		/*********************************************************************
        Test 4

		As per test three, but with the send and receive reversed. */
		xTimeWhenBlocking = xTaskGetTickCount();
  406b18:	f644 23c1 	movw	r3, #19137	; 0x4ac1
  406b1c:	f2c0 0340 	movt	r3, #64	; 0x40
  406b20:	4798      	blx	r3
  406b22:	6178      	str	r0, [r7, #20]

		/* We should unblock after bktTIME_TO_BLOCK having not received
		anything on the queue. */
		xRunIndicator = bktRUN_INDICATOR;
  406b24:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  406b28:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406b2c:	f04f 0255 	mov.w	r2, #85	; 0x55
  406b30:	601a      	str	r2, [r3, #0]
		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
  406b32:	f24a 63a4 	movw	r3, #42660	; 0xa6a4
  406b36:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406b3a:	681a      	ldr	r2, [r3, #0]
  406b3c:	f107 030c 	add.w	r3, r7, #12
  406b40:	4610      	mov	r0, r2
  406b42:	4619      	mov	r1, r3
  406b44:	f04f 02af 	mov.w	r2, #175	; 0xaf
  406b48:	f04f 0300 	mov.w	r3, #0
  406b4c:	f243 7469 	movw	r4, #14185	; 0x3769
  406b50:	f2c0 0440 	movt	r4, #64	; 0x40
  406b54:	47a0      	blx	r4
  406b56:	4603      	mov	r3, r0
  406b58:	2b00      	cmp	r3, #0
  406b5a:	d006      	beq.n	406b6a <vSecondaryBlockTimeTestTask+0x116>
		{
			xErrorOccurred = pdTRUE;
  406b5c:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406b60:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406b64:	f04f 0201 	mov.w	r2, #1
  406b68:	601a      	str	r2, [r3, #0]
		}

		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
  406b6a:	f644 23c1 	movw	r3, #19137	; 0x4ac1
  406b6e:	f2c0 0340 	movt	r3, #64	; 0x40
  406b72:	4798      	blx	r3
  406b74:	4602      	mov	r2, r0
  406b76:	697b      	ldr	r3, [r7, #20]
  406b78:	1ad3      	subs	r3, r2, r3
  406b7a:	613b      	str	r3, [r7, #16]

		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
		if( xBlockedTime < bktTIME_TO_BLOCK )
  406b7c:	693b      	ldr	r3, [r7, #16]
  406b7e:	2bae      	cmp	r3, #174	; 0xae
  406b80:	d806      	bhi.n	406b90 <vSecondaryBlockTimeTestTask+0x13c>
		{
			xErrorOccurred = pdTRUE;
  406b82:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406b86:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406b8a:	f04f 0201 	mov.w	r2, #1
  406b8e:	601a      	str	r2, [r3, #0]
		}

		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
		either.  A margin is permitted as we would not necessarily run as soon
		as we unblocked. */
		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
  406b90:	693b      	ldr	r3, [r7, #16]
  406b92:	2bbe      	cmp	r3, #190	; 0xbe
  406b94:	d906      	bls.n	406ba4 <vSecondaryBlockTimeTestTask+0x150>
		{
			xErrorOccurred = pdTRUE;
  406b96:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406b9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406b9e:	f04f 0201 	mov.w	r2, #1
  406ba2:	601a      	str	r2, [r3, #0]
		}

		xRunIndicator = bktRUN_INDICATOR;
  406ba4:	f24a 63b8 	movw	r3, #42680	; 0xa6b8
  406ba8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406bac:	f04f 0255 	mov.w	r2, #85	; 0x55
  406bb0:	601a      	str	r2, [r3, #0]

		xSecondaryCycles++;
  406bb2:	f24a 63b0 	movw	r3, #42672	; 0xa6b0
  406bb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406bba:	681b      	ldr	r3, [r3, #0]
  406bbc:	f103 0201 	add.w	r2, r3, #1
  406bc0:	f24a 63b0 	movw	r3, #42672	; 0xa6b0
  406bc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406bc8:	601a      	str	r2, [r3, #0]
	}
  406bca:	e747      	b.n	406a5c <vSecondaryBlockTimeTestTask+0x8>

00406bcc <xAreBlockTimeTestTasksStillRunning>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xAreBlockTimeTestTasksStillRunning( void )
{
  406bcc:	b480      	push	{r7}
  406bce:	b083      	sub	sp, #12
  406bd0:	af00      	add	r7, sp, #0
static portBASE_TYPE xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
portBASE_TYPE xReturn = pdPASS;
  406bd2:	f04f 0301 	mov.w	r3, #1
  406bd6:	607b      	str	r3, [r7, #4]

	/* Have both tasks performed at least one cycle since this function was
	last called? */
	if( xPrimaryCycles == xLastPrimaryCycleCount )
  406bd8:	f24a 63ac 	movw	r3, #42668	; 0xa6ac
  406bdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406be0:	681a      	ldr	r2, [r3, #0]
  406be2:	f24a 63bc 	movw	r3, #42684	; 0xa6bc
  406be6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406bea:	681b      	ldr	r3, [r3, #0]
  406bec:	429a      	cmp	r2, r3
  406bee:	d102      	bne.n	406bf6 <xAreBlockTimeTestTasksStillRunning+0x2a>
	{
		xReturn = pdFAIL;
  406bf0:	f04f 0300 	mov.w	r3, #0
  406bf4:	607b      	str	r3, [r7, #4]
	}

	if( xSecondaryCycles == xLastSecondaryCycleCount )
  406bf6:	f24a 63b0 	movw	r3, #42672	; 0xa6b0
  406bfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406bfe:	681a      	ldr	r2, [r3, #0]
  406c00:	f24a 63c0 	movw	r3, #42688	; 0xa6c0
  406c04:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406c08:	681b      	ldr	r3, [r3, #0]
  406c0a:	429a      	cmp	r2, r3
  406c0c:	d102      	bne.n	406c14 <xAreBlockTimeTestTasksStillRunning+0x48>
	{
		xReturn = pdFAIL;
  406c0e:	f04f 0300 	mov.w	r3, #0
  406c12:	607b      	str	r3, [r7, #4]
	}

	if( xErrorOccurred == pdTRUE )
  406c14:	f24a 63b4 	movw	r3, #42676	; 0xa6b4
  406c18:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406c1c:	681b      	ldr	r3, [r3, #0]
  406c1e:	2b01      	cmp	r3, #1
  406c20:	d102      	bne.n	406c28 <xAreBlockTimeTestTasksStillRunning+0x5c>
	{
		xReturn = pdFAIL;
  406c22:	f04f 0300 	mov.w	r3, #0
  406c26:	607b      	str	r3, [r7, #4]
	}

	xLastSecondaryCycleCount = xSecondaryCycles;
  406c28:	f24a 63b0 	movw	r3, #42672	; 0xa6b0
  406c2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406c30:	681a      	ldr	r2, [r3, #0]
  406c32:	f24a 63c0 	movw	r3, #42688	; 0xa6c0
  406c36:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406c3a:	601a      	str	r2, [r3, #0]
	xLastPrimaryCycleCount = xPrimaryCycles;
  406c3c:	f24a 63ac 	movw	r3, #42668	; 0xa6ac
  406c40:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406c44:	681a      	ldr	r2, [r3, #0]
  406c46:	f24a 63bc 	movw	r3, #42684	; 0xa6bc
  406c4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406c4e:	601a      	str	r2, [r3, #0]

	return xReturn;
  406c50:	687b      	ldr	r3, [r7, #4]
}
  406c52:	4618      	mov	r0, r3
  406c54:	f107 070c 	add.w	r7, r7, #12
  406c58:	46bd      	mov	sp, r7
  406c5a:	bc80      	pop	{r7}
  406c5c:	4770      	bx	lr
  406c5e:	bf00      	nop

00406c60 <vAltStartComTestTasks>:
static volatile unsigned portBASE_TYPE uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( unsigned portBASE_TYPE uxPriority, unsigned long ulBaudRate, unsigned portBASE_TYPE uxLED )
{
  406c60:	b590      	push	{r4, r7, lr}
  406c62:	b089      	sub	sp, #36	; 0x24
  406c64:	af04      	add	r7, sp, #16
  406c66:	60f8      	str	r0, [r7, #12]
  406c68:	60b9      	str	r1, [r7, #8]
  406c6a:	607a      	str	r2, [r7, #4]
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
  406c6c:	f24a 63c8 	movw	r3, #42696	; 0xa6c8
  406c70:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406c74:	687a      	ldr	r2, [r7, #4]
  406c76:	601a      	str	r2, [r3, #0]
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
  406c78:	68b8      	ldr	r0, [r7, #8]
  406c7a:	f04f 0118 	mov.w	r1, #24
  406c7e:	f241 43bd 	movw	r3, #5309	; 0x14bd
  406c82:	f2c0 0340 	movt	r3, #64	; 0x40
  406c86:	4798      	blx	r3

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, ( signed char * ) "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( xTaskHandle * ) NULL );
  406c88:	68fb      	ldr	r3, [r7, #12]
  406c8a:	f103 33ff 	add.w	r3, r3, #4294967295
  406c8e:	9300      	str	r3, [sp, #0]
  406c90:	f04f 0300 	mov.w	r3, #0
  406c94:	9301      	str	r3, [sp, #4]
  406c96:	f04f 0300 	mov.w	r3, #0
  406c9a:	9302      	str	r3, [sp, #8]
  406c9c:	f04f 0300 	mov.w	r3, #0
  406ca0:	9303      	str	r3, [sp, #12]
  406ca2:	f646 5005 	movw	r0, #27909	; 0x6d05
  406ca6:	f2c0 0040 	movt	r0, #64	; 0x40
  406caa:	f249 7108 	movw	r1, #38664	; 0x9708
  406cae:	f2c0 0140 	movt	r1, #64	; 0x40
  406cb2:	f04f 0282 	mov.w	r2, #130	; 0x82
  406cb6:	f04f 0300 	mov.w	r3, #0
  406cba:	f244 0415 	movw	r4, #16405	; 0x4015
  406cbe:	f2c0 0440 	movt	r4, #64	; 0x40
  406cc2:	47a0      	blx	r4
	xTaskCreate( vComRxTask, ( signed char * ) "COMRx", comSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
  406cc4:	68fb      	ldr	r3, [r7, #12]
  406cc6:	9300      	str	r3, [sp, #0]
  406cc8:	f04f 0300 	mov.w	r3, #0
  406ccc:	9301      	str	r3, [sp, #4]
  406cce:	f04f 0300 	mov.w	r3, #0
  406cd2:	9302      	str	r3, [sp, #8]
  406cd4:	f04f 0300 	mov.w	r3, #0
  406cd8:	9303      	str	r3, [sp, #12]
  406cda:	f646 50c5 	movw	r0, #28101	; 0x6dc5
  406cde:	f2c0 0040 	movt	r0, #64	; 0x40
  406ce2:	f249 7110 	movw	r1, #38672	; 0x9710
  406ce6:	f2c0 0140 	movt	r1, #64	; 0x40
  406cea:	f04f 0282 	mov.w	r2, #130	; 0x82
  406cee:	f04f 0300 	mov.w	r3, #0
  406cf2:	f244 0415 	movw	r4, #16405	; 0x4015
  406cf6:	f2c0 0440 	movt	r4, #64	; 0x40
  406cfa:	47a0      	blx	r4
}
  406cfc:	f107 0714 	add.w	r7, r7, #20
  406d00:	46bd      	mov	sp, r7
  406d02:	bd90      	pop	{r4, r7, pc}

00406d04 <vComTxTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComTxTask, pvParameters )
{
  406d04:	b580      	push	{r7, lr}
  406d06:	b084      	sub	sp, #16
  406d08:	af00      	add	r7, sp, #0
  406d0a:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
  406d0c:	f04f 0341 	mov.w	r3, #65	; 0x41
  406d10:	73fb      	strb	r3, [r7, #15]
  406d12:	e021      	b.n	406d58 <vComTxTask+0x54>
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
  406d14:	f24a 63c4 	movw	r3, #42692	; 0xa6c4
  406d18:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406d1c:	681a      	ldr	r2, [r3, #0]
  406d1e:	f997 300f 	ldrsb.w	r3, [r7, #15]
  406d22:	4610      	mov	r0, r2
  406d24:	4619      	mov	r1, r3
  406d26:	f04f 0200 	mov.w	r2, #0
  406d2a:	f241 6361 	movw	r3, #5729	; 0x1661
  406d2e:	f2c0 0340 	movt	r3, #64	; 0x40
  406d32:	4798      	blx	r3
  406d34:	4603      	mov	r3, r0
  406d36:	2b01      	cmp	r3, #1
  406d38:	d10a      	bne.n	406d50 <vComTxTask+0x4c>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
  406d3a:	f24a 63c8 	movw	r3, #42696	; 0xa6c8
  406d3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406d42:	681b      	ldr	r3, [r3, #0]
  406d44:	4618      	mov	r0, r3
  406d46:	f249 43d1 	movw	r3, #38097	; 0x94d1
  406d4a:	f2c0 0340 	movt	r3, #64	; 0x40
  406d4e:	4798      	blx	r3

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
  406d50:	7bfb      	ldrb	r3, [r7, #15]
  406d52:	f103 0301 	add.w	r3, r3, #1
  406d56:	73fb      	strb	r3, [r7, #15]
  406d58:	f997 300f 	ldrsb.w	r3, [r7, #15]
  406d5c:	2b58      	cmp	r3, #88	; 0x58
  406d5e:	ddd9      	ble.n	406d14 <vComTxTask+0x10>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
  406d60:	f24a 63c8 	movw	r3, #42696	; 0xa6c8
  406d64:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406d68:	681b      	ldr	r3, [r3, #0]
  406d6a:	4618      	mov	r0, r3
  406d6c:	f04f 0100 	mov.w	r1, #0
  406d70:	f249 4341 	movw	r3, #37953	; 0x9441
  406d74:	f2c0 0340 	movt	r3, #64	; 0x40
  406d78:	4798      	blx	r3

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
  406d7a:	f644 23c1 	movw	r3, #19137	; 0x4ac1
  406d7e:	f2c0 0340 	movt	r3, #64	; 0x40
  406d82:	4798      	blx	r3
  406d84:	4603      	mov	r3, r0
  406d86:	f103 0303 	add.w	r3, r3, #3
  406d8a:	60bb      	str	r3, [r7, #8]

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
  406d8c:	68ba      	ldr	r2, [r7, #8]
  406d8e:	f248 13b5 	movw	r3, #33205	; 0x81b5
  406d92:	f6c1 334e 	movt	r3, #6990	; 0x1b4e
  406d96:	fba3 1302 	umull	r1, r3, r3, r2
  406d9a:	ea4f 1313 	mov.w	r3, r3, lsr #4
  406d9e:	f04f 0196 	mov.w	r1, #150	; 0x96
  406da2:	fb01 f303 	mul.w	r3, r1, r3
  406da6:	1ad3      	subs	r3, r2, r3
  406da8:	60bb      	str	r3, [r7, #8]

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
  406daa:	68bb      	ldr	r3, [r7, #8]
  406dac:	2b31      	cmp	r3, #49	; 0x31
  406dae:	d802      	bhi.n	406db6 <vComTxTask+0xb2>
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
  406db0:	f04f 0332 	mov.w	r3, #50	; 0x32
  406db4:	60bb      	str	r3, [r7, #8]
		}

		vTaskDelay( xTimeToWait );
  406db6:	68b8      	ldr	r0, [r7, #8]
  406db8:	f244 332d 	movw	r3, #17197	; 0x432d
  406dbc:	f2c0 0340 	movt	r3, #64	; 0x40
  406dc0:	4798      	blx	r3
	}
  406dc2:	e7a3      	b.n	406d0c <vComTxTask+0x8>

00406dc4 <vComRxTask>:
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
  406dc4:	b580      	push	{r7, lr}
  406dc6:	b086      	sub	sp, #24
  406dc8:	af00      	add	r7, sp, #0
  406dca:	6078      	str	r0, [r7, #4]
signed char cExpectedByte, cByteRxed;
portBASE_TYPE xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
  406dcc:	f04f 0300 	mov.w	r3, #0
  406dd0:	613b      	str	r3, [r7, #16]
  406dd2:	f04f 0300 	mov.w	r3, #0
  406dd6:	60fb      	str	r3, [r7, #12]
  406dd8:	e000      	b.n	406ddc <vComRxTask+0x18>
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
			}
		}
	}
  406dda:	bf00      	nop

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
  406ddc:	f04f 0341 	mov.w	r3, #65	; 0x41
  406de0:	75fb      	strb	r3, [r7, #23]
  406de2:	e02e      	b.n	406e42 <vComRxTask+0x7e>
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
  406de4:	f24a 63c4 	movw	r3, #42692	; 0xa6c4
  406de8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406dec:	681a      	ldr	r2, [r3, #0]
  406dee:	f107 030b 	add.w	r3, r7, #11
  406df2:	4610      	mov	r0, r2
  406df4:	4619      	mov	r1, r3
  406df6:	f64f 72ff 	movw	r2, #65535	; 0xffff
  406dfa:	f241 631d 	movw	r3, #5661	; 0x161d
  406dfe:	f2c0 0340 	movt	r3, #64	; 0x40
  406e02:	4798      	blx	r3
  406e04:	4603      	mov	r3, r0
  406e06:	2b00      	cmp	r3, #0
  406e08:	d017      	beq.n	406e3a <vComRxTask+0x76>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
  406e0a:	7afb      	ldrb	r3, [r7, #11]
  406e0c:	f997 2017 	ldrsb.w	r2, [r7, #23]
  406e10:	b25b      	sxtb	r3, r3
  406e12:	429a      	cmp	r2, r3
  406e14:	d10d      	bne.n	406e32 <vComRxTask+0x6e>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
  406e16:	f24a 63c8 	movw	r3, #42696	; 0xa6c8
  406e1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406e1e:	681b      	ldr	r3, [r3, #0]
  406e20:	f103 0301 	add.w	r3, r3, #1
  406e24:	4618      	mov	r0, r3
  406e26:	f249 43d1 	movw	r3, #38097	; 0x94d1
  406e2a:	f2c0 0340 	movt	r3, #64	; 0x40
  406e2e:	4798      	blx	r3
  406e30:	e003      	b.n	406e3a <vComRxTask+0x76>
				}
				else
				{
					xResyncRequired = pdTRUE;
  406e32:	f04f 0301 	mov.w	r3, #1
  406e36:	613b      	str	r3, [r7, #16]
					break; /*lint !e960 Non-switch break allowed. */
  406e38:	e007      	b.n	406e4a <vComRxTask+0x86>

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
  406e3a:	7dfb      	ldrb	r3, [r7, #23]
  406e3c:	f103 0301 	add.w	r3, r3, #1
  406e40:	75fb      	strb	r3, [r7, #23]
  406e42:	f997 3017 	ldrsb.w	r3, [r7, #23]
  406e46:	2b58      	cmp	r3, #88	; 0x58
  406e48:	ddcc      	ble.n	406de4 <vComRxTask+0x20>
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
  406e4a:	f24a 63c8 	movw	r3, #42696	; 0xa6c8
  406e4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406e52:	681b      	ldr	r3, [r3, #0]
  406e54:	f103 0301 	add.w	r3, r3, #1
  406e58:	4618      	mov	r0, r3
  406e5a:	f04f 0100 	mov.w	r1, #0
  406e5e:	f249 4341 	movw	r3, #37953	; 0x9441
  406e62:	f2c0 0340 	movt	r3, #64	; 0x40
  406e66:	4798      	blx	r3

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
  406e68:	693b      	ldr	r3, [r7, #16]
  406e6a:	2b01      	cmp	r3, #1
  406e6c:	d11c      	bne.n	406ea8 <vComRxTask+0xe4>
		{
			while( cByteRxed != comLAST_BYTE )
  406e6e:	e00f      	b.n	406e90 <vComRxTask+0xcc>
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
  406e70:	f24a 63c4 	movw	r3, #42692	; 0xa6c4
  406e74:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406e78:	681a      	ldr	r2, [r3, #0]
  406e7a:	f107 030b 	add.w	r3, r7, #11
  406e7e:	4610      	mov	r0, r2
  406e80:	4619      	mov	r1, r3
  406e82:	f64f 72ff 	movw	r2, #65535	; 0xffff
  406e86:	f241 631d 	movw	r3, #5661	; 0x161d
  406e8a:	f2c0 0340 	movt	r3, #64	; 0x40
  406e8e:	4798      	blx	r3
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
  406e90:	7afb      	ldrb	r3, [r7, #11]
  406e92:	b25b      	sxtb	r3, r3
  406e94:	2b58      	cmp	r3, #88	; 0x58
  406e96:	d1eb      	bne.n	406e70 <vComRxTask+0xac>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
  406e98:	68fb      	ldr	r3, [r7, #12]
  406e9a:	f103 0301 	add.w	r3, r3, #1
  406e9e:	60fb      	str	r3, [r7, #12]

			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
  406ea0:	f04f 0300 	mov.w	r3, #0
  406ea4:	613b      	str	r3, [r7, #16]
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
			}
		}
	}
  406ea6:	e798      	b.n	406dda <vComRxTask+0x16>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
  406ea8:	68fb      	ldr	r3, [r7, #12]
  406eaa:	2b01      	cmp	r3, #1
  406eac:	dc95      	bgt.n	406dda <vComRxTask+0x16>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
  406eae:	f24a 63cc 	movw	r3, #42700	; 0xa6cc
  406eb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406eb6:	681b      	ldr	r3, [r3, #0]
  406eb8:	f103 0201 	add.w	r2, r3, #1
  406ebc:	f24a 63cc 	movw	r3, #42700	; 0xa6cc
  406ec0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406ec4:	601a      	str	r2, [r3, #0]
			}
		}
	}
  406ec6:	e788      	b.n	406dda <vComRxTask+0x16>

00406ec8 <xAreComTestTasksStillRunning>:
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

portBASE_TYPE xAreComTestTasksStillRunning( void )
{
  406ec8:	b480      	push	{r7}
  406eca:	b083      	sub	sp, #12
  406ecc:	af00      	add	r7, sp, #0
portBASE_TYPE xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
  406ece:	f24a 63cc 	movw	r3, #42700	; 0xa6cc
  406ed2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406ed6:	681b      	ldr	r3, [r3, #0]
  406ed8:	2b00      	cmp	r3, #0
  406eda:	d103      	bne.n	406ee4 <xAreComTestTasksStillRunning+0x1c>
	{
		xReturn = pdFALSE;
  406edc:	f04f 0300 	mov.w	r3, #0
  406ee0:	607b      	str	r3, [r7, #4]
  406ee2:	e002      	b.n	406eea <xAreComTestTasksStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
  406ee4:	f04f 0301 	mov.w	r3, #1
  406ee8:	607b      	str	r3, [r7, #4]
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
  406eea:	f24a 63cc 	movw	r3, #42700	; 0xa6cc
  406eee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406ef2:	f04f 0200 	mov.w	r2, #0
  406ef6:	601a      	str	r2, [r3, #0]

	return xReturn;
  406ef8:	687b      	ldr	r3, [r7, #4]
}
  406efa:	4618      	mov	r0, r3
  406efc:	f107 070c 	add.w	r7, r7, #12
  406f00:	46bd      	mov	sp, r7
  406f02:	bc80      	pop	{r7}
  406f04:	4770      	bx	lr
  406f06:	bf00      	nop

00406f08 <vStartCountingSemaphoreTasks>:
static volatile xCountSemStruct xParameters[ countNUM_TEST_TASKS ];

/*-----------------------------------------------------------*/

void vStartCountingSemaphoreTasks( void )
{
  406f08:	b590      	push	{r4, r7, lr}
  406f0a:	b085      	sub	sp, #20
  406f0c:	af04      	add	r7, sp, #16
	/* Create the semaphores that we are going to use for the test/demo.  The
	first should be created such that it starts at its maximum count value,
	the second should be created such that it starts with a count value of zero. */
	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE );
  406f0e:	f04f 00c8 	mov.w	r0, #200	; 0xc8
  406f12:	f04f 01c8 	mov.w	r1, #200	; 0xc8
  406f16:	f243 3381 	movw	r3, #13185	; 0x3381
  406f1a:	f2c0 0340 	movt	r3, #64	; 0x40
  406f1e:	4798      	blx	r3
  406f20:	4602      	mov	r2, r0
  406f22:	f24a 63d4 	movw	r3, #42708	; 0xa6d4
  406f26:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406f2a:	601a      	str	r2, [r3, #0]
	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
  406f2c:	f24a 63d4 	movw	r3, #42708	; 0xa6d4
  406f30:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406f34:	f04f 02aa 	mov.w	r2, #170	; 0xaa
  406f38:	605a      	str	r2, [r3, #4]
	xParameters[ 0 ].uxLoopCounter = 0;
  406f3a:	f24a 63d4 	movw	r3, #42708	; 0xa6d4
  406f3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406f42:	f04f 0200 	mov.w	r2, #0
  406f46:	609a      	str	r2, [r3, #8]

	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
  406f48:	f04f 00c8 	mov.w	r0, #200	; 0xc8
  406f4c:	f04f 0100 	mov.w	r1, #0
  406f50:	f243 3381 	movw	r3, #13185	; 0x3381
  406f54:	f2c0 0340 	movt	r3, #64	; 0x40
  406f58:	4798      	blx	r3
  406f5a:	4602      	mov	r2, r0
  406f5c:	f24a 63d4 	movw	r3, #42708	; 0xa6d4
  406f60:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406f64:	60da      	str	r2, [r3, #12]
	xParameters[ 1 ].uxExpectedStartCount = 0;
  406f66:	f24a 63d4 	movw	r3, #42708	; 0xa6d4
  406f6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406f6e:	f04f 0200 	mov.w	r2, #0
  406f72:	611a      	str	r2, [r3, #16]
	xParameters[ 1 ].uxLoopCounter = 0;
  406f74:	f24a 63d4 	movw	r3, #42708	; 0xa6d4
  406f78:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406f7c:	f04f 0200 	mov.w	r2, #0
  406f80:	615a      	str	r2, [r3, #20]
	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 0 ].xSemaphore, ( signed portCHAR * ) "Counting_Sem_1" );
	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 1 ].xSemaphore, ( signed portCHAR * ) "Counting_Sem_2" );


	/* Were the semaphores created? */
	if( ( xParameters[ 0 ].xSemaphore != NULL ) || ( xParameters[ 1 ].xSemaphore != NULL ) )
  406f82:	f24a 63d4 	movw	r3, #42708	; 0xa6d4
  406f86:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406f8a:	681b      	ldr	r3, [r3, #0]
  406f8c:	2b00      	cmp	r3, #0
  406f8e:	d106      	bne.n	406f9e <vStartCountingSemaphoreTasks+0x96>
  406f90:	f24a 63d4 	movw	r3, #42708	; 0xa6d4
  406f94:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406f98:	68db      	ldr	r3, [r3, #12]
  406f9a:	2b00      	cmp	r3, #0
  406f9c:	d03a      	beq.n	407014 <vStartCountingSemaphoreTasks+0x10c>
	{
		/* Create the demo tasks, passing in the semaphore to use as the parameter. */
		xTaskCreate( prvCountingSemaphoreTask, ( signed portCHAR * ) "CNT1", configMINIMAL_STACK_SIZE, ( void * ) &( xParameters[ 0 ] ), tskIDLE_PRIORITY, NULL );
  406f9e:	f04f 0300 	mov.w	r3, #0
  406fa2:	9300      	str	r3, [sp, #0]
  406fa4:	f04f 0300 	mov.w	r3, #0
  406fa8:	9301      	str	r3, [sp, #4]
  406faa:	f04f 0300 	mov.w	r3, #0
  406fae:	9302      	str	r3, [sp, #8]
  406fb0:	f04f 0300 	mov.w	r3, #0
  406fb4:	9303      	str	r3, [sp, #12]
  406fb6:	f247 1091 	movw	r0, #29073	; 0x7191
  406fba:	f2c0 0040 	movt	r0, #64	; 0x40
  406fbe:	f249 7118 	movw	r1, #38680	; 0x9718
  406fc2:	f2c0 0140 	movt	r1, #64	; 0x40
  406fc6:	f04f 0282 	mov.w	r2, #130	; 0x82
  406fca:	f24a 63d4 	movw	r3, #42708	; 0xa6d4
  406fce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  406fd2:	f244 0415 	movw	r4, #16405	; 0x4015
  406fd6:	f2c0 0440 	movt	r4, #64	; 0x40
  406fda:	47a0      	blx	r4
		xTaskCreate( prvCountingSemaphoreTask, ( signed portCHAR * ) "CNT2", configMINIMAL_STACK_SIZE, ( void * ) &( xParameters[ 1 ] ), tskIDLE_PRIORITY, NULL );		
  406fdc:	f04f 0300 	mov.w	r3, #0
  406fe0:	9300      	str	r3, [sp, #0]
  406fe2:	f04f 0300 	mov.w	r3, #0
  406fe6:	9301      	str	r3, [sp, #4]
  406fe8:	f04f 0300 	mov.w	r3, #0
  406fec:	9302      	str	r3, [sp, #8]
  406fee:	f04f 0300 	mov.w	r3, #0
  406ff2:	9303      	str	r3, [sp, #12]
  406ff4:	f247 1091 	movw	r0, #29073	; 0x7191
  406ff8:	f2c0 0040 	movt	r0, #64	; 0x40
  406ffc:	f249 7120 	movw	r1, #38688	; 0x9720
  407000:	f2c0 0140 	movt	r1, #64	; 0x40
  407004:	f04f 0282 	mov.w	r2, #130	; 0x82
  407008:	4b04      	ldr	r3, [pc, #16]	; (40701c <vStartCountingSemaphoreTasks+0x114>)
  40700a:	f244 0415 	movw	r4, #16405	; 0x4015
  40700e:	f2c0 0440 	movt	r4, #64	; 0x40
  407012:	47a0      	blx	r4
	}
}
  407014:	f107 0704 	add.w	r7, r7, #4
  407018:	46bd      	mov	sp, r7
  40701a:	bd90      	pop	{r4, r7, pc}
  40701c:	2000a6e0 	.word	0x2000a6e0

00407020 <prvDecrementSemaphoreCount>:
/*-----------------------------------------------------------*/

static void prvDecrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoopCounter )
{
  407020:	b590      	push	{r4, r7, lr}
  407022:	b085      	sub	sp, #20
  407024:	af00      	add	r7, sp, #0
  407026:	6078      	str	r0, [r7, #4]
  407028:	6039      	str	r1, [r7, #0]
unsigned portBASE_TYPE ux;

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
  40702a:	6878      	ldr	r0, [r7, #4]
  40702c:	f04f 0100 	mov.w	r1, #0
  407030:	f04f 0200 	mov.w	r2, #0
  407034:	f04f 0300 	mov.w	r3, #0
  407038:	f243 34f1 	movw	r4, #13297	; 0x33f1
  40703c:	f2c0 0440 	movt	r4, #64	; 0x40
  407040:	47a0      	blx	r4
  407042:	4603      	mov	r3, r0
  407044:	2b01      	cmp	r3, #1
  407046:	d106      	bne.n	407056 <prvDecrementSemaphoreCount+0x36>
	{
		xErrorDetected = pdTRUE;
  407048:	f24a 63d0 	movw	r3, #42704	; 0xa6d0
  40704c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407050:	f04f 0201 	mov.w	r2, #1
  407054:	601a      	str	r2, [r3, #0]
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
  407056:	f04f 0300 	mov.w	r3, #0
  40705a:	60fb      	str	r3, [r7, #12]
  40705c:	e01f      	b.n	40709e <prvDecrementSemaphoreCount+0x7e>
	{
		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
  40705e:	6878      	ldr	r0, [r7, #4]
  407060:	f04f 0100 	mov.w	r1, #0
  407064:	f04f 0200 	mov.w	r2, #0
  407068:	f04f 0300 	mov.w	r3, #0
  40706c:	f243 7469 	movw	r4, #14185	; 0x3769
  407070:	f2c0 0440 	movt	r4, #64	; 0x40
  407074:	47a0      	blx	r4
  407076:	4603      	mov	r3, r0
  407078:	2b01      	cmp	r3, #1
  40707a:	d006      	beq.n	40708a <prvDecrementSemaphoreCount+0x6a>
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
  40707c:	f24a 63d0 	movw	r3, #42704	; 0xa6d0
  407080:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407084:	f04f 0201 	mov.w	r2, #1
  407088:	601a      	str	r2, [r3, #0]
		}

		( *puxLoopCounter )++;
  40708a:	683b      	ldr	r3, [r7, #0]
  40708c:	681b      	ldr	r3, [r3, #0]
  40708e:	f103 0201 	add.w	r2, r3, #1
  407092:	683b      	ldr	r3, [r7, #0]
  407094:	601a      	str	r2, [r3, #0]
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
  407096:	68fb      	ldr	r3, [r7, #12]
  407098:	f103 0301 	add.w	r3, r3, #1
  40709c:	60fb      	str	r3, [r7, #12]
  40709e:	68fb      	ldr	r3, [r7, #12]
  4070a0:	2bc7      	cmp	r3, #199	; 0xc7
  4070a2:	d9dc      	bls.n	40705e <prvDecrementSemaphoreCount+0x3e>
		taskYIELD();
	#endif

	/* If the semaphore count is zero then we should not be able to	'take' 
	the semaphore. */
	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
  4070a4:	6878      	ldr	r0, [r7, #4]
  4070a6:	f04f 0100 	mov.w	r1, #0
  4070aa:	f04f 0200 	mov.w	r2, #0
  4070ae:	f04f 0300 	mov.w	r3, #0
  4070b2:	f243 7469 	movw	r4, #14185	; 0x3769
  4070b6:	f2c0 0440 	movt	r4, #64	; 0x40
  4070ba:	47a0      	blx	r4
  4070bc:	4603      	mov	r3, r0
  4070be:	2b01      	cmp	r3, #1
  4070c0:	d106      	bne.n	4070d0 <prvDecrementSemaphoreCount+0xb0>
	{
		xErrorDetected = pdTRUE;
  4070c2:	f24a 63d0 	movw	r3, #42704	; 0xa6d0
  4070c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4070ca:	f04f 0201 	mov.w	r2, #1
  4070ce:	601a      	str	r2, [r3, #0]
	}
}
  4070d0:	f107 0714 	add.w	r7, r7, #20
  4070d4:	46bd      	mov	sp, r7
  4070d6:	bd90      	pop	{r4, r7, pc}

004070d8 <prvIncrementSemaphoreCount>:
/*-----------------------------------------------------------*/

static void prvIncrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoopCounter )
{
  4070d8:	b590      	push	{r4, r7, lr}
  4070da:	b085      	sub	sp, #20
  4070dc:	af00      	add	r7, sp, #0
  4070de:	6078      	str	r0, [r7, #4]
  4070e0:	6039      	str	r1, [r7, #0]
unsigned portBASE_TYPE ux;

	/* If the semaphore count is zero then we should not be able to	'take' 
	the semaphore. */
	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
  4070e2:	6878      	ldr	r0, [r7, #4]
  4070e4:	f04f 0100 	mov.w	r1, #0
  4070e8:	f04f 0200 	mov.w	r2, #0
  4070ec:	f04f 0300 	mov.w	r3, #0
  4070f0:	f243 7469 	movw	r4, #14185	; 0x3769
  4070f4:	f2c0 0440 	movt	r4, #64	; 0x40
  4070f8:	47a0      	blx	r4
  4070fa:	4603      	mov	r3, r0
  4070fc:	2b01      	cmp	r3, #1
  4070fe:	d106      	bne.n	40710e <prvIncrementSemaphoreCount+0x36>
	{
		xErrorDetected = pdTRUE;
  407100:	f24a 63d0 	movw	r3, #42704	; 0xa6d0
  407104:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407108:	f04f 0201 	mov.w	r2, #1
  40710c:	601a      	str	r2, [r3, #0]
	}

	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
  40710e:	f04f 0300 	mov.w	r3, #0
  407112:	60fb      	str	r3, [r7, #12]
  407114:	e01f      	b.n	407156 <prvIncrementSemaphoreCount+0x7e>
	{
		if( xSemaphoreGive( xSemaphore ) != pdPASS )
  407116:	6878      	ldr	r0, [r7, #4]
  407118:	f04f 0100 	mov.w	r1, #0
  40711c:	f04f 0200 	mov.w	r2, #0
  407120:	f04f 0300 	mov.w	r3, #0
  407124:	f243 34f1 	movw	r4, #13297	; 0x33f1
  407128:	f2c0 0440 	movt	r4, #64	; 0x40
  40712c:	47a0      	blx	r4
  40712e:	4603      	mov	r3, r0
  407130:	2b01      	cmp	r3, #1
  407132:	d006      	beq.n	407142 <prvIncrementSemaphoreCount+0x6a>
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
  407134:	f24a 63d0 	movw	r3, #42704	; 0xa6d0
  407138:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40713c:	f04f 0201 	mov.w	r2, #1
  407140:	601a      	str	r2, [r3, #0]
		}

		( *puxLoopCounter )++;
  407142:	683b      	ldr	r3, [r7, #0]
  407144:	681b      	ldr	r3, [r3, #0]
  407146:	f103 0201 	add.w	r2, r3, #1
  40714a:	683b      	ldr	r3, [r7, #0]
  40714c:	601a      	str	r2, [r3, #0]
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
  40714e:	68fb      	ldr	r3, [r7, #12]
  407150:	f103 0301 	add.w	r3, r3, #1
  407154:	60fb      	str	r3, [r7, #12]
  407156:	68fb      	ldr	r3, [r7, #12]
  407158:	2bc7      	cmp	r3, #199	; 0xc7
  40715a:	d9dc      	bls.n	407116 <prvIncrementSemaphoreCount+0x3e>
		taskYIELD();
	#endif

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
  40715c:	6878      	ldr	r0, [r7, #4]
  40715e:	f04f 0100 	mov.w	r1, #0
  407162:	f04f 0200 	mov.w	r2, #0
  407166:	f04f 0300 	mov.w	r3, #0
  40716a:	f243 34f1 	movw	r4, #13297	; 0x33f1
  40716e:	f2c0 0440 	movt	r4, #64	; 0x40
  407172:	47a0      	blx	r4
  407174:	4603      	mov	r3, r0
  407176:	2b01      	cmp	r3, #1
  407178:	d106      	bne.n	407188 <prvIncrementSemaphoreCount+0xb0>
	{
		xErrorDetected = pdTRUE;
  40717a:	f24a 63d0 	movw	r3, #42704	; 0xa6d0
  40717e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407182:	f04f 0201 	mov.w	r2, #1
  407186:	601a      	str	r2, [r3, #0]
	}
}
  407188:	f107 0714 	add.w	r7, r7, #20
  40718c:	46bd      	mov	sp, r7
  40718e:	bd90      	pop	{r4, r7, pc}

00407190 <prvCountingSemaphoreTask>:
/*-----------------------------------------------------------*/

static void prvCountingSemaphoreTask( void *pvParameters )
{
  407190:	b590      	push	{r4, r7, lr}
  407192:	b085      	sub	sp, #20
  407194:	af00      	add	r7, sp, #0
  407196:	6078      	str	r0, [r7, #4]
		/* Queue a message for printing to say the task has started. */
		vPrintDisplayMessage( &pcTaskStartMsg );
	#endif

	/* The semaphore to be used was passed as the parameter. */
	pxParameter = ( xCountSemStruct * ) pvParameters;
  407198:	687b      	ldr	r3, [r7, #4]
  40719a:	60fb      	str	r3, [r7, #12]

	/* Did we expect to find the semaphore already at its max count value, or
	at zero? */
	if( pxParameter->uxExpectedStartCount == countSTART_AT_MAX_COUNT )
  40719c:	68fb      	ldr	r3, [r7, #12]
  40719e:	685b      	ldr	r3, [r3, #4]
  4071a0:	2baa      	cmp	r3, #170	; 0xaa
  4071a2:	d10b      	bne.n	4071bc <prvCountingSemaphoreTask+0x2c>
	{
		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
  4071a4:	68fb      	ldr	r3, [r7, #12]
  4071a6:	681a      	ldr	r2, [r3, #0]
  4071a8:	68fb      	ldr	r3, [r7, #12]
  4071aa:	f103 0308 	add.w	r3, r3, #8
  4071ae:	4610      	mov	r0, r2
  4071b0:	4619      	mov	r1, r3
  4071b2:	f247 0321 	movw	r3, #28705	; 0x7021
  4071b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4071ba:	4798      	blx	r3
	}

	/* Now we expect the semaphore count to be 0, so this time there is an
	error if we can take the semaphore. */
	if( xSemaphoreTake( pxParameter->xSemaphore, 0 ) == pdPASS )
  4071bc:	68fb      	ldr	r3, [r7, #12]
  4071be:	681b      	ldr	r3, [r3, #0]
  4071c0:	4618      	mov	r0, r3
  4071c2:	f04f 0100 	mov.w	r1, #0
  4071c6:	f04f 0200 	mov.w	r2, #0
  4071ca:	f04f 0300 	mov.w	r3, #0
  4071ce:	f243 7469 	movw	r4, #14185	; 0x3769
  4071d2:	f2c0 0440 	movt	r4, #64	; 0x40
  4071d6:	47a0      	blx	r4
  4071d8:	4603      	mov	r3, r0
  4071da:	2b01      	cmp	r3, #1
  4071dc:	d106      	bne.n	4071ec <prvCountingSemaphoreTask+0x5c>
	{
		xErrorDetected = pdTRUE;
  4071de:	f24a 63d0 	movw	r3, #42704	; 0xa6d0
  4071e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4071e6:	f04f 0201 	mov.w	r2, #1
  4071ea:	601a      	str	r2, [r3, #0]
	}

	for( ;; )
	{
		prvIncrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
  4071ec:	68fb      	ldr	r3, [r7, #12]
  4071ee:	681a      	ldr	r2, [r3, #0]
  4071f0:	68fb      	ldr	r3, [r7, #12]
  4071f2:	f103 0308 	add.w	r3, r3, #8
  4071f6:	4610      	mov	r0, r2
  4071f8:	4619      	mov	r1, r3
  4071fa:	f247 03d9 	movw	r3, #28889	; 0x70d9
  4071fe:	f2c0 0340 	movt	r3, #64	; 0x40
  407202:	4798      	blx	r3
		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
  407204:	68fb      	ldr	r3, [r7, #12]
  407206:	681a      	ldr	r2, [r3, #0]
  407208:	68fb      	ldr	r3, [r7, #12]
  40720a:	f103 0308 	add.w	r3, r3, #8
  40720e:	4610      	mov	r0, r2
  407210:	4619      	mov	r1, r3
  407212:	f247 0321 	movw	r3, #28705	; 0x7021
  407216:	f2c0 0340 	movt	r3, #64	; 0x40
  40721a:	4798      	blx	r3
	}
  40721c:	e7e6      	b.n	4071ec <prvCountingSemaphoreTask+0x5c>
  40721e:	bf00      	nop

00407220 <vCreateSuicidalTasks>:
xTaskHandle xCreatedTask;

/*-----------------------------------------------------------*/

void vCreateSuicidalTasks( unsigned portBASE_TYPE uxPriority )
{
  407220:	b590      	push	{r4, r7, lr}
  407222:	b089      	sub	sp, #36	; 0x24
  407224:	af04      	add	r7, sp, #16
  407226:	6078      	str	r0, [r7, #4]
unsigned portBASE_TYPE *puxPriority;

	/* Create the Creator tasks - passing in as a parameter the priority at which
	the suicidal tasks should be created. */
	puxPriority = ( unsigned portBASE_TYPE * ) pvPortMalloc( sizeof( unsigned portBASE_TYPE ) );
  407228:	f04f 0004 	mov.w	r0, #4
  40722c:	f240 5345 	movw	r3, #1349	; 0x545
  407230:	f2c0 0340 	movt	r3, #64	; 0x40
  407234:	4798      	blx	r3
  407236:	60f8      	str	r0, [r7, #12]
	*puxPriority = uxPriority;
  407238:	68fb      	ldr	r3, [r7, #12]
  40723a:	687a      	ldr	r2, [r7, #4]
  40723c:	601a      	str	r2, [r3, #0]

	xTaskCreate( vCreateTasks, ( signed char * ) "CREATOR", deathSTACK_SIZE, ( void * ) puxPriority, uxPriority, NULL );
  40723e:	687b      	ldr	r3, [r7, #4]
  407240:	9300      	str	r3, [sp, #0]
  407242:	f04f 0300 	mov.w	r3, #0
  407246:	9301      	str	r3, [sp, #4]
  407248:	f04f 0300 	mov.w	r3, #0
  40724c:	9302      	str	r3, [sp, #8]
  40724e:	f04f 0300 	mov.w	r3, #0
  407252:	9303      	str	r3, [sp, #12]
  407254:	f247 303d 	movw	r0, #29501	; 0x733d
  407258:	f2c0 0040 	movt	r0, #64	; 0x40
  40725c:	f249 712c 	movw	r1, #38700	; 0x972c
  407260:	f2c0 0140 	movt	r1, #64	; 0x40
  407264:	f04f 02be 	mov.w	r2, #190	; 0xbe
  407268:	68fb      	ldr	r3, [r7, #12]
  40726a:	f244 0415 	movw	r4, #16405	; 0x4015
  40726e:	f2c0 0440 	movt	r4, #64	; 0x40
  407272:	47a0      	blx	r4

	/* Record the number of tasks that are running now so we know if any of the
	suicidal tasks have failed to be killed. */
	uxTasksRunningAtStart = ( unsigned portBASE_TYPE ) uxTaskGetNumberOfTasks();
  407274:	f644 23f5 	movw	r3, #19189	; 0x4af5
  407278:	f2c0 0340 	movt	r3, #64	; 0x40
  40727c:	4798      	blx	r3
  40727e:	4602      	mov	r2, r0
  407280:	f24a 63f0 	movw	r3, #42736	; 0xa6f0
  407284:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407288:	601a      	str	r2, [r3, #0]
	/* FreeRTOS.org versions before V3.0 started the idle-task as the very
	first task. The idle task was then already included in uxTasksRunningAtStart.
	From FreeRTOS V3.0 on, the idle task is started when the scheduler is
	started. Therefore the idle task is not yet accounted for. We correct
	this by increasing uxTasksRunningAtStart by 1. */
	uxTasksRunningAtStart++;
  40728a:	f24a 63f0 	movw	r3, #42736	; 0xa6f0
  40728e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407292:	681b      	ldr	r3, [r3, #0]
  407294:	f103 0201 	add.w	r2, r3, #1
  407298:	f24a 63f0 	movw	r3, #42736	; 0xa6f0
  40729c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4072a0:	601a      	str	r2, [r3, #0]
	
	/* From FreeRTOS version 7.0.0 can optionally create a timer service task.  
	If this is done, then uxTasksRunningAtStart needs incrementing again as that
	too is created when the scheduler is started. */
	#if configUSE_TIMERS == 1
		uxTasksRunningAtStart++;
  4072a2:	f24a 63f0 	movw	r3, #42736	; 0xa6f0
  4072a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4072aa:	681b      	ldr	r3, [r3, #0]
  4072ac:	f103 0201 	add.w	r2, r3, #1
  4072b0:	f24a 63f0 	movw	r3, #42736	; 0xa6f0
  4072b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4072b8:	601a      	str	r2, [r3, #0]
	#endif
}
  4072ba:	f107 0714 	add.w	r7, r7, #20
  4072be:	46bd      	mov	sp, r7
  4072c0:	bd90      	pop	{r4, r7, pc}
  4072c2:	bf00      	nop

004072c4 <vSuicidalTask>:
/*-----------------------------------------------------------*/
					
static portTASK_FUNCTION( vSuicidalTask, pvParameters )
{
  4072c4:	b580      	push	{r7, lr}
  4072c6:	b086      	sub	sp, #24
  4072c8:	af00      	add	r7, sp, #0
  4072ca:	6078      	str	r0, [r7, #4]
volatile long l1, l2;
xTaskHandle xTaskToKill;
const portTickType xDelay = ( portTickType ) 200 / portTICK_RATE_MS;
  4072cc:	f04f 03c8 	mov.w	r3, #200	; 0xc8
  4072d0:	613b      	str	r3, [r7, #16]

	if( pvParameters != NULL )
  4072d2:	687b      	ldr	r3, [r7, #4]
  4072d4:	2b00      	cmp	r3, #0
  4072d6:	d003      	beq.n	4072e0 <vSuicidalTask+0x1c>
	{
		/* This task is periodically created four times.  Two created tasks are
		passed a handle to the other task so it can kill it before killing itself.
		The other task is passed in null. */
		xTaskToKill = *( xTaskHandle* )pvParameters;
  4072d8:	687b      	ldr	r3, [r7, #4]
  4072da:	681b      	ldr	r3, [r3, #0]
  4072dc:	617b      	str	r3, [r7, #20]
  4072de:	e004      	b.n	4072ea <vSuicidalTask+0x26>
	}
	else
	{
		xTaskToKill = NULL;
  4072e0:	f04f 0300 	mov.w	r3, #0
  4072e4:	617b      	str	r3, [r7, #20]
  4072e6:	e000      	b.n	4072ea <vSuicidalTask+0x26>
			vTaskDelete( xTaskToKill );

			/* Kill ourselves. */
			vTaskDelete( NULL );
		}
	}
  4072e8:	bf00      	nop
	}

	for( ;; )
	{
		/* Do something random just to use some stack and registers. */
		l1 = 2;
  4072ea:	f04f 0302 	mov.w	r3, #2
  4072ee:	60fb      	str	r3, [r7, #12]
		l2 = 89;
  4072f0:	f04f 0359 	mov.w	r3, #89	; 0x59
  4072f4:	60bb      	str	r3, [r7, #8]
		l2 *= l1;
  4072f6:	68bb      	ldr	r3, [r7, #8]
  4072f8:	68fa      	ldr	r2, [r7, #12]
  4072fa:	fb02 f303 	mul.w	r3, r2, r3
  4072fe:	60bb      	str	r3, [r7, #8]
		vTaskDelay( xDelay );
  407300:	6938      	ldr	r0, [r7, #16]
  407302:	f244 332d 	movw	r3, #17197	; 0x432d
  407306:	f2c0 0340 	movt	r3, #64	; 0x40
  40730a:	4798      	blx	r3

		if( xTaskToKill != NULL )
  40730c:	697b      	ldr	r3, [r7, #20]
  40730e:	2b00      	cmp	r3, #0
  407310:	d0ea      	beq.n	4072e8 <vSuicidalTask+0x24>
		{
			/* Make sure the other task has a go before we delete it. */
			vTaskDelay( ( portTickType ) 0 );
  407312:	f04f 0000 	mov.w	r0, #0
  407316:	f244 332d 	movw	r3, #17197	; 0x432d
  40731a:	f2c0 0340 	movt	r3, #64	; 0x40
  40731e:	4798      	blx	r3

			/* Kill the other task that was created by vCreateTasks(). */
			vTaskDelete( xTaskToKill );
  407320:	6978      	ldr	r0, [r7, #20]
  407322:	f244 2309 	movw	r3, #16905	; 0x4209
  407326:	f2c0 0340 	movt	r3, #64	; 0x40
  40732a:	4798      	blx	r3

			/* Kill ourselves. */
			vTaskDelete( NULL );
  40732c:	f04f 0000 	mov.w	r0, #0
  407330:	f244 2309 	movw	r3, #16905	; 0x4209
  407334:	f2c0 0340 	movt	r3, #64	; 0x40
  407338:	4798      	blx	r3
		}
	}
  40733a:	e7d5      	b.n	4072e8 <vSuicidalTask+0x24>

0040733c <vCreateTasks>:
}/*lint !e818 !e550 Function prototype must be as per standard for task functions. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCreateTasks, pvParameters )
{
  40733c:	b590      	push	{r4, r7, lr}
  40733e:	b089      	sub	sp, #36	; 0x24
  407340:	af04      	add	r7, sp, #16
  407342:	6078      	str	r0, [r7, #4]
const portTickType xDelay = ( portTickType ) 1000 / portTICK_RATE_MS;
  407344:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  407348:	60fb      	str	r3, [r7, #12]
unsigned portBASE_TYPE uxPriority;

	uxPriority = *( unsigned portBASE_TYPE * ) pvParameters;
  40734a:	687b      	ldr	r3, [r7, #4]
  40734c:	681b      	ldr	r3, [r3, #0]
  40734e:	60bb      	str	r3, [r7, #8]
	vPortFree( pvParameters );
  407350:	6878      	ldr	r0, [r7, #4]
  407352:	f240 63c5 	movw	r3, #1733	; 0x6c5
  407356:	f2c0 0340 	movt	r3, #64	; 0x40
  40735a:	4798      	blx	r3

	for( ;; )
	{
		/* Just loop round, delaying then creating the four suicidal tasks. */
		vTaskDelay( xDelay );
  40735c:	68f8      	ldr	r0, [r7, #12]
  40735e:	f244 332d 	movw	r3, #17197	; 0x432d
  407362:	f2c0 0340 	movt	r3, #64	; 0x40
  407366:	4798      	blx	r3

		xCreatedTask = NULL;
  407368:	f24a 73a0 	movw	r3, #42912	; 0xa7a0
  40736c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407370:	f04f 0200 	mov.w	r2, #0
  407374:	601a      	str	r2, [r3, #0]

		xTaskCreate( vSuicidalTask, ( signed char * ) "SUICID1", configMINIMAL_STACK_SIZE, NULL, uxPriority, &xCreatedTask );
  407376:	68bb      	ldr	r3, [r7, #8]
  407378:	9300      	str	r3, [sp, #0]
  40737a:	f24a 73a0 	movw	r3, #42912	; 0xa7a0
  40737e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407382:	9301      	str	r3, [sp, #4]
  407384:	f04f 0300 	mov.w	r3, #0
  407388:	9302      	str	r3, [sp, #8]
  40738a:	f04f 0300 	mov.w	r3, #0
  40738e:	9303      	str	r3, [sp, #12]
  407390:	f247 20c5 	movw	r0, #29381	; 0x72c5
  407394:	f2c0 0040 	movt	r0, #64	; 0x40
  407398:	f249 7134 	movw	r1, #38708	; 0x9734
  40739c:	f2c0 0140 	movt	r1, #64	; 0x40
  4073a0:	f04f 0282 	mov.w	r2, #130	; 0x82
  4073a4:	f04f 0300 	mov.w	r3, #0
  4073a8:	f244 0415 	movw	r4, #16405	; 0x4015
  4073ac:	f2c0 0440 	movt	r4, #64	; 0x40
  4073b0:	47a0      	blx	r4
		xTaskCreate( vSuicidalTask, ( signed char * ) "SUICID2", configMINIMAL_STACK_SIZE, &xCreatedTask, uxPriority, NULL );
  4073b2:	68bb      	ldr	r3, [r7, #8]
  4073b4:	9300      	str	r3, [sp, #0]
  4073b6:	f04f 0300 	mov.w	r3, #0
  4073ba:	9301      	str	r3, [sp, #4]
  4073bc:	f04f 0300 	mov.w	r3, #0
  4073c0:	9302      	str	r3, [sp, #8]
  4073c2:	f04f 0300 	mov.w	r3, #0
  4073c6:	9303      	str	r3, [sp, #12]
  4073c8:	f247 20c5 	movw	r0, #29381	; 0x72c5
  4073cc:	f2c0 0040 	movt	r0, #64	; 0x40
  4073d0:	f249 713c 	movw	r1, #38716	; 0x973c
  4073d4:	f2c0 0140 	movt	r1, #64	; 0x40
  4073d8:	f04f 0282 	mov.w	r2, #130	; 0x82
  4073dc:	f24a 73a0 	movw	r3, #42912	; 0xa7a0
  4073e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4073e4:	f244 0415 	movw	r4, #16405	; 0x4015
  4073e8:	f2c0 0440 	movt	r4, #64	; 0x40
  4073ec:	47a0      	blx	r4

		++usCreationCount;
  4073ee:	f24a 63ec 	movw	r3, #42732	; 0xa6ec
  4073f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4073f6:	881b      	ldrh	r3, [r3, #0]
  4073f8:	b29b      	uxth	r3, r3
  4073fa:	f103 0301 	add.w	r3, r3, #1
  4073fe:	b29a      	uxth	r2, r3
  407400:	f24a 63ec 	movw	r3, #42732	; 0xa6ec
  407404:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407408:	801a      	strh	r2, [r3, #0]
	}
  40740a:	e7a7      	b.n	40735c <vCreateTasks+0x20>

0040740c <xIsCreateTaskStillRunning>:
/*-----------------------------------------------------------*/

/* This is called to check that the creator task is still running and that there
are not any more than four extra tasks. */
portBASE_TYPE xIsCreateTaskStillRunning( void )
{
  40740c:	b580      	push	{r7, lr}
  40740e:	b082      	sub	sp, #8
  407410:	af00      	add	r7, sp, #0
static unsigned short usLastCreationCount = 0xfff;
portBASE_TYPE xReturn = pdTRUE;
  407412:	f04f 0301 	mov.w	r3, #1
  407416:	607b      	str	r3, [r7, #4]
static unsigned portBASE_TYPE uxTasksRunningNow;

	if( usLastCreationCount == usCreationCount )
  407418:	f240 031c 	movw	r3, #28
  40741c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407420:	881a      	ldrh	r2, [r3, #0]
  407422:	f24a 63ec 	movw	r3, #42732	; 0xa6ec
  407426:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40742a:	881b      	ldrh	r3, [r3, #0]
  40742c:	b29b      	uxth	r3, r3
  40742e:	429a      	cmp	r2, r3
  407430:	d103      	bne.n	40743a <xIsCreateTaskStillRunning+0x2e>
	{
		xReturn = pdFALSE;
  407432:	f04f 0300 	mov.w	r3, #0
  407436:	607b      	str	r3, [r7, #4]
  407438:	e00a      	b.n	407450 <xIsCreateTaskStillRunning+0x44>
	}
	else
	{
		usLastCreationCount = usCreationCount;
  40743a:	f24a 63ec 	movw	r3, #42732	; 0xa6ec
  40743e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407442:	881b      	ldrh	r3, [r3, #0]
  407444:	b29a      	uxth	r2, r3
  407446:	f240 031c 	movw	r3, #28
  40744a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40744e:	801a      	strh	r2, [r3, #0]
	}
	
	uxTasksRunningNow = ( unsigned portBASE_TYPE ) uxTaskGetNumberOfTasks();
  407450:	f644 23f5 	movw	r3, #19189	; 0x4af5
  407454:	f2c0 0340 	movt	r3, #64	; 0x40
  407458:	4798      	blx	r3
  40745a:	4602      	mov	r2, r0
  40745c:	f24a 63f4 	movw	r3, #42740	; 0xa6f4
  407460:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407464:	601a      	str	r2, [r3, #0]

	if( uxTasksRunningNow < uxTasksRunningAtStart )
  407466:	f24a 63f4 	movw	r3, #42740	; 0xa6f4
  40746a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40746e:	681a      	ldr	r2, [r3, #0]
  407470:	f24a 63f0 	movw	r3, #42736	; 0xa6f0
  407474:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407478:	681b      	ldr	r3, [r3, #0]
  40747a:	429a      	cmp	r2, r3
  40747c:	d203      	bcs.n	407486 <xIsCreateTaskStillRunning+0x7a>
	{
		xReturn = pdFALSE;
  40747e:	f04f 0300 	mov.w	r3, #0
  407482:	607b      	str	r3, [r7, #4]
  407484:	e014      	b.n	4074b0 <xIsCreateTaskStillRunning+0xa4>
	}
	else if( ( uxTasksRunningNow - uxTasksRunningAtStart ) > uxMaxNumberOfExtraTasksRunning )
  407486:	f24a 63f4 	movw	r3, #42740	; 0xa6f4
  40748a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40748e:	681a      	ldr	r2, [r3, #0]
  407490:	f24a 63f0 	movw	r3, #42736	; 0xa6f0
  407494:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407498:	681b      	ldr	r3, [r3, #0]
  40749a:	1ad2      	subs	r2, r2, r3
  40749c:	f249 7328 	movw	r3, #38696	; 0x9728
  4074a0:	f2c0 0340 	movt	r3, #64	; 0x40
  4074a4:	681b      	ldr	r3, [r3, #0]
  4074a6:	429a      	cmp	r2, r3
  4074a8:	d902      	bls.n	4074b0 <xIsCreateTaskStillRunning+0xa4>
	{
		xReturn = pdFALSE;
  4074aa:	f04f 0300 	mov.w	r3, #0
  4074ae:	607b      	str	r3, [r7, #4]
	else
	{
		/* Everything is okay. */
	}

	return xReturn;
  4074b0:	687b      	ldr	r3, [r7, #4]
}
  4074b2:	4618      	mov	r0, r3
  4074b4:	f107 0708 	add.w	r7, r7, #8
  4074b8:	46bd      	mov	sp, r7
  4074ba:	bd80      	pop	{r7, pc}

004074bc <vStartDynamicPriorityTasks>:
/*
 * Start the three tasks as described at the top of the file.
 * Note that the limited count task is given a higher priority.
 */
void vStartDynamicPriorityTasks( void )
{
  4074bc:	b590      	push	{r4, r7, lr}
  4074be:	b085      	sub	sp, #20
  4074c0:	af04      	add	r7, sp, #16
	xSuspendedTestQueue = xQueueCreate( priSUSPENDED_QUEUE_LENGTH, sizeof( unsigned long ) );
  4074c2:	f04f 0001 	mov.w	r0, #1
  4074c6:	f04f 0104 	mov.w	r1, #4
  4074ca:	f04f 0200 	mov.w	r2, #0
  4074ce:	f243 1311 	movw	r3, #12561	; 0x3111
  4074d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4074d6:	4798      	blx	r3
  4074d8:	4602      	mov	r2, r0
  4074da:	f24a 73a4 	movw	r3, #42916	; 0xa7a4
  4074de:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4074e2:	601a      	str	r2, [r3, #0]
	is not being used.  The call to vQueueAddToRegistry() will be removed
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
	defined to be less than 1. */
	vQueueAddToRegistry( xSuspendedTestQueue, ( signed char * ) "Suspended_Test_Queue" );

	xTaskCreate( vContinuousIncrementTask, ( signed char * ) "CNT_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY, &xContinuousIncrementHandle );
  4074e4:	f04f 0300 	mov.w	r3, #0
  4074e8:	9300      	str	r3, [sp, #0]
  4074ea:	f24a 63f8 	movw	r3, #42744	; 0xa6f8
  4074ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4074f2:	9301      	str	r3, [sp, #4]
  4074f4:	f04f 0300 	mov.w	r3, #0
  4074f8:	9302      	str	r3, [sp, #8]
  4074fa:	f04f 0300 	mov.w	r3, #0
  4074fe:	9303      	str	r3, [sp, #12]
  407500:	f247 6065 	movw	r0, #30309	; 0x7665
  407504:	f2c0 0040 	movt	r0, #64	; 0x40
  407508:	f249 7144 	movw	r1, #38724	; 0x9744
  40750c:	f2c0 0140 	movt	r1, #64	; 0x40
  407510:	f04f 0282 	mov.w	r2, #130	; 0x82
  407514:	f24a 7300 	movw	r3, #42752	; 0xa700
  407518:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40751c:	f244 0415 	movw	r4, #16405	; 0x4015
  407520:	f2c0 0440 	movt	r4, #64	; 0x40
  407524:	47a0      	blx	r4
	xTaskCreate( vLimitedIncrementTask, ( signed char * ) "LIM_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY + 1, &xLimitedIncrementHandle );
  407526:	f04f 0301 	mov.w	r3, #1
  40752a:	9300      	str	r3, [sp, #0]
  40752c:	f24a 63fc 	movw	r3, #42748	; 0xa6fc
  407530:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407534:	9301      	str	r3, [sp, #4]
  407536:	f04f 0300 	mov.w	r3, #0
  40753a:	9302      	str	r3, [sp, #8]
  40753c:	f04f 0300 	mov.w	r3, #0
  407540:	9303      	str	r3, [sp, #12]
  407542:	f247 6021 	movw	r0, #30241	; 0x7621
  407546:	f2c0 0040 	movt	r0, #64	; 0x40
  40754a:	f249 714c 	movw	r1, #38732	; 0x974c
  40754e:	f2c0 0140 	movt	r1, #64	; 0x40
  407552:	f04f 0282 	mov.w	r2, #130	; 0x82
  407556:	f24a 7300 	movw	r3, #42752	; 0xa700
  40755a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40755e:	f244 0415 	movw	r4, #16405	; 0x4015
  407562:	f2c0 0440 	movt	r4, #64	; 0x40
  407566:	47a0      	blx	r4
	xTaskCreate( vCounterControlTask, ( signed char * ) "C_CTRL", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
  407568:	f04f 0300 	mov.w	r3, #0
  40756c:	9300      	str	r3, [sp, #0]
  40756e:	f04f 0300 	mov.w	r3, #0
  407572:	9301      	str	r3, [sp, #4]
  407574:	f04f 0300 	mov.w	r3, #0
  407578:	9302      	str	r3, [sp, #8]
  40757a:	f04f 0300 	mov.w	r3, #0
  40757e:	9303      	str	r3, [sp, #12]
  407580:	f247 7001 	movw	r0, #30465	; 0x7701
  407584:	f2c0 0040 	movt	r0, #64	; 0x40
  407588:	f249 7154 	movw	r1, #38740	; 0x9754
  40758c:	f2c0 0140 	movt	r1, #64	; 0x40
  407590:	f04f 0282 	mov.w	r2, #130	; 0x82
  407594:	f04f 0300 	mov.w	r3, #0
  407598:	f244 0415 	movw	r4, #16405	; 0x4015
  40759c:	f2c0 0440 	movt	r4, #64	; 0x40
  4075a0:	47a0      	blx	r4
	xTaskCreate( vQueueSendWhenSuspendedTask, ( signed char * ) "SUSP_TX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
  4075a2:	f04f 0300 	mov.w	r3, #0
  4075a6:	9300      	str	r3, [sp, #0]
  4075a8:	f04f 0300 	mov.w	r3, #0
  4075ac:	9301      	str	r3, [sp, #4]
  4075ae:	f04f 0300 	mov.w	r3, #0
  4075b2:	9302      	str	r3, [sp, #8]
  4075b4:	f04f 0300 	mov.w	r3, #0
  4075b8:	9303      	str	r3, [sp, #12]
  4075ba:	f647 0045 	movw	r0, #30789	; 0x7845
  4075be:	f2c0 0040 	movt	r0, #64	; 0x40
  4075c2:	f249 715c 	movw	r1, #38748	; 0x975c
  4075c6:	f2c0 0140 	movt	r1, #64	; 0x40
  4075ca:	f04f 0282 	mov.w	r2, #130	; 0x82
  4075ce:	f04f 0300 	mov.w	r3, #0
  4075d2:	f244 0415 	movw	r4, #16405	; 0x4015
  4075d6:	f2c0 0440 	movt	r4, #64	; 0x40
  4075da:	47a0      	blx	r4
	xTaskCreate( vQueueReceiveWhenSuspendedTask, ( signed char * ) "SUSP_RX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
  4075dc:	f04f 0300 	mov.w	r3, #0
  4075e0:	9300      	str	r3, [sp, #0]
  4075e2:	f04f 0300 	mov.w	r3, #0
  4075e6:	9301      	str	r3, [sp, #4]
  4075e8:	f04f 0300 	mov.w	r3, #0
  4075ec:	9302      	str	r3, [sp, #8]
  4075ee:	f04f 0300 	mov.w	r3, #0
  4075f2:	9303      	str	r3, [sp, #12]
  4075f4:	f647 00c5 	movw	r0, #30917	; 0x78c5
  4075f8:	f2c0 0040 	movt	r0, #64	; 0x40
  4075fc:	f249 7164 	movw	r1, #38756	; 0x9764
  407600:	f2c0 0140 	movt	r1, #64	; 0x40
  407604:	f04f 0282 	mov.w	r2, #130	; 0x82
  407608:	f04f 0300 	mov.w	r3, #0
  40760c:	f244 0415 	movw	r4, #16405	; 0x4015
  407610:	f2c0 0440 	movt	r4, #64	; 0x40
  407614:	47a0      	blx	r4
}
  407616:	f107 0704 	add.w	r7, r7, #4
  40761a:	46bd      	mov	sp, r7
  40761c:	bd90      	pop	{r4, r7, pc}
  40761e:	bf00      	nop

00407620 <vLimitedIncrementTask>:
/*
 * Just loops around incrementing the shared variable until the limit has been
 * reached.  Once the limit has been reached it suspends itself.
 */
static portTASK_FUNCTION( vLimitedIncrementTask, pvParameters )
{
  407620:	b580      	push	{r7, lr}
  407622:	b084      	sub	sp, #16
  407624:	af00      	add	r7, sp, #0
  407626:	6078      	str	r0, [r7, #4]
unsigned long *pulCounter;

	/* Take a pointer to the shared variable from the parameters passed into
	the task. */
	pulCounter = ( unsigned long * ) pvParameters;
  407628:	687b      	ldr	r3, [r7, #4]
  40762a:	60fb      	str	r3, [r7, #12]

	/* This will run before the control task, so the first thing it does is
	suspend - the control task will resume it when ready. */
	vTaskSuspend( NULL );
  40762c:	f04f 0000 	mov.w	r0, #0
  407630:	f244 53c9 	movw	r3, #17865	; 0x45c9
  407634:	f2c0 0340 	movt	r3, #64	; 0x40
  407638:	4798      	blx	r3
  40763a:	e000      	b.n	40763e <vLimitedIncrementTask+0x1e>

		if( *pulCounter >= priMAX_COUNT )
		{
			vTaskSuspend( NULL );
		}
	}
  40763c:	bf00      	nop
	vTaskSuspend( NULL );

	for( ;; )
	{
		/* Just count up to a value then suspend. */
		( *pulCounter )++;
  40763e:	68fb      	ldr	r3, [r7, #12]
  407640:	681b      	ldr	r3, [r3, #0]
  407642:	f103 0201 	add.w	r2, r3, #1
  407646:	68fb      	ldr	r3, [r7, #12]
  407648:	601a      	str	r2, [r3, #0]

		if( *pulCounter >= priMAX_COUNT )
  40764a:	68fb      	ldr	r3, [r7, #12]
  40764c:	681b      	ldr	r3, [r3, #0]
  40764e:	2bfe      	cmp	r3, #254	; 0xfe
  407650:	d9f4      	bls.n	40763c <vLimitedIncrementTask+0x1c>
		{
			vTaskSuspend( NULL );
  407652:	f04f 0000 	mov.w	r0, #0
  407656:	f244 53c9 	movw	r3, #17865	; 0x45c9
  40765a:	f2c0 0340 	movt	r3, #64	; 0x40
  40765e:	4798      	blx	r3
		}
	}
  407660:	e7ec      	b.n	40763c <vLimitedIncrementTask+0x1c>
  407662:	bf00      	nop

00407664 <vContinuousIncrementTask>:
/*
 * Just keep counting the shared variable up.  The control task will suspend
 * this task when it wants.
 */
static portTASK_FUNCTION( vContinuousIncrementTask, pvParameters )
{
  407664:	b580      	push	{r7, lr}
  407666:	b084      	sub	sp, #16
  407668:	af00      	add	r7, sp, #0
  40766a:	6078      	str	r0, [r7, #4]
volatile unsigned long *pulCounter;
unsigned portBASE_TYPE uxOurPriority;

	/* Take a pointer to the shared variable from the parameters passed into
	the task. */
	pulCounter = ( unsigned long * ) pvParameters;
  40766c:	687b      	ldr	r3, [r7, #4]
  40766e:	60fb      	str	r3, [r7, #12]

	/* Query our priority so we can raise it when exclusive access to the
	shared variable is required. */
	uxOurPriority = uxTaskPriorityGet( NULL );
  407670:	f04f 0000 	mov.w	r0, #0
  407674:	f244 33d9 	movw	r3, #17369	; 0x43d9
  407678:	f2c0 0340 	movt	r3, #64	; 0x40
  40767c:	4798      	blx	r3
  40767e:	60b8      	str	r0, [r7, #8]
  407680:	e000      	b.n	407684 <vContinuousIncrementTask+0x20>
		#if( configUSE_PREEMPTION == 0 )
			taskYIELD();
		#endif

		configASSERT( ( uxTaskPriorityGet( NULL ) == uxOurPriority ) );
	}
  407682:	bf00      	nop

	for( ;; )
	{
		/* Raise the priority above the controller task to ensure a context
		switch does not occur while the variable is being accessed. */
		vTaskPrioritySet( NULL, uxOurPriority + 1 );
  407684:	68bb      	ldr	r3, [r7, #8]
  407686:	f103 0301 	add.w	r3, r3, #1
  40768a:	f04f 0000 	mov.w	r0, #0
  40768e:	4619      	mov	r1, r3
  407690:	f244 431d 	movw	r3, #17437	; 0x441d
  407694:	f2c0 0340 	movt	r3, #64	; 0x40
  407698:	4798      	blx	r3
		{
			configASSERT( ( uxTaskPriorityGet( NULL ) == ( uxOurPriority + 1 ) ) );
  40769a:	f04f 0000 	mov.w	r0, #0
  40769e:	f244 33d9 	movw	r3, #17369	; 0x43d9
  4076a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4076a6:	4798      	blx	r3
  4076a8:	4602      	mov	r2, r0
  4076aa:	68bb      	ldr	r3, [r7, #8]
  4076ac:	f103 0301 	add.w	r3, r3, #1
  4076b0:	429a      	cmp	r2, r3
  4076b2:	d005      	beq.n	4076c0 <vContinuousIncrementTask+0x5c>
  4076b4:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4076b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4076bc:	4798      	blx	r3
  4076be:	e7fe      	b.n	4076be <vContinuousIncrementTask+0x5a>
			( *pulCounter )++;
  4076c0:	68fb      	ldr	r3, [r7, #12]
  4076c2:	681b      	ldr	r3, [r3, #0]
  4076c4:	f103 0201 	add.w	r2, r3, #1
  4076c8:	68fb      	ldr	r3, [r7, #12]
  4076ca:	601a      	str	r2, [r3, #0]
		}
		vTaskPrioritySet( NULL, uxOurPriority );
  4076cc:	f04f 0000 	mov.w	r0, #0
  4076d0:	68b9      	ldr	r1, [r7, #8]
  4076d2:	f244 431d 	movw	r3, #17437	; 0x441d
  4076d6:	f2c0 0340 	movt	r3, #64	; 0x40
  4076da:	4798      	blx	r3

		#if( configUSE_PREEMPTION == 0 )
			taskYIELD();
		#endif

		configASSERT( ( uxTaskPriorityGet( NULL ) == uxOurPriority ) );
  4076dc:	f04f 0000 	mov.w	r0, #0
  4076e0:	f244 33d9 	movw	r3, #17369	; 0x43d9
  4076e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4076e8:	4798      	blx	r3
  4076ea:	4602      	mov	r2, r0
  4076ec:	68bb      	ldr	r3, [r7, #8]
  4076ee:	429a      	cmp	r2, r3
  4076f0:	d0c7      	beq.n	407682 <vContinuousIncrementTask+0x1e>
  4076f2:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  4076f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4076fa:	4798      	blx	r3
  4076fc:	e7fe      	b.n	4076fc <vContinuousIncrementTask+0x98>
  4076fe:	bf00      	nop

00407700 <vCounterControlTask>:

/*
 * Controller task as described above.
 */
static portTASK_FUNCTION( vCounterControlTask, pvParameters )
{
  407700:	b580      	push	{r7, lr}
  407702:	b084      	sub	sp, #16
  407704:	af00      	add	r7, sp, #0
  407706:	6078      	str	r0, [r7, #4]
unsigned long ulLastCounter;
short sLoops;
short sError = pdFALSE;
  407708:	f04f 0300 	mov.w	r3, #0
  40770c:	81bb      	strh	r3, [r7, #12]
	( void ) pvParameters;

	for( ;; )
	{
		/* Start with the counter at zero. */
		ulCounter = ( unsigned long ) 0;
  40770e:	f24a 7300 	movw	r3, #42752	; 0xa700
  407712:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407716:	f04f 0200 	mov.w	r2, #0
  40771a:	601a      	str	r2, [r3, #0]

		/* First section : */

		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
  40771c:	f04f 0300 	mov.w	r3, #0
  407720:	81fb      	strh	r3, [r7, #14]
  407722:	e03b      	b.n	40779c <vCounterControlTask+0x9c>
		{
			/* Suspend the continuous count task so we can take a mirror of the
			shared variable without risk of corruption.  This is not really
			needed as the other task raises its priority above this task's
			priority. */
			vTaskSuspend( xContinuousIncrementHandle );
  407724:	f24a 63f8 	movw	r3, #42744	; 0xa6f8
  407728:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40772c:	681b      	ldr	r3, [r3, #0]
  40772e:	4618      	mov	r0, r3
  407730:	f244 53c9 	movw	r3, #17865	; 0x45c9
  407734:	f2c0 0340 	movt	r3, #64	; 0x40
  407738:	4798      	blx	r3
				{
					configASSERT( eTaskGetState( xContinuousIncrementHandle ) == eSuspended );
				}
				#endif /* INCLUDE_eTaskGetState */

				ulLastCounter = ulCounter;
  40773a:	f24a 7300 	movw	r3, #42752	; 0xa700
  40773e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407742:	681b      	ldr	r3, [r3, #0]
  407744:	60bb      	str	r3, [r7, #8]
			}
			vTaskResume( xContinuousIncrementHandle );
  407746:	f24a 63f8 	movw	r3, #42744	; 0xa6f8
  40774a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40774e:	681b      	ldr	r3, [r3, #0]
  407750:	4618      	mov	r0, r3
  407752:	f244 736d 	movw	r3, #18285	; 0x476d
  407756:	f2c0 0340 	movt	r3, #64	; 0x40
  40775a:	4798      	blx	r3
				configASSERT( eTaskGetState( xContinuousIncrementHandle ) == eReady );
			}
			#endif /* INCLUDE_eTaskGetState */

			/* Now delay to ensure the other task has processor time. */
			vTaskDelay( priSLEEP_TIME );
  40775c:	f04f 0080 	mov.w	r0, #128	; 0x80
  407760:	f244 332d 	movw	r3, #17197	; 0x432d
  407764:	f2c0 0340 	movt	r3, #64	; 0x40
  407768:	4798      	blx	r3

			/* Check the shared variable again.  This time to ensure mutual
			exclusion the whole scheduler will be locked.  This is just for
			demo purposes! */
			vTaskSuspendAll();
  40776a:	f644 03f9 	movw	r3, #18681	; 0x48f9
  40776e:	f2c0 0340 	movt	r3, #64	; 0x40
  407772:	4798      	blx	r3
			{
				if( ulLastCounter == ulCounter )
  407774:	f24a 7300 	movw	r3, #42752	; 0xa700
  407778:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40777c:	681b      	ldr	r3, [r3, #0]
  40777e:	68ba      	ldr	r2, [r7, #8]
  407780:	429a      	cmp	r2, r3
  407782:	d102      	bne.n	40778a <vCounterControlTask+0x8a>
				{
					/* The shared variable has not changed.  There is a problem
					with the continuous count task so flag an error. */
					sError = pdTRUE;
  407784:	f04f 0301 	mov.w	r3, #1
  407788:	81bb      	strh	r3, [r7, #12]
				}
			}
			xTaskResumeAll();
  40778a:	f644 131d 	movw	r3, #18717	; 0x491d
  40778e:	f2c0 0340 	movt	r3, #64	; 0x40
  407792:	4798      	blx	r3
		ulCounter = ( unsigned long ) 0;

		/* First section : */

		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
  407794:	89fb      	ldrh	r3, [r7, #14]
  407796:	f103 0301 	add.w	r3, r3, #1
  40779a:	81fb      	strh	r3, [r7, #14]
  40779c:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
  4077a0:	2b04      	cmp	r3, #4
  4077a2:	ddbf      	ble.n	407724 <vCounterControlTask+0x24>

		/* Second section: */

		/* Suspend the continuous counter task so it stops accessing the shared
		variable. */
		vTaskSuspend( xContinuousIncrementHandle );
  4077a4:	f24a 63f8 	movw	r3, #42744	; 0xa6f8
  4077a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4077ac:	681b      	ldr	r3, [r3, #0]
  4077ae:	4618      	mov	r0, r3
  4077b0:	f244 53c9 	movw	r3, #17865	; 0x45c9
  4077b4:	f2c0 0340 	movt	r3, #64	; 0x40
  4077b8:	4798      	blx	r3

		/* Reset the variable. */
		ulCounter = ( unsigned long ) 0;
  4077ba:	f24a 7300 	movw	r3, #42752	; 0xa700
  4077be:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4077c2:	f04f 0200 	mov.w	r2, #0
  4077c6:	601a      	str	r2, [r3, #0]
		#endif /* INCLUDE_eTaskGetState */

		/* Resume the limited count task which has a higher priority than us.
		We should therefore not return from this call until the limited count
		task has suspended itself with a known value in the counter variable. */
		vTaskResume( xLimitedIncrementHandle );
  4077c8:	f24a 63fc 	movw	r3, #42748	; 0xa6fc
  4077cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4077d0:	681b      	ldr	r3, [r3, #0]
  4077d2:	4618      	mov	r0, r3
  4077d4:	f244 736d 	movw	r3, #18285	; 0x476d
  4077d8:	f2c0 0340 	movt	r3, #64	; 0x40
  4077dc:	4798      	blx	r3
			configASSERT( eTaskGetState( xLimitedIncrementHandle ) == eSuspended );
		}
		#endif /* INCLUDE_eTaskGetState */

		/* Does the counter variable have the expected value? */
		if( ulCounter != priMAX_COUNT )
  4077de:	f24a 7300 	movw	r3, #42752	; 0xa700
  4077e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4077e6:	681b      	ldr	r3, [r3, #0]
  4077e8:	2bff      	cmp	r3, #255	; 0xff
  4077ea:	d002      	beq.n	4077f2 <vCounterControlTask+0xf2>
		{
			sError = pdTRUE;
  4077ec:	f04f 0301 	mov.w	r3, #1
  4077f0:	81bb      	strh	r3, [r7, #12]
		}

		if( sError == pdFALSE )
  4077f2:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
  4077f6:	2b00      	cmp	r3, #0
  4077f8:	d117      	bne.n	40782a <vCounterControlTask+0x12a>
		{
			/* If no errors have occurred then increment the check variable. */
			portENTER_CRITICAL();
  4077fa:	f642 6379 	movw	r3, #11897	; 0x2e79
  4077fe:	f2c0 0340 	movt	r3, #64	; 0x40
  407802:	4798      	blx	r3
				usCheckVariable++;
  407804:	f24a 7304 	movw	r3, #42756	; 0xa704
  407808:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40780c:	881b      	ldrh	r3, [r3, #0]
  40780e:	b29b      	uxth	r3, r3
  407810:	f103 0301 	add.w	r3, r3, #1
  407814:	b29a      	uxth	r2, r3
  407816:	f24a 7304 	movw	r3, #42756	; 0xa704
  40781a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40781e:	801a      	strh	r2, [r3, #0]
			portEXIT_CRITICAL();
  407820:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  407824:	f2c0 0340 	movt	r3, #64	; 0x40
  407828:	4798      	blx	r3
		}

		/* Resume the continuous count task and do it all again. */
		vTaskResume( xContinuousIncrementHandle );
  40782a:	f24a 63f8 	movw	r3, #42744	; 0xa6f8
  40782e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407832:	681b      	ldr	r3, [r3, #0]
  407834:	4618      	mov	r0, r3
  407836:	f244 736d 	movw	r3, #18285	; 0x476d
  40783a:	f2c0 0340 	movt	r3, #64	; 0x40
  40783e:	4798      	blx	r3

		#if( configUSE_PREEMPTION == 0 )
			taskYIELD();
		#endif
	}
  407840:	e765      	b.n	40770e <vCounterControlTask+0xe>
  407842:	bf00      	nop

00407844 <vQueueSendWhenSuspendedTask>:
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vQueueSendWhenSuspendedTask, pvParameters )
{
  407844:	b590      	push	{r4, r7, lr}
  407846:	b083      	sub	sp, #12
  407848:	af00      	add	r7, sp, #0
  40784a:	6078      	str	r0, [r7, #4]
	/* Just to stop warning messages. */
	( void ) pvParameters;

	for( ;; )
	{
		vTaskSuspendAll();
  40784c:	f644 03f9 	movw	r3, #18681	; 0x48f9
  407850:	f2c0 0340 	movt	r3, #64	; 0x40
  407854:	4798      	blx	r3
		{
			/* We must not block while the scheduler is suspended! */
			if( xQueueSend( xSuspendedTestQueue, ( void * ) &ulValueToSend, priNO_BLOCK ) != pdTRUE )
  407856:	f24a 73a4 	movw	r3, #42916	; 0xa7a4
  40785a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40785e:	681b      	ldr	r3, [r3, #0]
  407860:	4618      	mov	r0, r3
  407862:	f24a 711c 	movw	r1, #42780	; 0xa71c
  407866:	f2c2 0100 	movt	r1, #8192	; 0x2000
  40786a:	f04f 0200 	mov.w	r2, #0
  40786e:	f04f 0300 	mov.w	r3, #0
  407872:	f243 34f1 	movw	r4, #13297	; 0x33f1
  407876:	f2c0 0440 	movt	r4, #64	; 0x40
  40787a:	47a0      	blx	r4
  40787c:	4603      	mov	r3, r0
  40787e:	2b01      	cmp	r3, #1
  407880:	d006      	beq.n	407890 <vQueueSendWhenSuspendedTask+0x4c>
			{
				xSuspendedQueueSendError = pdTRUE;
  407882:	f24a 7308 	movw	r3, #42760	; 0xa708
  407886:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40788a:	f04f 0201 	mov.w	r2, #1
  40788e:	601a      	str	r2, [r3, #0]
			}
		}
		xTaskResumeAll();
  407890:	f644 131d 	movw	r3, #18717	; 0x491d
  407894:	f2c0 0340 	movt	r3, #64	; 0x40
  407898:	4798      	blx	r3

		vTaskDelay( priSLEEP_TIME );
  40789a:	f04f 0080 	mov.w	r0, #128	; 0x80
  40789e:	f244 332d 	movw	r3, #17197	; 0x432d
  4078a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4078a6:	4798      	blx	r3

		++ulValueToSend;
  4078a8:	f24a 731c 	movw	r3, #42780	; 0xa71c
  4078ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4078b0:	681b      	ldr	r3, [r3, #0]
  4078b2:	f103 0201 	add.w	r2, r3, #1
  4078b6:	f24a 731c 	movw	r3, #42780	; 0xa71c
  4078ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4078be:	601a      	str	r2, [r3, #0]
	}
  4078c0:	e7c4      	b.n	40784c <vQueueSendWhenSuspendedTask+0x8>
  4078c2:	bf00      	nop

004078c4 <vQueueReceiveWhenSuspendedTask>:
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vQueueReceiveWhenSuspendedTask, pvParameters )
{
  4078c4:	b590      	push	{r4, r7, lr}
  4078c6:	b085      	sub	sp, #20
  4078c8:	af00      	add	r7, sp, #0
  4078ca:	6078      	str	r0, [r7, #4]
  4078cc:	e000      	b.n	4078d0 <vQueueReceiveWhenSuspendedTask+0xc>
			/* Only increment the variable if an error has not occurred.  This
			allows xAreDynamicPriorityTasksStillRunning() to check for stalled
			tasks as well as explicit errors. */
			++ulExpectedValue;
		}
	}
  4078ce:	bf00      	nop
			/* Suspending the scheduler here is fairly pointless and
			undesirable for a normal application.  It is done here purely
			to test the scheduler.  The inner xTaskResumeAll() should
			never return pdTRUE as the scheduler is still locked by the
			outer call. */
			vTaskSuspendAll();
  4078d0:	f644 03f9 	movw	r3, #18681	; 0x48f9
  4078d4:	f2c0 0340 	movt	r3, #64	; 0x40
  4078d8:	4798      	blx	r3
			{
				vTaskSuspendAll();
  4078da:	f644 03f9 	movw	r3, #18681	; 0x48f9
  4078de:	f2c0 0340 	movt	r3, #64	; 0x40
  4078e2:	4798      	blx	r3
				{
					xGotValue = xQueueReceive( xSuspendedTestQueue, ( void * ) &ulReceivedValue, priNO_BLOCK );
  4078e4:	f24a 73a4 	movw	r3, #42916	; 0xa7a4
  4078e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4078ec:	681a      	ldr	r2, [r3, #0]
  4078ee:	f107 0308 	add.w	r3, r7, #8
  4078f2:	4610      	mov	r0, r2
  4078f4:	4619      	mov	r1, r3
  4078f6:	f04f 0200 	mov.w	r2, #0
  4078fa:	f04f 0300 	mov.w	r3, #0
  4078fe:	f243 7469 	movw	r4, #14185	; 0x3769
  407902:	f2c0 0440 	movt	r4, #64	; 0x40
  407906:	47a0      	blx	r4
  407908:	60f8      	str	r0, [r7, #12]
				}
				if( xTaskResumeAll() != pdFALSE )
  40790a:	f644 131d 	movw	r3, #18717	; 0x491d
  40790e:	f2c0 0340 	movt	r3, #64	; 0x40
  407912:	4798      	blx	r3
  407914:	4603      	mov	r3, r0
  407916:	2b00      	cmp	r3, #0
  407918:	d006      	beq.n	407928 <vQueueReceiveWhenSuspendedTask+0x64>
				{
					xSuspendedQueueReceiveError = pdTRUE;
  40791a:	f24a 730c 	movw	r3, #42764	; 0xa70c
  40791e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407922:	f04f 0201 	mov.w	r2, #1
  407926:	601a      	str	r2, [r3, #0]
				}
			}
			xTaskResumeAll();
  407928:	f644 131d 	movw	r3, #18717	; 0x491d
  40792c:	f2c0 0340 	movt	r3, #64	; 0x40
  407930:	4798      	blx	r3
			{
				taskYIELD();
			}
			#endif

		} while( xGotValue == pdFALSE );
  407932:	68fb      	ldr	r3, [r7, #12]
  407934:	2b00      	cmp	r3, #0
  407936:	d0cb      	beq.n	4078d0 <vQueueReceiveWhenSuspendedTask+0xc>

		if( ulReceivedValue != ulExpectedValue )
  407938:	68ba      	ldr	r2, [r7, #8]
  40793a:	f24a 7310 	movw	r3, #42768	; 0xa710
  40793e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407942:	681b      	ldr	r3, [r3, #0]
  407944:	429a      	cmp	r2, r3
  407946:	d006      	beq.n	407956 <vQueueReceiveWhenSuspendedTask+0x92>
		{
			xSuspendedQueueReceiveError = pdTRUE;
  407948:	f24a 730c 	movw	r3, #42764	; 0xa70c
  40794c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407950:	f04f 0201 	mov.w	r2, #1
  407954:	601a      	str	r2, [r3, #0]
		}

		if( xSuspendedQueueReceiveError != pdTRUE )
  407956:	f24a 730c 	movw	r3, #42764	; 0xa70c
  40795a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40795e:	681b      	ldr	r3, [r3, #0]
  407960:	2b01      	cmp	r3, #1
  407962:	d0b4      	beq.n	4078ce <vQueueReceiveWhenSuspendedTask+0xa>
		{
			/* Only increment the variable if an error has not occurred.  This
			allows xAreDynamicPriorityTasksStillRunning() to check for stalled
			tasks as well as explicit errors. */
			++ulExpectedValue;
  407964:	f24a 7310 	movw	r3, #42768	; 0xa710
  407968:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40796c:	681b      	ldr	r3, [r3, #0]
  40796e:	f103 0201 	add.w	r2, r3, #1
  407972:	f24a 7310 	movw	r3, #42768	; 0xa710
  407976:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40797a:	601a      	str	r2, [r3, #0]
		}
	}
  40797c:	e7a7      	b.n	4078ce <vQueueReceiveWhenSuspendedTask+0xa>
  40797e:	bf00      	nop

00407980 <xAreDynamicPriorityTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* Called to check that all the created tasks are still running without error. */
portBASE_TYPE xAreDynamicPriorityTasksStillRunning( void )
{
  407980:	b480      	push	{r7}
  407982:	b083      	sub	sp, #12
  407984:	af00      	add	r7, sp, #0
/* Keep a history of the check variables so we know if it has been incremented
since the last call. */
static unsigned short usLastTaskCheck = ( unsigned short ) 0;
static unsigned long ulLastExpectedValue = ( unsigned long ) 0U;
portBASE_TYPE xReturn = pdTRUE;
  407986:	f04f 0301 	mov.w	r3, #1
  40798a:	607b      	str	r3, [r7, #4]

	/* Check the tasks are still running by ensuring the check variable
	is still incrementing. */

	if( usCheckVariable == usLastTaskCheck )
  40798c:	f24a 7304 	movw	r3, #42756	; 0xa704
  407990:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407994:	881b      	ldrh	r3, [r3, #0]
  407996:	b29a      	uxth	r2, r3
  407998:	f24a 7314 	movw	r3, #42772	; 0xa714
  40799c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4079a0:	881b      	ldrh	r3, [r3, #0]
  4079a2:	429a      	cmp	r2, r3
  4079a4:	d102      	bne.n	4079ac <xAreDynamicPriorityTasksStillRunning+0x2c>
	{
		/* The check has not incremented so an error exists. */
		xReturn = pdFALSE;
  4079a6:	f04f 0300 	mov.w	r3, #0
  4079aa:	607b      	str	r3, [r7, #4]
	}

	if( ulExpectedValue == ulLastExpectedValue )
  4079ac:	f24a 7310 	movw	r3, #42768	; 0xa710
  4079b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4079b4:	681a      	ldr	r2, [r3, #0]
  4079b6:	f24a 7318 	movw	r3, #42776	; 0xa718
  4079ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4079be:	681b      	ldr	r3, [r3, #0]
  4079c0:	429a      	cmp	r2, r3
  4079c2:	d102      	bne.n	4079ca <xAreDynamicPriorityTasksStillRunning+0x4a>
	{
		/* The value being received by the queue receive task has not
		incremented so an error exists. */
		xReturn = pdFALSE;
  4079c4:	f04f 0300 	mov.w	r3, #0
  4079c8:	607b      	str	r3, [r7, #4]
	}

	if( xSuspendedQueueSendError == pdTRUE )
  4079ca:	f24a 7308 	movw	r3, #42760	; 0xa708
  4079ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4079d2:	681b      	ldr	r3, [r3, #0]
  4079d4:	2b01      	cmp	r3, #1
  4079d6:	d102      	bne.n	4079de <xAreDynamicPriorityTasksStillRunning+0x5e>
	{
		xReturn = pdFALSE;
  4079d8:	f04f 0300 	mov.w	r3, #0
  4079dc:	607b      	str	r3, [r7, #4]
	}

	if( xSuspendedQueueReceiveError == pdTRUE )
  4079de:	f24a 730c 	movw	r3, #42764	; 0xa70c
  4079e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4079e6:	681b      	ldr	r3, [r3, #0]
  4079e8:	2b01      	cmp	r3, #1
  4079ea:	d102      	bne.n	4079f2 <xAreDynamicPriorityTasksStillRunning+0x72>
	{
		xReturn = pdFALSE;
  4079ec:	f04f 0300 	mov.w	r3, #0
  4079f0:	607b      	str	r3, [r7, #4]
	}

	usLastTaskCheck = usCheckVariable;
  4079f2:	f24a 7304 	movw	r3, #42756	; 0xa704
  4079f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4079fa:	881b      	ldrh	r3, [r3, #0]
  4079fc:	b29a      	uxth	r2, r3
  4079fe:	f24a 7314 	movw	r3, #42772	; 0xa714
  407a02:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407a06:	801a      	strh	r2, [r3, #0]
	ulLastExpectedValue = ulExpectedValue;
  407a08:	f24a 7310 	movw	r3, #42768	; 0xa710
  407a0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407a10:	681a      	ldr	r2, [r3, #0]
  407a12:	f24a 7318 	movw	r3, #42776	; 0xa718
  407a16:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407a1a:	601a      	str	r2, [r3, #0]

	return xReturn;
  407a1c:	687b      	ldr	r3, [r7, #4]
}
  407a1e:	4618      	mov	r0, r3
  407a20:	f107 070c 	add.w	r7, r7, #12
  407a24:	46bd      	mov	sp, r7
  407a26:	bc80      	pop	{r7}
  407a28:	4770      	bx	lr
  407a2a:	bf00      	nop

00407a2c <vStartLEDFlashTimers>:
static void prvLEDTimerCallback( xTimerHandle xTimer );

/*-----------------------------------------------------------*/

void vStartLEDFlashTimers( unsigned portBASE_TYPE uxNumberOfLEDs )
{
  407a2c:	b590      	push	{r4, r7, lr}
  407a2e:	b087      	sub	sp, #28
  407a30:	af02      	add	r7, sp, #8
  407a32:	6078      	str	r0, [r7, #4]
unsigned portBASE_TYPE uxLEDTimer;
xTimerHandle xTimer;

	/* Create and start the requested number of timers. */
	for( uxLEDTimer = 0; uxLEDTimer < uxNumberOfLEDs; ++uxLEDTimer )
  407a34:	f04f 0300 	mov.w	r3, #0
  407a38:	60fb      	str	r3, [r7, #12]
  407a3a:	e035      	b.n	407aa8 <vStartLEDFlashTimers+0x7c>
	{
		/* Create the timer. */
		xTimer = xTimerCreate( 	( const signed char * const ) "Flasher",/* A text name, purely to help debugging. */
  407a3c:	68fb      	ldr	r3, [r7, #12]
  407a3e:	f103 0301 	add.w	r3, r3, #1
  407a42:	f240 124d 	movw	r2, #333	; 0x14d
  407a46:	fb02 f203 	mul.w	r2, r2, r3
  407a4a:	68fc      	ldr	r4, [r7, #12]
  407a4c:	f647 23b9 	movw	r3, #31417	; 0x7ab9
  407a50:	f2c0 0340 	movt	r3, #64	; 0x40
  407a54:	9300      	str	r3, [sp, #0]
  407a56:	f249 706c 	movw	r0, #38764	; 0x976c
  407a5a:	f2c0 0040 	movt	r0, #64	; 0x40
  407a5e:	4611      	mov	r1, r2
  407a60:	f04f 0201 	mov.w	r2, #1
  407a64:	4623      	mov	r3, r4
  407a66:	f645 145d 	movw	r4, #22877	; 0x595d
  407a6a:	f2c0 0440 	movt	r4, #64	; 0x40
  407a6e:	47a0      	blx	r4
  407a70:	60b8      	str	r0, [r7, #8]
		/* If the timer was created successfully, attempt to start it.  If the
		scheduler has not yet been started then the timer command queue must
		be long enough to hold each command sent to it until such time that the
		scheduler is started.  The timer command queue length is set by
		configTIMER_QUEUE_LENGTH in FreeRTOSConfig.h. */
		if( xTimer != NULL )
  407a72:	68bb      	ldr	r3, [r7, #8]
  407a74:	2b00      	cmp	r3, #0
  407a76:	d013      	beq.n	407aa0 <vStartLEDFlashTimers+0x74>
		{
			xTimerStart( xTimer, ledDONT_BLOCK );
  407a78:	f644 23c1 	movw	r3, #19137	; 0x4ac1
  407a7c:	f2c0 0340 	movt	r3, #64	; 0x40
  407a80:	4798      	blx	r3
  407a82:	4603      	mov	r3, r0
  407a84:	f04f 0200 	mov.w	r2, #0
  407a88:	9200      	str	r2, [sp, #0]
  407a8a:	68b8      	ldr	r0, [r7, #8]
  407a8c:	f04f 0100 	mov.w	r1, #0
  407a90:	461a      	mov	r2, r3
  407a92:	f04f 0300 	mov.w	r3, #0
  407a96:	f645 14e9 	movw	r4, #23017	; 0x59e9
  407a9a:	f2c0 0440 	movt	r4, #64	; 0x40
  407a9e:	47a0      	blx	r4
{
unsigned portBASE_TYPE uxLEDTimer;
xTimerHandle xTimer;

	/* Create and start the requested number of timers. */
	for( uxLEDTimer = 0; uxLEDTimer < uxNumberOfLEDs; ++uxLEDTimer )
  407aa0:	68fb      	ldr	r3, [r7, #12]
  407aa2:	f103 0301 	add.w	r3, r3, #1
  407aa6:	60fb      	str	r3, [r7, #12]
  407aa8:	68fa      	ldr	r2, [r7, #12]
  407aaa:	687b      	ldr	r3, [r7, #4]
  407aac:	429a      	cmp	r2, r3
  407aae:	d3c5      	bcc.n	407a3c <vStartLEDFlashTimers+0x10>
		if( xTimer != NULL )
		{
			xTimerStart( xTimer, ledDONT_BLOCK );
		}							  
	}
}
  407ab0:	f107 0714 	add.w	r7, r7, #20
  407ab4:	46bd      	mov	sp, r7
  407ab6:	bd90      	pop	{r4, r7, pc}

00407ab8 <prvLEDTimerCallback>:
/*-----------------------------------------------------------*/

static void prvLEDTimerCallback( xTimerHandle xTimer )
{
  407ab8:	b580      	push	{r7, lr}
  407aba:	b084      	sub	sp, #16
  407abc:	af00      	add	r7, sp, #0
  407abe:	6078      	str	r0, [r7, #4]
portBASE_TYPE xTimerID;

	/* The timer ID is used to identify the timer that has actually expired as
	each timer uses the same callback.  The ID is then also used as the number
	of the LED that is to be toggled. */
	xTimerID = ( portBASE_TYPE ) pvTimerGetTimerID( xTimer );
  407ac0:	6878      	ldr	r0, [r7, #4]
  407ac2:	f246 0345 	movw	r3, #24645	; 0x6045
  407ac6:	f2c0 0340 	movt	r3, #64	; 0x40
  407aca:	4798      	blx	r3
  407acc:	4603      	mov	r3, r0
  407ace:	60fb      	str	r3, [r7, #12]
	vParTestToggleLED( xTimerID );
  407ad0:	68fb      	ldr	r3, [r7, #12]
  407ad2:	4618      	mov	r0, r3
  407ad4:	f249 43d1 	movw	r3, #38097	; 0x94d1
  407ad8:	f2c0 0340 	movt	r3, #64	; 0x40
  407adc:	4798      	blx	r3
}
  407ade:	f107 0710 	add.w	r7, r7, #16
  407ae2:	46bd      	mov	sp, r7
  407ae4:	bd80      	pop	{r7, pc}
  407ae6:	bf00      	nop

00407ae8 <vStartGenericQueueTasks>:
static xTaskHandle xHighPriorityMutexTask, xMediumPriorityMutexTask;

/*-----------------------------------------------------------*/

void vStartGenericQueueTasks( unsigned portBASE_TYPE uxPriority )
{
  407ae8:	b590      	push	{r4, r7, lr}
  407aea:	b089      	sub	sp, #36	; 0x24
  407aec:	af04      	add	r7, sp, #16
  407aee:	6078      	str	r0, [r7, #4]
xQueueHandle xQueue;
xSemaphoreHandle xMutex;

	/* Create the queue that we are going to use for the
	prvSendFrontAndBackTest demo. */
	xQueue = xQueueCreate( genqQUEUE_LENGTH, sizeof( unsigned portLONG ) );
  407af0:	f04f 0005 	mov.w	r0, #5
  407af4:	f04f 0104 	mov.w	r1, #4
  407af8:	f04f 0200 	mov.w	r2, #0
  407afc:	f243 1311 	movw	r3, #12561	; 0x3111
  407b00:	f2c0 0340 	movt	r3, #64	; 0x40
  407b04:	4798      	blx	r3
  407b06:	60f8      	str	r0, [r7, #12]
	vQueueAddToRegistry( xQueue, ( signed portCHAR * ) "Gen_Queue_Test" );

	/* Create the demo task and pass it the queue just created.  We are
	passing the queue handle by value so it does not matter that it is
	declared on the stack here. */
	xTaskCreate( prvSendFrontAndBackTest, ( signed portCHAR * )"GenQ", configMINIMAL_STACK_SIZE, ( void * ) xQueue, uxPriority, NULL );
  407b08:	687b      	ldr	r3, [r7, #4]
  407b0a:	9300      	str	r3, [sp, #0]
  407b0c:	f04f 0300 	mov.w	r3, #0
  407b10:	9301      	str	r3, [sp, #4]
  407b12:	f04f 0300 	mov.w	r3, #0
  407b16:	9302      	str	r3, [sp, #8]
  407b18:	f04f 0300 	mov.w	r3, #0
  407b1c:	9303      	str	r3, [sp, #12]
  407b1e:	f647 4009 	movw	r0, #31753	; 0x7c09
  407b22:	f2c0 0040 	movt	r0, #64	; 0x40
  407b26:	f249 7174 	movw	r1, #38772	; 0x9774
  407b2a:	f2c0 0140 	movt	r1, #64	; 0x40
  407b2e:	f04f 0282 	mov.w	r2, #130	; 0x82
  407b32:	68fb      	ldr	r3, [r7, #12]
  407b34:	f244 0415 	movw	r4, #16405	; 0x4015
  407b38:	f2c0 0440 	movt	r4, #64	; 0x40
  407b3c:	47a0      	blx	r4

	/* Create the mutex used by the prvMutexTest task. */
	xMutex = xSemaphoreCreateMutex();
  407b3e:	f04f 0001 	mov.w	r0, #1
  407b42:	f243 13bd 	movw	r3, #12733	; 0x31bd
  407b46:	f2c0 0340 	movt	r3, #64	; 0x40
  407b4a:	4798      	blx	r3
  407b4c:	60b8      	str	r0, [r7, #8]
	vQueueAddToRegistry( ( xQueueHandle ) xMutex, ( signed portCHAR * ) "Gen_Queue_Mutex" );

	/* Create the mutex demo tasks and pass it the mutex just created.  We are
	passing the mutex handle by value so it does not matter that it is declared
	on the stack here. */
	xTaskCreate( prvLowPriorityMutexTask, ( signed portCHAR * )"MuLow", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_LOW_PRIORITY, NULL );
  407b4e:	f04f 0300 	mov.w	r3, #0
  407b52:	9300      	str	r3, [sp, #0]
  407b54:	f04f 0300 	mov.w	r3, #0
  407b58:	9301      	str	r3, [sp, #4]
  407b5a:	f04f 0300 	mov.w	r3, #0
  407b5e:	9302      	str	r3, [sp, #8]
  407b60:	f04f 0300 	mov.w	r3, #0
  407b64:	9303      	str	r3, [sp, #12]
  407b66:	f248 1015 	movw	r0, #33045	; 0x8115
  407b6a:	f2c0 0040 	movt	r0, #64	; 0x40
  407b6e:	f249 717c 	movw	r1, #38780	; 0x977c
  407b72:	f2c0 0140 	movt	r1, #64	; 0x40
  407b76:	f04f 0282 	mov.w	r2, #130	; 0x82
  407b7a:	68bb      	ldr	r3, [r7, #8]
  407b7c:	f244 0415 	movw	r4, #16405	; 0x4015
  407b80:	f2c0 0440 	movt	r4, #64	; 0x40
  407b84:	47a0      	blx	r4
	xTaskCreate( prvMediumPriorityMutexTask, ( signed portCHAR * )"MuMed", configMINIMAL_STACK_SIZE, NULL, genqMUTEX_MEDIUM_PRIORITY, &xMediumPriorityMutexTask );
  407b86:	f04f 0302 	mov.w	r3, #2
  407b8a:	9300      	str	r3, [sp, #0]
  407b8c:	f24a 7334 	movw	r3, #42804	; 0xa734
  407b90:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407b94:	9301      	str	r3, [sp, #4]
  407b96:	f04f 0300 	mov.w	r3, #0
  407b9a:	9302      	str	r3, [sp, #8]
  407b9c:	f04f 0300 	mov.w	r3, #0
  407ba0:	9303      	str	r3, [sp, #12]
  407ba2:	f248 20b1 	movw	r0, #33457	; 0x82b1
  407ba6:	f2c0 0040 	movt	r0, #64	; 0x40
  407baa:	f249 7184 	movw	r1, #38788	; 0x9784
  407bae:	f2c0 0140 	movt	r1, #64	; 0x40
  407bb2:	f04f 0282 	mov.w	r2, #130	; 0x82
  407bb6:	f04f 0300 	mov.w	r3, #0
  407bba:	f244 0415 	movw	r4, #16405	; 0x4015
  407bbe:	f2c0 0440 	movt	r4, #64	; 0x40
  407bc2:	47a0      	blx	r4
	xTaskCreate( prvHighPriorityMutexTask, ( signed portCHAR * )"MuHigh", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_HIGH_PRIORITY, &xHighPriorityMutexTask );
  407bc4:	f04f 0303 	mov.w	r3, #3
  407bc8:	9300      	str	r3, [sp, #0]
  407bca:	f24a 7330 	movw	r3, #42800	; 0xa730
  407bce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407bd2:	9301      	str	r3, [sp, #4]
  407bd4:	f04f 0300 	mov.w	r3, #0
  407bd8:	9302      	str	r3, [sp, #8]
  407bda:	f04f 0300 	mov.w	r3, #0
  407bde:	9303      	str	r3, [sp, #12]
  407be0:	f248 20e1 	movw	r0, #33505	; 0x82e1
  407be4:	f2c0 0040 	movt	r0, #64	; 0x40
  407be8:	f249 718c 	movw	r1, #38796	; 0x978c
  407bec:	f2c0 0140 	movt	r1, #64	; 0x40
  407bf0:	f04f 0282 	mov.w	r2, #130	; 0x82
  407bf4:	68bb      	ldr	r3, [r7, #8]
  407bf6:	f244 0415 	movw	r4, #16405	; 0x4015
  407bfa:	f2c0 0440 	movt	r4, #64	; 0x40
  407bfe:	47a0      	blx	r4
}
  407c00:	f107 0714 	add.w	r7, r7, #20
  407c04:	46bd      	mov	sp, r7
  407c06:	bd90      	pop	{r4, r7, pc}

00407c08 <prvSendFrontAndBackTest>:
/*-----------------------------------------------------------*/

static void prvSendFrontAndBackTest( void *pvParameters )
{
  407c08:	b590      	push	{r4, r7, lr}
  407c0a:	b087      	sub	sp, #28
  407c0c:	af00      	add	r7, sp, #0
  407c0e:	6078      	str	r0, [r7, #4]

		/* Queue a message for printing to say the task has started. */
		vPrintDisplayMessage( &pcTaskStartMsg );
	#endif

	xQueue = ( xQueueHandle ) pvParameters;
  407c10:	687b      	ldr	r3, [r7, #4]
  407c12:	617b      	str	r3, [r7, #20]
	{
		/* The queue is empty, so sending an item to the back of the queue
		should have the same efect as sending it to the front of the queue.

		First send to the front and check everything is as expected. */
		xQueueSendToFront( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );
  407c14:	6978      	ldr	r0, [r7, #20]
  407c16:	f24a 7124 	movw	r1, #42788	; 0xa724
  407c1a:	f2c2 0100 	movt	r1, #8192	; 0x2000
  407c1e:	f04f 0200 	mov.w	r2, #0
  407c22:	f04f 0301 	mov.w	r3, #1
  407c26:	f243 34f1 	movw	r4, #13297	; 0x33f1
  407c2a:	f2c0 0440 	movt	r4, #64	; 0x40
  407c2e:	47a0      	blx	r4

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
  407c30:	6978      	ldr	r0, [r7, #20]
  407c32:	f643 23bd 	movw	r3, #15037	; 0x3abd
  407c36:	f2c0 0340 	movt	r3, #64	; 0x40
  407c3a:	4798      	blx	r3
  407c3c:	4603      	mov	r3, r0
  407c3e:	2b01      	cmp	r3, #1
  407c40:	d006      	beq.n	407c50 <prvSendFrontAndBackTest+0x48>
		{
			xErrorDetected = pdTRUE;
  407c42:	f24a 7320 	movw	r3, #42784	; 0xa720
  407c46:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407c4a:	f04f 0201 	mov.w	r2, #1
  407c4e:	601a      	str	r2, [r3, #0]
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
  407c50:	f107 0310 	add.w	r3, r7, #16
  407c54:	6978      	ldr	r0, [r7, #20]
  407c56:	4619      	mov	r1, r3
  407c58:	f04f 0200 	mov.w	r2, #0
  407c5c:	f04f 0300 	mov.w	r3, #0
  407c60:	f243 7469 	movw	r4, #14185	; 0x3769
  407c64:	f2c0 0440 	movt	r4, #64	; 0x40
  407c68:	47a0      	blx	r4
  407c6a:	4603      	mov	r3, r0
  407c6c:	2b01      	cmp	r3, #1
  407c6e:	d006      	beq.n	407c7e <prvSendFrontAndBackTest+0x76>
		{
			xErrorDetected = pdTRUE;
  407c70:	f24a 7320 	movw	r3, #42784	; 0xa720
  407c74:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407c78:	f04f 0201 	mov.w	r2, #1
  407c7c:	601a      	str	r2, [r3, #0]
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
  407c7e:	f24a 7324 	movw	r3, #42788	; 0xa724
  407c82:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407c86:	681a      	ldr	r2, [r3, #0]
  407c88:	693b      	ldr	r3, [r7, #16]
  407c8a:	429a      	cmp	r2, r3
  407c8c:	d006      	beq.n	407c9c <prvSendFrontAndBackTest+0x94>
		{
			xErrorDetected = pdTRUE;
  407c8e:	f24a 7320 	movw	r3, #42784	; 0xa720
  407c92:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407c96:	f04f 0201 	mov.w	r2, #1
  407c9a:	601a      	str	r2, [r3, #0]
		}

		/* Then do the same, sending the data to the back, checking everything
		is as expected. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
  407c9c:	6978      	ldr	r0, [r7, #20]
  407c9e:	f643 23bd 	movw	r3, #15037	; 0x3abd
  407ca2:	f2c0 0340 	movt	r3, #64	; 0x40
  407ca6:	4798      	blx	r3
  407ca8:	4603      	mov	r3, r0
  407caa:	2b00      	cmp	r3, #0
  407cac:	d006      	beq.n	407cbc <prvSendFrontAndBackTest+0xb4>
		{
			xErrorDetected = pdTRUE;
  407cae:	f24a 7320 	movw	r3, #42784	; 0xa720
  407cb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407cb6:	f04f 0201 	mov.w	r2, #1
  407cba:	601a      	str	r2, [r3, #0]
		}

		xQueueSendToBack( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );
  407cbc:	6978      	ldr	r0, [r7, #20]
  407cbe:	f24a 7124 	movw	r1, #42788	; 0xa724
  407cc2:	f2c2 0100 	movt	r1, #8192	; 0x2000
  407cc6:	f04f 0200 	mov.w	r2, #0
  407cca:	f04f 0300 	mov.w	r3, #0
  407cce:	f243 34f1 	movw	r4, #13297	; 0x33f1
  407cd2:	f2c0 0440 	movt	r4, #64	; 0x40
  407cd6:	47a0      	blx	r4

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
  407cd8:	6978      	ldr	r0, [r7, #20]
  407cda:	f643 23bd 	movw	r3, #15037	; 0x3abd
  407cde:	f2c0 0340 	movt	r3, #64	; 0x40
  407ce2:	4798      	blx	r3
  407ce4:	4603      	mov	r3, r0
  407ce6:	2b01      	cmp	r3, #1
  407ce8:	d006      	beq.n	407cf8 <prvSendFrontAndBackTest+0xf0>
		{
			xErrorDetected = pdTRUE;
  407cea:	f24a 7320 	movw	r3, #42784	; 0xa720
  407cee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407cf2:	f04f 0201 	mov.w	r2, #1
  407cf6:	601a      	str	r2, [r3, #0]
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
  407cf8:	f107 0310 	add.w	r3, r7, #16
  407cfc:	6978      	ldr	r0, [r7, #20]
  407cfe:	4619      	mov	r1, r3
  407d00:	f04f 0200 	mov.w	r2, #0
  407d04:	f04f 0300 	mov.w	r3, #0
  407d08:	f243 7469 	movw	r4, #14185	; 0x3769
  407d0c:	f2c0 0440 	movt	r4, #64	; 0x40
  407d10:	47a0      	blx	r4
  407d12:	4603      	mov	r3, r0
  407d14:	2b01      	cmp	r3, #1
  407d16:	d006      	beq.n	407d26 <prvSendFrontAndBackTest+0x11e>
		{
			xErrorDetected = pdTRUE;
  407d18:	f24a 7320 	movw	r3, #42784	; 0xa720
  407d1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407d20:	f04f 0201 	mov.w	r2, #1
  407d24:	601a      	str	r2, [r3, #0]
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
  407d26:	6978      	ldr	r0, [r7, #20]
  407d28:	f643 23bd 	movw	r3, #15037	; 0x3abd
  407d2c:	f2c0 0340 	movt	r3, #64	; 0x40
  407d30:	4798      	blx	r3
  407d32:	4603      	mov	r3, r0
  407d34:	2b00      	cmp	r3, #0
  407d36:	d006      	beq.n	407d46 <prvSendFrontAndBackTest+0x13e>
		{
			xErrorDetected = pdTRUE;
  407d38:	f24a 7320 	movw	r3, #42784	; 0xa720
  407d3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407d40:	f04f 0201 	mov.w	r2, #1
  407d44:	601a      	str	r2, [r3, #0]
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
  407d46:	f24a 7324 	movw	r3, #42788	; 0xa724
  407d4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407d4e:	681a      	ldr	r2, [r3, #0]
  407d50:	693b      	ldr	r3, [r7, #16]
  407d52:	429a      	cmp	r2, r3
  407d54:	d006      	beq.n	407d64 <prvSendFrontAndBackTest+0x15c>
		{
			xErrorDetected = pdTRUE;
  407d56:	f24a 7320 	movw	r3, #42784	; 0xa720
  407d5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407d5e:	f04f 0201 	mov.w	r2, #1
  407d62:	601a      	str	r2, [r3, #0]
		#endif



		/* Place 2, 3, 4 into the queue, adding items to the back of the queue. */
		for( ulData = 2; ulData < 5; ulData++ )
  407d64:	f04f 0302 	mov.w	r3, #2
  407d68:	613b      	str	r3, [r7, #16]
  407d6a:	e010      	b.n	407d8e <prvSendFrontAndBackTest+0x186>
		{
			xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK );
  407d6c:	f107 0310 	add.w	r3, r7, #16
  407d70:	6978      	ldr	r0, [r7, #20]
  407d72:	4619      	mov	r1, r3
  407d74:	f04f 0200 	mov.w	r2, #0
  407d78:	f04f 0300 	mov.w	r3, #0
  407d7c:	f243 34f1 	movw	r4, #13297	; 0x33f1
  407d80:	f2c0 0440 	movt	r4, #64	; 0x40
  407d84:	47a0      	blx	r4
		#endif



		/* Place 2, 3, 4 into the queue, adding items to the back of the queue. */
		for( ulData = 2; ulData < 5; ulData++ )
  407d86:	693b      	ldr	r3, [r7, #16]
  407d88:	f103 0301 	add.w	r3, r3, #1
  407d8c:	613b      	str	r3, [r7, #16]
  407d8e:	693b      	ldr	r3, [r7, #16]
  407d90:	2b04      	cmp	r3, #4
  407d92:	d9eb      	bls.n	407d6c <prvSendFrontAndBackTest+0x164>
			xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK );
		}

		/* Now the order in the queue should be 2, 3, 4, with 2 being the first
		thing to be read out.  Now add 1 then 0 to the front of the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 3 )
  407d94:	6978      	ldr	r0, [r7, #20]
  407d96:	f643 23bd 	movw	r3, #15037	; 0x3abd
  407d9a:	f2c0 0340 	movt	r3, #64	; 0x40
  407d9e:	4798      	blx	r3
  407da0:	4603      	mov	r3, r0
  407da2:	2b03      	cmp	r3, #3
  407da4:	d006      	beq.n	407db4 <prvSendFrontAndBackTest+0x1ac>
		{
			xErrorDetected = pdTRUE;
  407da6:	f24a 7320 	movw	r3, #42784	; 0xa720
  407daa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407dae:	f04f 0201 	mov.w	r2, #1
  407db2:	601a      	str	r2, [r3, #0]
		}
		ulData = 1;
  407db4:	f04f 0301 	mov.w	r3, #1
  407db8:	613b      	str	r3, [r7, #16]
		xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK );
  407dba:	f107 0310 	add.w	r3, r7, #16
  407dbe:	6978      	ldr	r0, [r7, #20]
  407dc0:	4619      	mov	r1, r3
  407dc2:	f04f 0200 	mov.w	r2, #0
  407dc6:	f04f 0301 	mov.w	r3, #1
  407dca:	f243 34f1 	movw	r4, #13297	; 0x33f1
  407dce:	f2c0 0440 	movt	r4, #64	; 0x40
  407dd2:	47a0      	blx	r4
		ulData = 0;
  407dd4:	f04f 0300 	mov.w	r3, #0
  407dd8:	613b      	str	r3, [r7, #16]
		xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK );
  407dda:	f107 0310 	add.w	r3, r7, #16
  407dde:	6978      	ldr	r0, [r7, #20]
  407de0:	4619      	mov	r1, r3
  407de2:	f04f 0200 	mov.w	r2, #0
  407de6:	f04f 0301 	mov.w	r3, #1
  407dea:	f243 34f1 	movw	r4, #13297	; 0x33f1
  407dee:	f2c0 0440 	movt	r4, #64	; 0x40
  407df2:	47a0      	blx	r4

		/* Now the queue should be full, and when we read the data out we
		should receive 0, 1, 2, 3, 4. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
  407df4:	6978      	ldr	r0, [r7, #20]
  407df6:	f643 23bd 	movw	r3, #15037	; 0x3abd
  407dfa:	f2c0 0340 	movt	r3, #64	; 0x40
  407dfe:	4798      	blx	r3
  407e00:	4603      	mov	r3, r0
  407e02:	2b05      	cmp	r3, #5
  407e04:	d006      	beq.n	407e14 <prvSendFrontAndBackTest+0x20c>
		{
			xErrorDetected = pdTRUE;
  407e06:	f24a 7320 	movw	r3, #42784	; 0xa720
  407e0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407e0e:	f04f 0201 	mov.w	r2, #1
  407e12:	601a      	str	r2, [r3, #0]
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
  407e14:	f107 0310 	add.w	r3, r7, #16
  407e18:	6978      	ldr	r0, [r7, #20]
  407e1a:	4619      	mov	r1, r3
  407e1c:	f04f 0200 	mov.w	r2, #0
  407e20:	f04f 0301 	mov.w	r3, #1
  407e24:	f243 34f1 	movw	r4, #13297	; 0x33f1
  407e28:	f2c0 0440 	movt	r4, #64	; 0x40
  407e2c:	47a0      	blx	r4
  407e2e:	4603      	mov	r3, r0
  407e30:	2b00      	cmp	r3, #0
  407e32:	d006      	beq.n	407e42 <prvSendFrontAndBackTest+0x23a>
		{
			xErrorDetected = pdTRUE;
  407e34:	f24a 7320 	movw	r3, #42784	; 0xa720
  407e38:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407e3c:	f04f 0201 	mov.w	r2, #1
  407e40:	601a      	str	r2, [r3, #0]
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
  407e42:	f107 0310 	add.w	r3, r7, #16
  407e46:	6978      	ldr	r0, [r7, #20]
  407e48:	4619      	mov	r1, r3
  407e4a:	f04f 0200 	mov.w	r2, #0
  407e4e:	f04f 0300 	mov.w	r3, #0
  407e52:	f243 34f1 	movw	r4, #13297	; 0x33f1
  407e56:	f2c0 0440 	movt	r4, #64	; 0x40
  407e5a:	47a0      	blx	r4
  407e5c:	4603      	mov	r3, r0
  407e5e:	2b00      	cmp	r3, #0
  407e60:	d006      	beq.n	407e70 <prvSendFrontAndBackTest+0x268>
		{
			xErrorDetected = pdTRUE;
  407e62:	f24a 7320 	movw	r3, #42784	; 0xa720
  407e66:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407e6a:	f04f 0201 	mov.w	r2, #1
  407e6e:	601a      	str	r2, [r3, #0]
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
  407e70:	f04f 0300 	mov.w	r3, #0
  407e74:	613b      	str	r3, [r7, #16]
  407e76:	e04b      	b.n	407f10 <prvSendFrontAndBackTest+0x308>
		{
			/* Try peeking the data first. */
			if( xQueuePeek( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
  407e78:	f107 030c 	add.w	r3, r7, #12
  407e7c:	6978      	ldr	r0, [r7, #20]
  407e7e:	4619      	mov	r1, r3
  407e80:	f04f 0200 	mov.w	r2, #0
  407e84:	f04f 0301 	mov.w	r3, #1
  407e88:	f243 7469 	movw	r4, #14185	; 0x3769
  407e8c:	f2c0 0440 	movt	r4, #64	; 0x40
  407e90:	47a0      	blx	r4
  407e92:	4603      	mov	r3, r0
  407e94:	2b01      	cmp	r3, #1
  407e96:	d006      	beq.n	407ea6 <prvSendFrontAndBackTest+0x29e>
			{
				xErrorDetected = pdTRUE;
  407e98:	f24a 7320 	movw	r3, #42784	; 0xa720
  407e9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407ea0:	f04f 0201 	mov.w	r2, #1
  407ea4:	601a      	str	r2, [r3, #0]
			}

			if( ulData != ulData2 )
  407ea6:	693a      	ldr	r2, [r7, #16]
  407ea8:	68fb      	ldr	r3, [r7, #12]
  407eaa:	429a      	cmp	r2, r3
  407eac:	d006      	beq.n	407ebc <prvSendFrontAndBackTest+0x2b4>
			{
				xErrorDetected = pdTRUE;
  407eae:	f24a 7320 	movw	r3, #42784	; 0xa720
  407eb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407eb6:	f04f 0201 	mov.w	r2, #1
  407eba:	601a      	str	r2, [r3, #0]
			}


			/* Now try receiving the data for real.  The value should be the
			same.  Clobber the value first so we know we really received it. */
			ulData2 = ~ulData2;
  407ebc:	68fb      	ldr	r3, [r7, #12]
  407ebe:	ea6f 0303 	mvn.w	r3, r3
  407ec2:	60fb      	str	r3, [r7, #12]
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
  407ec4:	f107 030c 	add.w	r3, r7, #12
  407ec8:	6978      	ldr	r0, [r7, #20]
  407eca:	4619      	mov	r1, r3
  407ecc:	f04f 0200 	mov.w	r2, #0
  407ed0:	f04f 0300 	mov.w	r3, #0
  407ed4:	f243 7469 	movw	r4, #14185	; 0x3769
  407ed8:	f2c0 0440 	movt	r4, #64	; 0x40
  407edc:	47a0      	blx	r4
  407ede:	4603      	mov	r3, r0
  407ee0:	2b01      	cmp	r3, #1
  407ee2:	d006      	beq.n	407ef2 <prvSendFrontAndBackTest+0x2ea>
			{
				xErrorDetected = pdTRUE;
  407ee4:	f24a 7320 	movw	r3, #42784	; 0xa720
  407ee8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407eec:	f04f 0201 	mov.w	r2, #1
  407ef0:	601a      	str	r2, [r3, #0]
			}

			if( ulData != ulData2 )
  407ef2:	693a      	ldr	r2, [r7, #16]
  407ef4:	68fb      	ldr	r3, [r7, #12]
  407ef6:	429a      	cmp	r2, r3
  407ef8:	d006      	beq.n	407f08 <prvSendFrontAndBackTest+0x300>
			{
				xErrorDetected = pdTRUE;
  407efa:	f24a 7320 	movw	r3, #42784	; 0xa720
  407efe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407f02:	f04f 0201 	mov.w	r2, #1
  407f06:	601a      	str	r2, [r3, #0]
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
  407f08:	693b      	ldr	r3, [r7, #16]
  407f0a:	f103 0301 	add.w	r3, r3, #1
  407f0e:	613b      	str	r3, [r7, #16]
  407f10:	693b      	ldr	r3, [r7, #16]
  407f12:	2b04      	cmp	r3, #4
  407f14:	d9b0      	bls.n	407e78 <prvSendFrontAndBackTest+0x270>
				xErrorDetected = pdTRUE;
			}
		}

		/* The queue should now be empty again. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
  407f16:	6978      	ldr	r0, [r7, #20]
  407f18:	f643 23bd 	movw	r3, #15037	; 0x3abd
  407f1c:	f2c0 0340 	movt	r3, #64	; 0x40
  407f20:	4798      	blx	r3
  407f22:	4603      	mov	r3, r0
  407f24:	2b00      	cmp	r3, #0
  407f26:	d006      	beq.n	407f36 <prvSendFrontAndBackTest+0x32e>
		{
			xErrorDetected = pdTRUE;
  407f28:	f24a 7320 	movw	r3, #42784	; 0xa720
  407f2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407f30:	f04f 0201 	mov.w	r2, #1
  407f34:	601a      	str	r2, [r3, #0]
			taskYIELD();
		#endif


		/* Our queue is empty once more, add 10, 11 to the back. */
		ulData = 10;
  407f36:	f04f 030a 	mov.w	r3, #10
  407f3a:	613b      	str	r3, [r7, #16]
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
  407f3c:	f107 0310 	add.w	r3, r7, #16
  407f40:	6978      	ldr	r0, [r7, #20]
  407f42:	4619      	mov	r1, r3
  407f44:	f04f 0200 	mov.w	r2, #0
  407f48:	f04f 0300 	mov.w	r3, #0
  407f4c:	f243 34f1 	movw	r4, #13297	; 0x33f1
  407f50:	f2c0 0440 	movt	r4, #64	; 0x40
  407f54:	47a0      	blx	r4
  407f56:	4603      	mov	r3, r0
  407f58:	2b01      	cmp	r3, #1
  407f5a:	d006      	beq.n	407f6a <prvSendFrontAndBackTest+0x362>
		{
			xErrorDetected = pdTRUE;
  407f5c:	f24a 7320 	movw	r3, #42784	; 0xa720
  407f60:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407f64:	f04f 0201 	mov.w	r2, #1
  407f68:	601a      	str	r2, [r3, #0]
		}
		ulData = 11;
  407f6a:	f04f 030b 	mov.w	r3, #11
  407f6e:	613b      	str	r3, [r7, #16]
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
  407f70:	f107 0310 	add.w	r3, r7, #16
  407f74:	6978      	ldr	r0, [r7, #20]
  407f76:	4619      	mov	r1, r3
  407f78:	f04f 0200 	mov.w	r2, #0
  407f7c:	f04f 0300 	mov.w	r3, #0
  407f80:	f243 34f1 	movw	r4, #13297	; 0x33f1
  407f84:	f2c0 0440 	movt	r4, #64	; 0x40
  407f88:	47a0      	blx	r4
  407f8a:	4603      	mov	r3, r0
  407f8c:	2b01      	cmp	r3, #1
  407f8e:	d006      	beq.n	407f9e <prvSendFrontAndBackTest+0x396>
		{
			xErrorDetected = pdTRUE;
  407f90:	f24a 7320 	movw	r3, #42784	; 0xa720
  407f94:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407f98:	f04f 0201 	mov.w	r2, #1
  407f9c:	601a      	str	r2, [r3, #0]
		}

		if( uxQueueMessagesWaiting( xQueue ) != 2 )
  407f9e:	6978      	ldr	r0, [r7, #20]
  407fa0:	f643 23bd 	movw	r3, #15037	; 0x3abd
  407fa4:	f2c0 0340 	movt	r3, #64	; 0x40
  407fa8:	4798      	blx	r3
  407faa:	4603      	mov	r3, r0
  407fac:	2b02      	cmp	r3, #2
  407fae:	d006      	beq.n	407fbe <prvSendFrontAndBackTest+0x3b6>
		{
			xErrorDetected = pdTRUE;
  407fb0:	f24a 7320 	movw	r3, #42784	; 0xa720
  407fb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407fb8:	f04f 0201 	mov.w	r2, #1
  407fbc:	601a      	str	r2, [r3, #0]
		}

		/* Now we should have 10, 11 in the queue.  Add 7, 8, 9 to the
		front. */
		for( ulData = 9; ulData >= 7; ulData-- )
  407fbe:	f04f 0309 	mov.w	r3, #9
  407fc2:	613b      	str	r3, [r7, #16]
  407fc4:	e01a      	b.n	407ffc <prvSendFrontAndBackTest+0x3f4>
		{
			if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
  407fc6:	f107 0310 	add.w	r3, r7, #16
  407fca:	6978      	ldr	r0, [r7, #20]
  407fcc:	4619      	mov	r1, r3
  407fce:	f04f 0200 	mov.w	r2, #0
  407fd2:	f04f 0301 	mov.w	r3, #1
  407fd6:	f243 34f1 	movw	r4, #13297	; 0x33f1
  407fda:	f2c0 0440 	movt	r4, #64	; 0x40
  407fde:	47a0      	blx	r4
  407fe0:	4603      	mov	r3, r0
  407fe2:	2b01      	cmp	r3, #1
  407fe4:	d006      	beq.n	407ff4 <prvSendFrontAndBackTest+0x3ec>
			{
				xErrorDetected = pdTRUE;
  407fe6:	f24a 7320 	movw	r3, #42784	; 0xa720
  407fea:	f2c2 0300 	movt	r3, #8192	; 0x2000
  407fee:	f04f 0201 	mov.w	r2, #1
  407ff2:	601a      	str	r2, [r3, #0]
			xErrorDetected = pdTRUE;
		}

		/* Now we should have 10, 11 in the queue.  Add 7, 8, 9 to the
		front. */
		for( ulData = 9; ulData >= 7; ulData-- )
  407ff4:	693b      	ldr	r3, [r7, #16]
  407ff6:	f103 33ff 	add.w	r3, r3, #4294967295
  407ffa:	613b      	str	r3, [r7, #16]
  407ffc:	693b      	ldr	r3, [r7, #16]
  407ffe:	2b06      	cmp	r3, #6
  408000:	d8e1      	bhi.n	407fc6 <prvSendFrontAndBackTest+0x3be>
			}
		}

		/* Now check that the queue is full, and that receiving data provides
		the expected sequence of 7, 8, 9, 10, 11. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
  408002:	6978      	ldr	r0, [r7, #20]
  408004:	f643 23bd 	movw	r3, #15037	; 0x3abd
  408008:	f2c0 0340 	movt	r3, #64	; 0x40
  40800c:	4798      	blx	r3
  40800e:	4603      	mov	r3, r0
  408010:	2b05      	cmp	r3, #5
  408012:	d006      	beq.n	408022 <prvSendFrontAndBackTest+0x41a>
		{
			xErrorDetected = pdTRUE;
  408014:	f24a 7320 	movw	r3, #42784	; 0xa720
  408018:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40801c:	f04f 0201 	mov.w	r2, #1
  408020:	601a      	str	r2, [r3, #0]
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
  408022:	f107 0310 	add.w	r3, r7, #16
  408026:	6978      	ldr	r0, [r7, #20]
  408028:	4619      	mov	r1, r3
  40802a:	f04f 0200 	mov.w	r2, #0
  40802e:	f04f 0301 	mov.w	r3, #1
  408032:	f243 34f1 	movw	r4, #13297	; 0x33f1
  408036:	f2c0 0440 	movt	r4, #64	; 0x40
  40803a:	47a0      	blx	r4
  40803c:	4603      	mov	r3, r0
  40803e:	2b00      	cmp	r3, #0
  408040:	d006      	beq.n	408050 <prvSendFrontAndBackTest+0x448>
		{
			xErrorDetected = pdTRUE;
  408042:	f24a 7320 	movw	r3, #42784	; 0xa720
  408046:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40804a:	f04f 0201 	mov.w	r2, #1
  40804e:	601a      	str	r2, [r3, #0]
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
  408050:	f107 0310 	add.w	r3, r7, #16
  408054:	6978      	ldr	r0, [r7, #20]
  408056:	4619      	mov	r1, r3
  408058:	f04f 0200 	mov.w	r2, #0
  40805c:	f04f 0300 	mov.w	r3, #0
  408060:	f243 34f1 	movw	r4, #13297	; 0x33f1
  408064:	f2c0 0440 	movt	r4, #64	; 0x40
  408068:	47a0      	blx	r4
  40806a:	4603      	mov	r3, r0
  40806c:	2b00      	cmp	r3, #0
  40806e:	d006      	beq.n	40807e <prvSendFrontAndBackTest+0x476>
		{
			xErrorDetected = pdTRUE;
  408070:	f24a 7320 	movw	r3, #42784	; 0xa720
  408074:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408078:	f04f 0201 	mov.w	r2, #1
  40807c:	601a      	str	r2, [r3, #0]
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
  40807e:	f04f 0307 	mov.w	r3, #7
  408082:	613b      	str	r3, [r7, #16]
  408084:	e025      	b.n	4080d2 <prvSendFrontAndBackTest+0x4ca>
		{
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
  408086:	f107 030c 	add.w	r3, r7, #12
  40808a:	6978      	ldr	r0, [r7, #20]
  40808c:	4619      	mov	r1, r3
  40808e:	f04f 0200 	mov.w	r2, #0
  408092:	f04f 0300 	mov.w	r3, #0
  408096:	f243 7469 	movw	r4, #14185	; 0x3769
  40809a:	f2c0 0440 	movt	r4, #64	; 0x40
  40809e:	47a0      	blx	r4
  4080a0:	4603      	mov	r3, r0
  4080a2:	2b01      	cmp	r3, #1
  4080a4:	d006      	beq.n	4080b4 <prvSendFrontAndBackTest+0x4ac>
			{
				xErrorDetected = pdTRUE;
  4080a6:	f24a 7320 	movw	r3, #42784	; 0xa720
  4080aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4080ae:	f04f 0201 	mov.w	r2, #1
  4080b2:	601a      	str	r2, [r3, #0]
			}

			if( ulData != ulData2 )
  4080b4:	693a      	ldr	r2, [r7, #16]
  4080b6:	68fb      	ldr	r3, [r7, #12]
  4080b8:	429a      	cmp	r2, r3
  4080ba:	d006      	beq.n	4080ca <prvSendFrontAndBackTest+0x4c2>
			{
				xErrorDetected = pdTRUE;
  4080bc:	f24a 7320 	movw	r3, #42784	; 0xa720
  4080c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4080c4:	f04f 0201 	mov.w	r2, #1
  4080c8:	601a      	str	r2, [r3, #0]
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
  4080ca:	693b      	ldr	r3, [r7, #16]
  4080cc:	f103 0301 	add.w	r3, r3, #1
  4080d0:	613b      	str	r3, [r7, #16]
  4080d2:	693b      	ldr	r3, [r7, #16]
  4080d4:	2b0b      	cmp	r3, #11
  4080d6:	d9d6      	bls.n	408086 <prvSendFrontAndBackTest+0x47e>
			{
				xErrorDetected = pdTRUE;
			}
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
  4080d8:	6978      	ldr	r0, [r7, #20]
  4080da:	f643 23bd 	movw	r3, #15037	; 0x3abd
  4080de:	f2c0 0340 	movt	r3, #64	; 0x40
  4080e2:	4798      	blx	r3
  4080e4:	4603      	mov	r3, r0
  4080e6:	2b00      	cmp	r3, #0
  4080e8:	d006      	beq.n	4080f8 <prvSendFrontAndBackTest+0x4f0>
		{
			xErrorDetected = pdTRUE;
  4080ea:	f24a 7320 	movw	r3, #42784	; 0xa720
  4080ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4080f2:	f04f 0201 	mov.w	r2, #1
  4080f6:	601a      	str	r2, [r3, #0]
		}

		ulLoopCounter++;
  4080f8:	f24a 7324 	movw	r3, #42788	; 0xa724
  4080fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408100:	681b      	ldr	r3, [r3, #0]
  408102:	f103 0201 	add.w	r2, r3, #1
  408106:	f24a 7324 	movw	r3, #42788	; 0xa724
  40810a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40810e:	601a      	str	r2, [r3, #0]
	}
  408110:	e580      	b.n	407c14 <prvSendFrontAndBackTest+0xc>
  408112:	bf00      	nop

00408114 <prvLowPriorityMutexTask>:
}
/*-----------------------------------------------------------*/

static void prvLowPriorityMutexTask( void *pvParameters )
{
  408114:	b590      	push	{r4, r7, lr}
  408116:	b085      	sub	sp, #20
  408118:	af00      	add	r7, sp, #0
  40811a:	6078      	str	r0, [r7, #4]
xSemaphoreHandle xMutex = ( xSemaphoreHandle ) pvParameters;
  40811c:	687b      	ldr	r3, [r7, #4]
  40811e:	60fb      	str	r3, [r7, #12]
	#endif

	for( ;; )
	{
		/* Take the mutex.  It should be available now. */
		if( xSemaphoreTake( xMutex, genqNO_BLOCK ) != pdPASS )
  408120:	68f8      	ldr	r0, [r7, #12]
  408122:	f04f 0100 	mov.w	r1, #0
  408126:	f04f 0200 	mov.w	r2, #0
  40812a:	f04f 0300 	mov.w	r3, #0
  40812e:	f243 7469 	movw	r4, #14185	; 0x3769
  408132:	f2c0 0440 	movt	r4, #64	; 0x40
  408136:	47a0      	blx	r4
  408138:	4603      	mov	r3, r0
  40813a:	2b01      	cmp	r3, #1
  40813c:	d006      	beq.n	40814c <prvLowPriorityMutexTask+0x38>
		{
			xErrorDetected = pdTRUE;
  40813e:	f24a 7320 	movw	r3, #42784	; 0xa720
  408142:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408146:	f04f 0201 	mov.w	r2, #1
  40814a:	601a      	str	r2, [r3, #0]
		}

		/* Set our guarded variable to a known start value. */
		ulGuardedVariable = 0;
  40814c:	f24a 732c 	movw	r3, #42796	; 0xa72c
  408150:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408154:	f04f 0200 	mov.w	r2, #0
  408158:	601a      	str	r2, [r3, #0]

		/* Our priority should be as per that assigned when the task was
		created. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_LOW_PRIORITY )
  40815a:	f04f 0000 	mov.w	r0, #0
  40815e:	f244 33d9 	movw	r3, #17369	; 0x43d9
  408162:	f2c0 0340 	movt	r3, #64	; 0x40
  408166:	4798      	blx	r3
  408168:	4603      	mov	r3, r0
  40816a:	2b00      	cmp	r3, #0
  40816c:	d006      	beq.n	40817c <prvLowPriorityMutexTask+0x68>
		{
			xErrorDetected = pdTRUE;
  40816e:	f24a 7320 	movw	r3, #42784	; 0xa720
  408172:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408176:	f04f 0201 	mov.w	r2, #1
  40817a:	601a      	str	r2, [r3, #0]
		}

		/* Now unsuspend the high priority task.  This will attempt to take the
		mutex, and block when it finds it cannot obtain it. */
		vTaskResume( xHighPriorityMutexTask );
  40817c:	f24a 7330 	movw	r3, #42800	; 0xa730
  408180:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408184:	681b      	ldr	r3, [r3, #0]
  408186:	4618      	mov	r0, r3
  408188:	f244 736d 	movw	r3, #18285	; 0x476d
  40818c:	f2c0 0340 	movt	r3, #64	; 0x40
  408190:	4798      	blx	r3
		}
		#endif /* INCLUDE_eTaskGetState */

		/* We should now have inherited the prioritoy of the high priority task,
		as by now it will have attempted to get the mutex. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
  408192:	f04f 0000 	mov.w	r0, #0
  408196:	f244 33d9 	movw	r3, #17369	; 0x43d9
  40819a:	f2c0 0340 	movt	r3, #64	; 0x40
  40819e:	4798      	blx	r3
  4081a0:	4603      	mov	r3, r0
  4081a2:	2b03      	cmp	r3, #3
  4081a4:	d006      	beq.n	4081b4 <prvLowPriorityMutexTask+0xa0>
		{
			xErrorDetected = pdTRUE;
  4081a6:	f24a 7320 	movw	r3, #42784	; 0xa720
  4081aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4081ae:	f04f 0201 	mov.w	r2, #1
  4081b2:	601a      	str	r2, [r3, #0]
		}

		/* We can attempt to set our priority to the test priority - between the
		idle priority and the medium/high test priorities, but our actual
		prioroity should remain at the high priority. */
		vTaskPrioritySet( NULL, genqMUTEX_TEST_PRIORITY );
  4081b4:	f04f 0000 	mov.w	r0, #0
  4081b8:	f04f 0101 	mov.w	r1, #1
  4081bc:	f244 431d 	movw	r3, #17437	; 0x441d
  4081c0:	f2c0 0340 	movt	r3, #64	; 0x40
  4081c4:	4798      	blx	r3
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
  4081c6:	f04f 0000 	mov.w	r0, #0
  4081ca:	f244 33d9 	movw	r3, #17369	; 0x43d9
  4081ce:	f2c0 0340 	movt	r3, #64	; 0x40
  4081d2:	4798      	blx	r3
  4081d4:	4603      	mov	r3, r0
  4081d6:	2b03      	cmp	r3, #3
  4081d8:	d006      	beq.n	4081e8 <prvLowPriorityMutexTask+0xd4>
		{
			xErrorDetected = pdTRUE;
  4081da:	f24a 7320 	movw	r3, #42784	; 0xa720
  4081de:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4081e2:	f04f 0201 	mov.w	r2, #1
  4081e6:	601a      	str	r2, [r3, #0]
		}

		/* Now unsuspend the medium priority task.  This should not run as our
		inherited priority is above that of the medium priority task. */
		vTaskResume( xMediumPriorityMutexTask );
  4081e8:	f24a 7334 	movw	r3, #42804	; 0xa734
  4081ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4081f0:	681b      	ldr	r3, [r3, #0]
  4081f2:	4618      	mov	r0, r3
  4081f4:	f244 736d 	movw	r3, #18285	; 0x476d
  4081f8:	f2c0 0340 	movt	r3, #64	; 0x40
  4081fc:	4798      	blx	r3

		/* If the did run then it will have incremented our guarded variable. */
		if( ulGuardedVariable != 0 )
  4081fe:	f24a 732c 	movw	r3, #42796	; 0xa72c
  408202:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408206:	681b      	ldr	r3, [r3, #0]
  408208:	2b00      	cmp	r3, #0
  40820a:	d006      	beq.n	40821a <prvLowPriorityMutexTask+0x106>
		{
			xErrorDetected = pdTRUE;
  40820c:	f24a 7320 	movw	r3, #42784	; 0xa720
  408210:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408214:	f04f 0201 	mov.w	r2, #1
  408218:	601a      	str	r2, [r3, #0]
		/* When we give back the semaphore our priority should be disinherited
		back to the priority to which we attempted to set ourselves.  This means
		that when the high priority task next blocks, the medium priority task
		should execute and increment the guarded variable.   When we next run
		both the high and medium priority tasks will have been suspended again. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
  40821a:	68f8      	ldr	r0, [r7, #12]
  40821c:	f04f 0100 	mov.w	r1, #0
  408220:	f04f 0200 	mov.w	r2, #0
  408224:	f04f 0300 	mov.w	r3, #0
  408228:	f243 34f1 	movw	r4, #13297	; 0x33f1
  40822c:	f2c0 0440 	movt	r4, #64	; 0x40
  408230:	47a0      	blx	r4
  408232:	4603      	mov	r3, r0
  408234:	2b01      	cmp	r3, #1
  408236:	d006      	beq.n	408246 <prvLowPriorityMutexTask+0x132>
		{
			xErrorDetected = pdTRUE;
  408238:	f24a 7320 	movw	r3, #42784	; 0xa720
  40823c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408240:	f04f 0201 	mov.w	r2, #1
  408244:	601a      	str	r2, [r3, #0]
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check that the guarded variable did indeed increment... */
		if( ulGuardedVariable != 1 )
  408246:	f24a 732c 	movw	r3, #42796	; 0xa72c
  40824a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40824e:	681b      	ldr	r3, [r3, #0]
  408250:	2b01      	cmp	r3, #1
  408252:	d006      	beq.n	408262 <prvLowPriorityMutexTask+0x14e>
		{
			xErrorDetected = pdTRUE;
  408254:	f24a 7320 	movw	r3, #42784	; 0xa720
  408258:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40825c:	f04f 0201 	mov.w	r2, #1
  408260:	601a      	str	r2, [r3, #0]
		}

		/* ... and that our priority has been disinherited to
		genqMUTEX_TEST_PRIORITY. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_TEST_PRIORITY )
  408262:	f04f 0000 	mov.w	r0, #0
  408266:	f244 33d9 	movw	r3, #17369	; 0x43d9
  40826a:	f2c0 0340 	movt	r3, #64	; 0x40
  40826e:	4798      	blx	r3
  408270:	4603      	mov	r3, r0
  408272:	2b01      	cmp	r3, #1
  408274:	d006      	beq.n	408284 <prvLowPriorityMutexTask+0x170>
		{
			xErrorDetected = pdTRUE;
  408276:	f24a 7320 	movw	r3, #42784	; 0xa720
  40827a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40827e:	f04f 0201 	mov.w	r2, #1
  408282:	601a      	str	r2, [r3, #0]
		}

		/* Set our priority back to our original priority ready for the next
		loop around this test. */
		vTaskPrioritySet( NULL, genqMUTEX_LOW_PRIORITY );
  408284:	f04f 0000 	mov.w	r0, #0
  408288:	f04f 0100 	mov.w	r1, #0
  40828c:	f244 431d 	movw	r3, #17437	; 0x441d
  408290:	f2c0 0340 	movt	r3, #64	; 0x40
  408294:	4798      	blx	r3

		/* Just to show we are still running. */
		ulLoopCounter2++;
  408296:	f24a 7328 	movw	r3, #42792	; 0xa728
  40829a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40829e:	681b      	ldr	r3, [r3, #0]
  4082a0:	f103 0201 	add.w	r2, r3, #1
  4082a4:	f24a 7328 	movw	r3, #42792	; 0xa728
  4082a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4082ac:	601a      	str	r2, [r3, #0]

		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif
	}
  4082ae:	e737      	b.n	408120 <prvLowPriorityMutexTask+0xc>

004082b0 <prvMediumPriorityMutexTask>:
}
/*-----------------------------------------------------------*/

static void prvMediumPriorityMutexTask( void *pvParameters )
{
  4082b0:	b580      	push	{r7, lr}
  4082b2:	b082      	sub	sp, #8
  4082b4:	af00      	add	r7, sp, #0
  4082b6:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* The medium priority task starts by suspending itself.  The low
		priority task will unsuspend this task when required. */
		vTaskSuspend( NULL );
  4082b8:	f04f 0000 	mov.w	r0, #0
  4082bc:	f244 53c9 	movw	r3, #17865	; 0x45c9
  4082c0:	f2c0 0340 	movt	r3, #64	; 0x40
  4082c4:	4798      	blx	r3

		/* When this task unsuspends all it does is increment the guarded
		variable, this is so the low priority task knows that it has
		executed. */
		ulGuardedVariable++;
  4082c6:	f24a 732c 	movw	r3, #42796	; 0xa72c
  4082ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4082ce:	681b      	ldr	r3, [r3, #0]
  4082d0:	f103 0201 	add.w	r2, r3, #1
  4082d4:	f24a 732c 	movw	r3, #42796	; 0xa72c
  4082d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4082dc:	601a      	str	r2, [r3, #0]
	}
  4082de:	e7eb      	b.n	4082b8 <prvMediumPriorityMutexTask+0x8>

004082e0 <prvHighPriorityMutexTask>:
}
/*-----------------------------------------------------------*/

static void prvHighPriorityMutexTask( void *pvParameters )
{
  4082e0:	b590      	push	{r4, r7, lr}
  4082e2:	b085      	sub	sp, #20
  4082e4:	af00      	add	r7, sp, #0
  4082e6:	6078      	str	r0, [r7, #4]
xSemaphoreHandle xMutex = ( xSemaphoreHandle ) pvParameters;
  4082e8:	687b      	ldr	r3, [r7, #4]
  4082ea:	60fb      	str	r3, [r7, #12]
  4082ec:	e000      	b.n	4082f0 <prvHighPriorityMutexTask+0x10>
		return to suspend ready for the next test. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
		}
	}
  4082ee:	bf00      	nop

	for( ;; )
	{
		/* The high priority task starts by suspending itself.  The low
		priority task will unsuspend this task when required. */
		vTaskSuspend( NULL );
  4082f0:	f04f 0000 	mov.w	r0, #0
  4082f4:	f244 53c9 	movw	r3, #17865	; 0x45c9
  4082f8:	f2c0 0340 	movt	r3, #64	; 0x40
  4082fc:	4798      	blx	r3

		/* When this task unsuspends all it does is attempt to obtain
		the mutex.  It should find the mutex is not available so a
		block time is specified. */
		if( xSemaphoreTake( xMutex, portMAX_DELAY ) != pdPASS )
  4082fe:	68f8      	ldr	r0, [r7, #12]
  408300:	f04f 0100 	mov.w	r1, #0
  408304:	f04f 32ff 	mov.w	r2, #4294967295
  408308:	f04f 0300 	mov.w	r3, #0
  40830c:	f243 7469 	movw	r4, #14185	; 0x3769
  408310:	f2c0 0440 	movt	r4, #64	; 0x40
  408314:	47a0      	blx	r4
  408316:	4603      	mov	r3, r0
  408318:	2b01      	cmp	r3, #1
  40831a:	d006      	beq.n	40832a <prvHighPriorityMutexTask+0x4a>
		{
			xErrorDetected = pdTRUE;
  40831c:	f24a 7320 	movw	r3, #42784	; 0xa720
  408320:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408324:	f04f 0201 	mov.w	r2, #1
  408328:	601a      	str	r2, [r3, #0]
		}

		/* When we eventually obtain the mutex we just give it back then
		return to suspend ready for the next test. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
  40832a:	68f8      	ldr	r0, [r7, #12]
  40832c:	f04f 0100 	mov.w	r1, #0
  408330:	f04f 0200 	mov.w	r2, #0
  408334:	f04f 0300 	mov.w	r3, #0
  408338:	f243 34f1 	movw	r4, #13297	; 0x33f1
  40833c:	f2c0 0440 	movt	r4, #64	; 0x40
  408340:	47a0      	blx	r4
  408342:	4603      	mov	r3, r0
  408344:	2b01      	cmp	r3, #1
  408346:	d0d2      	beq.n	4082ee <prvHighPriorityMutexTask+0xe>
		{
			xErrorDetected = pdTRUE;
  408348:	f24a 7320 	movw	r3, #42784	; 0xa720
  40834c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408350:	f04f 0201 	mov.w	r2, #1
  408354:	601a      	str	r2, [r3, #0]
		}
	}
  408356:	e7ca      	b.n	4082ee <prvHighPriorityMutexTask+0xe>

00408358 <xAreGenericQueueTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreGenericQueueTasksStillRunning( void )
{
  408358:	b480      	push	{r7}
  40835a:	af00      	add	r7, sp, #0
static unsigned portLONG ulLastLoopCounter = 0, ulLastLoopCounter2 = 0;

	/* If the demo task is still running then we expect the loopcounters to
	have incremented since this function was last called. */
	if( ulLastLoopCounter == ulLoopCounter )
  40835c:	f24a 7338 	movw	r3, #42808	; 0xa738
  408360:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408364:	681a      	ldr	r2, [r3, #0]
  408366:	f24a 7324 	movw	r3, #42788	; 0xa724
  40836a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40836e:	681b      	ldr	r3, [r3, #0]
  408370:	429a      	cmp	r2, r3
  408372:	d106      	bne.n	408382 <xAreGenericQueueTasksStillRunning+0x2a>
	{
		xErrorDetected = pdTRUE;
  408374:	f24a 7320 	movw	r3, #42784	; 0xa720
  408378:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40837c:	f04f 0201 	mov.w	r2, #1
  408380:	601a      	str	r2, [r3, #0]
	}

	if( ulLastLoopCounter2 == ulLoopCounter2 )
  408382:	f24a 733c 	movw	r3, #42812	; 0xa73c
  408386:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40838a:	681a      	ldr	r2, [r3, #0]
  40838c:	f24a 7328 	movw	r3, #42792	; 0xa728
  408390:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408394:	681b      	ldr	r3, [r3, #0]
  408396:	429a      	cmp	r2, r3
  408398:	d106      	bne.n	4083a8 <xAreGenericQueueTasksStillRunning+0x50>
	{
		xErrorDetected = pdTRUE;
  40839a:	f24a 7320 	movw	r3, #42784	; 0xa720
  40839e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4083a2:	f04f 0201 	mov.w	r2, #1
  4083a6:	601a      	str	r2, [r3, #0]
	}

	ulLastLoopCounter = ulLoopCounter;
  4083a8:	f24a 7324 	movw	r3, #42788	; 0xa724
  4083ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4083b0:	681a      	ldr	r2, [r3, #0]
  4083b2:	f24a 7338 	movw	r3, #42808	; 0xa738
  4083b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4083ba:	601a      	str	r2, [r3, #0]
	ulLastLoopCounter2 = ulLoopCounter2;
  4083bc:	f24a 7328 	movw	r3, #42792	; 0xa728
  4083c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4083c4:	681a      	ldr	r2, [r3, #0]
  4083c6:	f24a 733c 	movw	r3, #42812	; 0xa73c
  4083ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4083ce:	601a      	str	r2, [r3, #0]

	/* Errors detected in the task itself will have latched xErrorDetected
	to true. */

	return ( portBASE_TYPE ) !xErrorDetected;
  4083d0:	f24a 7320 	movw	r3, #42784	; 0xa720
  4083d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4083d8:	681b      	ldr	r3, [r3, #0]
  4083da:	2b00      	cmp	r3, #0
  4083dc:	bf14      	ite	ne
  4083de:	2300      	movne	r3, #0
  4083e0:	2301      	moveq	r3, #1
  4083e2:	b2db      	uxtb	r3, r3
}
  4083e4:	4618      	mov	r0, r3
  4083e6:	46bd      	mov	sp, r7
  4083e8:	bc80      	pop	{r7}
  4083ea:	4770      	bx	lr

004083ec <vStartIntegerMathTasks>:
static volatile signed portBASE_TYPE xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( signed portBASE_TYPE ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( unsigned portBASE_TYPE uxPriority )
{
  4083ec:	b590      	push	{r4, r7, lr}
  4083ee:	b089      	sub	sp, #36	; 0x24
  4083f0:	af04      	add	r7, sp, #16
  4083f2:	6078      	str	r0, [r7, #4]
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
  4083f4:	f04f 0300 	mov.w	r3, #0
  4083f8:	81fb      	strh	r3, [r7, #14]
  4083fa:	e026      	b.n	40844a <vStartIntegerMathTasks+0x5e>
	{
		xTaskCreate( vCompeteingIntMathTask, ( signed char * ) "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( xTaskHandle * ) NULL );
  4083fc:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
  408400:	ea4f 0283 	mov.w	r2, r3, lsl #2
  408404:	f24a 7340 	movw	r3, #42816	; 0xa740
  408408:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40840c:	18d3      	adds	r3, r2, r3
  40840e:	687a      	ldr	r2, [r7, #4]
  408410:	9200      	str	r2, [sp, #0]
  408412:	f04f 0200 	mov.w	r2, #0
  408416:	9201      	str	r2, [sp, #4]
  408418:	f04f 0200 	mov.w	r2, #0
  40841c:	9202      	str	r2, [sp, #8]
  40841e:	f04f 0200 	mov.w	r2, #0
  408422:	9203      	str	r2, [sp, #12]
  408424:	f248 405d 	movw	r0, #33885	; 0x845d
  408428:	f2c0 0040 	movt	r0, #64	; 0x40
  40842c:	f249 7194 	movw	r1, #38804	; 0x9794
  408430:	f2c0 0140 	movt	r1, #64	; 0x40
  408434:	f04f 0282 	mov.w	r2, #130	; 0x82
  408438:	f244 0415 	movw	r4, #16405	; 0x4015
  40843c:	f2c0 0440 	movt	r4, #64	; 0x40
  408440:	47a0      	blx	r4

void vStartIntegerMathTasks( unsigned portBASE_TYPE uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
  408442:	89fb      	ldrh	r3, [r7, #14]
  408444:	f103 0301 	add.w	r3, r3, #1
  408448:	81fb      	strh	r3, [r7, #14]
  40844a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
  40844e:	2b00      	cmp	r3, #0
  408450:	ddd4      	ble.n	4083fc <vStartIntegerMathTasks+0x10>
	{
		xTaskCreate( vCompeteingIntMathTask, ( signed char * ) "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( xTaskHandle * ) NULL );
	}
}
  408452:	f107 0714 	add.w	r7, r7, #20
  408456:	46bd      	mov	sp, r7
  408458:	bd90      	pop	{r4, r7, pc}
  40845a:	bf00      	nop

0040845c <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
  40845c:	b580      	push	{r7, lr}
  40845e:	b086      	sub	sp, #24
  408460:	af00      	add	r7, sp, #0
  408462:	6078      	str	r0, [r7, #4]
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
  408464:	f04f 0300 	mov.w	r3, #0
  408468:	82fb      	strh	r3, [r7, #22]
volatile signed portBASE_TYPE *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
  40846a:	687b      	ldr	r3, [r7, #4]
  40846c:	613b      	str	r3, [r7, #16]
  40846e:	e000      	b.n	408472 <vCompeteingIntMathTask+0x16>
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
  408470:	bf00      	nop
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
  408472:	f04f 037b 	mov.w	r3, #123	; 0x7b
  408476:	60fb      	str	r3, [r7, #12]
		lValue += intgCONST2;
  408478:	68fb      	ldr	r3, [r7, #12]
  40847a:	f503 3365 	add.w	r3, r3, #234496	; 0x39400
  40847e:	f103 0347 	add.w	r3, r3, #71	; 0x47
  408482:	60fb      	str	r3, [r7, #12]
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
  408484:	68fb      	ldr	r3, [r7, #12]
  408486:	461a      	mov	r2, r3
  408488:	ea4f 0383 	mov.w	r3, r3, lsl #2
  40848c:	1ad3      	subs	r3, r2, r3
  40848e:	60fb      	str	r3, [r7, #12]
		lValue /= intgCONST4;
  408490:	68fb      	ldr	r3, [r7, #12]
  408492:	f242 4293 	movw	r2, #9363	; 0x2493
  408496:	f2c9 2249 	movt	r2, #37449	; 0x9249
  40849a:	fb82 1203 	smull	r1, r2, r2, r3
  40849e:	18d2      	adds	r2, r2, r3
  4084a0:	ea4f 02a2 	mov.w	r2, r2, asr #2
  4084a4:	ea4f 73e3 	mov.w	r3, r3, asr #31
  4084a8:	1ad3      	subs	r3, r2, r3
  4084aa:	60fb      	str	r3, [r7, #12]

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
  4084ac:	68fa      	ldr	r2, [r7, #12]
  4084ae:	f247 731b 	movw	r3, #30491	; 0x771b
  4084b2:	f6cf 73fe 	movt	r3, #65534	; 0xfffe
  4084b6:	429a      	cmp	r2, r3
  4084b8:	d002      	beq.n	4084c0 <vCompeteingIntMathTask+0x64>
		{
			sError = pdTRUE;
  4084ba:	f04f 0301 	mov.w	r3, #1
  4084be:	82fb      	strh	r3, [r7, #22]
		}

		if( sError == pdFALSE )
  4084c0:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
  4084c4:	2b00      	cmp	r3, #0
  4084c6:	d1d3      	bne.n	408470 <vCompeteingIntMathTask+0x14>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
  4084c8:	f642 6379 	movw	r3, #11897	; 0x2e79
  4084cc:	f2c0 0340 	movt	r3, #64	; 0x40
  4084d0:	4798      	blx	r3
				*pxTaskHasExecuted = pdTRUE;
  4084d2:	693b      	ldr	r3, [r7, #16]
  4084d4:	f04f 0201 	mov.w	r2, #1
  4084d8:	601a      	str	r2, [r3, #0]
			portEXIT_CRITICAL();
  4084da:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  4084de:	f2c0 0340 	movt	r3, #64	; 0x40
  4084e2:	4798      	blx	r3
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
  4084e4:	e7c4      	b.n	408470 <vCompeteingIntMathTask+0x14>
  4084e6:	bf00      	nop

004084e8 <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreIntegerMathsTaskStillRunning( void )
{
  4084e8:	b480      	push	{r7}
  4084ea:	b083      	sub	sp, #12
  4084ec:	af00      	add	r7, sp, #0
portBASE_TYPE xReturn = pdTRUE;
  4084ee:	f04f 0301 	mov.w	r3, #1
  4084f2:	607b      	str	r3, [r7, #4]
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
  4084f4:	f04f 0300 	mov.w	r3, #0
  4084f8:	807b      	strh	r3, [r7, #2]
  4084fa:	e01a      	b.n	408532 <xAreIntegerMathsTaskStillRunning+0x4a>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
  4084fc:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
  408500:	f24a 7340 	movw	r3, #42816	; 0xa740
  408504:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408508:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40850c:	2b00      	cmp	r3, #0
  40850e:	d102      	bne.n	408516 <xAreIntegerMathsTaskStillRunning+0x2e>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
  408510:	f04f 0300 	mov.w	r3, #0
  408514:	607b      	str	r3, [r7, #4]
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
  408516:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
  40851a:	f24a 7340 	movw	r3, #42816	; 0xa740
  40851e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408522:	f04f 0100 	mov.w	r1, #0
  408526:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
portBASE_TYPE xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
  40852a:	887b      	ldrh	r3, [r7, #2]
  40852c:	f103 0301 	add.w	r3, r3, #1
  408530:	807b      	strh	r3, [r7, #2]
  408532:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  408536:	2b00      	cmp	r3, #0
  408538:	dde0      	ble.n	4084fc <xAreIntegerMathsTaskStillRunning+0x14>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
  40853a:	687b      	ldr	r3, [r7, #4]
}
  40853c:	4618      	mov	r0, r3
  40853e:	f107 070c 	add.w	r7, r7, #12
  408542:	46bd      	mov	sp, r7
  408544:	bc80      	pop	{r7}
  408546:	4770      	bx	lr

00408548 <vStartPolledQueueTasks>:
static volatile signed portBASE_TYPE xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( unsigned portBASE_TYPE uxPriority )
{
  408548:	b590      	push	{r4, r7, lr}
  40854a:	b087      	sub	sp, #28
  40854c:	af04      	add	r7, sp, #16
  40854e:	6078      	str	r0, [r7, #4]
static xQueueHandle xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
  408550:	f04f 000a 	mov.w	r0, #10
  408554:	f04f 0102 	mov.w	r1, #2
  408558:	f04f 0200 	mov.w	r2, #0
  40855c:	f243 1311 	movw	r3, #12561	; 0x3111
  408560:	f2c0 0340 	movt	r3, #64	; 0x40
  408564:	4798      	blx	r3
  408566:	4602      	mov	r2, r0
  408568:	f24a 734c 	movw	r3, #42828	; 0xa74c
  40856c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408570:	601a      	str	r2, [r3, #0]
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, ( signed char * ) "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, ( signed char * ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
  408572:	687b      	ldr	r3, [r7, #4]
  408574:	9300      	str	r3, [sp, #0]
  408576:	f04f 0300 	mov.w	r3, #0
  40857a:	9301      	str	r3, [sp, #4]
  40857c:	f04f 0300 	mov.w	r3, #0
  408580:	9302      	str	r3, [sp, #8]
  408582:	f04f 0300 	mov.w	r3, #0
  408586:	9303      	str	r3, [sp, #12]
  408588:	f248 6099 	movw	r0, #34457	; 0x8699
  40858c:	f2c0 0040 	movt	r0, #64	; 0x40
  408590:	f249 719c 	movw	r1, #38812	; 0x979c
  408594:	f2c0 0140 	movt	r1, #64	; 0x40
  408598:	f04f 0282 	mov.w	r2, #130	; 0x82
  40859c:	f24a 734c 	movw	r3, #42828	; 0xa74c
  4085a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4085a4:	f244 0415 	movw	r4, #16405	; 0x4015
  4085a8:	f2c0 0440 	movt	r4, #64	; 0x40
  4085ac:	47a0      	blx	r4
	xTaskCreate( vPolledQueueProducer, ( signed char * ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
  4085ae:	687b      	ldr	r3, [r7, #4]
  4085b0:	9300      	str	r3, [sp, #0]
  4085b2:	f04f 0300 	mov.w	r3, #0
  4085b6:	9301      	str	r3, [sp, #4]
  4085b8:	f04f 0300 	mov.w	r3, #0
  4085bc:	9302      	str	r3, [sp, #8]
  4085be:	f04f 0300 	mov.w	r3, #0
  4085c2:	9303      	str	r3, [sp, #12]
  4085c4:	f248 50f5 	movw	r0, #34293	; 0x85f5
  4085c8:	f2c0 0040 	movt	r0, #64	; 0x40
  4085cc:	f249 71a4 	movw	r1, #38820	; 0x97a4
  4085d0:	f2c0 0140 	movt	r1, #64	; 0x40
  4085d4:	f04f 0282 	mov.w	r2, #130	; 0x82
  4085d8:	f24a 734c 	movw	r3, #42828	; 0xa74c
  4085dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4085e0:	f244 0415 	movw	r4, #16405	; 0x4015
  4085e4:	f2c0 0440 	movt	r4, #64	; 0x40
  4085e8:	47a0      	blx	r4
}
  4085ea:	f107 070c 	add.w	r7, r7, #12
  4085ee:	46bd      	mov	sp, r7
  4085f0:	bd90      	pop	{r4, r7, pc}
  4085f2:	bf00      	nop

004085f4 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
  4085f4:	b590      	push	{r4, r7, lr}
  4085f6:	b087      	sub	sp, #28
  4085f8:	af00      	add	r7, sp, #0
  4085fa:	6078      	str	r0, [r7, #4]
unsigned short usValue = ( unsigned short ) 0;
  4085fc:	f04f 0300 	mov.w	r3, #0
  408600:	81fb      	strh	r3, [r7, #14]
signed portBASE_TYPE xError = pdFALSE, xLoop;
  408602:	f04f 0300 	mov.w	r3, #0
  408606:	617b      	str	r3, [r7, #20]

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
  408608:	f04f 0300 	mov.w	r3, #0
  40860c:	613b      	str	r3, [r7, #16]
  40860e:	e037      	b.n	408680 <vPolledQueueProducer+0x8c>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
  408610:	687b      	ldr	r3, [r7, #4]
  408612:	681a      	ldr	r2, [r3, #0]
  408614:	f107 030e 	add.w	r3, r7, #14
  408618:	4610      	mov	r0, r2
  40861a:	4619      	mov	r1, r3
  40861c:	f04f 0200 	mov.w	r2, #0
  408620:	f04f 0300 	mov.w	r3, #0
  408624:	f243 34f1 	movw	r4, #13297	; 0x33f1
  408628:	f2c0 0440 	movt	r4, #64	; 0x40
  40862c:	47a0      	blx	r4
  40862e:	4603      	mov	r3, r0
  408630:	2b01      	cmp	r3, #1
  408632:	d003      	beq.n	40863c <vPolledQueueProducer+0x48>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
  408634:	f04f 0301 	mov.w	r3, #1
  408638:	617b      	str	r3, [r7, #20]
  40863a:	e01d      	b.n	408678 <vPolledQueueProducer+0x84>
			}
			else
			{
				if( xError == pdFALSE )
  40863c:	697b      	ldr	r3, [r7, #20]
  40863e:	2b00      	cmp	r3, #0
  408640:	d115      	bne.n	40866e <vPolledQueueProducer+0x7a>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
  408642:	f642 6379 	movw	r3, #11897	; 0x2e79
  408646:	f2c0 0340 	movt	r3, #64	; 0x40
  40864a:	4798      	blx	r3
						xPollingProducerCount++;
  40864c:	f24a 7348 	movw	r3, #42824	; 0xa748
  408650:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408654:	681b      	ldr	r3, [r3, #0]
  408656:	f103 0201 	add.w	r2, r3, #1
  40865a:	f24a 7348 	movw	r3, #42824	; 0xa748
  40865e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408662:	601a      	str	r2, [r3, #0]
					portEXIT_CRITICAL();
  408664:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  408668:	f2c0 0340 	movt	r3, #64	; 0x40
  40866c:	4798      	blx	r3
				}

				/* Update the value we are going to post next time around. */
				usValue++;
  40866e:	89fb      	ldrh	r3, [r7, #14]
  408670:	f103 0301 	add.w	r3, r3, #1
  408674:	b29b      	uxth	r3, r3
  408676:	81fb      	strh	r3, [r7, #14]
unsigned short usValue = ( unsigned short ) 0;
signed portBASE_TYPE xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
  408678:	693b      	ldr	r3, [r7, #16]
  40867a:	f103 0301 	add.w	r3, r3, #1
  40867e:	613b      	str	r3, [r7, #16]
  408680:	693b      	ldr	r3, [r7, #16]
  408682:	2b02      	cmp	r3, #2
  408684:	ddc4      	ble.n	408610 <vPolledQueueProducer+0x1c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
  408686:	f04f 00c8 	mov.w	r0, #200	; 0xc8
  40868a:	f244 332d 	movw	r3, #17197	; 0x432d
  40868e:	f2c0 0340 	movt	r3, #64	; 0x40
  408692:	4798      	blx	r3
	}
  408694:	e7b8      	b.n	408608 <vPolledQueueProducer+0x14>
  408696:	bf00      	nop

00408698 <vPolledQueueConsumer>:
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
  408698:	b590      	push	{r4, r7, lr}
  40869a:	b087      	sub	sp, #28
  40869c:	af00      	add	r7, sp, #0
  40869e:	6078      	str	r0, [r7, #4]
unsigned short usData, usExpectedValue = ( unsigned short ) 0;
  4086a0:	f04f 0300 	mov.w	r3, #0
  4086a4:	82fb      	strh	r3, [r7, #22]
signed portBASE_TYPE xError = pdFALSE;
  4086a6:	f04f 0300 	mov.w	r3, #0
  4086aa:	613b      	str	r3, [r7, #16]

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
  4086ac:	e038      	b.n	408720 <vPolledQueueConsumer+0x88>
		{
			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
  4086ae:	687b      	ldr	r3, [r7, #4]
  4086b0:	681a      	ldr	r2, [r3, #0]
  4086b2:	f107 030e 	add.w	r3, r7, #14
  4086b6:	4610      	mov	r0, r2
  4086b8:	4619      	mov	r1, r3
  4086ba:	f04f 0200 	mov.w	r2, #0
  4086be:	f04f 0300 	mov.w	r3, #0
  4086c2:	f243 7469 	movw	r4, #14185	; 0x3769
  4086c6:	f2c0 0440 	movt	r4, #64	; 0x40
  4086ca:	47a0      	blx	r4
  4086cc:	4603      	mov	r3, r0
  4086ce:	2b01      	cmp	r3, #1
  4086d0:	d126      	bne.n	408720 <vPolledQueueConsumer+0x88>
			{
				if( usData != usExpectedValue )
  4086d2:	89fb      	ldrh	r3, [r7, #14]
  4086d4:	8afa      	ldrh	r2, [r7, #22]
  4086d6:	429a      	cmp	r2, r3
  4086d8:	d005      	beq.n	4086e6 <vPolledQueueConsumer+0x4e>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
  4086da:	f04f 0301 	mov.w	r3, #1
  4086de:	613b      	str	r3, [r7, #16]

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
  4086e0:	89fb      	ldrh	r3, [r7, #14]
  4086e2:	82fb      	strh	r3, [r7, #22]
  4086e4:	e018      	b.n	408718 <vPolledQueueConsumer+0x80>
				}
				else
				{
					if( xError == pdFALSE )
  4086e6:	693b      	ldr	r3, [r7, #16]
  4086e8:	2b00      	cmp	r3, #0
  4086ea:	d115      	bne.n	408718 <vPolledQueueConsumer+0x80>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
  4086ec:	f642 6379 	movw	r3, #11897	; 0x2e79
  4086f0:	f2c0 0340 	movt	r3, #64	; 0x40
  4086f4:	4798      	blx	r3
							xPollingConsumerCount++;
  4086f6:	f24a 7344 	movw	r3, #42820	; 0xa744
  4086fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4086fe:	681b      	ldr	r3, [r3, #0]
  408700:	f103 0201 	add.w	r2, r3, #1
  408704:	f24a 7344 	movw	r3, #42820	; 0xa744
  408708:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40870c:	601a      	str	r2, [r3, #0]
						portEXIT_CRITICAL();
  40870e:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  408712:	f2c0 0340 	movt	r3, #64	; 0x40
  408716:	4798      	blx	r3
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
  408718:	8afb      	ldrh	r3, [r7, #22]
  40871a:	f103 0301 	add.w	r3, r3, #1
  40871e:	82fb      	strh	r3, [r7, #22]
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
  408720:	687b      	ldr	r3, [r7, #4]
  408722:	681b      	ldr	r3, [r3, #0]
  408724:	4618      	mov	r0, r3
  408726:	f643 23bd 	movw	r3, #15037	; 0x3abd
  40872a:	f2c0 0340 	movt	r3, #64	; 0x40
  40872e:	4798      	blx	r3
  408730:	4603      	mov	r3, r0
  408732:	2b00      	cmp	r3, #0
  408734:	d1bb      	bne.n	4086ae <vPolledQueueConsumer+0x16>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
  408736:	f04f 00b4 	mov.w	r0, #180	; 0xb4
  40873a:	f244 332d 	movw	r3, #17197	; 0x432d
  40873e:	f2c0 0340 	movt	r3, #64	; 0x40
  408742:	4798      	blx	r3
	}
  408744:	bf00      	nop
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
  408746:	e7eb      	b.n	408720 <vPolledQueueConsumer+0x88>

00408748 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
portBASE_TYPE xArePollingQueuesStillRunning( void )
{
  408748:	b480      	push	{r7}
  40874a:	b083      	sub	sp, #12
  40874c:	af00      	add	r7, sp, #0

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
  40874e:	f24a 7344 	movw	r3, #42820	; 0xa744
  408752:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408756:	681b      	ldr	r3, [r3, #0]
  408758:	2b00      	cmp	r3, #0
  40875a:	d006      	beq.n	40876a <xArePollingQueuesStillRunning+0x22>
		( xPollingProducerCount == pollqINITIAL_VALUE )
  40875c:	f24a 7348 	movw	r3, #42824	; 0xa748
  408760:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408764:	681b      	ldr	r3, [r3, #0]

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
  408766:	2b00      	cmp	r3, #0
  408768:	d103      	bne.n	408772 <xArePollingQueuesStillRunning+0x2a>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
  40876a:	f04f 0300 	mov.w	r3, #0
  40876e:	607b      	str	r3, [r7, #4]
  408770:	e002      	b.n	408778 <xArePollingQueuesStillRunning+0x30>
	}
	else
	{
		xReturn = pdTRUE;
  408772:	f04f 0301 	mov.w	r3, #1
  408776:	607b      	str	r3, [r7, #4]
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
  408778:	f24a 7344 	movw	r3, #42820	; 0xa744
  40877c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408780:	f04f 0200 	mov.w	r2, #0
  408784:	601a      	str	r2, [r3, #0]
	xPollingProducerCount = pollqINITIAL_VALUE;
  408786:	f24a 7348 	movw	r3, #42824	; 0xa748
  40878a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40878e:	f04f 0200 	mov.w	r2, #0
  408792:	601a      	str	r2, [r3, #0]

	return xReturn;
  408794:	687b      	ldr	r3, [r7, #4]
}
  408796:	4618      	mov	r0, r3
  408798:	f107 070c 	add.w	r7, r7, #12
  40879c:	46bd      	mov	sp, r7
  40879e:	bc80      	pop	{r7}
  4087a0:	4770      	bx	lr
  4087a2:	bf00      	nop

004087a4 <vStartRecursiveMutexTasks>:
static xTaskHandle xControllingTaskHandle, xBlockingTaskHandle;

/*-----------------------------------------------------------*/

void vStartRecursiveMutexTasks( void )
{
  4087a4:	b590      	push	{r4, r7, lr}
  4087a6:	b085      	sub	sp, #20
  4087a8:	af04      	add	r7, sp, #16
	/* Just creates the mutex and the three tasks. */

	xMutex = xSemaphoreCreateRecursiveMutex();
  4087aa:	f04f 0004 	mov.w	r0, #4
  4087ae:	f243 13bd 	movw	r3, #12733	; 0x31bd
  4087b2:	f2c0 0340 	movt	r3, #64	; 0x40
  4087b6:	4798      	blx	r3
  4087b8:	4602      	mov	r2, r0
  4087ba:	f24a 7350 	movw	r3, #42832	; 0xa750
  4087be:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4087c2:	601a      	str	r2, [r3, #0]
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
	defined to be less than 1. */
	vQueueAddToRegistry( ( xQueueHandle ) xMutex, ( signed portCHAR * ) "Recursive_Mutex" );


	if( xMutex != NULL )
  4087c4:	f24a 7350 	movw	r3, #42832	; 0xa750
  4087c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4087cc:	681b      	ldr	r3, [r3, #0]
  4087ce:	2b00      	cmp	r3, #0
  4087d0:	d05a      	beq.n	408888 <vStartRecursiveMutexTasks+0xe4>
	{
		xTaskCreate( prvRecursiveMutexControllingTask, ( signed portCHAR * ) "Rec1", configMINIMAL_STACK_SIZE, NULL, recmuCONTROLLING_TASK_PRIORITY, &xControllingTaskHandle );
  4087d2:	f04f 0302 	mov.w	r3, #2
  4087d6:	9300      	str	r3, [sp, #0]
  4087d8:	f24a 736c 	movw	r3, #42860	; 0xa76c
  4087dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4087e0:	9301      	str	r3, [sp, #4]
  4087e2:	f04f 0300 	mov.w	r3, #0
  4087e6:	9302      	str	r3, [sp, #8]
  4087e8:	f04f 0300 	mov.w	r3, #0
  4087ec:	9303      	str	r3, [sp, #12]
  4087ee:	f648 0091 	movw	r0, #34961	; 0x8891
  4087f2:	f2c0 0040 	movt	r0, #64	; 0x40
  4087f6:	f249 71ac 	movw	r1, #38828	; 0x97ac
  4087fa:	f2c0 0140 	movt	r1, #64	; 0x40
  4087fe:	f04f 0282 	mov.w	r2, #130	; 0x82
  408802:	f04f 0300 	mov.w	r3, #0
  408806:	f244 0415 	movw	r4, #16405	; 0x4015
  40880a:	f2c0 0440 	movt	r4, #64	; 0x40
  40880e:	47a0      	blx	r4
        xTaskCreate( prvRecursiveMutexBlockingTask, ( signed portCHAR * ) "Rec2", configMINIMAL_STACK_SIZE, NULL, recmuBLOCKING_TASK_PRIORITY, &xBlockingTaskHandle );
  408810:	f04f 0301 	mov.w	r3, #1
  408814:	9300      	str	r3, [sp, #0]
  408816:	f24a 7370 	movw	r3, #42864	; 0xa770
  40881a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40881e:	9301      	str	r3, [sp, #4]
  408820:	f04f 0300 	mov.w	r3, #0
  408824:	9302      	str	r3, [sp, #8]
  408826:	f04f 0300 	mov.w	r3, #0
  40882a:	9303      	str	r3, [sp, #12]
  40882c:	f648 10d1 	movw	r0, #35281	; 0x89d1
  408830:	f2c0 0040 	movt	r0, #64	; 0x40
  408834:	f249 71b4 	movw	r1, #38836	; 0x97b4
  408838:	f2c0 0140 	movt	r1, #64	; 0x40
  40883c:	f04f 0282 	mov.w	r2, #130	; 0x82
  408840:	f04f 0300 	mov.w	r3, #0
  408844:	f244 0415 	movw	r4, #16405	; 0x4015
  408848:	f2c0 0440 	movt	r4, #64	; 0x40
  40884c:	47a0      	blx	r4
        xTaskCreate( prvRecursiveMutexPollingTask, ( signed portCHAR * ) "Rec3", configMINIMAL_STACK_SIZE, NULL, recmuPOLLING_TASK_PRIORITY, NULL );
  40884e:	f04f 0300 	mov.w	r3, #0
  408852:	9300      	str	r3, [sp, #0]
  408854:	f04f 0300 	mov.w	r3, #0
  408858:	9301      	str	r3, [sp, #4]
  40885a:	f04f 0300 	mov.w	r3, #0
  40885e:	9302      	str	r3, [sp, #8]
  408860:	f04f 0300 	mov.w	r3, #0
  408864:	9303      	str	r3, [sp, #12]
  408866:	f648 20c1 	movw	r0, #35521	; 0x8ac1
  40886a:	f2c0 0040 	movt	r0, #64	; 0x40
  40886e:	f249 71bc 	movw	r1, #38844	; 0x97bc
  408872:	f2c0 0140 	movt	r1, #64	; 0x40
  408876:	f04f 0282 	mov.w	r2, #130	; 0x82
  40887a:	f04f 0300 	mov.w	r3, #0
  40887e:	f244 0415 	movw	r4, #16405	; 0x4015
  408882:	f2c0 0440 	movt	r4, #64	; 0x40
  408886:	47a0      	blx	r4
	}
}
  408888:	f107 0704 	add.w	r7, r7, #4
  40888c:	46bd      	mov	sp, r7
  40888e:	bd90      	pop	{r4, r7, pc}

00408890 <prvRecursiveMutexControllingTask>:
/*-----------------------------------------------------------*/

static void prvRecursiveMutexControllingTask( void *pvParameters )
{
  408890:	b580      	push	{r7, lr}
  408892:	b084      	sub	sp, #16
  408894:	af00      	add	r7, sp, #0
  408896:	6078      	str	r0, [r7, #4]
	{
		/* Should not be able to 'give' the mutex, as we have not yet 'taken'
		it.   The first time through, the mutex will not have been used yet,
		subsequent times through, at this point the mutex will be held by the
		polling task. */
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
  408898:	f24a 7350 	movw	r3, #42832	; 0xa750
  40889c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4088a0:	681b      	ldr	r3, [r3, #0]
  4088a2:	4618      	mov	r0, r3
  4088a4:	f243 2389 	movw	r3, #12937	; 0x3289
  4088a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4088ac:	4798      	blx	r3
  4088ae:	4603      	mov	r3, r0
  4088b0:	2b01      	cmp	r3, #1
  4088b2:	d106      	bne.n	4088c2 <prvRecursiveMutexControllingTask+0x32>
		{
			xErrorOccurred = pdTRUE;
  4088b4:	f24a 7354 	movw	r3, #42836	; 0xa754
  4088b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4088bc:	f04f 0201 	mov.w	r2, #1
  4088c0:	601a      	str	r2, [r3, #0]
		}

		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
  4088c2:	f04f 0300 	mov.w	r3, #0
  4088c6:	60fb      	str	r3, [r7, #12]
  4088c8:	e021      	b.n	40890e <prvRecursiveMutexControllingTask+0x7e>
			at this point and this Take will cause the polling task to inherit
			the priority of this task.  In this case the block time must be
			long enough to ensure the polling task will execute again before the
			block time expires.  If the block time does expire then the error
			flag will be set here. */
			if( xSemaphoreTakeRecursive( xMutex, recmuFIVE_TICK_DELAY ) != pdPASS )
  4088ca:	f24a 7350 	movw	r3, #42832	; 0xa750
  4088ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4088d2:	681b      	ldr	r3, [r3, #0]
  4088d4:	4618      	mov	r0, r3
  4088d6:	f04f 0105 	mov.w	r1, #5
  4088da:	f243 3301 	movw	r3, #13057	; 0x3301
  4088de:	f2c0 0340 	movt	r3, #64	; 0x40
  4088e2:	4798      	blx	r3
  4088e4:	4603      	mov	r3, r0
  4088e6:	2b01      	cmp	r3, #1
  4088e8:	d006      	beq.n	4088f8 <prvRecursiveMutexControllingTask+0x68>
			{
				xErrorOccurred = pdTRUE;
  4088ea:	f24a 7354 	movw	r3, #42836	; 0xa754
  4088ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4088f2:	f04f 0201 	mov.w	r2, #1
  4088f6:	601a      	str	r2, [r3, #0]

			/* Ensure the other task attempting to access the mutex (and the
			other demo tasks) are able to execute to ensure they either block
			(where a block time is specified) or return an error (where no
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
  4088f8:	f04f 0014 	mov.w	r0, #20
  4088fc:	f244 332d 	movw	r3, #17197	; 0x432d
  408900:	f2c0 0340 	movt	r3, #64	; 0x40
  408904:	4798      	blx	r3
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
		{
			xErrorOccurred = pdTRUE;
		}

		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
  408906:	68fb      	ldr	r3, [r7, #12]
  408908:	f103 0301 	add.w	r3, r3, #1
  40890c:	60fb      	str	r3, [r7, #12]
  40890e:	68fb      	ldr	r3, [r7, #12]
  408910:	2b09      	cmp	r3, #9
  408912:	d9da      	bls.n	4088ca <prvRecursiveMutexControllingTask+0x3a>
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
		}

		/* For each time we took the mutex, give it back. */
		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
  408914:	f04f 0300 	mov.w	r3, #0
  408918:	60fb      	str	r3, [r7, #12]
  40891a:	e01f      	b.n	40895c <prvRecursiveMutexControllingTask+0xcc>
		{
			/* Ensure the other task attempting to access the mutex (and the
			other demo tasks) are able to execute. */
			vTaskDelay( recmuSHORT_DELAY );
  40891c:	f04f 0014 	mov.w	r0, #20
  408920:	f244 332d 	movw	r3, #17197	; 0x432d
  408924:	f2c0 0340 	movt	r3, #64	; 0x40
  408928:	4798      	blx	r3
			/* We should now be able to give the mutex as many times as we
			took it.  When the mutex is available again the Blocking task
			should be unblocked but not run because it has a lower priority
			than this task.  The polling task should also not run at this point
			as it too has a lower priority than this task. */
			if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
  40892a:	f24a 7350 	movw	r3, #42832	; 0xa750
  40892e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408932:	681b      	ldr	r3, [r3, #0]
  408934:	4618      	mov	r0, r3
  408936:	f243 2389 	movw	r3, #12937	; 0x3289
  40893a:	f2c0 0340 	movt	r3, #64	; 0x40
  40893e:	4798      	blx	r3
  408940:	4603      	mov	r3, r0
  408942:	2b01      	cmp	r3, #1
  408944:	d006      	beq.n	408954 <prvRecursiveMutexControllingTask+0xc4>
			{
				xErrorOccurred = pdTRUE;
  408946:	f24a 7354 	movw	r3, #42836	; 0xa754
  40894a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40894e:	f04f 0201 	mov.w	r2, #1
  408952:	601a      	str	r2, [r3, #0]
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
		}

		/* For each time we took the mutex, give it back. */
		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
  408954:	68fb      	ldr	r3, [r7, #12]
  408956:	f103 0301 	add.w	r3, r3, #1
  40895a:	60fb      	str	r3, [r7, #12]
  40895c:	68fb      	ldr	r3, [r7, #12]
  40895e:	2b09      	cmp	r3, #9
  408960:	d9dc      	bls.n	40891c <prvRecursiveMutexControllingTask+0x8c>
			}
		}

		/* Having given it back the same number of times as it was taken, we
		should no longer be the mutex owner, so the next give should fail. */
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
  408962:	f24a 7350 	movw	r3, #42832	; 0xa750
  408966:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40896a:	681b      	ldr	r3, [r3, #0]
  40896c:	4618      	mov	r0, r3
  40896e:	f243 2389 	movw	r3, #12937	; 0x3289
  408972:	f2c0 0340 	movt	r3, #64	; 0x40
  408976:	4798      	blx	r3
  408978:	4603      	mov	r3, r0
  40897a:	2b01      	cmp	r3, #1
  40897c:	d106      	bne.n	40898c <prvRecursiveMutexControllingTask+0xfc>
		{
			xErrorOccurred = pdTRUE;
  40897e:	f24a 7354 	movw	r3, #42836	; 0xa754
  408982:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408986:	f04f 0201 	mov.w	r2, #1
  40898a:	601a      	str	r2, [r3, #0]
		}

		/* Keep count of the number of cycles this task has performed so a
		stall can be detected. */
		uxControllingCycles++;
  40898c:	f24a 7360 	movw	r3, #42848	; 0xa760
  408990:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408994:	681b      	ldr	r3, [r3, #0]
  408996:	f103 0201 	add.w	r2, r3, #1
  40899a:	f24a 7360 	movw	r3, #42848	; 0xa760
  40899e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4089a2:	601a      	str	r2, [r3, #0]

		/* Suspend ourselves so the blocking task can execute. */
		xControllingIsSuspended = pdTRUE;
  4089a4:	f24a 7358 	movw	r3, #42840	; 0xa758
  4089a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4089ac:	f04f 0201 	mov.w	r2, #1
  4089b0:	601a      	str	r2, [r3, #0]
		vTaskSuspend( NULL );
  4089b2:	f04f 0000 	mov.w	r0, #0
  4089b6:	f244 53c9 	movw	r3, #17865	; 0x45c9
  4089ba:	f2c0 0340 	movt	r3, #64	; 0x40
  4089be:	4798      	blx	r3
		xControllingIsSuspended = pdFALSE;
  4089c0:	f24a 7358 	movw	r3, #42840	; 0xa758
  4089c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4089c8:	f04f 0200 	mov.w	r2, #0
  4089cc:	601a      	str	r2, [r3, #0]
	}
  4089ce:	e763      	b.n	408898 <prvRecursiveMutexControllingTask+0x8>

004089d0 <prvRecursiveMutexBlockingTask>:
}
/*-----------------------------------------------------------*/

static void prvRecursiveMutexBlockingTask( void *pvParameters )
{
  4089d0:	b580      	push	{r7, lr}
  4089d2:	b082      	sub	sp, #8
  4089d4:	af00      	add	r7, sp, #0
  4089d6:	6078      	str	r0, [r7, #4]
		this call should block until the controlling task has given up the
		mutex, and not actually execute	past this call until the controlling
		task is suspended.  portMAX_DELAY - 1 is used instead of portMAX_DELAY
		to ensure the task's state is reported as Blocked and not Suspended in
		a later call to configASSERT() (within the polling task). */
		if( xSemaphoreTakeRecursive( xMutex, ( portMAX_DELAY - 1 ) ) == pdPASS )
  4089d8:	f24a 7350 	movw	r3, #42832	; 0xa750
  4089dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4089e0:	681b      	ldr	r3, [r3, #0]
  4089e2:	4618      	mov	r0, r3
  4089e4:	f06f 0101 	mvn.w	r1, #1
  4089e8:	f243 3301 	movw	r3, #13057	; 0x3301
  4089ec:	f2c0 0340 	movt	r3, #64	; 0x40
  4089f0:	4798      	blx	r3
  4089f2:	4603      	mov	r3, r0
  4089f4:	2b01      	cmp	r3, #1
  4089f6:	d139      	bne.n	408a6c <prvRecursiveMutexBlockingTask+0x9c>
		{
			if( xControllingIsSuspended != pdTRUE )
  4089f8:	f24a 7358 	movw	r3, #42840	; 0xa758
  4089fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408a00:	681b      	ldr	r3, [r3, #0]
  408a02:	2b01      	cmp	r3, #1
  408a04:	d007      	beq.n	408a16 <prvRecursiveMutexBlockingTask+0x46>
			{
				/* Did not expect to execute until the controlling task was
				suspended. */
				xErrorOccurred = pdTRUE;
  408a06:	f24a 7354 	movw	r3, #42836	; 0xa754
  408a0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408a0e:	f04f 0201 	mov.w	r2, #1
  408a12:	601a      	str	r2, [r3, #0]
  408a14:	e031      	b.n	408a7a <prvRecursiveMutexBlockingTask+0xaa>
			}
			else
			{
				/* Give the mutex back before suspending ourselves to allow
				the polling task to obtain the mutex. */
				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
  408a16:	f24a 7350 	movw	r3, #42832	; 0xa750
  408a1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408a1e:	681b      	ldr	r3, [r3, #0]
  408a20:	4618      	mov	r0, r3
  408a22:	f243 2389 	movw	r3, #12937	; 0x3289
  408a26:	f2c0 0340 	movt	r3, #64	; 0x40
  408a2a:	4798      	blx	r3
  408a2c:	4603      	mov	r3, r0
  408a2e:	2b01      	cmp	r3, #1
  408a30:	d006      	beq.n	408a40 <prvRecursiveMutexBlockingTask+0x70>
				{
					xErrorOccurred = pdTRUE;
  408a32:	f24a 7354 	movw	r3, #42836	; 0xa754
  408a36:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408a3a:	f04f 0201 	mov.w	r2, #1
  408a3e:	601a      	str	r2, [r3, #0]
				}

				xBlockingIsSuspended = pdTRUE;
  408a40:	f24a 735c 	movw	r3, #42844	; 0xa75c
  408a44:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408a48:	f04f 0201 	mov.w	r2, #1
  408a4c:	601a      	str	r2, [r3, #0]
				vTaskSuspend( NULL );
  408a4e:	f04f 0000 	mov.w	r0, #0
  408a52:	f244 53c9 	movw	r3, #17865	; 0x45c9
  408a56:	f2c0 0340 	movt	r3, #64	; 0x40
  408a5a:	4798      	blx	r3
				xBlockingIsSuspended = pdFALSE;
  408a5c:	f24a 735c 	movw	r3, #42844	; 0xa75c
  408a60:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408a64:	f04f 0200 	mov.w	r2, #0
  408a68:	601a      	str	r2, [r3, #0]
  408a6a:	e006      	b.n	408a7a <prvRecursiveMutexBlockingTask+0xaa>
		}
		else
		{
			/* We should not leave the xSemaphoreTakeRecursive() function
			until the mutex was obtained. */
			xErrorOccurred = pdTRUE;
  408a6c:	f24a 7354 	movw	r3, #42836	; 0xa754
  408a70:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408a74:	f04f 0201 	mov.w	r2, #1
  408a78:	601a      	str	r2, [r3, #0]
		}

		/* The controlling and blocking tasks should be in lock step. */
		if( uxControllingCycles != ( uxBlockingCycles + 1 ) )
  408a7a:	f24a 7364 	movw	r3, #42852	; 0xa764
  408a7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408a82:	681b      	ldr	r3, [r3, #0]
  408a84:	f103 0201 	add.w	r2, r3, #1
  408a88:	f24a 7360 	movw	r3, #42848	; 0xa760
  408a8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408a90:	681b      	ldr	r3, [r3, #0]
  408a92:	429a      	cmp	r2, r3
  408a94:	d006      	beq.n	408aa4 <prvRecursiveMutexBlockingTask+0xd4>
		{
			xErrorOccurred = pdTRUE;
  408a96:	f24a 7354 	movw	r3, #42836	; 0xa754
  408a9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408a9e:	f04f 0201 	mov.w	r2, #1
  408aa2:	601a      	str	r2, [r3, #0]
		}

		/* Keep count of the number of cycles this task has performed so a
		stall can be detected. */
		uxBlockingCycles++;
  408aa4:	f24a 7364 	movw	r3, #42852	; 0xa764
  408aa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408aac:	681b      	ldr	r3, [r3, #0]
  408aae:	f103 0201 	add.w	r2, r3, #1
  408ab2:	f24a 7364 	movw	r3, #42852	; 0xa764
  408ab6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408aba:	601a      	str	r2, [r3, #0]
	}
  408abc:	e78c      	b.n	4089d8 <prvRecursiveMutexBlockingTask+0x8>
  408abe:	bf00      	nop

00408ac0 <prvRecursiveMutexPollingTask>:
}
/*-----------------------------------------------------------*/

static void prvRecursiveMutexPollingTask( void *pvParameters )
{
  408ac0:	b580      	push	{r7, lr}
  408ac2:	b082      	sub	sp, #8
  408ac4:	af00      	add	r7, sp, #0
  408ac6:	6078      	str	r0, [r7, #4]
  408ac8:	e000      	b.n	408acc <prvRecursiveMutexPollingTask+0xc>
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
  408aca:	bf00      	nop
	for( ;; )
	{
		/* Keep attempting to obtain the mutex.  We should only obtain it when
		the blocking task has suspended itself, which in turn should only
		happen when the controlling task is also suspended. */
		if( xSemaphoreTakeRecursive( xMutex, recmuNO_DELAY ) == pdPASS )
  408acc:	f24a 7350 	movw	r3, #42832	; 0xa750
  408ad0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408ad4:	681b      	ldr	r3, [r3, #0]
  408ad6:	4618      	mov	r0, r3
  408ad8:	f04f 0100 	mov.w	r1, #0
  408adc:	f243 3301 	movw	r3, #13057	; 0x3301
  408ae0:	f2c0 0340 	movt	r3, #64	; 0x40
  408ae4:	4798      	blx	r3
  408ae6:	4603      	mov	r3, r0
  408ae8:	2b01      	cmp	r3, #1
  408aea:	d1ee      	bne.n	408aca <prvRecursiveMutexPollingTask+0xa>
				configASSERT( eTaskGetState( xBlockingTaskHandle ) == eSuspended );
			}
			#endif /* INCLUDE_eTaskGetState */

			/* Is the blocking task suspended? */
			if( ( xBlockingIsSuspended != pdTRUE ) || ( xControllingIsSuspended != pdTRUE ) )
  408aec:	f24a 735c 	movw	r3, #42844	; 0xa75c
  408af0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408af4:	681b      	ldr	r3, [r3, #0]
  408af6:	2b01      	cmp	r3, #1
  408af8:	d106      	bne.n	408b08 <prvRecursiveMutexPollingTask+0x48>
  408afa:	f24a 7358 	movw	r3, #42840	; 0xa758
  408afe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408b02:	681b      	ldr	r3, [r3, #0]
  408b04:	2b01      	cmp	r3, #1
  408b06:	d007      	beq.n	408b18 <prvRecursiveMutexPollingTask+0x58>
			{
				xErrorOccurred = pdTRUE;
  408b08:	f24a 7354 	movw	r3, #42836	; 0xa754
  408b0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408b10:	f04f 0201 	mov.w	r2, #1
  408b14:	601a      	str	r2, [r3, #0]
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
  408b16:	e7d8      	b.n	408aca <prvRecursiveMutexPollingTask+0xa>
			}
			else
			{
				/* Keep count of the number of cycles this task has performed
				so a stall can be detected. */
				uxPollingCycles++;
  408b18:	f24a 7368 	movw	r3, #42856	; 0xa768
  408b1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408b20:	681b      	ldr	r3, [r3, #0]
  408b22:	f103 0201 	add.w	r2, r3, #1
  408b26:	f24a 7368 	movw	r3, #42856	; 0xa768
  408b2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408b2e:	601a      	str	r2, [r3, #0]
				will then inherit the higher priority.  The Blocking task will
				block indefinitely when it attempts to obtain the mutex, the
				Controlling task will only block for a fixed period and an
				error will be latched if the polling task has not returned the
				mutex by the time this fixed period has expired. */
				vTaskResume( xBlockingTaskHandle );
  408b30:	f24a 7370 	movw	r3, #42864	; 0xa770
  408b34:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408b38:	681b      	ldr	r3, [r3, #0]
  408b3a:	4618      	mov	r0, r3
  408b3c:	f244 736d 	movw	r3, #18285	; 0x476d
  408b40:	f2c0 0340 	movt	r3, #64	; 0x40
  408b44:	4798      	blx	r3
                vTaskResume( xControllingTaskHandle );
  408b46:	f24a 736c 	movw	r3, #42860	; 0xa76c
  408b4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408b4e:	681b      	ldr	r3, [r3, #0]
  408b50:	4618      	mov	r0, r3
  408b52:	f244 736d 	movw	r3, #18285	; 0x476d
  408b56:	f2c0 0340 	movt	r3, #64	; 0x40
  408b5a:	4798      	blx	r3

				/* The other two tasks should now have executed and no longer
				be suspended. */
				if( ( xBlockingIsSuspended == pdTRUE ) || ( xControllingIsSuspended == pdTRUE ) )
  408b5c:	f24a 735c 	movw	r3, #42844	; 0xa75c
  408b60:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408b64:	681b      	ldr	r3, [r3, #0]
  408b66:	2b01      	cmp	r3, #1
  408b68:	d006      	beq.n	408b78 <prvRecursiveMutexPollingTask+0xb8>
  408b6a:	f24a 7358 	movw	r3, #42840	; 0xa758
  408b6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408b72:	681b      	ldr	r3, [r3, #0]
  408b74:	2b01      	cmp	r3, #1
  408b76:	d106      	bne.n	408b86 <prvRecursiveMutexPollingTask+0xc6>
				{
					xErrorOccurred = pdTRUE;
  408b78:	f24a 7354 	movw	r3, #42836	; 0xa754
  408b7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408b80:	f04f 0201 	mov.w	r2, #1
  408b84:	601a      	str	r2, [r3, #0]
				}

				#if( INCLUDE_uxTaskPriorityGet == 1 )
				{
					/* Check priority inherited. */
					configASSERT( uxTaskPriorityGet( NULL ) == recmuCONTROLLING_TASK_PRIORITY );
  408b86:	f04f 0000 	mov.w	r0, #0
  408b8a:	f244 33d9 	movw	r3, #17369	; 0x43d9
  408b8e:	f2c0 0340 	movt	r3, #64	; 0x40
  408b92:	4798      	blx	r3
  408b94:	4603      	mov	r3, r0
  408b96:	2b02      	cmp	r3, #2
  408b98:	d005      	beq.n	408ba6 <prvRecursiveMutexPollingTask+0xe6>
  408b9a:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  408b9e:	f2c0 0340 	movt	r3, #64	; 0x40
  408ba2:	4798      	blx	r3
  408ba4:	e7fe      	b.n	408ba4 <prvRecursiveMutexPollingTask+0xe4>
					configASSERT( eTaskGetState( xBlockingTaskHandle ) == eBlocked );
				}
				#endif /* INCLUDE_eTaskGetState */

				/* Release the mutex, disinheriting the higher priority again. */
				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
  408ba6:	f24a 7350 	movw	r3, #42832	; 0xa750
  408baa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408bae:	681b      	ldr	r3, [r3, #0]
  408bb0:	4618      	mov	r0, r3
  408bb2:	f243 2389 	movw	r3, #12937	; 0x3289
  408bb6:	f2c0 0340 	movt	r3, #64	; 0x40
  408bba:	4798      	blx	r3
  408bbc:	4603      	mov	r3, r0
  408bbe:	2b01      	cmp	r3, #1
  408bc0:	d006      	beq.n	408bd0 <prvRecursiveMutexPollingTask+0x110>
				{
					xErrorOccurred = pdTRUE;
  408bc2:	f24a 7354 	movw	r3, #42836	; 0xa754
  408bc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408bca:	f04f 0201 	mov.w	r2, #1
  408bce:	601a      	str	r2, [r3, #0]
				}

				#if( INCLUDE_uxTaskPriorityGet == 1 )
				{
					/* Check priority disinherited. */
					configASSERT( uxTaskPriorityGet( NULL ) == recmuPOLLING_TASK_PRIORITY );
  408bd0:	f04f 0000 	mov.w	r0, #0
  408bd4:	f244 33d9 	movw	r3, #17369	; 0x43d9
  408bd8:	f2c0 0340 	movt	r3, #64	; 0x40
  408bdc:	4798      	blx	r3
  408bde:	4603      	mov	r3, r0
  408be0:	2b00      	cmp	r3, #0
  408be2:	f43f af72 	beq.w	408aca <prvRecursiveMutexPollingTask+0xa>
  408be6:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  408bea:	f2c0 0340 	movt	r3, #64	; 0x40
  408bee:	4798      	blx	r3
  408bf0:	e7fe      	b.n	408bf0 <prvRecursiveMutexPollingTask+0x130>
  408bf2:	bf00      	nop

00408bf4 <xAreRecursiveMutexTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreRecursiveMutexTasksStillRunning( void )
{
  408bf4:	b480      	push	{r7}
  408bf6:	b083      	sub	sp, #12
  408bf8:	af00      	add	r7, sp, #0
portBASE_TYPE xReturn;
static unsigned portBASE_TYPE uxLastControllingCycles = 0, uxLastBlockingCycles = 0, uxLastPollingCycles = 0;

	/* Is the controlling task still cycling? */
	if( uxLastControllingCycles == uxControllingCycles )
  408bfa:	f24a 7374 	movw	r3, #42868	; 0xa774
  408bfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c02:	681a      	ldr	r2, [r3, #0]
  408c04:	f24a 7360 	movw	r3, #42848	; 0xa760
  408c08:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c0c:	681b      	ldr	r3, [r3, #0]
  408c0e:	429a      	cmp	r2, r3
  408c10:	d107      	bne.n	408c22 <xAreRecursiveMutexTasksStillRunning+0x2e>
	{
		xErrorOccurred = pdTRUE;
  408c12:	f24a 7354 	movw	r3, #42836	; 0xa754
  408c16:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c1a:	f04f 0201 	mov.w	r2, #1
  408c1e:	601a      	str	r2, [r3, #0]
  408c20:	e009      	b.n	408c36 <xAreRecursiveMutexTasksStillRunning+0x42>
	}
	else
	{
		uxLastControllingCycles = uxControllingCycles;
  408c22:	f24a 7360 	movw	r3, #42848	; 0xa760
  408c26:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c2a:	681a      	ldr	r2, [r3, #0]
  408c2c:	f24a 7374 	movw	r3, #42868	; 0xa774
  408c30:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c34:	601a      	str	r2, [r3, #0]
	}

	/* Is the blocking task still cycling? */
	if( uxLastBlockingCycles == uxBlockingCycles )
  408c36:	f24a 7378 	movw	r3, #42872	; 0xa778
  408c3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c3e:	681a      	ldr	r2, [r3, #0]
  408c40:	f24a 7364 	movw	r3, #42852	; 0xa764
  408c44:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c48:	681b      	ldr	r3, [r3, #0]
  408c4a:	429a      	cmp	r2, r3
  408c4c:	d107      	bne.n	408c5e <xAreRecursiveMutexTasksStillRunning+0x6a>
	{
		xErrorOccurred = pdTRUE;
  408c4e:	f24a 7354 	movw	r3, #42836	; 0xa754
  408c52:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c56:	f04f 0201 	mov.w	r2, #1
  408c5a:	601a      	str	r2, [r3, #0]
  408c5c:	e009      	b.n	408c72 <xAreRecursiveMutexTasksStillRunning+0x7e>
	}
	else
	{
		uxLastBlockingCycles = uxBlockingCycles;
  408c5e:	f24a 7364 	movw	r3, #42852	; 0xa764
  408c62:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c66:	681a      	ldr	r2, [r3, #0]
  408c68:	f24a 7378 	movw	r3, #42872	; 0xa778
  408c6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c70:	601a      	str	r2, [r3, #0]
	}

	/* Is the polling task still cycling? */
	if( uxLastPollingCycles == uxPollingCycles )
  408c72:	f24a 737c 	movw	r3, #42876	; 0xa77c
  408c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c7a:	681a      	ldr	r2, [r3, #0]
  408c7c:	f24a 7368 	movw	r3, #42856	; 0xa768
  408c80:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c84:	681b      	ldr	r3, [r3, #0]
  408c86:	429a      	cmp	r2, r3
  408c88:	d107      	bne.n	408c9a <xAreRecursiveMutexTasksStillRunning+0xa6>
	{
		xErrorOccurred = pdTRUE;
  408c8a:	f24a 7354 	movw	r3, #42836	; 0xa754
  408c8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408c92:	f04f 0201 	mov.w	r2, #1
  408c96:	601a      	str	r2, [r3, #0]
  408c98:	e009      	b.n	408cae <xAreRecursiveMutexTasksStillRunning+0xba>
	}
	else
	{
		uxLastPollingCycles = uxPollingCycles;
  408c9a:	f24a 7368 	movw	r3, #42856	; 0xa768
  408c9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408ca2:	681a      	ldr	r2, [r3, #0]
  408ca4:	f24a 737c 	movw	r3, #42876	; 0xa77c
  408ca8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408cac:	601a      	str	r2, [r3, #0]
	}

	if( xErrorOccurred == pdTRUE )
  408cae:	f24a 7354 	movw	r3, #42836	; 0xa754
  408cb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408cb6:	681b      	ldr	r3, [r3, #0]
  408cb8:	2b01      	cmp	r3, #1
  408cba:	d103      	bne.n	408cc4 <xAreRecursiveMutexTasksStillRunning+0xd0>
	{
		xReturn = pdFAIL;
  408cbc:	f04f 0300 	mov.w	r3, #0
  408cc0:	607b      	str	r3, [r7, #4]
  408cc2:	e002      	b.n	408cca <xAreRecursiveMutexTasksStillRunning+0xd6>
	}
	else
	{
		xReturn = pdTRUE;
  408cc4:	f04f 0301 	mov.w	r3, #1
  408cc8:	607b      	str	r3, [r7, #4]
	}

	return xReturn;
  408cca:	687b      	ldr	r3, [r7, #4]
}
  408ccc:	4618      	mov	r0, r3
  408cce:	f107 070c 	add.w	r7, r7, #12
  408cd2:	46bd      	mov	sp, r7
  408cd4:	bc80      	pop	{r7}
  408cd6:	4770      	bx	lr

00408cd8 <vStartSemaphoreTasks>:
static volatile short sNextCheckVariable = 0;

/*-----------------------------------------------------------*/

void vStartSemaphoreTasks( unsigned portBASE_TYPE uxPriority )
{
  408cd8:	b590      	push	{r4, r7, lr}
  408cda:	b08b      	sub	sp, #44	; 0x2c
  408cdc:	af04      	add	r7, sp, #16
  408cde:	6078      	str	r0, [r7, #4]
xSemaphoreParameters *pxFirstSemaphoreParameters, *pxSecondSemaphoreParameters;
const portTickType xBlockTime = ( portTickType ) 100;
  408ce0:	f04f 0364 	mov.w	r3, #100	; 0x64
  408ce4:	617b      	str	r3, [r7, #20]

	/* Create the structure used to pass parameters to the first two tasks. */
	pxFirstSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
  408ce6:	f04f 000c 	mov.w	r0, #12
  408cea:	f240 5345 	movw	r3, #1349	; 0x545
  408cee:	f2c0 0340 	movt	r3, #64	; 0x40
  408cf2:	4798      	blx	r3
  408cf4:	6138      	str	r0, [r7, #16]

	if( pxFirstSemaphoreParameters != NULL )
  408cf6:	693b      	ldr	r3, [r7, #16]
  408cf8:	2b00      	cmp	r3, #0
  408cfa:	d06a      	beq.n	408dd2 <vStartSemaphoreTasks+0xfa>
	{
		/* Create the semaphore used by the first two tasks. */
		pxFirstSemaphoreParameters->xSemaphore = xSemaphoreCreateBinary();
  408cfc:	f04f 0001 	mov.w	r0, #1
  408d00:	f04f 0100 	mov.w	r1, #0
  408d04:	f04f 0203 	mov.w	r2, #3
  408d08:	f243 1311 	movw	r3, #12561	; 0x3111
  408d0c:	f2c0 0340 	movt	r3, #64	; 0x40
  408d10:	4798      	blx	r3
  408d12:	4602      	mov	r2, r0
  408d14:	693b      	ldr	r3, [r7, #16]
  408d16:	601a      	str	r2, [r3, #0]
		xSemaphoreGive( pxFirstSemaphoreParameters->xSemaphore );
  408d18:	693b      	ldr	r3, [r7, #16]
  408d1a:	681b      	ldr	r3, [r3, #0]
  408d1c:	4618      	mov	r0, r3
  408d1e:	f04f 0100 	mov.w	r1, #0
  408d22:	f04f 0200 	mov.w	r2, #0
  408d26:	f04f 0300 	mov.w	r3, #0
  408d2a:	f243 34f1 	movw	r4, #13297	; 0x33f1
  408d2e:	f2c0 0440 	movt	r4, #64	; 0x40
  408d32:	47a0      	blx	r4

		if( pxFirstSemaphoreParameters->xSemaphore != NULL )
  408d34:	693b      	ldr	r3, [r7, #16]
  408d36:	681b      	ldr	r3, [r3, #0]
  408d38:	2b00      	cmp	r3, #0
  408d3a:	d04a      	beq.n	408dd2 <vStartSemaphoreTasks+0xfa>
		{
			/* Create the variable which is to be shared by the first two tasks. */
			pxFirstSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
  408d3c:	f04f 0004 	mov.w	r0, #4
  408d40:	f240 5345 	movw	r3, #1349	; 0x545
  408d44:	f2c0 0340 	movt	r3, #64	; 0x40
  408d48:	4798      	blx	r3
  408d4a:	4602      	mov	r2, r0
  408d4c:	693b      	ldr	r3, [r7, #16]
  408d4e:	605a      	str	r2, [r3, #4]

			/* Initialise the share variable to the value the tasks expect. */
			*( pxFirstSemaphoreParameters->pulSharedVariable ) = semtstNON_BLOCKING_EXPECTED_VALUE;
  408d50:	693b      	ldr	r3, [r7, #16]
  408d52:	685b      	ldr	r3, [r3, #4]
  408d54:	f04f 02ff 	mov.w	r2, #255	; 0xff
  408d58:	601a      	str	r2, [r3, #0]

			/* The first two tasks do not block on semaphore calls. */
			pxFirstSemaphoreParameters->xBlockTime = ( portTickType ) 0;
  408d5a:	693b      	ldr	r3, [r7, #16]
  408d5c:	f04f 0200 	mov.w	r2, #0
  408d60:	609a      	str	r2, [r3, #8]

			/* Spawn the first two tasks.  As they poll they operate at the idle priority. */
			xTaskCreate( prvSemaphoreTest, ( signed char * ) "PolSEM1", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
  408d62:	f04f 0300 	mov.w	r3, #0
  408d66:	9300      	str	r3, [sp, #0]
  408d68:	f04f 0300 	mov.w	r3, #0
  408d6c:	9301      	str	r3, [sp, #4]
  408d6e:	f04f 0300 	mov.w	r3, #0
  408d72:	9302      	str	r3, [sp, #8]
  408d74:	f04f 0300 	mov.w	r3, #0
  408d78:	9303      	str	r3, [sp, #12]
  408d7a:	f648 60c1 	movw	r0, #36545	; 0x8ec1
  408d7e:	f2c0 0040 	movt	r0, #64	; 0x40
  408d82:	f249 71c4 	movw	r1, #38852	; 0x97c4
  408d86:	f2c0 0140 	movt	r1, #64	; 0x40
  408d8a:	f04f 0282 	mov.w	r2, #130	; 0x82
  408d8e:	693b      	ldr	r3, [r7, #16]
  408d90:	f244 0415 	movw	r4, #16405	; 0x4015
  408d94:	f2c0 0440 	movt	r4, #64	; 0x40
  408d98:	47a0      	blx	r4
			xTaskCreate( prvSemaphoreTest, ( signed char * ) "PolSEM2", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
  408d9a:	f04f 0300 	mov.w	r3, #0
  408d9e:	9300      	str	r3, [sp, #0]
  408da0:	f04f 0300 	mov.w	r3, #0
  408da4:	9301      	str	r3, [sp, #4]
  408da6:	f04f 0300 	mov.w	r3, #0
  408daa:	9302      	str	r3, [sp, #8]
  408dac:	f04f 0300 	mov.w	r3, #0
  408db0:	9303      	str	r3, [sp, #12]
  408db2:	f648 60c1 	movw	r0, #36545	; 0x8ec1
  408db6:	f2c0 0040 	movt	r0, #64	; 0x40
  408dba:	f249 71cc 	movw	r1, #38860	; 0x97cc
  408dbe:	f2c0 0140 	movt	r1, #64	; 0x40
  408dc2:	f04f 0282 	mov.w	r2, #130	; 0x82
  408dc6:	693b      	ldr	r3, [r7, #16]
  408dc8:	f244 0415 	movw	r4, #16405	; 0x4015
  408dcc:	f2c0 0440 	movt	r4, #64	; 0x40
  408dd0:	47a0      	blx	r4
		}
	}

	/* Do exactly the same to create the second set of tasks, only this time 
	provide a block time for the semaphore calls. */
	pxSecondSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
  408dd2:	f04f 000c 	mov.w	r0, #12
  408dd6:	f240 5345 	movw	r3, #1349	; 0x545
  408dda:	f2c0 0340 	movt	r3, #64	; 0x40
  408dde:	4798      	blx	r3
  408de0:	60f8      	str	r0, [r7, #12]
	if( pxSecondSemaphoreParameters != NULL )
  408de2:	68fb      	ldr	r3, [r7, #12]
  408de4:	2b00      	cmp	r3, #0
  408de6:	d067      	beq.n	408eb8 <vStartSemaphoreTasks+0x1e0>
	{
		pxSecondSemaphoreParameters->xSemaphore = xSemaphoreCreateBinary();
  408de8:	f04f 0001 	mov.w	r0, #1
  408dec:	f04f 0100 	mov.w	r1, #0
  408df0:	f04f 0203 	mov.w	r2, #3
  408df4:	f243 1311 	movw	r3, #12561	; 0x3111
  408df8:	f2c0 0340 	movt	r3, #64	; 0x40
  408dfc:	4798      	blx	r3
  408dfe:	4602      	mov	r2, r0
  408e00:	68fb      	ldr	r3, [r7, #12]
  408e02:	601a      	str	r2, [r3, #0]
		xSemaphoreGive( pxSecondSemaphoreParameters->xSemaphore );
  408e04:	68fb      	ldr	r3, [r7, #12]
  408e06:	681b      	ldr	r3, [r3, #0]
  408e08:	4618      	mov	r0, r3
  408e0a:	f04f 0100 	mov.w	r1, #0
  408e0e:	f04f 0200 	mov.w	r2, #0
  408e12:	f04f 0300 	mov.w	r3, #0
  408e16:	f243 34f1 	movw	r4, #13297	; 0x33f1
  408e1a:	f2c0 0440 	movt	r4, #64	; 0x40
  408e1e:	47a0      	blx	r4

		if( pxSecondSemaphoreParameters->xSemaphore != NULL )
  408e20:	68fb      	ldr	r3, [r7, #12]
  408e22:	681b      	ldr	r3, [r3, #0]
  408e24:	2b00      	cmp	r3, #0
  408e26:	d047      	beq.n	408eb8 <vStartSemaphoreTasks+0x1e0>
		{
			pxSecondSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
  408e28:	f04f 0004 	mov.w	r0, #4
  408e2c:	f240 5345 	movw	r3, #1349	; 0x545
  408e30:	f2c0 0340 	movt	r3, #64	; 0x40
  408e34:	4798      	blx	r3
  408e36:	4602      	mov	r2, r0
  408e38:	68fb      	ldr	r3, [r7, #12]
  408e3a:	605a      	str	r2, [r3, #4]
			*( pxSecondSemaphoreParameters->pulSharedVariable ) = semtstBLOCKING_EXPECTED_VALUE;
  408e3c:	68fb      	ldr	r3, [r7, #12]
  408e3e:	685b      	ldr	r3, [r3, #4]
  408e40:	f640 72ff 	movw	r2, #4095	; 0xfff
  408e44:	601a      	str	r2, [r3, #0]
			pxSecondSemaphoreParameters->xBlockTime = xBlockTime / portTICK_RATE_MS;
  408e46:	68fb      	ldr	r3, [r7, #12]
  408e48:	697a      	ldr	r2, [r7, #20]
  408e4a:	609a      	str	r2, [r3, #8]

			xTaskCreate( prvSemaphoreTest, ( signed char * ) "BlkSEM1", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( xTaskHandle * ) NULL );
  408e4c:	687b      	ldr	r3, [r7, #4]
  408e4e:	9300      	str	r3, [sp, #0]
  408e50:	f04f 0300 	mov.w	r3, #0
  408e54:	9301      	str	r3, [sp, #4]
  408e56:	f04f 0300 	mov.w	r3, #0
  408e5a:	9302      	str	r3, [sp, #8]
  408e5c:	f04f 0300 	mov.w	r3, #0
  408e60:	9303      	str	r3, [sp, #12]
  408e62:	f648 60c1 	movw	r0, #36545	; 0x8ec1
  408e66:	f2c0 0040 	movt	r0, #64	; 0x40
  408e6a:	f249 71d4 	movw	r1, #38868	; 0x97d4
  408e6e:	f2c0 0140 	movt	r1, #64	; 0x40
  408e72:	f04f 0282 	mov.w	r2, #130	; 0x82
  408e76:	68fb      	ldr	r3, [r7, #12]
  408e78:	f244 0415 	movw	r4, #16405	; 0x4015
  408e7c:	f2c0 0440 	movt	r4, #64	; 0x40
  408e80:	47a0      	blx	r4
			xTaskCreate( prvSemaphoreTest, ( signed char * ) "BlkSEM2", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( xTaskHandle * ) NULL );
  408e82:	687b      	ldr	r3, [r7, #4]
  408e84:	9300      	str	r3, [sp, #0]
  408e86:	f04f 0300 	mov.w	r3, #0
  408e8a:	9301      	str	r3, [sp, #4]
  408e8c:	f04f 0300 	mov.w	r3, #0
  408e90:	9302      	str	r3, [sp, #8]
  408e92:	f04f 0300 	mov.w	r3, #0
  408e96:	9303      	str	r3, [sp, #12]
  408e98:	f648 60c1 	movw	r0, #36545	; 0x8ec1
  408e9c:	f2c0 0040 	movt	r0, #64	; 0x40
  408ea0:	f249 71dc 	movw	r1, #38876	; 0x97dc
  408ea4:	f2c0 0140 	movt	r1, #64	; 0x40
  408ea8:	f04f 0282 	mov.w	r2, #130	; 0x82
  408eac:	68fb      	ldr	r3, [r7, #12]
  408eae:	f244 0415 	movw	r4, #16405	; 0x4015
  408eb2:	f2c0 0440 	movt	r4, #64	; 0x40
  408eb6:	47a0      	blx	r4
	is not being used.  The call to vQueueAddToRegistry() will be removed
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( ( xQueueHandle ) pxFirstSemaphoreParameters->xSemaphore, ( signed char * ) "Counting_Sem_1" );
	vQueueAddToRegistry( ( xQueueHandle ) pxSecondSemaphoreParameters->xSemaphore, ( signed char * ) "Counting_Sem_2" );
}
  408eb8:	f107 071c 	add.w	r7, r7, #28
  408ebc:	46bd      	mov	sp, r7
  408ebe:	bd90      	pop	{r4, r7, pc}

00408ec0 <prvSemaphoreTest>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvSemaphoreTest, pvParameters )
{
  408ec0:	b590      	push	{r4, r7, lr}
  408ec2:	b089      	sub	sp, #36	; 0x24
  408ec4:	af00      	add	r7, sp, #0
  408ec6:	6078      	str	r0, [r7, #4]
xSemaphoreParameters *pxParameters;
volatile unsigned long *pulSharedVariable, ulExpectedValue;
unsigned long ulCounter;
short sError = pdFALSE, sCheckVariableToUse;
  408ec8:	f04f 0300 	mov.w	r3, #0
  408ecc:	837b      	strh	r3, [r7, #26]

	/* See which check variable to use.  sNextCheckVariable is not semaphore 
	protected! */
	portENTER_CRITICAL();
  408ece:	f642 6379 	movw	r3, #11897	; 0x2e79
  408ed2:	f2c0 0340 	movt	r3, #64	; 0x40
  408ed6:	4798      	blx	r3
		sCheckVariableToUse = sNextCheckVariable;
  408ed8:	f24a 7388 	movw	r3, #42888	; 0xa788
  408edc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408ee0:	881b      	ldrh	r3, [r3, #0]
  408ee2:	833b      	strh	r3, [r7, #24]
		sNextCheckVariable++;
  408ee4:	f24a 7388 	movw	r3, #42888	; 0xa788
  408ee8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408eec:	881b      	ldrh	r3, [r3, #0]
  408eee:	b29b      	uxth	r3, r3
  408ef0:	f103 0301 	add.w	r3, r3, #1
  408ef4:	b29a      	uxth	r2, r3
  408ef6:	f24a 7388 	movw	r3, #42888	; 0xa788
  408efa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408efe:	801a      	strh	r2, [r3, #0]
	portEXIT_CRITICAL();
  408f00:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  408f04:	f2c0 0340 	movt	r3, #64	; 0x40
  408f08:	4798      	blx	r3

	/* A structure is passed in as the parameter.  This contains the shared 
	variable being guarded. */
	pxParameters = ( xSemaphoreParameters * ) pvParameters;
  408f0a:	687b      	ldr	r3, [r7, #4]
  408f0c:	617b      	str	r3, [r7, #20]
	pulSharedVariable = pxParameters->pulSharedVariable;
  408f0e:	697b      	ldr	r3, [r7, #20]
  408f10:	685b      	ldr	r3, [r3, #4]
  408f12:	613b      	str	r3, [r7, #16]

	/* If we are blocking we use a much higher count to ensure loads of context
	switches occur during the count. */
	if( pxParameters->xBlockTime > ( portTickType ) 0 )
  408f14:	697b      	ldr	r3, [r7, #20]
  408f16:	689b      	ldr	r3, [r3, #8]
  408f18:	2b00      	cmp	r3, #0
  408f1a:	d003      	beq.n	408f24 <prvSemaphoreTest+0x64>
	{
		ulExpectedValue = semtstBLOCKING_EXPECTED_VALUE;
  408f1c:	f640 73ff 	movw	r3, #4095	; 0xfff
  408f20:	60fb      	str	r3, [r7, #12]
  408f22:	e004      	b.n	408f2e <prvSemaphoreTest+0x6e>
	}
	else
	{
		ulExpectedValue = semtstNON_BLOCKING_EXPECTED_VALUE;
  408f24:	f04f 03ff 	mov.w	r3, #255	; 0xff
  408f28:	60fb      	str	r3, [r7, #12]
  408f2a:	e000      	b.n	408f2e <prvSemaphoreTest+0x6e>
				processor.  We are not blocking when attempting to obtain the
				semaphore. */
				taskYIELD();
			}
		}
	}
  408f2c:	bf00      	nop
	}

	for( ;; )
	{
		/* Try to obtain the semaphore. */
		if( xSemaphoreTake( pxParameters->xSemaphore, pxParameters->xBlockTime ) == pdPASS )
  408f2e:	697b      	ldr	r3, [r7, #20]
  408f30:	681a      	ldr	r2, [r3, #0]
  408f32:	697b      	ldr	r3, [r7, #20]
  408f34:	689b      	ldr	r3, [r3, #8]
  408f36:	4610      	mov	r0, r2
  408f38:	f04f 0100 	mov.w	r1, #0
  408f3c:	461a      	mov	r2, r3
  408f3e:	f04f 0300 	mov.w	r3, #0
  408f42:	f243 7469 	movw	r4, #14185	; 0x3769
  408f46:	f2c0 0440 	movt	r4, #64	; 0x40
  408f4a:	47a0      	blx	r4
  408f4c:	4603      	mov	r3, r0
  408f4e:	2b01      	cmp	r3, #1
  408f50:	d15b      	bne.n	40900a <prvSemaphoreTest+0x14a>
		{
			/* We have the semaphore and so expect any other tasks using the
			shared variable to have left it in the state we expect to find
			it. */
			if( *pulSharedVariable != ulExpectedValue )
  408f52:	693b      	ldr	r3, [r7, #16]
  408f54:	681a      	ldr	r2, [r3, #0]
  408f56:	68fb      	ldr	r3, [r7, #12]
  408f58:	429a      	cmp	r2, r3
  408f5a:	d002      	beq.n	408f62 <prvSemaphoreTest+0xa2>
			{
				sError = pdTRUE;
  408f5c:	f04f 0301 	mov.w	r3, #1
  408f60:	837b      	strh	r3, [r7, #26]
			}
			
			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( unsigned long ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
  408f62:	f04f 0300 	mov.w	r3, #0
  408f66:	61fb      	str	r3, [r7, #28]
  408f68:	e00e      	b.n	408f88 <prvSemaphoreTest+0xc8>
			{
				*pulSharedVariable = ulCounter;
  408f6a:	693b      	ldr	r3, [r7, #16]
  408f6c:	69fa      	ldr	r2, [r7, #28]
  408f6e:	601a      	str	r2, [r3, #0]
				if( *pulSharedVariable != ulCounter )
  408f70:	693b      	ldr	r3, [r7, #16]
  408f72:	681a      	ldr	r2, [r3, #0]
  408f74:	69fb      	ldr	r3, [r7, #28]
  408f76:	429a      	cmp	r2, r3
  408f78:	d002      	beq.n	408f80 <prvSemaphoreTest+0xc0>
				{
					sError = pdTRUE;
  408f7a:	f04f 0301 	mov.w	r3, #1
  408f7e:	837b      	strh	r3, [r7, #26]
			}
			
			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( unsigned long ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
  408f80:	69fb      	ldr	r3, [r7, #28]
  408f82:	f103 0301 	add.w	r3, r3, #1
  408f86:	61fb      	str	r3, [r7, #28]
  408f88:	68fb      	ldr	r3, [r7, #12]
  408f8a:	69fa      	ldr	r2, [r7, #28]
  408f8c:	429a      	cmp	r2, r3
  408f8e:	d9ec      	bls.n	408f6a <prvSemaphoreTest+0xaa>
				}
			}

			/* Release the semaphore, and if no errors have occurred increment the check
			variable. */
			if(	xSemaphoreGive( pxParameters->xSemaphore ) == pdFALSE )
  408f90:	697b      	ldr	r3, [r7, #20]
  408f92:	681b      	ldr	r3, [r3, #0]
  408f94:	4618      	mov	r0, r3
  408f96:	f04f 0100 	mov.w	r1, #0
  408f9a:	f04f 0200 	mov.w	r2, #0
  408f9e:	f04f 0300 	mov.w	r3, #0
  408fa2:	f243 34f1 	movw	r4, #13297	; 0x33f1
  408fa6:	f2c0 0440 	movt	r4, #64	; 0x40
  408faa:	47a0      	blx	r4
  408fac:	4603      	mov	r3, r0
  408fae:	2b00      	cmp	r3, #0
  408fb0:	d102      	bne.n	408fb8 <prvSemaphoreTest+0xf8>
			{
				sError = pdTRUE;
  408fb2:	f04f 0301 	mov.w	r3, #1
  408fb6:	837b      	strh	r3, [r7, #26]
			}

			if( sError == pdFALSE )
  408fb8:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
  408fbc:	2b00      	cmp	r3, #0
  408fbe:	d115      	bne.n	408fec <prvSemaphoreTest+0x12c>
			{
				if( sCheckVariableToUse < semtstNUM_TASKS )
  408fc0:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
  408fc4:	2b03      	cmp	r3, #3
  408fc6:	dc11      	bgt.n	408fec <prvSemaphoreTest+0x12c>
				{
					( sCheckVariables[ sCheckVariableToUse ] )++;
  408fc8:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
  408fcc:	f24a 7380 	movw	r3, #42880	; 0xa780
  408fd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408fd4:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
  408fd8:	b29b      	uxth	r3, r3
  408fda:	f103 0301 	add.w	r3, r3, #1
  408fde:	b299      	uxth	r1, r3
  408fe0:	f24a 7380 	movw	r3, #42880	; 0xa780
  408fe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  408fe8:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
			/* If we have a block time then we are running at a priority higher
			than the idle priority.  This task takes a long time to complete
			a cycle	(deliberately so to test the guarding) so will be starving
			out lower priority tasks.  Block for some time to allow give lower
			priority tasks some processor time. */
			vTaskDelay( pxParameters->xBlockTime * semtstDELAY_FACTOR );
  408fec:	697b      	ldr	r3, [r7, #20]
  408fee:	689a      	ldr	r2, [r3, #8]
  408ff0:	4613      	mov	r3, r2
  408ff2:	ea4f 0383 	mov.w	r3, r3, lsl #2
  408ff6:	189b      	adds	r3, r3, r2
  408ff8:	ea4f 0343 	mov.w	r3, r3, lsl #1
  408ffc:	4618      	mov	r0, r3
  408ffe:	f244 332d 	movw	r3, #17197	; 0x432d
  409002:	f2c0 0340 	movt	r3, #64	; 0x40
  409006:	4798      	blx	r3
				processor.  We are not blocking when attempting to obtain the
				semaphore. */
				taskYIELD();
			}
		}
	}
  409008:	e790      	b.n	408f2c <prvSemaphoreTest+0x6c>
			priority tasks some processor time. */
			vTaskDelay( pxParameters->xBlockTime * semtstDELAY_FACTOR );
		}
		else
		{
			if( pxParameters->xBlockTime == ( portTickType ) 0 )
  40900a:	697b      	ldr	r3, [r7, #20]
  40900c:	689b      	ldr	r3, [r3, #8]
  40900e:	2b00      	cmp	r3, #0
  409010:	d18c      	bne.n	408f2c <prvSemaphoreTest+0x6c>
			{
				/* We have not got the semaphore yet, so no point using the
				processor.  We are not blocking when attempting to obtain the
				semaphore. */
				taskYIELD();
  409012:	f642 6359 	movw	r3, #11865	; 0x2e59
  409016:	f2c0 0340 	movt	r3, #64	; 0x40
  40901a:	4798      	blx	r3
			}
		}
	}
  40901c:	e786      	b.n	408f2c <prvSemaphoreTest+0x6c>
  40901e:	bf00      	nop

00409020 <xAreSemaphoreTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreSemaphoreTasksStillRunning( void )
{
  409020:	b480      	push	{r7}
  409022:	b083      	sub	sp, #12
  409024:	af00      	add	r7, sp, #0
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;
  409026:	f04f 0301 	mov.w	r3, #1
  40902a:	603b      	str	r3, [r7, #0]

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
  40902c:	f04f 0300 	mov.w	r3, #0
  409030:	607b      	str	r3, [r7, #4]
  409032:	e028      	b.n	409086 <xAreSemaphoreTasksStillRunning+0x66>
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
  409034:	f24a 738c 	movw	r3, #42892	; 0xa78c
  409038:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40903c:	687a      	ldr	r2, [r7, #4]
  40903e:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
  409042:	f24a 7380 	movw	r3, #42880	; 0xa780
  409046:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40904a:	6879      	ldr	r1, [r7, #4]
  40904c:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
  409050:	b29b      	uxth	r3, r3
  409052:	b212      	sxth	r2, r2
  409054:	b21b      	sxth	r3, r3
  409056:	429a      	cmp	r2, r3
  409058:	d102      	bne.n	409060 <xAreSemaphoreTasksStillRunning+0x40>
		{
			xReturn = pdFALSE;
  40905a:	f04f 0300 	mov.w	r3, #0
  40905e:	603b      	str	r3, [r7, #0]
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
  409060:	f24a 7380 	movw	r3, #42880	; 0xa780
  409064:	f2c2 0300 	movt	r3, #8192	; 0x2000
  409068:	687a      	ldr	r2, [r7, #4]
  40906a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
  40906e:	b299      	uxth	r1, r3
  409070:	f24a 738c 	movw	r3, #42892	; 0xa78c
  409074:	f2c2 0300 	movt	r3, #8192	; 0x2000
  409078:	687a      	ldr	r2, [r7, #4]
  40907a:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
portBASE_TYPE xAreSemaphoreTasksStillRunning( void )
{
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
  40907e:	687b      	ldr	r3, [r7, #4]
  409080:	f103 0301 	add.w	r3, r3, #1
  409084:	607b      	str	r3, [r7, #4]
  409086:	687b      	ldr	r3, [r7, #4]
  409088:	2b03      	cmp	r3, #3
  40908a:	ddd3      	ble.n	409034 <xAreSemaphoreTasksStillRunning+0x14>
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
	}

	return xReturn;
  40908c:	683b      	ldr	r3, [r7, #0]
}
  40908e:	4618      	mov	r0, r3
  409090:	f107 070c 	add.w	r7, r7, #12
  409094:	46bd      	mov	sp, r7
  409096:	bc80      	pop	{r7}
  409098:	4770      	bx	lr
  40909a:	bf00      	nop

0040909c <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field
 */
static __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  40909c:	b480      	push	{r7}
  40909e:	b085      	sub	sp, #20
  4090a0:	af00      	add	r7, sp, #0
  4090a2:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
  4090a4:	687b      	ldr	r3, [r7, #4]
  4090a6:	f003 0307 	and.w	r3, r3, #7
  4090aa:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  4090ac:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  4090b0:	f2ce 0300 	movt	r3, #57344	; 0xe000
  4090b4:	68db      	ldr	r3, [r3, #12]
  4090b6:	60bb      	str	r3, [r7, #8]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  4090b8:	68ba      	ldr	r2, [r7, #8]
  4090ba:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
  4090be:	4013      	ands	r3, r2
  4090c0:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  4090c2:	68fb      	ldr	r3, [r7, #12]
  4090c4:	ea4f 2203 	mov.w	r2, r3, lsl #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
  4090c8:	68bb      	ldr	r3, [r7, #8]
  4090ca:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
  4090cc:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  4090d0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  4090d4:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
  4090d6:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  4090da:	f2ce 0300 	movt	r3, #57344	; 0xe000
  4090de:	68ba      	ldr	r2, [r7, #8]
  4090e0:	60da      	str	r2, [r3, #12]
}
  4090e2:	f107 0714 	add.w	r7, r7, #20
  4090e6:	46bd      	mov	sp, r7
  4090e8:	bc80      	pop	{r7}
  4090ea:	4770      	bx	lr

004090ec <main>:

/* See the documentation page for this demo on the FreeRTOS.org web site for
full information - including hardware setup requirements. */

int main( void )
{
  4090ec:	b580      	push	{r7, lr}
  4090ee:	af00      	add	r7, sp, #0
	/* Prepare the hardware to run this demo. */
	prvSetupHardware();
  4090f0:	f249 130d 	movw	r3, #37133	; 0x910d
  4090f4:	f2c0 0340 	movt	r3, #64	; 0x40
  4090f8:	4798      	blx	r3
	{
		main_blinky();
	}
	#else
	{
		main_full();
  4090fa:	f249 1379 	movw	r3, #37241	; 0x9179
  4090fe:	f2c0 0340 	movt	r3, #64	; 0x40
  409102:	4798      	blx	r3
	}
	#endif

	return 0;
  409104:	f04f 0300 	mov.w	r3, #0
}
  409108:	4618      	mov	r0, r3
  40910a:	bd80      	pop	{r7, pc}

0040910c <prvSetupHardware>:
/*-----------------------------------------------------------*/

static void prvSetupHardware( void )
{
  40910c:	b580      	push	{r7, lr}
  40910e:	af00      	add	r7, sp, #0
extern void SystemCoreClockUpdate( void );

	/* ASF function to setup clocking. */
	sysclk_init();
  409110:	f641 3331 	movw	r3, #6961	; 0x1b31
  409114:	f2c0 0340 	movt	r3, #64	; 0x40
  409118:	4798      	blx	r3

	/* Ensure all priority bits are assigned as preemption priority bits. */
	NVIC_SetPriorityGrouping( 0 );
  40911a:	f04f 0000 	mov.w	r0, #0
  40911e:	f249 039d 	movw	r3, #37021	; 0x909d
  409122:	f2c0 0340 	movt	r3, #64	; 0x40
  409126:	4798      	blx	r3

	/* Atmel library function to setup for the evaluation kit being used. */
	board_init();
  409128:	f641 33bd 	movw	r3, #7101	; 0x1bbd
  40912c:	f2c0 0340 	movt	r3, #64	; 0x40
  409130:	4798      	blx	r3

	/* Perform any configuration necessary to use the ParTest LED output
	functions. */
	vParTestInitialise();
  409132:	f249 33ed 	movw	r3, #37869	; 0x93ed
  409136:	f2c0 0340 	movt	r3, #64	; 0x40
  40913a:	4798      	blx	r3
}
  40913c:	bd80      	pop	{r7, pc}
  40913e:	bf00      	nop

00409140 <vApplicationMallocFailedHook>:
/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
  409140:	b580      	push	{r7, lr}
  409142:	af00      	add	r7, sp, #0
	demo application.  If heap_1.c or heap_2.c are used, then the size of the
	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
  409144:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  409148:	f2c0 0340 	movt	r3, #64	; 0x40
  40914c:	4798      	blx	r3
	for( ;; );
  40914e:	e7fe      	b.n	40914e <vApplicationMallocFailedHook+0xe>

00409150 <vApplicationStackOverflowHook>:
	memory allocated by the kernel to any task that has since been deleted. */
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName )
{
  409150:	b580      	push	{r7, lr}
  409152:	b082      	sub	sp, #8
  409154:	af00      	add	r7, sp, #0
  409156:	6078      	str	r0, [r7, #4]
  409158:	6039      	str	r1, [r7, #0]
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
  40915a:	f642 63e5 	movw	r3, #12005	; 0x2ee5
  40915e:	f2c0 0340 	movt	r3, #64	; 0x40
  409162:	4798      	blx	r3
	for( ;; );
  409164:	e7fe      	b.n	409164 <vApplicationStackOverflowHook+0x14>
  409166:	bf00      	nop

00409168 <vApplicationTickHook>:
}
/*-----------------------------------------------------------*/

void vApplicationTickHook( void )
{
  409168:	b580      	push	{r7, lr}
  40916a:	af00      	add	r7, sp, #0
	functions can be used (those that end in FromISR()).  */

	#if ( mainCREATE_SIMPLE_BLINKY_DEMO_ONLY == 0 )
	{
		/* In this case the tick hook is used as part of the queue set test. */
		vQueueSetAccessQueueSetFromISR();
  40916c:	f640 5379 	movw	r3, #3449	; 0xd79
  409170:	f2c0 0340 	movt	r3, #64	; 0x40
  409174:	4798      	blx	r3
	}
	#endif /* mainCREATE_SIMPLE_BLINKY_DEMO_ONLY */
}
  409176:	bd80      	pop	{r7, pc}

00409178 <main_full>:
static void prvCheckTimerCallback( xTimerHandle xTimer );

/*-----------------------------------------------------------*/

void main_full( void )
{
  409178:	b590      	push	{r4, r7, lr}
  40917a:	b085      	sub	sp, #20
  40917c:	af02      	add	r7, sp, #8
xTimerHandle xCheckTimer = NULL;
  40917e:	f04f 0300 	mov.w	r3, #0
  409182:	607b      	str	r3, [r7, #4]

	/* Start all the other standard demo/test tasks.  The have not particular
	functionality, but do demonstrate how to use the FreeRTOS API and test the
	kernel port. */
	vStartIntegerMathTasks( tskIDLE_PRIORITY );
  409184:	f04f 0000 	mov.w	r0, #0
  409188:	f248 33ed 	movw	r3, #33773	; 0x83ed
  40918c:	f2c0 0340 	movt	r3, #64	; 0x40
  409190:	4798      	blx	r3
	vStartDynamicPriorityTasks();
  409192:	f247 43bd 	movw	r3, #29885	; 0x74bd
  409196:	f2c0 0340 	movt	r3, #64	; 0x40
  40919a:	4798      	blx	r3
	vStartBlockingQueueTasks( mainBLOCK_Q_PRIORITY );
  40919c:	f04f 0002 	mov.w	r0, #2
  4091a0:	f246 0361 	movw	r3, #24673	; 0x6061
  4091a4:	f2c0 0340 	movt	r3, #64	; 0x40
  4091a8:	4798      	blx	r3
	vCreateBlockTimeTasks();
  4091aa:	f246 43a9 	movw	r3, #25769	; 0x64a9
  4091ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4091b2:	4798      	blx	r3
	vStartCountingSemaphoreTasks();
  4091b4:	f646 7309 	movw	r3, #28425	; 0x6f09
  4091b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4091bc:	4798      	blx	r3
	vStartGenericQueueTasks( tskIDLE_PRIORITY );
  4091be:	f04f 0000 	mov.w	r0, #0
  4091c2:	f647 23e9 	movw	r3, #31465	; 0x7ae9
  4091c6:	f2c0 0340 	movt	r3, #64	; 0x40
  4091ca:	4798      	blx	r3
	vStartRecursiveMutexTasks();
  4091cc:	f248 73a5 	movw	r3, #34725	; 0x87a5
  4091d0:	f2c0 0340 	movt	r3, #64	; 0x40
  4091d4:	4798      	blx	r3
	vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
  4091d6:	f04f 0002 	mov.w	r0, #2
  4091da:	f248 5349 	movw	r3, #34121	; 0x8549
  4091de:	f2c0 0340 	movt	r3, #64	; 0x40
  4091e2:	4798      	blx	r3
	vStartSemaphoreTasks( mainSEM_TEST_PRIORITY );
  4091e4:	f04f 0001 	mov.w	r0, #1
  4091e8:	f648 43d9 	movw	r3, #36057	; 0x8cd9
  4091ec:	f2c0 0340 	movt	r3, #64	; 0x40
  4091f0:	4798      	blx	r3
	vStartLEDFlashTimers( mainNUMBER_OF_FLASH_TIMERS_LEDS );
  4091f2:	f04f 0002 	mov.w	r0, #2
  4091f6:	f647 232d 	movw	r3, #31277	; 0x7a2d
  4091fa:	f2c0 0340 	movt	r3, #64	; 0x40
  4091fe:	4798      	blx	r3
	vAltStartComTestTasks( mainCOM_TEST_PRIORITY, mainCOM_TEST_BAUD_RATE, mainCOM_TEST_LED );
  409200:	f04f 0002 	mov.w	r0, #2
  409204:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
  409208:	f04f 0203 	mov.w	r2, #3
  40920c:	f646 4361 	movw	r3, #27745	; 0x6c61
  409210:	f2c0 0340 	movt	r3, #64	; 0x40
  409214:	4798      	blx	r3
	vStartQueueSetTasks();
  409216:	f640 1351 	movw	r3, #2385	; 0x951
  40921a:	f2c0 0340 	movt	r3, #64	; 0x40
  40921e:	4798      	blx	r3

	/* Create the software timer that performs the 'check' functionality,
	as described at the top of this file. */
	xCheckTimer = xTimerCreate( ( const signed char * ) "CheckTimer",/* A text name, purely to help debugging. */
  409220:	f249 2395 	movw	r3, #37525	; 0x9295
  409224:	f2c0 0340 	movt	r3, #64	; 0x40
  409228:	9300      	str	r3, [sp, #0]
  40922a:	f249 70e4 	movw	r0, #38884	; 0x97e4
  40922e:	f2c0 0040 	movt	r0, #64	; 0x40
  409232:	f640 31b8 	movw	r1, #3000	; 0xbb8
  409236:	f04f 0201 	mov.w	r2, #1
  40923a:	f04f 0300 	mov.w	r3, #0
  40923e:	f645 145d 	movw	r4, #22877	; 0x595d
  409242:	f2c0 0440 	movt	r4, #64	; 0x40
  409246:	47a0      	blx	r4
  409248:	6078      	str	r0, [r7, #4]
								pdTRUE,								/* This is an auto-reload timer, so xAutoReload is set to pdTRUE. */
								( void * ) 0,						/* The ID is not used, so can be set to anything. */
								prvCheckTimerCallback				/* The callback function that inspects the status of all the other tasks. */
							  );

	if( xCheckTimer != NULL )
  40924a:	687b      	ldr	r3, [r7, #4]
  40924c:	2b00      	cmp	r3, #0
  40924e:	d013      	beq.n	409278 <main_full+0x100>
	{
		xTimerStart( xCheckTimer, mainDONT_BLOCK );
  409250:	f644 23c1 	movw	r3, #19137	; 0x4ac1
  409254:	f2c0 0340 	movt	r3, #64	; 0x40
  409258:	4798      	blx	r3
  40925a:	4603      	mov	r3, r0
  40925c:	f04f 0200 	mov.w	r2, #0
  409260:	9200      	str	r2, [sp, #0]
  409262:	6878      	ldr	r0, [r7, #4]
  409264:	f04f 0100 	mov.w	r1, #0
  409268:	461a      	mov	r2, r3
  40926a:	f04f 0300 	mov.w	r3, #0
  40926e:	f645 14e9 	movw	r4, #23017	; 0x59e9
  409272:	f2c0 0440 	movt	r4, #64	; 0x40
  409276:	47a0      	blx	r4
	}

	/* The set of tasks created by the following function call have to be
	created last as they keep account of the number of tasks they expect to see
	running. */
	vCreateSuicidalTasks( mainCREATOR_TASK_PRIORITY );
  409278:	f04f 0003 	mov.w	r0, #3
  40927c:	f247 2321 	movw	r3, #29217	; 0x7221
  409280:	f2c0 0340 	movt	r3, #64	; 0x40
  409284:	4798      	blx	r3

	/* Start the scheduler. */
	vTaskStartScheduler();
  409286:	f644 0351 	movw	r3, #18513	; 0x4851
  40928a:	f2c0 0340 	movt	r3, #64	; 0x40
  40928e:	4798      	blx	r3
	/* If all is well, the scheduler will now be running, and the following line
	will never be reached.  If the following line does execute, then there was
	insufficient FreeRTOS heap memory available for the idle and/or timer tasks
	to be created.  See the memory management section on the FreeRTOS web site
	for more details. */
	for( ;; );
  409290:	e7fe      	b.n	409290 <main_full+0x118>
  409292:	bf00      	nop

00409294 <prvCheckTimerCallback>:
}
/*-----------------------------------------------------------*/

static void prvCheckTimerCallback( xTimerHandle xTimer )
{
  409294:	b590      	push	{r4, r7, lr}
  409296:	b087      	sub	sp, #28
  409298:	af02      	add	r7, sp, #8
  40929a:	6078      	str	r0, [r7, #4]
static long lChangedTimerPeriodAlready = pdFALSE;
unsigned long ulErrorFound = pdFALSE;
  40929c:	f04f 0300 	mov.w	r3, #0
  4092a0:	60fb      	str	r3, [r7, #12]

	/* Check all the demo tasks (other than the flash tasks) to ensure
	they are all still running, and that none have detected an error. */

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
  4092a2:	f248 43e9 	movw	r3, #34025	; 0x84e9
  4092a6:	f2c0 0340 	movt	r3, #64	; 0x40
  4092aa:	4798      	blx	r3
  4092ac:	4603      	mov	r3, r0
  4092ae:	2b01      	cmp	r3, #1
  4092b0:	d002      	beq.n	4092b8 <prvCheckTimerCallback+0x24>
	{
		ulErrorFound = pdTRUE;
  4092b2:	f04f 0301 	mov.w	r3, #1
  4092b6:	60fb      	str	r3, [r7, #12]
	}

	if( xAreDynamicPriorityTasksStillRunning() != pdTRUE )
  4092b8:	f647 1381 	movw	r3, #31105	; 0x7981
  4092bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4092c0:	4798      	blx	r3
  4092c2:	4603      	mov	r3, r0
  4092c4:	2b01      	cmp	r3, #1
  4092c6:	d002      	beq.n	4092ce <prvCheckTimerCallback+0x3a>
	{
		ulErrorFound = pdTRUE;
  4092c8:	f04f 0301 	mov.w	r3, #1
  4092cc:	60fb      	str	r3, [r7, #12]
	}

	if( xAreBlockingQueuesStillRunning() != pdTRUE )
  4092ce:	f246 33e5 	movw	r3, #25573	; 0x63e5
  4092d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4092d6:	4798      	blx	r3
  4092d8:	4603      	mov	r3, r0
  4092da:	2b01      	cmp	r3, #1
  4092dc:	d002      	beq.n	4092e4 <prvCheckTimerCallback+0x50>
	{
		ulErrorFound = pdTRUE;
  4092de:	f04f 0301 	mov.w	r3, #1
  4092e2:	60fb      	str	r3, [r7, #12]
	}

	if ( xAreBlockTimeTestTasksStillRunning() != pdTRUE )
  4092e4:	f646 33cd 	movw	r3, #27597	; 0x6bcd
  4092e8:	f2c0 0340 	movt	r3, #64	; 0x40
  4092ec:	4798      	blx	r3
  4092ee:	4603      	mov	r3, r0
  4092f0:	2b01      	cmp	r3, #1
  4092f2:	d002      	beq.n	4092fa <prvCheckTimerCallback+0x66>
	{
		ulErrorFound = pdTRUE;
  4092f4:	f04f 0301 	mov.w	r3, #1
  4092f8:	60fb      	str	r3, [r7, #12]
	}

	if ( xAreGenericQueueTasksStillRunning() != pdTRUE )
  4092fa:	f248 3359 	movw	r3, #33625	; 0x8359
  4092fe:	f2c0 0340 	movt	r3, #64	; 0x40
  409302:	4798      	blx	r3
  409304:	4603      	mov	r3, r0
  409306:	2b01      	cmp	r3, #1
  409308:	d002      	beq.n	409310 <prvCheckTimerCallback+0x7c>
	{
		ulErrorFound = pdTRUE;
  40930a:	f04f 0301 	mov.w	r3, #1
  40930e:	60fb      	str	r3, [r7, #12]
	}

	if ( xAreRecursiveMutexTasksStillRunning() != pdTRUE )
  409310:	f648 33f5 	movw	r3, #35829	; 0x8bf5
  409314:	f2c0 0340 	movt	r3, #64	; 0x40
  409318:	4798      	blx	r3
  40931a:	4603      	mov	r3, r0
  40931c:	2b01      	cmp	r3, #1
  40931e:	d002      	beq.n	409326 <prvCheckTimerCallback+0x92>
	{
		ulErrorFound = pdTRUE;
  409320:	f04f 0301 	mov.w	r3, #1
  409324:	60fb      	str	r3, [r7, #12]
	}

	if( xIsCreateTaskStillRunning() != pdTRUE )
  409326:	f247 430d 	movw	r3, #29709	; 0x740d
  40932a:	f2c0 0340 	movt	r3, #64	; 0x40
  40932e:	4798      	blx	r3
  409330:	4603      	mov	r3, r0
  409332:	2b01      	cmp	r3, #1
  409334:	d002      	beq.n	40933c <prvCheckTimerCallback+0xa8>
	{
		ulErrorFound = pdTRUE;
  409336:	f04f 0301 	mov.w	r3, #1
  40933a:	60fb      	str	r3, [r7, #12]
	}

	if( xArePollingQueuesStillRunning() != pdTRUE )
  40933c:	f248 7349 	movw	r3, #34633	; 0x8749
  409340:	f2c0 0340 	movt	r3, #64	; 0x40
  409344:	4798      	blx	r3
  409346:	4603      	mov	r3, r0
  409348:	2b01      	cmp	r3, #1
  40934a:	d002      	beq.n	409352 <prvCheckTimerCallback+0xbe>
	{
		ulErrorFound = pdTRUE;
  40934c:	f04f 0301 	mov.w	r3, #1
  409350:	60fb      	str	r3, [r7, #12]
	}

	if( xAreSemaphoreTasksStillRunning() != pdTRUE )
  409352:	f249 0321 	movw	r3, #36897	; 0x9021
  409356:	f2c0 0340 	movt	r3, #64	; 0x40
  40935a:	4798      	blx	r3
  40935c:	4603      	mov	r3, r0
  40935e:	2b01      	cmp	r3, #1
  409360:	d002      	beq.n	409368 <prvCheckTimerCallback+0xd4>
	{
		ulErrorFound = pdTRUE;
  409362:	f04f 0301 	mov.w	r3, #1
  409366:	60fb      	str	r3, [r7, #12]
	}

	if( xAreComTestTasksStillRunning() != pdTRUE )
  409368:	f646 63c9 	movw	r3, #28361	; 0x6ec9
  40936c:	f2c0 0340 	movt	r3, #64	; 0x40
  409370:	4798      	blx	r3
  409372:	4603      	mov	r3, r0
  409374:	2b01      	cmp	r3, #1
  409376:	d002      	beq.n	40937e <prvCheckTimerCallback+0xea>
	{
		ulErrorFound = pdTRUE;
  409378:	f04f 0301 	mov.w	r3, #1
  40937c:	60fb      	str	r3, [r7, #12]
	}

	if( xAreQueueSetTasksStillRunning() != pdPASS )
  40937e:	f640 13f9 	movw	r3, #2553	; 0x9f9
  409382:	f2c0 0340 	movt	r3, #64	; 0x40
  409386:	4798      	blx	r3
  409388:	4603      	mov	r3, r0
  40938a:	2b01      	cmp	r3, #1
  40938c:	d002      	beq.n	409394 <prvCheckTimerCallback+0x100>
	{
		ulErrorFound = pdTRUE;
  40938e:	f04f 0301 	mov.w	r3, #1
  409392:	60fb      	str	r3, [r7, #12]
	}

	/* Toggle the check LED to give an indication of the system status.  If
	the LED toggles every mainCHECK_TIMER_PERIOD_MS milliseconds then
	everything is ok.  A faster toggle indicates an error. */
	vParTestToggleLED( mainCHECK_LED );
  409394:	f04f 0002 	mov.w	r0, #2
  409398:	f249 43d1 	movw	r3, #38097	; 0x94d1
  40939c:	f2c0 0340 	movt	r3, #64	; 0x40
  4093a0:	4798      	blx	r3

	/* Have any errors been latch in ulErrorFound?  If so, shorten the
	period of the check timer to mainERROR_CHECK_TIMER_PERIOD_MS milliseconds.
	This will result in an increase in the rate at which mainCHECK_LED
	toggles. */
	if( ulErrorFound != pdFALSE )
  4093a2:	68fb      	ldr	r3, [r7, #12]
  4093a4:	2b00      	cmp	r3, #0
  4093a6:	d01c      	beq.n	4093e2 <prvCheckTimerCallback+0x14e>
	{
		if( lChangedTimerPeriodAlready == pdFALSE )
  4093a8:	f24a 7394 	movw	r3, #42900	; 0xa794
  4093ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4093b0:	681b      	ldr	r3, [r3, #0]
  4093b2:	2b00      	cmp	r3, #0
  4093b4:	d115      	bne.n	4093e2 <prvCheckTimerCallback+0x14e>
		{
			lChangedTimerPeriodAlready = pdTRUE;
  4093b6:	f24a 7394 	movw	r3, #42900	; 0xa794
  4093ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4093be:	f04f 0201 	mov.w	r2, #1
  4093c2:	601a      	str	r2, [r3, #0]

			/* This call to xTimerChangePeriod() uses a zero block time.
			Functions called from inside of a timer callback function must
			*never* attempt	to block. */
			xTimerChangePeriod( xTimer, ( mainERROR_CHECK_TIMER_PERIOD_MS ), mainDONT_BLOCK );
  4093c4:	f04f 0300 	mov.w	r3, #0
  4093c8:	9300      	str	r3, [sp, #0]
  4093ca:	6878      	ldr	r0, [r7, #4]
  4093cc:	f04f 0102 	mov.w	r1, #2
  4093d0:	f04f 02c8 	mov.w	r2, #200	; 0xc8
  4093d4:	f04f 0300 	mov.w	r3, #0
  4093d8:	f645 14e9 	movw	r4, #23017	; 0x59e9
  4093dc:	f2c0 0440 	movt	r4, #64	; 0x40
  4093e0:	47a0      	blx	r4
		}
	}
}
  4093e2:	f107 0714 	add.w	r7, r7, #20
  4093e6:	46bd      	mov	sp, r7
  4093e8:	bd90      	pop	{r4, r7, pc}
  4093ea:	bf00      	nop

004093ec <vParTestInitialise>:
static const uint32_t ulLED[] = { LED2_GPIO, LED0_GPIO, LED1_GPIO };

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
  4093ec:	b580      	push	{r7, lr}
  4093ee:	b082      	sub	sp, #8
  4093f0:	af00      	add	r7, sp, #0
unsigned long ul;

	for( ul = 0; ul < partestNUM_LEDS; ul++ )
  4093f2:	f04f 0300 	mov.w	r3, #0
  4093f6:	607b      	str	r3, [r7, #4]
  4093f8:	e01a      	b.n	409430 <vParTestInitialise+0x44>
	{
		/* Configure the LED, before ensuring it starts in the off state. */
		gpio_configure_pin( ulLED[ ul ],  ( PIO_OUTPUT_1 | PIO_DEFAULT ) );
  4093fa:	f249 73f0 	movw	r3, #38896	; 0x97f0
  4093fe:	f2c0 0340 	movt	r3, #64	; 0x40
  409402:	687a      	ldr	r2, [r7, #4]
  409404:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  409408:	4618      	mov	r0, r3
  40940a:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  40940e:	f641 73c1 	movw	r3, #8129	; 0x1fc1
  409412:	f2c0 0340 	movt	r3, #64	; 0x40
  409416:	4798      	blx	r3
		vParTestSetLED( ul, pdFALSE );
  409418:	6878      	ldr	r0, [r7, #4]
  40941a:	f04f 0100 	mov.w	r1, #0
  40941e:	f249 4341 	movw	r3, #37953	; 0x9441
  409422:	f2c0 0340 	movt	r3, #64	; 0x40
  409426:	4798      	blx	r3

void vParTestInitialise( void )
{
unsigned long ul;

	for( ul = 0; ul < partestNUM_LEDS; ul++ )
  409428:	687b      	ldr	r3, [r7, #4]
  40942a:	f103 0301 	add.w	r3, r3, #1
  40942e:	607b      	str	r3, [r7, #4]
  409430:	687b      	ldr	r3, [r7, #4]
  409432:	2b02      	cmp	r3, #2
  409434:	d9e1      	bls.n	4093fa <vParTestInitialise+0xe>
	{
		/* Configure the LED, before ensuring it starts in the off state. */
		gpio_configure_pin( ulLED[ ul ],  ( PIO_OUTPUT_1 | PIO_DEFAULT ) );
		vParTestSetLED( ul, pdFALSE );
	}
}
  409436:	f107 0708 	add.w	r7, r7, #8
  40943a:	46bd      	mov	sp, r7
  40943c:	bd80      	pop	{r7, pc}
  40943e:	bf00      	nop

00409440 <vParTestSetLED>:
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{	
  409440:	b580      	push	{r7, lr}
  409442:	b082      	sub	sp, #8
  409444:	af00      	add	r7, sp, #0
  409446:	6078      	str	r0, [r7, #4]
  409448:	6039      	str	r1, [r7, #0]
	if( uxLED < partestNUM_LEDS )
  40944a:	687b      	ldr	r3, [r7, #4]
  40944c:	2b02      	cmp	r3, #2
  40944e:	d83b      	bhi.n	4094c8 <vParTestSetLED+0x88>
	{
		if( uxLED == partstsINVERTED_LED )
  409450:	687b      	ldr	r3, [r7, #4]
  409452:	2b00      	cmp	r3, #0
  409454:	d106      	bne.n	409464 <vParTestSetLED+0x24>
		{
			xValue = !xValue;					
  409456:	683b      	ldr	r3, [r7, #0]
  409458:	2b00      	cmp	r3, #0
  40945a:	bf14      	ite	ne
  40945c:	2300      	movne	r3, #0
  40945e:	2301      	moveq	r3, #1
  409460:	b2db      	uxtb	r3, r3
  409462:	603b      	str	r3, [r7, #0]
		}
		
		if( xValue != pdFALSE )
  409464:	683b      	ldr	r3, [r7, #0]
  409466:	2b00      	cmp	r3, #0
  409468:	d017      	beq.n	40949a <vParTestSetLED+0x5a>
		{
			/* Turn the LED on. */
			taskENTER_CRITICAL();
  40946a:	f642 6379 	movw	r3, #11897	; 0x2e79
  40946e:	f2c0 0340 	movt	r3, #64	; 0x40
  409472:	4798      	blx	r3
			{
				gpio_set_pin_low( ulLED[ uxLED ]);
  409474:	f249 73f0 	movw	r3, #38896	; 0x97f0
  409478:	f2c0 0340 	movt	r3, #64	; 0x40
  40947c:	687a      	ldr	r2, [r7, #4]
  40947e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  409482:	4618      	mov	r0, r3
  409484:	f641 731d 	movw	r3, #7965	; 0x1f1d
  409488:	f2c0 0340 	movt	r3, #64	; 0x40
  40948c:	4798      	blx	r3
			}
			taskEXIT_CRITICAL();
  40948e:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  409492:	f2c0 0340 	movt	r3, #64	; 0x40
  409496:	4798      	blx	r3
  409498:	e016      	b.n	4094c8 <vParTestSetLED+0x88>
		}
		else
		{
			/* Turn the LED off. */
			taskENTER_CRITICAL();
  40949a:	f642 6379 	movw	r3, #11897	; 0x2e79
  40949e:	f2c0 0340 	movt	r3, #64	; 0x40
  4094a2:	4798      	blx	r3
			{
				gpio_set_pin_high( ulLED[ uxLED ]);
  4094a4:	f249 73f0 	movw	r3, #38896	; 0x97f0
  4094a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4094ac:	687a      	ldr	r2, [r7, #4]
  4094ae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4094b2:	4618      	mov	r0, r3
  4094b4:	f641 63e1 	movw	r3, #7905	; 0x1ee1
  4094b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4094bc:	4798      	blx	r3
			}
			taskEXIT_CRITICAL();
  4094be:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  4094c2:	f2c0 0340 	movt	r3, #64	; 0x40
  4094c6:	4798      	blx	r3
		}
	}
}
  4094c8:	f107 0708 	add.w	r7, r7, #8
  4094cc:	46bd      	mov	sp, r7
  4094ce:	bd80      	pop	{r7, pc}

004094d0 <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
  4094d0:	b580      	push	{r7, lr}
  4094d2:	b082      	sub	sp, #8
  4094d4:	af00      	add	r7, sp, #0
  4094d6:	6078      	str	r0, [r7, #4]
	if( uxLED < partestNUM_LEDS )
  4094d8:	687b      	ldr	r3, [r7, #4]
  4094da:	2b02      	cmp	r3, #2
  4094dc:	d816      	bhi.n	40950c <vParTestToggleLED+0x3c>
	{
		taskENTER_CRITICAL();
  4094de:	f642 6379 	movw	r3, #11897	; 0x2e79
  4094e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4094e6:	4798      	blx	r3
		{			
			gpio_toggle_pin( ulLED[ uxLED ] );
  4094e8:	f249 73f0 	movw	r3, #38896	; 0x97f0
  4094ec:	f2c0 0340 	movt	r3, #64	; 0x40
  4094f0:	687a      	ldr	r2, [r7, #4]
  4094f2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4094f6:	4618      	mov	r0, r3
  4094f8:	f641 7359 	movw	r3, #8025	; 0x1f59
  4094fc:	f2c0 0340 	movt	r3, #64	; 0x40
  409500:	4798      	blx	r3
		}
		taskEXIT_CRITICAL();		
  409502:	f642 63a9 	movw	r3, #11945	; 0x2ea9
  409506:	f2c0 0340 	movt	r3, #64	; 0x40
  40950a:	4798      	blx	r3
	}
}
  40950c:	f107 0708 	add.w	r7, r7, #8
  409510:	46bd      	mov	sp, r7
  409512:	bd80      	pop	{r7, pc}

00409514 <__register_exitproc>:
  409514:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  409518:	4698      	mov	r8, r3
  40951a:	4b23      	ldr	r3, [pc, #140]	; (4095a8 <__register_exitproc+0x94>)
  40951c:	681c      	ldr	r4, [r3, #0]
  40951e:	4606      	mov	r6, r0
  409520:	f8d4 0148 	ldr.w	r0, [r4, #328]	; 0x148
  409524:	460f      	mov	r7, r1
  409526:	4691      	mov	r9, r2
  409528:	b918      	cbnz	r0, 409532 <__register_exitproc+0x1e>
  40952a:	f504 70a6 	add.w	r0, r4, #332	; 0x14c
  40952e:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  409532:	6841      	ldr	r1, [r0, #4]
  409534:	291f      	cmp	r1, #31
  409536:	dd16      	ble.n	409566 <__register_exitproc+0x52>
  409538:	481c      	ldr	r0, [pc, #112]	; (4095ac <__register_exitproc+0x98>)
  40953a:	b918      	cbnz	r0, 409544 <__register_exitproc+0x30>
  40953c:	f04f 30ff 	mov.w	r0, #4294967295
  409540:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  409544:	f44f 70c8 	mov.w	r0, #400	; 0x190
  409548:	f3af 8000 	nop.w
  40954c:	2800      	cmp	r0, #0
  40954e:	d0f5      	beq.n	40953c <__register_exitproc+0x28>
  409550:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  409554:	2500      	movs	r5, #0
  409556:	6045      	str	r5, [r0, #4]
  409558:	6002      	str	r2, [r0, #0]
  40955a:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  40955e:	f8c0 5188 	str.w	r5, [r0, #392]	; 0x188
  409562:	f8c0 518c 	str.w	r5, [r0, #396]	; 0x18c
  409566:	b1b6      	cbz	r6, 409596 <__register_exitproc+0x82>
  409568:	6844      	ldr	r4, [r0, #4]
  40956a:	f8d0 1188 	ldr.w	r1, [r0, #392]	; 0x188
  40956e:	2201      	movs	r2, #1
  409570:	eb00 0384 	add.w	r3, r0, r4, lsl #2
  409574:	fa02 f204 	lsl.w	r2, r2, r4
  409578:	4311      	orrs	r1, r2
  40957a:	2e02      	cmp	r6, #2
  40957c:	f8c3 9088 	str.w	r9, [r3, #136]	; 0x88
  409580:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  409584:	461c      	mov	r4, r3
  409586:	f8c3 8108 	str.w	r8, [r3, #264]	; 0x108
  40958a:	d104      	bne.n	409596 <__register_exitproc+0x82>
  40958c:	f8d0 318c 	ldr.w	r3, [r0, #396]	; 0x18c
  409590:	431a      	orrs	r2, r3
  409592:	f8c0 218c 	str.w	r2, [r0, #396]	; 0x18c
  409596:	6841      	ldr	r1, [r0, #4]
  409598:	1c8b      	adds	r3, r1, #2
  40959a:	1c4a      	adds	r2, r1, #1
  40959c:	f840 7023 	str.w	r7, [r0, r3, lsl #2]
  4095a0:	6042      	str	r2, [r0, #4]
  4095a2:	2000      	movs	r0, #0
  4095a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4095a8:	004097fc 	.word	0x004097fc
  4095ac:	00000000 	.word	0x00000000

004095b0 <__libc_fini_array>:
  4095b0:	b570      	push	{r4, r5, r6, lr}
  4095b2:	4b08      	ldr	r3, [pc, #32]	; (4095d4 <__libc_fini_array+0x24>)
  4095b4:	4c08      	ldr	r4, [pc, #32]	; (4095d8 <__libc_fini_array+0x28>)
  4095b6:	1ae0      	subs	r0, r4, r3
  4095b8:	1084      	asrs	r4, r0, #2
  4095ba:	eb03 0684 	add.w	r6, r3, r4, lsl #2
  4095be:	2500      	movs	r5, #0
  4095c0:	3d04      	subs	r5, #4
  4095c2:	b11c      	cbz	r4, 4095cc <__libc_fini_array+0x1c>
  4095c4:	5972      	ldr	r2, [r6, r5]
  4095c6:	4790      	blx	r2
  4095c8:	3c01      	subs	r4, #1
  4095ca:	e7f9      	b.n	4095c0 <__libc_fini_array+0x10>
  4095cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  4095d0:	f000 b922 	b.w	409818 <_fini>
  4095d4:	00409824 	.word	0x00409824
  4095d8:	00409828 	.word	0x00409828

004095dc <__libc_init_array>:
  4095dc:	b538      	push	{r3, r4, r5, lr}
  4095de:	4d0e      	ldr	r5, [pc, #56]	; (409618 <__libc_init_array+0x3c>)
  4095e0:	4b0e      	ldr	r3, [pc, #56]	; (40961c <__libc_init_array+0x40>)
  4095e2:	1ae8      	subs	r0, r5, r3
  4095e4:	1085      	asrs	r5, r0, #2
  4095e6:	2400      	movs	r4, #0
  4095e8:	42ac      	cmp	r4, r5
  4095ea:	d005      	beq.n	4095f8 <__libc_init_array+0x1c>
  4095ec:	490b      	ldr	r1, [pc, #44]	; (40961c <__libc_init_array+0x40>)
  4095ee:	f851 2024 	ldr.w	r2, [r1, r4, lsl #2]
  4095f2:	4790      	blx	r2
  4095f4:	3401      	adds	r4, #1
  4095f6:	e7f7      	b.n	4095e8 <__libc_init_array+0xc>
  4095f8:	f000 f904 	bl	409804 <_init>
  4095fc:	4908      	ldr	r1, [pc, #32]	; (409620 <__libc_init_array+0x44>)
  4095fe:	4a09      	ldr	r2, [pc, #36]	; (409624 <__libc_init_array+0x48>)
  409600:	1a54      	subs	r4, r2, r1
  409602:	10a5      	asrs	r5, r4, #2
  409604:	2400      	movs	r4, #0
  409606:	42ac      	cmp	r4, r5
  409608:	d005      	beq.n	409616 <__libc_init_array+0x3a>
  40960a:	4b05      	ldr	r3, [pc, #20]	; (409620 <__libc_init_array+0x44>)
  40960c:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  409610:	4780      	blx	r0
  409612:	3401      	adds	r4, #1
  409614:	e7f7      	b.n	409606 <__libc_init_array+0x2a>
  409616:	bd38      	pop	{r3, r4, r5, pc}
  409618:	00409810 	.word	0x00409810
  40961c:	00409810 	.word	0x00409810
  409620:	00409810 	.word	0x00409810
  409624:	00409818 	.word	0x00409818

00409628 <memcmp>:
  409628:	b530      	push	{r4, r5, lr}
  40962a:	2300      	movs	r3, #0
  40962c:	4293      	cmp	r3, r2
  40962e:	d008      	beq.n	409642 <memcmp+0x1a>
  409630:	5cc5      	ldrb	r5, [r0, r3]
  409632:	3301      	adds	r3, #1
  409634:	18cc      	adds	r4, r1, r3
  409636:	f814 4c01 	ldrb.w	r4, [r4, #-1]
  40963a:	42a5      	cmp	r5, r4
  40963c:	d0f6      	beq.n	40962c <memcmp+0x4>
  40963e:	1b28      	subs	r0, r5, r4
  409640:	bd30      	pop	{r4, r5, pc}
  409642:	2000      	movs	r0, #0
  409644:	bd30      	pop	{r4, r5, pc}

00409646 <memcpy>:
  409646:	b510      	push	{r4, lr}
  409648:	2300      	movs	r3, #0
  40964a:	4293      	cmp	r3, r2
  40964c:	d003      	beq.n	409656 <memcpy+0x10>
  40964e:	5ccc      	ldrb	r4, [r1, r3]
  409650:	54c4      	strb	r4, [r0, r3]
  409652:	3301      	adds	r3, #1
  409654:	e7f9      	b.n	40964a <memcpy+0x4>
  409656:	bd10      	pop	{r4, pc}

00409658 <memset>:
  409658:	1882      	adds	r2, r0, r2
  40965a:	4603      	mov	r3, r0
  40965c:	4293      	cmp	r3, r2
  40965e:	d002      	beq.n	409666 <memset+0xe>
  409660:	f803 1b01 	strb.w	r1, [r3], #1
  409664:	e7fa      	b.n	40965c <memset+0x4>
  409666:	4770      	bx	lr

00409668 <register_fini>:
  409668:	4b02      	ldr	r3, [pc, #8]	; (409674 <register_fini+0xc>)
  40966a:	b113      	cbz	r3, 409672 <register_fini+0xa>
  40966c:	4802      	ldr	r0, [pc, #8]	; (409678 <register_fini+0x10>)
  40966e:	f000 b805 	b.w	40967c <atexit>
  409672:	4770      	bx	lr
  409674:	00000000 	.word	0x00000000
  409678:	004095b1 	.word	0x004095b1

0040967c <atexit>:
  40967c:	4601      	mov	r1, r0
  40967e:	2000      	movs	r0, #0
  409680:	4602      	mov	r2, r0
  409682:	4603      	mov	r3, r0
  409684:	f7ff bf46 	b.w	409514 <__register_exitproc>

00409688 <heapSTRUCT_SIZE>:
  409688:	0008 0000                                   ....

0040968c <xTotalHeapSize>:
  40968c:	9ff8 0000 6553 5474 0078 0000 6553 5274     ....SetTx...SetR
  40969c:	0078 0000                                   x...

004096a0 <pcInterruptPriorityRegisters>:
  4096a0:	e3f0 e000 4449 454c 0000 0000               ....IDLE....

004096ac <ucExpectedStackBytes.5224>:
  4096ac:	a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5     ................
  4096bc:	a5a5 a5a5 6d54 2072 7653 0063 4351 6e6f     ....Tmr Svc.QCon
  4096cc:	4273 0031 5051 6f72 4264 0032 4351 6e6f     sB1.QProdB2.QCon
  4096dc:	4273 0033 5051 6f72 4264 0034 5051 6f72     sB3.QProdB4.QPro
  4096ec:	4264 0035 4351 6e6f 4273 0036 5442 7365     dB5.QConsB6.BTes
  4096fc:	3174 0000 5442 7365 3274 0000 4f43 544d     t1..BTest2..COMT
  40970c:	0078 0000 4f43 524d 0078 0000 4e43 3154     x...COMRx...CNT1
  40971c:	0000 0000 4e43 3254 0000 0000               ....CNT2....

00409728 <uxMaxNumberOfExtraTasksRunning>:
  409728:	0003 0000 5243 4145 4f54 0052 5553 4349     ....CREATOR.SUIC
  409738:	4449 0031 5553 4349 4449 0032 4e43 5f54     ID1.SUICID2.CNT_
  409748:	4e49 0043 494c 5f4d 4e49 0043 5f43 5443     INC.LIM_INC.C_CT
  409758:	4c52 0000 5553 5053 545f 0058 5553 5053     RL..SUSP_TX.SUSP
  409768:	525f 0058 6c46 7361 6568 0072 6547 516e     _RX.Flasher.GenQ
  409778:	0000 0000 754d 6f4c 0077 0000 754d 654d     ....MuLow...MuMe
  409788:	0064 0000 754d 6948 6867 0000 6e49 4d74     d...MuHigh..IntM
  409798:	7461 0068 4351 6e6f 4e73 0042 5051 6f72     ath.QConsNB.QPro
  4097a8:	4e64 0042 6552 3163 0000 0000 6552 3263     dNB.Rec1....Rec2
  4097b8:	0000 0000 6552 3363 0000 0000 6f50 536c     ....Rec3....PolS
  4097c8:	4d45 0031 6f50 536c 4d45 0032 6c42 536b     EM1.PolSEM2.BlkS
  4097d8:	4d45 0031 6c42 536b 4d45 0032 6843 6365     EM1.BlkSEM2.Chec
  4097e8:	546b 6d69 7265 0000                         kTimer..

004097f0 <ulLED>:
  4097f0:	0054 0000 0013 0000 0014 0000               T...........

004097fc <_global_impure_ptr>:
  4097fc:	0028 2000 0043 0000                         (.. C...

00409804 <_init>:
  409804:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  409806:	bf00      	nop
  409808:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40980a:	bc08      	pop	{r3}
  40980c:	469e      	mov	lr, r3
  40980e:	4770      	bx	lr

00409810 <__init_array_start>:
  409810:	00409669 	.word	0x00409669

00409814 <__frame_dummy_init_array_entry>:
  409814:	00400149                                I.@.

00409818 <_fini>:
  409818:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40981a:	bf00      	nop
  40981c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40981e:	bc08      	pop	{r3}
  409820:	469e      	mov	lr, r3
  409822:	4770      	bx	lr

00409824 <__fini_array_start>:
  409824:	00400121 	.word	0x00400121
